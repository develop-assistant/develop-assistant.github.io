{"meta":{"title":"当我遇上你","subtitle":"当我遇上你的博客","description":"勿在浮沙筑高楼","author":"当我遇上你","url":"https://idea360.cn","root":"/"},"pages":[{"title":"分类","date":"2020-03-15T04:42:38.997Z","updated":"2020-03-15T04:42:38.997Z","comments":false,"path":"categories/index.html","permalink":"https://idea360.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-15T04:43:00.420Z","updated":"2020-03-15T04:43:00.420Z","comments":false,"path":"tags/index.html","permalink":"https://idea360.cn/tags/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2020-03-15T04:54:36.092Z","updated":"2020-03-15T04:54:36.092Z","comments":false,"path":"about/index.html","permalink":"https://idea360.cn/about/index.html","excerpt":"","text":"欢迎访问我的博客，我会保持不定期更新。 12345678910111213141516171819&#x2F;&#x2F;&#x2F;&#x2F; .::::.&#x2F;&#x2F; .::::::::.&#x2F;&#x2F; :::::::::::&#x2F;&#x2F; ..:::::::::::&#39;&#x2F;&#x2F; &#39;::::::::::::&#39;&#x2F;&#x2F; .::::::::::&#x2F;&#x2F; &#39;::::::::::::::..&#x2F;&#x2F; ..::::::::::::.&#x2F;&#x2F; &#96;&#96;::::::::::::::::&#x2F;&#x2F; ::::&#96;&#96;:::::::::&#39; .:::.&#x2F;&#x2F; ::::&#39; &#39;:::::&#39; .::::::::.&#x2F;&#x2F; .::::&#39; :::: .:::::::&#39;::::.&#x2F;&#x2F; .:::&#39; ::::: .:::::::::&#39; &#39;:::::.&#x2F;&#x2F; .::&#39; :::::.:::::::::&#39; &#39;:::::.&#x2F;&#x2F; .::&#39; ::::::::::::::&#39; &#96;&#96;::::.&#x2F;&#x2F; ...::: ::::::::::::&#39; &#96;&#96;::.&#x2F;&#x2F; &#96;&#96;&#96;&#96; &#39;:. &#39;:::::::::&#39; ::::..&#x2F;&#x2F; &#39;.:::::&#39; &#39;:&#39;&#96;&#96;&#96;&#96;.."}],"posts":[{"title":"Idea常用插件","slug":"idea-plugin","date":"2021-09-06T13:53:56.000Z","updated":"2021-09-06T14:59:41.887Z","comments":true,"path":"2021/09/06/idea-plugin/","link":"","permalink":"https://idea360.cn/2021/09/06/idea-plugin/","excerpt":"","text":"插件 Alibaba Java Coding Guidelines SonarLint Codota Convert YAML and Properties File Maven Helper MybatisX SequenceDiagram javaDoc VisualVM spring-javaformat-maven-plugin Key promoter X Git Commit Template IdeaVim Chinese ​(Simplified)​ Language Pack 参考 https://www.w3cschool.cn/intellij_idea_doc/ https://www.jetbrains.com/zh-cn/idea/whatsnew/?_gl=11e1xznr_gaNjgwODI2NDQ3LjE2MzA5MzYwMTI._ga_0WQ2ZF5VGT*MTYzMDkzNjk4OC4xLjEuMTYzMDkzOTM1Mi4w&amp;_ga=2.240295427.1219945209.1630936012-680826447.1630936012","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"idea","slug":"idea","permalink":"https://idea360.cn/tags/idea/"},{"name":"插件","slug":"插件","permalink":"https://idea360.cn/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"spring-HandlerInterceptor","slug":"spring-HandlerInterceptor","date":"2021-09-05T06:18:55.000Z","updated":"2021-09-06T13:45:13.544Z","comments":true,"path":"2021/09/05/spring-HandlerInterceptor/","link":"","permalink":"https://idea360.cn/2021/09/05/spring-HandlerInterceptor/","excerpt":"","text":"前言 本文风格类似 模仿SpringSecurity自定义过滤器链 首先我们看下源码, 然后手写模拟练习 如何看源码实现 首先debug调试是最简单的学习途径, 我们先定义一个拦截器 12345678910111213141516171819202122232425262728293031323334package com.example.demoboot.handler;import org.springframework.lang.Nullable;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author cuishiying * @date 2021-01-22 */@Componentpublic class DemoInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; System.out.println(&quot;afterHandle&quot;); &#125;&#125; 注册拦截器 1234567891011121314151617181920package com.example.demoboot.handler;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 如果有多个拦截器，继续registry.add往下添加就可以啦 registry.addInterceptor(new DemoInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; 在 preHandle 方法中打断点, 服务启动后请求任何uri, 即可进入查看调用链. 首先会进入类 HandlerExecutionChain 中的 applyPreHandle 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242/* * Copyright 2002-2020 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.web.servlet;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.lang.Nullable;import org.springframework.util.CollectionUtils;import org.springframework.util.ObjectUtils;/** * Handler execution chain, consisting of handler object and any handler interceptors. * Returned by HandlerMapping&#x27;s &#123;@link HandlerMapping#getHandler&#125; method. * * @author Juergen Hoeller * @since 20.06.2003 * @see HandlerInterceptor */public class HandlerExecutionChain &#123; private static final Log logger = LogFactory.getLog(HandlerExecutionChain.class); private final Object handler; @Nullable private HandlerInterceptor[] interceptors; @Nullable private List&lt;HandlerInterceptor&gt; interceptorList; private int interceptorIndex = -1; /** * Create a new HandlerExecutionChain. * @param handler the handler object to execute */ public HandlerExecutionChain(Object handler) &#123; this(handler, (HandlerInterceptor[]) null); &#125; /** * Create a new HandlerExecutionChain. * @param handler the handler object to execute * @param interceptors the array of interceptors to apply * (in the given order) before the handler itself executes */ public HandlerExecutionChain(Object handler, @Nullable HandlerInterceptor... interceptors) &#123; if (handler instanceof HandlerExecutionChain) &#123; HandlerExecutionChain originalChain = (HandlerExecutionChain) handler; this.handler = originalChain.getHandler(); this.interceptorList = new ArrayList&lt;&gt;(); CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(), this.interceptorList); CollectionUtils.mergeArrayIntoCollection(interceptors, this.interceptorList); &#125; else &#123; this.handler = handler; this.interceptors = interceptors; &#125; &#125; /** * Return the handler object to execute. */ public Object getHandler() &#123; return this.handler; &#125; /** * Add the given interceptor to the end of this chain. */ public void addInterceptor(HandlerInterceptor interceptor) &#123; initInterceptorList().add(interceptor); &#125; /** * Add the given interceptor at the specified index of this chain. * @since 5.2 */ public void addInterceptor(int index, HandlerInterceptor interceptor) &#123; initInterceptorList().add(index, interceptor); &#125; /** * Add the given interceptors to the end of this chain. */ public void addInterceptors(HandlerInterceptor... interceptors) &#123; if (!ObjectUtils.isEmpty(interceptors)) &#123; CollectionUtils.mergeArrayIntoCollection(interceptors, initInterceptorList()); &#125; &#125; private List&lt;HandlerInterceptor&gt; initInterceptorList() &#123; if (this.interceptorList == null) &#123; this.interceptorList = new ArrayList&lt;&gt;(); if (this.interceptors != null) &#123; // An interceptor array specified through the constructor CollectionUtils.mergeArrayIntoCollection(this.interceptors, this.interceptorList); &#125; &#125; this.interceptors = null; return this.interceptorList; &#125; /** * Return the array of interceptors to apply (in the given order). * @return the array of HandlerInterceptors instances (may be &#123;@code null&#125;) */ @Nullable public HandlerInterceptor[] getInterceptors() &#123; if (this.interceptors == null &amp;&amp; this.interceptorList != null) &#123; this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[0]); &#125; return this.interceptors; &#125; /** * Apply preHandle methods of registered interceptors. * @return &#123;@code true&#125; if the execution chain should proceed with the * next interceptor or the handler itself. Else, DispatcherServlet assumes * that this interceptor has already dealt with the response itself. */ boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = 0; i &lt; interceptors.length; i++) &#123; HandlerInterceptor interceptor = interceptors[i]; if (!interceptor.preHandle(request, response, this.handler)) &#123; triggerAfterCompletion(request, response, null); return false; &#125; this.interceptorIndex = i; &#125; &#125; return true; &#125; /** * Apply postHandle methods of registered interceptors. */ void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; interceptor.postHandle(request, response, this.handler, mv); &#125; &#125; &#125; /** * Trigger afterCompletion callbacks on the mapped HandlerInterceptors. * Will just invoke afterCompletion for all interceptors whose preHandle invocation * has successfully completed and returned true. */ void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = this.interceptorIndex; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; try &#123; interceptor.afterCompletion(request, response, this.handler, ex); &#125; catch (Throwable ex2) &#123; logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2); &#125; &#125; &#125; &#125; /** * Apply afterConcurrentHandlerStarted callback on mapped AsyncHandlerInterceptors. */ void applyAfterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response) &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; if (interceptor instanceof AsyncHandlerInterceptor) &#123; try &#123; AsyncHandlerInterceptor asyncInterceptor = (AsyncHandlerInterceptor) interceptor; asyncInterceptor.afterConcurrentHandlingStarted(request, response, this.handler); &#125; catch (Throwable ex) &#123; if (logger.isErrorEnabled()) &#123; logger.error(&quot;Interceptor [&quot; + interceptor + &quot;] failed in afterConcurrentHandlingStarted&quot;, ex); &#125; &#125; &#125; &#125; &#125; &#125; /** * Delegates to the handler&#x27;s &#123;@code toString()&#125; implementation. */ @Override public String toString() &#123; Object handler = getHandler(); StringBuilder sb = new StringBuilder(); sb.append(&quot;HandlerExecutionChain with [&quot;).append(handler).append(&quot;] and &quot;); if (this.interceptorList != null) &#123; sb.append(this.interceptorList.size()); &#125; else if (this.interceptors != null) &#123; sb.append(this.interceptors.length); &#125; else &#123; sb.append(0); &#125; return sb.append(&quot; interceptors&quot;).toString(); &#125;&#125; 继续向上看即可看到 DispatcherServlet 中的 doDispatch 在调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; &#125; 参考 https://blog.csdn.net/ooiuy450/article/details/70054613 https://mp.weixin.qq.com/s/gXCog_DxNjpMnYX9IpF6TQ https://zhuanlan.zhihu.com/p/47324985","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"拦截器","slug":"拦截器","permalink":"https://idea360.cn/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"HandlerInterceptor","slug":"HandlerInterceptor","permalink":"https://idea360.cn/tags/HandlerInterceptor/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://idea360.cn/tags/Interceptor/"}]},{"title":"spring-cloud基于Ribbon的服务间灰度","slug":"spring-cloud-service-gray","date":"2021-08-28T13:26:39.000Z","updated":"2021-08-29T09:36:02.190Z","comments":true,"path":"2021/08/28/spring-cloud-service-gray/","link":"","permalink":"https://idea360.cn/2021/08/28/spring-cloud-service-gray/","excerpt":"","text":"前言 本次还是灰度系列文章, 基于 Ribbon + nacos 实现 基础环境搭建 本项目基于聚合项目搭建, 项目结构如下, 其中provider启动2个实例, 通过consumer调用去模拟负载情况。 123├── consumer├── provider├── pom.xml 根pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.2.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;modules&gt; &lt;module&gt;provider&lt;/module&gt; &lt;module&gt;gateway&lt;/module&gt; &lt;module&gt;consumer&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; provider application.properties 123456789# 应用名称spring.application.name=provider# 应用服务 WEB 访问端口server.port=9001spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848# 9001为普通实例; 9002带元数据, 模拟灰度服务spring.cloud.nacos.discovery.metadata.version = gray 启动主类 123456789101112131415package cn.idea360.provider;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; 资源提供者 123456789101112131415161718192021222324252627282930313233package cn.idea360.provider.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.core.env.Environment;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author cuishiying * @date 2021-01-22 */@RefreshScope@RestController@RequestMapping(&quot;/echo&quot;)public class TestController &#123; @Autowired private Environment env; @Value(&quot;$&#123;version:0&#125;&quot;) private String version; /** * http://localhost:9001/echo/port * @return */ @GetMapping(&quot;/port&quot;) public Object port() &#123; return String.format(&quot;port=%s, version=%s&quot;, env.getProperty(&quot;local.server.port&quot;), version); &#125;&#125; 启动2个实例, 端口分别为9001和9002, 其中9002配置灰度元数据, nacos配置参见 灰度网关 consumer application.properties 1234567# 应用名称spring.application.name=consumer# 应用服务 WEB 访问端口server.port=9007spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 启动类 1234567891011121314151617181920212223package cn.idea360.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@EnableDiscoveryClient@SpringBootApplicationpublic class ConsumerApplication &#123; @LoadBalanced @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; 消费者 1234567891011121314151617181920212223242526272829package cn.idea360.consumer.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;/** * @author cuishiying * @date 2021-01-22 */@RefreshScope@RestController@RequestMapping(&quot;/echo&quot;)public class TestController &#123; @Autowired private RestTemplate restTemplate; /** * http://localhost:9007/echo/port * @return */ @GetMapping(&quot;/port&quot;) public Object port() &#123; return restTemplate.getForObject(&quot;http://provider/echo/port&quot;, String.class); &#125;&#125; 自定义负载均衡 自定义负载 123456789101112131415161718192021222324252627282930313233package cn.idea360.consumer.ribbon;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.List;/** * @author cuishiying * @date 2021-01-22 */public class GrayRule extends AbstractLoadBalancerRule &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; &#125; @Override public Server choose(Object o) &#123; logger.info(&quot;key:&#123;&#125;&quot;, o); ILoadBalancer loadBalancer = getLoadBalancer(); List&lt;Server&gt; allServers = loadBalancer.getAllServers(); logger.info(&quot;allServers:&#123;&#125;&quot;, allServers.toString()); return allServers.get(0); &#125;&#125; consumer配置文件添加 12# provider为服务名provider.ribbon.NFLoadBalancerRuleClassName=cn.idea360.consumer.ribbon.GrayRule 测试 1curl http:&#x2F;&#x2F;localhost:9007&#x2F;echo&#x2F;port 日志: 122021-08-28 22:11:14.917 INFO 3620 --- [nio-9007-exec-5] cn.idea360.consumer.ribbon.GrayRule : key:default2021-08-28 22:11:14.917 INFO 3620 --- [nio-9007-exec-5] cn.idea360.consumer.ribbon.GrayRule : allServers:[192.168.124.14:9002, 192.168.124.14:9001] nacos+ribbon负载均衡 consumer配置文件修改 application.properties 123456789101112# 应用名称spring.application.name=consumer# 应用服务 WEB 访问端口server.port=9007spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848# provider为服务名provider.ribbon.NFLoadBalancerRuleClassName=cn.idea360.consumer.ribbon.GrayRule# 代表需要请求灰度服务spring.cloud.nacos.discovery.metadata.version = gray 自定义负载均衡策略 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package cn.idea360.consumer.ribbon;import com.alibaba.cloud.nacos.NacosDiscoveryProperties;import com.alibaba.cloud.nacos.ribbon.NacosServer;import com.alibaba.nacos.api.exception.NacosException;import com.alibaba.nacos.api.naming.NamingFactory;import com.alibaba.nacos.api.naming.NamingService;import com.alibaba.nacos.api.naming.pojo.Instance;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.BaseLoadBalancer;import com.netflix.loadbalancer.Server;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import java.security.SecureRandom;import java.util.List;import java.util.stream.Collectors;/** * @author cuishiying * @date 2021-01-22 */public class GrayRule extends AbstractLoadBalancerRule &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); private static final String VERSION = &quot;version&quot;; @Autowired private NacosDiscoveryProperties nacosDiscoveryProperties; @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; &#125; @Override public Server choose(Object o) &#123; logger.info(&quot;key:&#123;&#125;&quot;, o); String clusterName = this.nacosDiscoveryProperties.getClusterName(); logger.info(&quot;clusterName:&#123;&#125;&quot;, clusterName); String groupName = this.nacosDiscoveryProperties.getGroup(); logger.info(&quot;groupName:&#123;&#125;&quot;, groupName); BaseLoadBalancer baseLoadBalancer = (BaseLoadBalancer) getLoadBalancer(); String serviceName = baseLoadBalancer.getName(); logger.info(&quot;serviceName:&#123;&#125;&quot;, serviceName); String currentVersion = nacosDiscoveryProperties.getMetadata().get(VERSION); logger.info(&quot;consumer-version:&#123;&#125;&quot;, currentVersion); try &#123; NamingService namingService = NamingFactory.createNamingService(nacosDiscoveryProperties.getNacosProperties()); List&lt;Instance&gt; instances = namingService.selectInstances(serviceName, groupName, true); if (instances.isEmpty()) &#123; logger.warn(&quot;no instance in service &#123;&#125;&quot;, serviceName); return null; &#125; List&lt;Instance&gt; targetInstances = instances.stream() .filter(x -&gt; StringUtils.equalsIgnoreCase(x.getMetadata().get(VERSION), currentVersion) &amp;&amp; StringUtils.equalsIgnoreCase(x.getClusterName(), clusterName) ).collect(Collectors.toList()); logger.info(&quot;targetInstances:&#123;&#125;&quot;, targetInstances); if (targetInstances.isEmpty()) &#123; return null; &#125; else &#123; SecureRandom random = new SecureRandom(); int i = random.nextInt(targetInstances.size()); Instance invokedInstance = targetInstances.get(i); logger.info(&quot;invokedInstance:&#123;&#125;&quot;, invokedInstance.getInstanceId()); return new NacosServer(invokedInstance); &#125; &#125; catch (NacosException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"nacos","slug":"nacos","permalink":"https://idea360.cn/tags/nacos/"},{"name":"springcloud","slug":"springcloud","permalink":"https://idea360.cn/tags/springcloud/"},{"name":"灰度","slug":"灰度","permalink":"https://idea360.cn/tags/%E7%81%B0%E5%BA%A6/"},{"name":"ribbon","slug":"ribbon","permalink":"https://idea360.cn/tags/ribbon/"},{"name":"gray","slug":"gray","permalink":"https://idea360.cn/tags/gray/"}]},{"title":"SQL规范","slug":"sql-standard","date":"2021-08-26T14:23:34.000Z","updated":"2021-08-26T14:25:51.937Z","comments":true,"path":"2021/08/26/sql-standard/","link":"","permalink":"https://idea360.cn/2021/08/26/sql-standard/","excerpt":"","text":"SQL规范 使用InnoDB存储引擎 字符集编码utf8mb4, 排序规则 默认采用不区分大小写的utf8mb4_general_ci, 表及字段必须添加COMMENT描述 把字段定义为NOT NULL并且提供默认值 null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化。 null 这种类型MySQL内部需要进行特殊处理,增加数据库处理记录的复杂性,同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。 null值需要更多的存储空,无论是表还是索引中每行中的null的列都需要额外的空间来标识。 对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。 禁止使用小数存储金额等数据, 避免精度丢失 数据量大的表必须建立索引 禁止在更新十分频繁、区分度不高的属性上建立索引 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能 性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似 建立组合索引, 把区分度高的字段放在前面 禁止在WHERE条件的属性上使用函数或者表达式","categories":[{"name":"sql","slug":"sql","permalink":"https://idea360.cn/categories/sql/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://idea360.cn/tags/%E8%A7%84%E8%8C%83/"},{"name":"sql","slug":"sql","permalink":"https://idea360.cn/tags/sql/"}]},{"title":"日志使用规范","slug":"log-standard","date":"2021-08-26T14:20:00.000Z","updated":"2021-08-26T14:22:43.290Z","comments":true,"path":"2021/08/26/log-standard/","link":"","permalink":"https://idea360.cn/2021/08/26/log-standard/","excerpt":"","text":"什么时候使用日志 系统初始化：系统或者服务的启动参数。核心模块或者组件初始化过程中往往依赖一些关键配置，根据参数不同会提供不一样的服务。务必在这里记录 INFO 日志，打印出参数以及启动完成态服务表述。 编程语言提示异常：如今各类主流的编程语言都包括异常机制，业务相关的流行框架有完整的异常模块。这类捕获的异常是系统告知开发人员需要加以关注的，是质量非常高的报错。应当适当记录日志，根据实际结合业务的情况使用 WARN 或者 ERROR 级别。 业务流程预期不符：除开平台以及编程语言异常之外，项目代码中结果与期望不符时也是日志场景之一，简单来说所有流程分支都可以加入考虑。取决于开发人员判断能否容忍情形发生。常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等。 系统核心角色，组件关键动作：系统中核心角色触发的业务动作是需要多加关注的，是衡量系统正常运行的重要指标，建议记录 INFO 级别日志，比如电商系统用户从登录到下单的整个流程；微服务各服务节点交互；核心数据表增删改；核心组件运行等等，如果日志频度高或者打印量特别大，可以提炼关键点 INFO 记录，其余酌情考虑 DEBUG 级别。 第三方服务远程调用：微服务架构体系中有一个重要的点就是第三方永远不可信，对于第三方服务远程调用建议打印请求和响应的参数，方便在和各个终端定位问题，不会因为第三方服务日志的缺失变得手足无措。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://idea360.cn/tags/%E8%A7%84%E8%8C%83/"},{"name":"log","slug":"log","permalink":"https://idea360.cn/tags/log/"},{"name":"日志","slug":"日志","permalink":"https://idea360.cn/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"Spring之RequestBodyAdvice参数校验","slug":"RequestBodyAdvice","date":"2021-08-22T07:00:52.000Z","updated":"2021-08-22T07:07:40.264Z","comments":true,"path":"2021/08/22/RequestBodyAdvice/","link":"","permalink":"https://idea360.cn/2021/08/22/RequestBodyAdvice/","excerpt":"","text":"前言 之前写了一篇 自定义starter之接口标准化。其中对requestBody做了validate统一参数校验。最近在写单元测试的时候发现body无法重复消费(正常http接口请求正常), 所以重新写了这部分逻辑。 实现逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package cn.idea360.unified;import org.hibernate.validator.HibernateValidator;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.core.MethodParameter;import org.springframework.core.annotation.AnnotationUtils;import org.springframework.http.HttpInputMessage;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.*;import org.springframework.web.servlet.mvc.method.annotation.RequestBodyAdvice;import javax.validation.*;import java.io.IOException;import java.lang.reflect.Type;import java.util.Arrays;import java.util.Set;/** * 校验请求体参数 * * @author cuishiying * @date 2021-01-22 */@ConditionalOnProperty(value = &quot;idea360.framework.unified.enable&quot;, havingValue = &quot;true&quot;)@RestControllerAdvicepublic class ValidateRequestBodyAdvice implements RequestBodyAdvice &#123; private static final Validator VALIDATOR = Validation.byProvider(HibernateValidator.class).configure() .failFast(true).buildValidatorFactory().getValidator(); @Override public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; // 已添加注解的无需二次处理 boolean matchValidAnnotation = Arrays.stream(methodParameter.getMethodAnnotations()) .anyMatch(t -&gt; t.annotationType().equals(Validated.class) || t.annotationType().equals(Valid.class)); // String不校验 boolean matchString = methodParameter.getParameterType().isAssignableFrom(String.class); // 匹配则校验 boolean matchPostOrPutMapping = Arrays.stream(methodParameter.getMethodAnnotations()).anyMatch( t -&gt; t.annotationType().equals(PostMapping.class) || t.annotationType().equals(PutMapping.class)); // 匹配则校验 boolean matchPostOrPutRequestMapping = Arrays.stream(methodParameter.getMethodAnnotations()) .anyMatch(t -&gt; t.annotationType().equals(RequestMapping.class) &amp;&amp; Arrays.stream(AnnotationUtils.getAnnotation(t, RequestMapping.class).method()) .anyMatch(m -&gt; m.equals(RequestMethod.POST) || m.equals(RequestMethod.PUT))); return (matchPostOrPutMapping || matchPostOrPutRequestMapping) &amp;&amp; !matchValidAnnotation &amp;&amp; !matchString; &#125; /** * 此处不做参数校验 * * String body = IOUtils.toString(inputMessage.getBody(), StandardCharsets.UTF_8); * Object o = objectMapper.readValue(body, parameter.getParameterType()); InputStream * inputStreamWrapper = IOUtils.toInputStream(body, StandardCharsets.UTF_8.name()); * return new MappingJacksonInputMessage(inputStreamWrapper, * inputMessage.getHeaders()); */ @Override public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123; return inputMessage; &#125; @Override public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolations = VALIDATOR.validate(body); if (!constraintViolations.isEmpty()) &#123; throw new ConstraintViolationException(constraintViolations); &#125; return body; &#125; @Override public Object handleEmptyBody(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return body; &#125;&#125; spring.factories修改 1234org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\cn.idea360.unified.UnifiedResponseBodyAdvice,\\cn.idea360.unified.UnifiedExceptionHandler,\\cn.idea360.unified.ValidateRequestBodyAdvice 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"valid","slug":"valid","permalink":"https://idea360.cn/tags/valid/"},{"name":"RequestBodyAdvice","slug":"RequestBodyAdvice","permalink":"https://idea360.cn/tags/RequestBodyAdvice/"}]},{"title":"SpringBoot MockMVC 单元测试","slug":"spring-boot-mockmvc","date":"2021-08-20T15:23:19.000Z","updated":"2021-08-24T02:55:44.255Z","comments":true,"path":"2021/08/20/spring-boot-mockmvc/","link":"","permalink":"https://idea360.cn/2021/08/20/spring-boot-mockmvc/","excerpt":"","text":"代码实现 pom.xml 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; controller 1234567891011121314151617181920212223242526272829303132333435package com.example.demoboot.controller;import com.example.demoboot.model.User;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.*;/** * 公众号: 当我遇上你 * * @author cuishiying * @date 2021-01-22 */@Slf4j@RestControllerpublic class IndexController &#123; /** * http://localhost:8088/hello/1?name=admin * * @param id id ID * @param name 帐号 * @return 测试数据 */ @GetMapping(&quot;/hello/&#123;id&#125;&quot;) public Object hello(@PathVariable Integer id, @RequestParam String name) &#123; log.info(String.format(&quot;hello: id=%d, name=%s&quot;, id, name)); return String.format(&quot;hello: id=%d, name=%s&quot;, id, name); &#125; @PostMapping(&quot;/submit&quot;) public Object submit(@RequestBody User user) &#123; log.info(user.toString()); return user; &#125;&#125; user 12345678/** * @author cuishiying * @date 2021-01-22 */@Datapublic class User &#123; private String username;&#125; 单元测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.example.demoboot.controller;import com.example.demoboot.model.User;import com.fasterxml.jackson.databind.ObjectMapper;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.RequestPostProcessor;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import java.nio.charset.StandardCharsets;import static org.hamcrest.Matchers.containsString;import static org.hamcrest.Matchers.is;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;@SpringBootTestclass IndexControllerTest &#123; protected MockMvc mockMvc; protected ObjectMapper objectMapper; public static RequestPostProcessor authentication() &#123; return request -&gt; &#123; request.addHeader(&quot;Authorization&quot;, &quot;123&quot;); return request; &#125;; &#125; @BeforeEach public void setUp(WebApplicationContext webApplicationContext) &#123; this.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).alwaysDo(print()).build(); this.objectMapper = new ObjectMapper(); &#125; @Test void hello() throws Exception &#123; mockMvc.perform( get(&quot;/hello/&#123;id&#125;&quot;, 1) // 设置返回值类型为application/json .accept(MediaType.APPLICATION_JSON) // 设置编码为utf-8，否则默认为ISO-8859-1 .characterEncoding(StandardCharsets.UTF_8.name()) // 设置请求参数 .param(&quot;name&quot;, &quot;admin&quot;) // 设置请求头 .with(authentication())) // 断言返回状态 .andExpect(status().isOk()) // 断言返回数据包含admin .andExpect(content().string(containsString(&quot;admin&quot;))) .andReturn() .getResponse() .getContentAsString(); &#125; @Test void submit() throws Exception &#123; User user = new User(); user.setUsername(&quot;当我遇上你&quot;); mockMvc.perform( post(&quot;/submit&quot;) // 设置提交格式为application/json .contentType(MediaType.APPLICATION_JSON) // 设置返回值类型为application/json;charset=UTF-8 .accept( new MediaType( &quot;application&quot;, &quot;json&quot;, StandardCharsets.UTF_8)) // 设置编码为utf-8，否则默认为ISO-8859-1 .characterEncoding(StandardCharsets.UTF_8.name()) // 设置请求体 .content(objectMapper.writeValueAsString(user))) // 断言返回状态 .andExpect(status().isOk()) // 断言返回字段 .andExpect(jsonPath(&quot;$.username&quot;, is(&quot;当我遇上你&quot;))) // 断言返回字段 .andExpect(jsonPath(&quot;$.username&quot;).value(&quot;当我遇上你&quot;)) // 断言返回内容 .andExpect(content().json(objectMapper.writeValueAsString(user))); &#125;&#125; 注意 JUnit5 在如上代码中 @BeforeEach 中构建 MockMvc, Filter 是不会生效的。需要按如下配置: 1234567@AutoConfigureMockMvc@SpringBootTestpublic class BaseMock &#123; @Resource protected MockMvc mockMvc;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"junit","slug":"junit","permalink":"https://idea360.cn/categories/junit/"}],"tags":[{"name":"junit","slug":"junit","permalink":"https://idea360.cn/tags/junit/"},{"name":"MockMVC","slug":"MockMVC","permalink":"https://idea360.cn/tags/MockMVC/"},{"name":"单元测试","slug":"单元测试","permalink":"https://idea360.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"JavaParser基于注释生成接口文档","slug":"java-parser-docs","date":"2021-08-15T14:54:51.000Z","updated":"2021-08-15T15:02:08.111Z","comments":true,"path":"2021/08/15/java-parser-docs/","link":"","permalink":"https://idea360.cn/2021/08/15/java-parser-docs/","excerpt":"","text":"前言 swagger接口文档侵入性比较强, 本来计划基于java注释做一个开源组件。经过调研选择了 JavaParser, 奈何解决不了jar包的注释问题, 所以最终放弃了, 仅记录下调研过程中的单元测试~ 测试 12345&lt;dependency&gt; &lt;groupId&gt;com.github.javaparser&lt;/groupId&gt; &lt;artifactId&gt;javaparser-core&lt;/artifactId&gt; &lt;version&gt;3.22.1&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package cn.idea360.docs;import com.github.javaparser.JavaParser;import com.github.javaparser.ParseResult;import com.github.javaparser.ast.CompilationUnit;import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;import com.github.javaparser.ast.comments.Comment;import com.github.javaparser.javadoc.Javadoc;import com.github.javaparser.javadoc.JavadocBlockTag;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.File;import java.util.List;import java.util.Optional;/** * @author cuishiying * @date 2021-01-22 */public class JavaParserTest &#123; CompilationUnit cu; @BeforeEach public void runBeforeTestMethod() throws Exception&#123; File javaFile = new File(&quot;/Users/cuishiying/work/rest-docs/src/main/java/cn/idea360/docs/controller/UserController.java&quot;); JavaParser javaParser = new JavaParser(); ParseResult&lt;CompilationUnit&gt; parseResult = javaParser.parse(javaFile); parseResult.ifSuccessful(compilationUnit -&gt; &#123; cu = compilationUnit; &#125;); &#125; @Test void t1() &#123; // 获取所有注释信息 List&lt;Comment&gt; comments = cu.getComments(); System.out.println(comments); &#125; @Test void t2() &#123; for (Comment comment : cu.getAllContainedComments()) &#123; // 获取注释内容 String content = comment.getContent(); System.out.println(content); &#125; &#125; @Test void t3() &#123; for (Comment comment : cu.getAllContainedComments()) &#123; // 解析注释 Javadoc parse = comment.asJavadocComment().parse(); String methodDesc = parse.getDescription().toText(); System.out.println(&quot;方法注释:&quot; + methodDesc); List&lt;JavadocBlockTag&gt; blockTags = parse.getBlockTags(); for (JavadocBlockTag javadocBlockTag: blockTags) &#123; Optional&lt;String&gt; name = javadocBlockTag.getName(); name.ifPresent(k -&gt; &#123; String text = javadocBlockTag.getContent().getElements().get(0).toText(); System.out.println(&quot;参数注释: &quot; + k + &quot;:&quot; + text); &#125;); &#125; &#125; &#125; @Test void t4() &#123; Optional&lt;ClassOrInterfaceDeclaration&gt; userController = cu.getClassByName(&quot;UserController&quot;); userController.ifPresent(c -&gt; &#123; c.getJavadoc().ifPresent(javadoc -&gt; &#123; // 解析注释 String methodDesc = javadoc.getDescription().toText(); System.out.println(&quot;方法注释:&quot; + methodDesc); List&lt;JavadocBlockTag&gt; blockTags = javadoc.getBlockTags(); for (JavadocBlockTag javadocBlockTag: blockTags) &#123; String name = javadocBlockTag.getTagName(); String content = javadocBlockTag.getContent().toText(); System.out.println(&quot;参数注释: &quot; + name + &quot;:&quot; + content); &#125; &#125;); &#125;); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"api","slug":"api","permalink":"https://idea360.cn/tags/api/"},{"name":"docs","slug":"docs","permalink":"https://idea360.cn/tags/docs/"},{"name":"javaparser","slug":"javaparser","permalink":"https://idea360.cn/tags/javaparser/"}]},{"title":"Spring Boot Admin","slug":"spring-boot-admin","date":"2021-08-13T15:45:37.000Z","updated":"2021-08-14T08:49:14.900Z","comments":true,"path":"2021/08/13/spring-boot-admin/","link":"","permalink":"https://idea360.cn/2021/08/13/spring-boot-admin/","excerpt":"","text":"前言 悲伤的运维沟通史, 没权限, 有问题排查累死, 哎… Admin-Server pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-admin&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-cloud-admin&lt;/name&gt; &lt;description&gt;[公众号: 当我遇上你]&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.2.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.admin.SpringCloudAdminApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties 1234567891011121314151617181920212223242526# 应用名称spring.application.name=spring-cloud-admin# 应用服务 WEB 访问端口server.port=7900server.servlet.context-path=# Nacos帮助文档: https://nacos.io/zh-cn/docs/concepts.html# Nacos认证信息spring.cloud.nacos.discovery.username=nacosspring.cloud.nacos.discovery.password=nacos# Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口spring.cloud.nacos.discovery.server-addr=localhost:8848# 注册到 nacos 的指定 namespace，默认为 publicspring.cloud.nacos.discovery.namespace=public# 健康配置management.endpoints.web.exposure.include=*management.endpoint.health.show-details=always# 上下文spring.cloud.nacos.discovery.metadata.management.context-path=$&#123;server.servlet.context-path&#125;/actuator# 登录spring.security.user.name=adminspring.security.user.password=123456## 指标安全, 否则401#spring.cloud.nacos.discovery.metadata.user.name=admin#spring.cloud.nacos.discovery.metadata.user.password=123456# 日志#logging.file.name=/Users/cuishiying/Desktop/admin.log 安全配置 1234567891011121314151617181920212223242526272829303132333435363738package com.example.admin.config;import de.codecentric.boot.admin.server.config.AdminServerProperties;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;import org.springframework.security.web.csrf.CookieCsrfTokenRepository;/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; private final String adminContextPath; public SecurityConfiguration(AdminServerProperties adminServerProperties) &#123; this.adminContextPath = adminServerProperties.getContextPath(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler(); successHandler.setTargetUrlParameter(&quot;redirectTo&quot;); successHandler.setDefaultTargetUrl(adminContextPath + &quot;/&quot;); http .authorizeRequests().antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll() .antMatchers(adminContextPath + &quot;/login&quot;).permitAll() .anyRequest().authenticated() .and().formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler) .and().logout().logoutUrl(adminContextPath + &quot;/logout&quot;) .and().httpBasic() .and().csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) .ignoringAntMatchers(adminContextPath + &quot;/instances&quot;, adminContextPath + &quot;/actuator/**&quot;); &#125;&#125; 启动类 1234567891011121314151617181920package com.example.admin;import de.codecentric.boot.admin.server.config.EnableAdminServer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * https://codecentric.github.io/spring-boot-admin/current/ * http://localhost:7900 */@EnableAdminServer@SpringBootApplicationpublic class SpringCloudAdminApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudAdminApplication.class, args); &#125;&#125; Client pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-cloud-client&lt;/name&gt; &lt;description&gt;[公众号: 当我遇上你]&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.2.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.springcloudclient.SpringCloudClientApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties 1234567891011121314151617181920# 应用名称spring.application.name=spring-cloud-client# 应用服务 WEB 访问端口server.port=7701# Nacos帮助文档: https://nacos.io/zh-cn/docs/concepts.html# Nacos认证信息spring.cloud.nacos.discovery.username=nacosspring.cloud.nacos.discovery.password=nacos# Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口spring.cloud.nacos.discovery.server-addr=localhost:8848# 注册到 nacos 的指定 namespace，默认为 publicspring.cloud.nacos.discovery.namespace=public# 健康配置management.endpoints.web.exposure.include=*management.endpoint.health.show-details=alwaysspring.boot.admin.client.username=adminspring.boot.admin.client.password=123456# spring-cloud-admin地址spring.boot.admin.client.url=http://localhost:7900logging.file.name=/Users/cuishiying/Desktop/client.log 启动类 123456789101112131415package com.example.springcloudclient;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class SpringCloudClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudClientApplication.class, args); &#125;&#125; 测试类 123456789101112131415161718192021222324252627package com.example.springcloudclient.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * @author cuishiying * @date 2021-01-22 */@RestControllerpublic class HelloController &#123; private final Logger log = LoggerFactory.getLogger(getClass()); /** * http://localhost:7701/hello?name=root * @param name * @return */ @GetMapping(&quot;/hello&quot;) public Object hello(@RequestParam(required = false) String name) &#123; log.info(&quot;hello:&quot; + name); return &quot;hello:&quot; + name; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"监控","slug":"监控","permalink":"https://idea360.cn/tags/%E7%9B%91%E6%8E%A7/"}]},{"title":"JVM线上调优","slug":"jvm-tuning-online","date":"2021-08-05T15:52:30.000Z","updated":"2021-08-05T16:26:46.667Z","comments":true,"path":"2021/08/05/jvm-tuning-online/","link":"","permalink":"https://idea360.cn/2021/08/05/jvm-tuning-online/","excerpt":"","text":"JVM线上调优 1. 调优原则 必须有监控； 调优目标: 最短停顿时间? CMS 最大吞吐量(吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间))？ Parallel Scavenge 调优手段 官方推荐调优流程 1.2. Hotspot虚拟机优化大纲 2. 线上问题 内存泄露； 某个进程突然 CPU 飙升； 线程死锁； 响应变慢(长时间卡顿)。 FGC频繁 3. 调优方向 内存调优 垃圾回收策略调优 4. Arthas线上监控 线上启动arthas后attach到我们需要监控的进程； 帮助文档 123456789101112131415161718192021222324252627282930313233343536373839[arthas@1701]$ help NAME DESCRIPTION help Display Arthas Help keymap Display all the available keymap for the specified connection. sc Search all the classes loaded by JVM sm Search the method of classes loaded by JVM classloader Show classloader info jad Decompile class getstatic Show the static field of a class monitor Monitor method execution statistics, e.g. total/success/failure count, average rt, fail rate, etc. stack Display the stack trace for the specified class and method thread Display thread info, thread stack trace Trace the execution time of specified method invocation. watch Display the input/output parameter, return object, and thrown exception of specified method invocation tt Time Tunnel jvm Display the target JVM information ognl Execute ognl expression. mc Memory compiler, compiles java files into bytecode and class files in memory. redefine Redefine classes. @see Instrumentation#redefineClasses(ClassDefinition...) dashboard Overview of target jvm&#x27;s thread, memory, gc, vm, tomcat info. dump Dump class byte array from JVM heapdump Heap dump options View and change various Arthas options cls Clear the screen reset Reset all the enhanced classes version Display Arthas version shutdown Shutdown Arthas server and exit the console stop Stop/Shutdown Arthas server and exit the console. Alias for shutdown. session Display current session information sysprop Display, and change the system properties. sysenv Display the system env. vmoption Display, and update the vm diagnostic options. logger Print logger info, and update the logger level history Display command history cat Concatenate and print files pwd Return working directory name mbean Display the mbean information grep grep command for pipes. profiler Async Profiler. https://github.com/jvm-profiling-tools/async-profiler 1、dashboard 在arthas的命令行界面，输入dashboard，会实时展示当前tomcat的多线程状态、Jvm各区域、GC情况等信息 2、查看线程监控 常用参数 输入thread会显示所有线程的状态信息 输入thread -n 3会显示当前最忙的3个线程，可以用来排查线程CPU消耗 输入thread -b 会显示当前处于BLOCKED状态的线程，可以排查线程锁的问题 3、jvm监控 输入jvm，查看jvm详细的性能数据 4、函数耗时监控 通常说一个接口性能不好，其实就是接口响应时间比较长造成的，具体代码中哪个函数耗时比较长呢？可以使用trace功能来监控一下 1trace com.idc.order.modules.sys.controller.AccountController login 解释： -j参数可以过滤掉jdk自身的函数 om.idc.order.modules.sys.controller.AccountController是接口所在的类 Login是接口的入口函数 通过圈起来的部分可以看到，接口的入口函数login总耗时268ms 其中verify函数耗时85ms 很明显，最慢的函数已经找到了，接下里就要去对代码进行进一步分析，然后再进行优化 5. 模拟堆栈溢出 堆溢出模拟 123456789101112131415161718192021222324252627/** * 堆溢出: java对象在堆中分配内存 * * VM options: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError * * 执行结果: * * 分配次数：1 * 分配次数：2 * 分配次数：3 * java.lang.OutOfMemoryError: Java heap space * Dumping heap to java_pid17426.hprof ... * Heap dump file created [17431809 bytes in 0.026 secs] * Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space * at com.example.demojava.demo.HeapOOm.main(HeapOOm.java:15) */public class HeapOOm &#123; public static void main(String[] args) &#123; List&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); int i=0; while(true)&#123; list.add(new byte[5*1024*1024]); System.out.println(&quot;分配次数：&quot;+(++i)); &#125; &#125;&#125; 附：dump文件会在项目的根目录下生成 从上面的例子我们可以看出，在进行第4次内存分配时，发生了内存溢出。 栈溢出模拟 栈空间不足时，需要分下面两种情况处理： 线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError 虚拟机在扩展栈深度时无法申请到足够的内存空间，将抛出OutOfMemberError 附：当前大部分的虚拟机栈都是可动态扩展的。 1、栈空间不足——StackOverflowError实例 12345678910111213141516171819202122232425262728/** * 栈空间不足溢出 * * 执行结果： * * 递归次数：18117 * Exception in thread &quot;main&quot; java.lang.StackOverflowError * at com.example.demojava.demo.StackOverflowErrorDemo.sofMethod(StackOverflowErrorDemo.java:13) */public class StackOverflowErrorDemo &#123; int depth = 0; public void sofMethod()&#123; depth ++ ; sofMethod(); &#125; public static void main(String[] args) &#123; StackOverflowErrorDemo test = null; try &#123; test = new StackOverflowErrorDemo(); test.sofMethod(); &#125; finally &#123; System.out.println(&quot;递归次数：&quot;+test.depth); &#125; &#125;&#125; 我们可以看到，sofMethod()方法递归调用了982次后，出现了StackOverflowError。 永久代溢出模拟 永久代溢出可以分为两种情况，第一种是常量池溢出，第二种是方法区溢出。 1、永久代溢出——常量池溢出 2、永久代溢出——方法区溢出 12345678910111213141516171819202122232425262728293031/** * java7 方法区溢出 * -XX:PermSize=10m -XX:MaxPermSize=10m */public class MethodAreaOOMTest &#123; public static void main(String[] args) &#123; int i=0; try &#123; while(true)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); i++; &#125; &#125; finally&#123; System.out.println(&quot;运行次数：&quot;+i); &#125; &#125; static class OOMObject&#123; &#125;&#125; 从上面的例子我们可以看出，在进行第4次内存分配时，发生了内存溢出。 元空间溢出模拟 12345678910111213141516171819202122/** * -Xms20m -Xmx20m -XX：MaxDirectMemorySize=10m */public class DirectMemoryOOMTest &#123; public static void main(String[] args) &#123; int i=0; try &#123; Field field = Unsafe.class.getDeclaredFields()[0]; field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); while(true)&#123; unsafe.allocateMemory(1024*1024); i++; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;分配次数：&quot;+i); &#125; &#125;&#125; 6. Btrace线上调优 https://hacpai.com/article/1480092912242 7. 线上内存溢出排查流程 1&gt;jps 2、查看线程信息 1&gt;jstack 19645 3、存储进程信息 1&gt;jstack 19645 &gt;t.log 4、查看内存信息 1&gt;jmap -histo 19645 5、dump内存信息到heap.bin文件 1&gt;jmap -dump:format=b,file=heap.bin 19645 6、jstat 监视垃圾回收（GC）时间，次数 1&gt;jstat -gc 19645 7、使用mat工具或者VisualVM工具导入heap.bin文件分析内存信息 1&gt; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://juejin.im/post/5dd0c0b95188253d73575ca1 https://tech.meituan.com/2017/12/29/jvm-optimize.html https://juejin.im/post/59e6c1f26fb9a0451c397a8c","categories":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/categories/jvm/"}],"tags":[{"name":"调优","slug":"调优","permalink":"https://idea360.cn/tags/%E8%B0%83%E4%BC%98/"},{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"}]},{"title":"JVM调优指令","slug":"jvm-tuning-cmd","date":"2021-08-05T15:50:16.000Z","updated":"2021-08-05T15:51:41.708Z","comments":true,"path":"2021/08/05/jvm-tuning-cmd/","link":"","permalink":"https://idea360.cn/2021/08/05/jvm-tuning-cmd/","excerpt":"","text":"JVM调优指令 JVM常用配置参数 12345678910-Xms2g：初始化推大小为 2g；-Xmx2g：堆最大内存为 2g；-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；-XX:+PrintGC：开启打印 gc 信息；-XX:+PrintGCDetails：打印 gc 详细信息。-XX:+HeapDumpOnOutOfMemoryError： 虚拟机在出现内存溢出异常时dump出当前内存堆转储快照以便事后进行分析 jdk命令行工具 123456jps: 显示系统内所有hotspot虚拟机进程jstat: 用于收集Hotspot虚拟机各方面的运行参数。jinfo: 显示虚拟机配置信息jmap: 生成虚拟机内存转储快照jhat: 用于分析heapdump文件，它会建立一个http/html服务器，让用户可以在浏览器上查看分析结果jstack: 显示虚拟机的线程快照 1. jps jps(JVM Process Status) 命令类似 UNIX 的 ps 命令。 命令帮助 123456[root@iz2ze2e5wmatyx36v5jw5lz ~]# jps -helpusage: jps [-help] jps [-q] [-mlvV] [&lt;hostid&gt;]Definitions: &lt;hostid&gt;: &lt;hostname&gt;[:&lt;port&gt;] 参数说明 1234-l : 输出主类全名或jar路径-q : 只输出LVMID-m : 输出JVM启动时传递给main()的参数-v : 输出JVM启动时显示指定的JVM参数 示例详解 123456789101112131415[root@iz2ze2e5wmatyx36v5jw5lz ~]# jps25378 Jps1701 idc-order-boot.jar[root@iz2ze2e5wmatyx36v5jw5lz ~]# jps -l1701 target/idc-order-boot.jar25391 sun.tools.jps.Jps[root@iz2ze2e5wmatyx36v5jw5lz ~]# jps -q254101701[root@iz2ze2e5wmatyx36v5jw5lz ~]# jps -m25425 Jps -m1701 idc-order-boot.jar --spring.profiles.active=dev --server.port=8080[root@iz2ze2e5wmatyx36v5jw5lz ~]# jps -v25440 Jps -Denv.class.path=.:/usr/java/jdk1.8.0_201/jre/lib/rt.jar:/usr/java/jdk1.8.0_201/lib/dt.jar:/usr/java/jdk1.8.0_201/lib/tools.jar -Dapplication.home=/usr/java/jdk1.8.0_201 -Xms8m1701 idc-order-boot.jar 2. jstat jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。 命令帮助 12345678910111213141516171819202122232425262728293031323334[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -helpUsage: jstat -help|-options jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]Definitions: &lt;option&gt; An option reported by the -options option &lt;vmid&gt; Virtual Machine Identifier. A vmid takes the following form: &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]] Where &lt;lvmid&gt; is the local vm identifier for the target Java virtual machine, typically a process id; &lt;hostname&gt; is the name of the host running the target Java virtual machine; and &lt;port&gt; is the port number for the rmiregistry on the target host. See the jvmstat documentation for a more complete description of the Virtual Machine Identifier. &lt;lines&gt; Number of samples between header lines. &lt;interval&gt; Sampling interval. The following forms are allowed: &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;] Where &lt;n&gt; is an integer and the suffix specifies the units as milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;. &lt;count&gt; Number of samples to take before terminating. -J&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system.[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -options-class-compiler-gc-gccapacity-gccause-gcmetacapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcutil-printcompilation 参数说明 1234[option] : 操作参数LVMID : 本地虚拟机进程ID[interval] : 连续输出的时间间隔[count] : 连续输出的次数 option参数说明 选项 作用 -class 监视类装载、卸载数量、总空间以及类装载所耗费的时间 -gc 监视java堆状况，包括Eden区，2个servivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到的最大、最小空间 -gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 -gccause 与-gcutil功能一样，但是会额外输出导致上一次gc产生的原因 -gcnew 监视新生代GC状况 -gcnewcapacity 监视内容与-gcnew基本相同，输出主要关注使用到的最大最小空间 -gcold 监视GC老年代状况 -gcoldcapacity 监视内容与-gcold基本相同，输出主要关注使用到的最大最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出JIT编译器编译过的方法、耗时等信息 -printcompilation 输出已经被JIT编译的方法 示例详解 -class 监视类装载、卸载数量、总空间以及耗费的时间 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -class 1701Loaded Bytes Unloaded Bytes Time 14317 27168.2 140 209.1 25.95 说明 12345Loaded : 加载class的数量Bytes : class字节大小Unloaded : 未加载class的数量Bytes : 未加载class的字节大小Time : 加载时间 -compiler 输出JIT编译过的方法数量耗时等 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -compiler 1701Compiled Failed Invalid Time FailedType FailedMethod 13515 1 0 134.67 1 org/springframework/boot/loader/jar/Handler openConnection 说明 123456Compiled : 编译数量Failed : 编译失败数量Invalid : 无效数量Time : 编译耗时FailedType : 失败类型FailedMethod : 失败方法的全限定名 -gc 监视java堆状况，包括Eden区，2个servivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息 1234567[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gc 1701 1000 5 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT5888.0 5888.0 0.0 0.0 47168.0 4656.0 117740.0 48648.4 86952.0 82657.6 10672.0 9866.7 306 6.441 14 2.882 9.3235888.0 5888.0 0.0 0.0 47168.0 4656.0 117740.0 48648.4 86952.0 82657.6 10672.0 9866.7 306 6.441 14 2.882 9.3235888.0 5888.0 0.0 0.0 47168.0 4656.0 117740.0 48648.4 86952.0 82657.6 10672.0 9866.7 306 6.441 14 2.882 9.3235888.0 5888.0 0.0 0.0 47168.0 4656.0 117740.0 48648.4 86952.0 82657.6 10672.0 9866.7 306 6.441 14 2.882 9.3235888.0 5888.0 0.0 0.0 47168.0 4656.0 117740.0 48648.4 86952.0 82657.6 10672.0 9866.7 306 6.441 14 2.882 9.323 上述指令的意思是1701进程每隔1000ms输出一次gc情况，一共5次。 说明 C即Capacity 总容量，U即Used 已使用的容量 1234567891011121314151617S0C : survivor0区的总容量S1C : survivor1区的总容量S0U : survivor0区已使用的容量S1C : survivor1区已使用的容量EC : Eden区的总容量EU : Eden区已使用的容量OC : Old区的总容量OU : Old区已使用的容量MC : 当前元空间的容量 (KB)MU : Metaspace的使用 (KB)CCSC: 压缩类空间大小CCSU: 压缩类空间使用大小YGC : 新生代垃圾回收次数YGCT : 新生代垃圾回收时间FGC : 老年代垃圾回收次数FGCT : 老年代垃圾回收时间GCT : 垃圾回收总消耗时间 -gccapacity 同-gc，不过还会输出Java堆各区域使用到的最大、最小空间 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gccapacity 1701 NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC 10240.0 156992.0 58944.0 5888.0 5888.0 47168.0 20480.0 314048.0 117740.0 117740.0 0.0 1126400.0 86952.0 0.0 1048576.0 10672.0 306 14 说明 12345678NGCMN : 新生代占用的最小空间NGCMX : 新生代占用的最大空间OGCMN : 老年代占用的最小空间OGCMX : 老年代占用的最大空间OGC：当前年老代的容量 (KB)OC：当前年老代的空间 (KB)PGCMN : perm占用的最小空间PGCMX : perm占用的最大空间 -gcutils 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcutil 1701 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 11.78 41.32 95.06 92.45 306 6.441 14 2.882 9.323 -gccause 与-gcutil功能一样，但是会额外输出导致上一次gc产生的原因 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gccause 1701 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT LGCC GCC 0.00 0.00 11.95 41.32 95.06 92.45 306 6.441 14 2.882 9.323 Heap Inspection Initiated GC No GC 说明 12LGCC：最近垃圾回收的原因GCC：当前垃圾回收的原因 -gcnew 统计新生代的行为 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcnew 1701 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT5888.0 5888.0 0.0 0.0 1 15 2080.0 47168.0 5656.6 306 6.441 说明 123TT：Tenuring threshold(提升阈值)MTT：最大的tenuring thresholdDSS：survivor区域大小 (KB) -gcnewcapacity 新生代与其相应的内存空间的统计 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcnewcapacity 1701 NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 10240.0 156992.0 58944.0 15680.0 5888.0 15680.0 5888.0 125632.0 47168.0 306 14 说明 12345NGC:当前年轻代的容量 (KB)S0CMX:最大的S0空间 (KB)S0C:当前S0空间 (KB)ECMX:最大eden空间 (KB)EC:当前eden空间 (KB) -gcold 统计旧生代的行为 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcold 1701 MC MU CCSC CCSU OC OU YGC FGC FGCT GCT 86952.0 82657.6 10672.0 9866.7 117740.0 48648.4 306 14 2.882 9.323 -gcoldcapacity 统计旧生代的大小和空间 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcoldcapacity 1701 OGCMN OGCMX OGC OC YGC FGC FGCT GCT 20480.0 314048.0 117740.0 117740.0 306 14 2.882 9.323 -gcmetacapacity 元空间统计 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcmetacapacity 1701 MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC FGCT GCT 0.0 1126400.0 86952.0 0.0 1048576.0 10672.0 306 14 2.882 9.323 -printcompilation hotspot编译方法统计 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -printcompilation 1701Compiled Size Type Method 13515 22 1 java/util/ResourceBundle$CacheKey getLoader 说明 1234Compiled：被执行的编译任务的数量Size：方法字节码的字节数Type：编译类型Method：编译方法的类名和方法名。类名使用&quot;&#x2F;&quot; 代替 &quot;.&quot; 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项 3. jmap jmap（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。 jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。 示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。 命令帮助 1234567891011121314151617181920212223242526272829[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -helpUsage: jmap [option] &lt;pid&gt; (to connect to running process) jmap [option] &lt;executable &lt;core&gt; (to connect to a core file) jmap [option] [server_id@]&lt;remote server IP or hostname&gt; (to connect to remote debug server)where &lt;option&gt; is one of: &lt;none&gt; to print same info as Solaris pmap -heap to print java heap summary -histo[:live] to print histogram of java object heap; if the &quot;live&quot; suboption is specified, only count live objects -clstats to print class loader statistics -finalizerinfo to print information on objects awaiting finalization -dump:&lt;dump-options&gt; to dump java heap in hprof binary format dump-options: live dump only live objects; if not specified, all objects in the heap are dumped. format=b binary format file=&lt;file&gt; dump heap to &lt;file&gt; Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt; -F force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo to force a heap dump or histogram when &lt;pid&gt; does not respond. The &quot;live&quot; suboption is not supported in this mode. -h | -help to print this help message -J&lt;flag&gt; to pass &lt;flag&gt; directly to the runtime system 参数详解 选项 作用 -dump 生成java堆转储快照。格式为:-dump:[live, ]format=b, file=,其中live子参数说明是否只dump出存活的对象 -finalizerinfo 显示在finalizer线程执行finalize方法的对象，只在linux平台下有效 -heap 显示java堆详细信息，如使用哪些回收器、参数配置、分代状况等。只在linux平台下有效 -histo 显示堆中对象统计信息，包括类、实例数量、合计容量 -permstat 以Classloader为统计口径显示永久代内存状态。只在linux平台下有效 -F 当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在linux平台下有效 示例详解 -dump 123[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -dump:format=b,file=dump.hprof 1701Dumping heap to /root/dump.hprof ...File exists dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名。dump.hprof这个后缀是为了后续可以直接用MAT(Memory Anlysis Tool)打开。 -finalizerinfo 打印等待回收对象的信息 123456[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -finalizerinfo 1701Attaching to process ID 1701, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.201-b09Number of objects pending for finalization: 0 可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行finalizer方法的对象。 -heap 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -heap 1701Attaching to process ID 1701, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.201-b09using thread-local object allocation.Mark Sweep Compact GC //GC 方式 Heap Configuration: //堆内存初始化配置 MinHeapFreeRatio = 40 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率 MaxHeapFreeRatio = 70 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率 MaxHeapSize = 482344960 (460.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小 NewSize = 10485760 (10.0MB) //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小 MaxNewSize = 160759808 (153.3125MB) //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小 OldSize = 20971520 (20.0MB) //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小 NewRatio = 2 //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小 SurvivorRatio = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 MetaspaceSize = 21807104 (20.796875MB) //元空间初始大小 CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage: //堆内存使用情况New Generation (Eden + 1 Survivor Space): capacity = 54329344 (51.8125MB) used = 7109688 (6.780326843261719MB) free = 47219656 (45.03217315673828MB) 13.086276175173401% usedEden Space: //Eden区内存分布 capacity = 48300032 (46.0625MB) //Eden区总容量 used = 7109688 (6.780326843261719MB) //Eden区已使用 free = 41190344 (39.28217315673828MB) //Eden区剩余容量 14.719841179401289% usedFrom Space: capacity = 6029312 (5.75MB) used = 0 (0.0MB) free = 6029312 (5.75MB) 0.0% usedTo Space: capacity = 6029312 (5.75MB) used = 0 (0.0MB) free = 6029312 (5.75MB) 0.0% usedtenured generation: //老年代内存分布 capacity = 120565760 (114.98046875MB) used = 49815952 (47.50819396972656MB) free = 70749808 (67.47227478027344MB) 41.318490423815184% used27371 interned Strings occupying 2942608 bytes. -histo 打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ） 1234567891011121314jmap -histo:live 1701 | less num #instances #bytes class name---------------------------------------------- 1: 4358 18044728 [B 2: 97247 8984344 [C 3: 26579 2338952 java.lang.reflect.Method 4: 96737 2321688 java.lang.String 5: 58232 1863424 java.util.concurrent.ConcurrentHashMap$Node 6: 22337 1824304 [Ljava.lang.Object; 7: 15080 1675792 java.lang.Class 8: 24027 961080 java.util.LinkedHashMap$Entry 9: 6227 917008 [I 10: 10500 797288 [Ljava.util.HashMap$Node; ... jhat jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。 1jhat [dumpfile] 分析同样一个dump快照，MAT需要的额外内存比jhat要小的多的多，所以建议使用MAT来进行分析，当然也看个人偏好。 具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。 一般情况，会down到客户端用工具来分析 5. jstack jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合. 生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。 命令帮助 12345678910111213141516[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstack -helpUsage: jstack [-l] &lt;pid&gt; (to connect to running process) jstack -F [-m] [-l] &lt;pid&gt; (to connect to a hung process) jstack [-m] [-l] &lt;executable&gt; &lt;core&gt; (to connect to a core file) jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt; (to connect to a remote debug server)Options: -F to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung) -m to print both java and native frames (mixed mode) -l long listing. Prints additional information about locks -h or -help to print this help message 参数详解 123-F : 当正常输出请求不被响应时，强制输出线程堆栈-l : 除堆栈外，显示关于锁的附加信息-m : 如果调用到本地方法的话，可以显示C&#x2F;C++的堆栈 示例详情 下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。 123456789101112131415161718192021222324252627282930313233343536373839package com.javaedge.concurrency.example.deadLock;public class DeadLockDemo &#123; private static Object resource1 = new Object();//资源 1 private static Object resource2 = new Object();//资源 2 public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (resource1) &#123; System.out.println(Thread.currentThread() + &quot;get resource1&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;); synchronized (resource2) &#123; System.out.println(Thread.currentThread() + &quot;get resource2&quot;); &#125; &#125; &#125;, &quot;线程 1&quot;).start(); new Thread(() -&gt; &#123; synchronized (resource2) &#123; System.out.println(Thread.currentThread() + &quot;get resource2&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;); synchronized (resource1) &#123; System.out.println(Thread.currentThread() + &quot;get resource1&quot;); &#125; &#125; &#125;, &quot;线程 2&quot;).start(); &#125;&#125; 线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。 通过 jstack 命令分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120➜ Java-Concurrency-Progamming-Tutorial git:(master) ✗ jstack 267522020-02-08 15:07:20Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):&quot;Attach Listener&quot; #16 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff49814c800 nid&#x3D;0x3207 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;DestroyJavaVM&quot; #15 prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007ff495857800 nid&#x3D;0xd03 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;线程 2&quot; #14 prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007ff498836800 nid&#x3D;0x5903 waiting for monitor entry [0x0000700005b7e000] java.lang.Thread.State: BLOCKED (on object monitor) at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34) - waiting to lock &lt;0x000000076af91968&gt; (a java.lang.Object) - locked &lt;0x000000076af91978&gt; (a java.lang.Object) at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$2&#x2F;194494468.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)&quot;线程 1&quot; #13 prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007ff499876000 nid&#x3D;0xa703 waiting for monitor entry [0x0000700005a7b000] java.lang.Thread.State: BLOCKED (on object monitor) at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$0(DeadLockDemo.java:19) - waiting to lock &lt;0x000000076af91978&gt; (a java.lang.Object) - locked &lt;0x000000076af91968&gt; (a java.lang.Object) at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$1&#x2F;972765878.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)&quot;Service Thread&quot; #12 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff495820800 nid&#x3D;0xa903 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C1 CompilerThread3&quot; #11 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff49612f800 nid&#x3D;0x5503 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread2&quot; #10 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff497014000 nid&#x3D;0x3f03 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread1&quot; #9 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff497013800 nid&#x3D;0x3d03 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread0&quot; #8 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff499880800 nid&#x3D;0x3c03 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;JDWP Command Reader&quot; #7 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff497009000 nid&#x3D;0x3a03 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;JDWP Event Helper Thread&quot; #6 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff497004800 nid&#x3D;0x4203 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;JDWP Transport Listener: dt_socket&quot; #5 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff497003800 nid&#x3D;0x4407 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Signal Dispatcher&quot; #4 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff49902d800 nid&#x3D;0x3803 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Finalizer&quot; #3 daemon prio&#x3D;8 os_prio&#x3D;31 tid&#x3D;0x00007ff497005800 nid&#x3D;0x4b03 in Object.wait() [0x0000700004e54000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x000000076ab08ed0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144) - locked &lt;0x000000076ab08ed0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff496835000 nid&#x3D;0x4d03 in Object.wait() [0x0000700004d51000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x000000076ab06bf8&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x000000076ab06bf8&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Thread&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff49682e800 nid&#x3D;0x2e03 runnable &quot;GC task thread#0 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498803800 nid&#x3D;0x2207 runnable &quot;GC task thread#1 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498804000 nid&#x3D;0x2103 runnable &quot;GC task thread#2 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498804800 nid&#x3D;0x1e03 runnable &quot;GC task thread#3 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498805000 nid&#x3D;0x2a03 runnable &quot;GC task thread#4 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498806000 nid&#x3D;0x5403 runnable &quot;GC task thread#5 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff496802000 nid&#x3D;0x5303 runnable &quot;GC task thread#6 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff496802800 nid&#x3D;0x5103 runnable &quot;GC task thread#7 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff495800800 nid&#x3D;0x4f03 runnable &quot;VM Periodic Task Thread&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498824800 nid&#x3D;0x5703 waiting on condition JNI global references: 2505Found one Java-level deadlock:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;线程 2&quot;: waiting to lock monitor 0x00007ff4998056a8 (object 0x000000076af91968, a java.lang.Object), which is held by &quot;线程 1&quot;&quot;线程 1&quot;: waiting to lock monitor 0x00007ff499801608 (object 0x000000076af91978, a java.lang.Object), which is held by &quot;线程 2&quot;Java stack information for the threads listed above:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;线程 2&quot;: at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34) - waiting to lock &lt;0x000000076af91968&gt; (a java.lang.Object) - locked &lt;0x000000076af91978&gt; (a java.lang.Object) at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$2&#x2F;194494468.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)&quot;线程 1&quot;: at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$0(DeadLockDemo.java:19) - waiting to lock &lt;0x000000076af91978&gt; (a java.lang.Object) - locked &lt;0x000000076af91968&gt; (a java.lang.Object) at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$1&#x2F;972765878.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock. 可以看到 jstack 命令已经帮我们找到发生死锁的线程的具体信息。 6. jinfo jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令 命令帮助 1234567891011121314151617[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -helpUsage: jinfo [option] &lt;pid&gt; (to connect to running process) jinfo [option] &lt;executable &lt;core&gt; (to connect to a core file) jinfo [option] [server_id@]&lt;remote server IP or hostname&gt; (to connect to remote debug server)where &lt;option&gt; is one of: -flag &lt;name&gt; to print the value of the named VM flag -flag [+|-]&lt;name&gt; to enable or disable the named VM flag -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value -flags to print VM flags -sysprops to print Java system properties &lt;no option&gt; to print both of the above -h | -help to print this help message 参数详解 123-flag : 输出指定args参数的值-flags : 不需要args参数，输出所有JVM参数的值-sysprops : 输出系统属性，等同于System.getProperties() 示例详情 -flags 1234567[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flags 1701Attaching to process ID 1701, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.201-b09Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=31457280 -XX:MaxHeapSize=482344960 -XX:MaxNewSize=160759808 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=10485760 -XX:OldSize=20971520 -XX:+UseCompressedClassPointers -XX:+UseCompressedOopsCommand line: -flag jinfo -flag name vmid :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails :详细 GC 日志模式，这两个都是默认关闭的)。 1234[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag MaxHeapSize 1701-XX:MaxHeapSize=482344960[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag PrintGC 1701-XX:-PrintGC 使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用。** jinfo -flag [+|-]name vmid 开启或者关闭对应名称的参数。 12345[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag PrintGC 1701-XX:-PrintGC[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag +PrintGC 1701[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag PrintGC 1701-XX:+PrintGC JVM查看运行时参数 打印命令行参数 12345[root@iz2ze2e5wmatyx36v5jw5lz ~]# java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize=30115776 -XX:MaxHeapSize=481852416 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOopsjava version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) 打印初始参数 1java -XX:+PrintFlagsInitial -version 查看最终值 1java -XX:+PrintFlagsFinal -version 生成dump文件 JVM的配置文件中配置： 例如：堆初始化大小，而堆最大大小 在应用启动时配置相关的参数 -XX:+HeapDumpOnOutOfMemoryError，当应用抛出OutOfMemoryError时生成dump文件。 在启动的时候，配置文件在哪个目录下面： -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=目录+产生的时间.hprof JVM启动时增加两个参数: 12345#出现 OOME 时生成堆 dump:-XX:+HeapDumpOnOutOfMemoryError#生成堆文件地址：-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;liuke&#x2F;jvmlogs&#x2F; 发现程序异常前通过执行指令，直接生成当前JVM的dmp文件，6214是指JVM的进程号 jmap -dump:file=文件名.dump [pid] 1jmap -dump:format&#x3D;b,file&#x3D;serviceDump.dat 6214 由于第一种方式是一种事后方式，需要等待当前JVM出现问题后才能生成dmp文件，实时性不高，第二种方式在执行时，JVM是暂停服务的，所以对线上的运行会产生影响。所以建议第一种方式。 生产级JVM参数配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#x2F;&#x2F;4核心8G内存配置 -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize&#x3D;256M -XX:MaxMetaspaceSize&#x3D;256M -XX:ReservedCodeCacheSize&#x3D;256M-XX:MaxDirectMemorySize&#x3D;1g &#x2F;&#x2F;8核16G内存配置-Xms10g -Xmx10g -Xmn6g -XX:MetaspaceSize&#x3D;512M -XX:MaxMetaspaceSize&#x3D;512M -XX:ReservedCodeCacheSize&#x3D;512M-XX:MaxDirectMemorySize&#x3D;1g &#x2F;&#x2F; Tuning JVM for Production Deployments&#x2F;&#x2F; &gt; java8&#x2F;&#x2F; 生产环境推荐-server -Xms24G-Xmx24G-XX:PermSize&#x3D;512m-XX:+UseG1GC -XX:MaxGCPauseMillis&#x3D;200 -XX:ParallelGCThreads&#x3D;20 -XX:ConcGCThreads&#x3D;5 -XX:InitiatingHeapOccupancyPercent&#x3D;70&#x2F;&#x2F; 从服务器推荐-server -Xms4G -Xmx4G -XX:PermSize&#x3D;512m -XX:+UseG1GC -XX:MaxGCPauseMillis&#x3D;200 -XX:ParallelGCThreads&#x3D;20 -XX:ConcGCThreads&#x3D;5 -XX:InitiatingHeapOccupancyPercent&#x3D;70&#x2F;&#x2F; 独立服务器-server -Xms32G -Xmx32G -XX:PermSize&#x3D;512m -XX:+UseG1GC -XX:MaxGCPauseMillis&#x3D;200 -XX:ParallelGCThreads&#x3D;20 -XX:ConcGCThreads&#x3D;5 -XX:InitiatingHeapOccupancyPercent&#x3D;70&#x2F;&#x2F; http:&#x2F;&#x2F;www.51gjie.com&#x2F;java&#x2F;551.html&#x2F;&#x2F; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;gxyandwmm&#x2F;p&#x2F;9456955.html&#x2F;&#x2F; For JDK 1.7⁄ 1.8 (8GB heap example for machine with 32 CPUs):-server &#x2F;&#x2F; 服务器模式-Xms8g &#x2F;&#x2F; JVM初始分配的堆内存，一般和Xmx配置成一样以避免每次gc后JVM重新分配内存-Xmx8g &#x2F;&#x2F; JVM最大允许分配的堆内存，按需分配-XX:+UseParNewGC &#x2F;&#x2F; 年轻代垃圾收集器-XX:+UseConcMarkSweepGC &#x2F;&#x2F; 并发标记清除（CMS）收集器 (年老代)-XX:+UseTLAB -XX:NewSize&#x3D;128m &#x2F;&#x2F; 年轻代大小-XX:MaxNewSize&#x3D;128m &#x2F;&#x2F; 最大年轻代大小-XX:MaxTenuringThreshold&#x3D;2 &#x2F;&#x2F; 提升年老代的最大临界值,JDK8里CMS 默认是6，其他如G1是15-XX:SurvivorRatio&#x3D;8 &#x2F;&#x2F; Eden区与Survivor区的大小比值-XX:+UseCMSInitiatingOccupancyOnly &#x2F;&#x2F;使用手动定义初始化定义开始CMS收集-XX:CMSInitiatingOccupancyFraction&#x3D;40 &#x2F;&#x2F;使用cms作为垃圾回收使用40％后开始CMS收集-XX:MaxGCPauseMillis&#x3D;1000 &#x2F;&#x2F; 用户设定的最大gc 停顿时间1000ms-XX:InitiatingHeapOccupancyPercent&#x3D;50 &#x2F;&#x2F; heap中50%的容量被使用，则会触发concurrent gc-XX:+UseCompressedOops-XX:ParallelGCThreads&#x3D;8 &#x2F;&#x2F; 设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.-XX:ConcGCThreads&#x3D;8 -XX:+DisableExplicitGC &#x2F;&#x2F; 忽略手动调用GC, System.gc()的调用就会变成一个空调用，完全不触发GC JVM参数设置优化例子 1. 承受海量访问的动态Web应用 服务器配置：8 CPU, 8G MEM, JDK 1.6.X 参数方案： -server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC 调优说明： -Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。 -Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。 -Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。 -XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。 -XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。 -XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。 -XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。 2. 内部集成构建服务器案例 高性能数据处理的工具应用 服务器配置：1 CPU, 4G MEM, JDK 1.6.X 参数方案： -server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m 调优说明： -XX:PermSize=196m -XX:MaxPermSize=196m 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。 -Xmn320m 遵循年轻代大小为整个堆的3/8原则。 -Xms768m -Xmx1024m 根据系统大致能够承受的堆内存大小设置即可。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/categories/jvm/"}],"tags":[{"name":"调优","slug":"调优","permalink":"https://idea360.cn/tags/%E8%B0%83%E4%BC%98/"},{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"}]},{"title":"JVM垃圾回收","slug":"jvm-gc","date":"2021-08-05T15:48:21.000Z","updated":"2021-08-05T16:22:58.657Z","comments":true,"path":"2021/08/05/jvm-gc/","link":"","permalink":"https://idea360.cn/2021/08/05/jvm-gc/","excerpt":"","text":"JVM 垃圾回收 写在前面 本节常见面试题 问题答案在文中都有提到 如何判断对象是否死亡（两种方法）。 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。 如何判断一个常量是废弃常量 如何判断一个类是无用的类 垃圾收集有哪些算法，各自的特点？ HotSpot 为什么要分为新生代和老年代？ 常见的垃圾回收器有哪些？ 介绍一下 CMS,G1 收集器。 Minor Gc 和 Full GC 有什么不同呢？ 本文导火索 当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。 1 揭开 JVM 内存分配与回收的神秘面纱 Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 堆空间的基本结构： 参考自oracle 上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次GC后，Eden区和&quot;From&quot;区已经被清空。这个时候，“From&quot;和&quot;To&quot;会交换他们的角色，也就是新的&quot;To&quot;就是上次GC前的“From”，新的&quot;From&quot;就是上次GC前的&quot;To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，&quot;To&quot;区被填满之后，会将所有对象移动到老年代中。 1.1 对象优先在 eden 区分配 目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。 在测试之前我们先来看看 Minor GC 和 Full GC 有什么不同呢？ 新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。 老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。 测试： 12345678public class GCTest &#123; public static void main(String[] args) &#123; byte[] allocation1, allocation2; allocation1 = new byte[30900*1024]; //allocation2 = new byte[900*1024]; &#125;&#125; 通过以下方式运行： 添加的参数：-XX:+PrintGCDetails 运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)： 从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？ 1allocation2 &#x3D; new byte[900*1024]; 简单解释一下为什么会出现这种情况： 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证： 1234567891011public class GCTest &#123; public static void main(String[] args) &#123; byte[] allocation1, allocation2,allocation3,allocation4,allocation5; allocation1 &#x3D; new byte[32000*1024]; allocation2 &#x3D; new byte[1000*1024]; allocation3 &#x3D; new byte[1000*1024]; allocation4 &#x3D; new byte[1000*1024]; allocation5 &#x3D; new byte[1000*1024]; &#125;&#125; 1.2 大对象直接进入老年代 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。 为什么要这样呢？ 为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 1.3 长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 1.4 动态对象年龄判定 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 修正（issue552）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。 动态年龄计算的代码如下 12345678910111213uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123; &#x2F;&#x2F;survivor_capacity是survivor空间的大小 size_t desired_survivor_size &#x3D; (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)&#x2F;100); size_t total &#x3D; 0; uint age &#x3D; 1; while (age &lt; table_size) &#123; total +&#x3D; sizes[age];&#x2F;&#x2F;sizes数组是每个年龄段对象大小 if (total &gt; desired_survivor_size) break; age++; &#125; uint result &#x3D; age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold; ...&#125; 1.5 分配担保 我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代内存进行分配担保（Handle Promotion）。如果另外一块Survivor上没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。 2 对象已经死亡？ 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。 2.1 引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。 123456789101112public class ReferenceCountingGc &#123; Object instance &#x3D; null; public static void main(String[] args) &#123; ReferenceCountingGc objA &#x3D; new ReferenceCountingGc(); ReferenceCountingGc objB &#x3D; new ReferenceCountingGc(); objA.instance &#x3D; objB; objB.instance &#x3D; objA; objA &#x3D; null; objB &#x3D; null; &#125;&#125; 2.2 可达性分析算法 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包含以下几种： 虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象) 方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象) 方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象) 本地方法栈中(Native方法)引用的对象(可以理解为:引用Native方法的所有对象) 2.3 再谈引用 无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱） 1．强引用（StrongReference） 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 2．软引用（SoftReference） 如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。 3．弱引用（WeakReference） 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。 4．虚引用（PhantomReference） &quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 2.4 不可达的对象并非“非死不可” 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。 2.5 如何判断一个常量是废弃常量 运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？ 假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。 2.6 如何判断一个类是无用的类 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 3 垃圾收集算法 3.1 标记-清除算法 该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题： 效率问题 空间问题（标记清除后会产生大量不连续的碎片） 3.2 复制算法 为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 3.3 标记-整理算法 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 3.4 分代收集算法 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。 延伸面试问题： HotSpot 为什么要分为新生代和老年代？ 根据上面的对分代收集算法的介绍回答。 4 垃圾收集器 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。 4.1 Serial 收集器 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。 新生代采用复制算法，老年代采用标记-整理算法。 虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。 但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。 4.2 ParNew 收集器 ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。 新生代采用复制算法，老年代采用标记-整理算法。 它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。 并行和并发概念补充： 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。 4.3 Parallel Scavenge 收集器 Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 那么它有什么特别之处呢？ 1234567-XX:+UseParallelGC 使用 Parallel 收集器+ 老年代串行-XX:+UseParallelOldGC 使用 Parallel 收集器+ 老年代并行 Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。 新生代采用复制算法，老年代采用标记-整理算法。 4.4.Serial Old 收集器 Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。 4.5 Parallel Old 收集器 Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。 4.6 CMS 收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对 CPU 资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 4.7 G1 收集器 G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征. 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点： 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。 空间整合：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。 G1 收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。 4.8. 老年代垃圾收集器对比 4.9. 总结 收集器 串行、并行or并发 新生代/老年代 算法 目标 适用场景 Serial 串行 新生代 复制算法 响应速度优先 单CPU环境下的Client模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单CPU环境下的Client模式、CMS的后备预案 ParNew 并行 新生代 复制算法 响应速度优先 多CPU环境时在Server模式下与CMS配合 Parallel Scavenge 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并发 老年代 标记-清除 响应速度优先 集中在互联网站或B/S系统服务端上的Java应用 G1 并发 both 标记-整理+复制算法 响应速度优先 面向服务端应用，将来替换CMS 5. 几种常见的垃圾收集器组合 5.1. 常见垃圾收集器组合 以下内容来自oracle官方。 5.2. 有效的虚拟机组合 5.3. 官方推荐组合 5.4. JDK6官方推荐 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》 https://my.oschina.net/hosee/blog/644618 https://docs.oracle.com/javase/specs/jvms/se8/html/index.html https://crowhawk.github.io/2017/08/15/jvm_3/ https://www.cnblogs.com/alsf/p/9484770.html https://blog.liu-kevin.com/2019/12/29/jvmla-ji-hui-shou-qi/","categories":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://idea360.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"JVM类加载机制","slug":"jvm-class-loader","date":"2021-08-05T15:46:32.000Z","updated":"2021-08-05T16:12:02.616Z","comments":true,"path":"2021/08/05/jvm-class-loader/","link":"","permalink":"https://idea360.cn/2021/08/05/jvm-class-loader/","excerpt":"","text":"JVM类加载机制 1. 什么是类的加载 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 2. 类的生命周期 加载 类加载过程的第一步，主要完成下面3件事情： 通过全类名获取定义此类的二进制字节流 将字节流所代表的静态存储结构转换为方法区的运行时数据结构 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 验证：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的 静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。 这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。 解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。 符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。 综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。 初始化 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ①声明类变量是指定初始值 ②使用静态代码块为类变量指定初始值 JVM初始化步骤 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类 结束生命周期 在如下几种情况下，Java虚拟机将结束生命周期 执行了 System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 3. 类加载器 JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader： BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。 ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。 AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。 JVM类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 4. 类的加载 类加载有三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 3、通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别 Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 5. 双亲委派模型 每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。 每个类加载都有一个父类加载器，我们通过下面的程序来验证。 1234567public class ClassLoaderDemo &#123; public static void main(String[] args) &#123; System.out.println(&quot;ClassLodarDemo&#x27;s ClassLoader is &quot; + ClassLoaderDemo.class.getClassLoader()); System.out.println(&quot;The Parent of ClassLodarDemo&#x27;s ClassLoader is &quot; + ClassLoaderDemo.class.getClassLoader().getParent()); System.out.println(&quot;The GrandParent of ClassLodarDemo&#x27;s ClassLoader is &quot; + ClassLoaderDemo.class.getClassLoader().getParent().getParent()); &#125;&#125; Output 1ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2 The Parent of ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586 The GrandParent of ClassLodarDemo&#x27;s ClassLoader is null AppClassLoader的父类加载器为ExtClassLoader ExtClassLoader的父类加载器为null，null并不代表ExtClassLoader没有父类加载器，而是 BootstrapClassLoader 。 双亲委派模型实现源码分析 123456789101112131415161718192021222324252627282930313233343536private final ClassLoader parent; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先，检查请求的类是否已经被加载过 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123;//父加载器不为空，调用父加载器loadClass()方法处理 c = parent.loadClass(name, false); &#125; else &#123;//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; //抛出异常说明父类加载器无法完成加载请求 &#125; if (c == null) &#123; long t1 = System.nanoTime(); //自己尝试加载 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 双亲委派模型的好处 双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。 如果我们不想用双亲委派模型怎么办？ 为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 loadClass() 即可。 6. 自定义类加载器 通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.demojava;import java.io.*;public class MyClassLoader extends ClassLoader &#123; private String root; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String className) &#123; String fileName = root + File.separatorChar + className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getRoot() &#123; return root; &#125; public void setRoot(String root) &#123; this.root = root; &#125; public static void main(String[] args) &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot(&quot;E:\\\\temp&quot;); Class&lt;?&gt; testClass = null; try &#123; testClass = classLoader.loadClass(&quot;com.neo.classloader.Test2&quot;); Object object = testClass.newInstance(); System.out.println(object.getClass().getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意： 1、这里传递的文件名需要是类的全限定性名称，即 com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。 2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。 3、这类Test 类本身可以被 AppClassLoader类加载，因此我们不能把 com/paddx/test/classloading/Test.class放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader加载，而不会通过我们自定义类加载器来加载。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"},{"name":"类加载机制","slug":"类加载机制","permalink":"https://idea360.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"}]},{"title":"JVM内存结构","slug":"jvm-memory-structure","date":"2021-08-05T15:44:51.000Z","updated":"2021-08-05T16:10:29.218Z","comments":true,"path":"2021/08/05/jvm-memory-structure/","link":"","permalink":"https://idea360.cn/2021/08/05/jvm-memory-structure/","excerpt":"","text":"JVM内存结构 1. 前言 以下是阅读《深入理解java虚拟机》一书的笔记，仅供参考 JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area classloader 把硬盘上的class 文件加载到JVM中的运行时数据区域, 但是它不负责这个类文件能否执行，而这个是 执行引擎 负责的。 上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。 但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次上下文切换。 切换诱因 在操作系统中，上下文切换的类型可以分为进程间的上下文切换和线程间的上下文切换 线程状态：NEW、RUNNABLE、RUNNING、BLOCKED、DEAD Java线程状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 线程上下文切换：RUNNING -&gt; BLOCKED -&gt; RUNNABLE -&gt; 被调度器选中执行 一个线程从RUNNING状态转为BLOCKED状态，称为一个线程的暂停 线程暂停被切出后，操作系统会保存相应的上下文 以便该线程再次进入RUNNABLE状态时能够在之前执行进度的基础上继续执行 一个线程从BLOCKED状态进入RUNNABLE状态，称为一个线程的唤醒 此时线程将获取上次保存的上下文继续执行 诱因：程序本身触发的自发性上下文切换、系统或虚拟机触发的非自发性上下文切换 自发性上下文切换 sleep、wait、yield、join、park、synchronized、lock 非自发性上下文切换 线程被分配的时间片用完、JVM垃圾回收（STW、线程暂停）、线程执行优先级 切换的系统开销 操作系统保存和恢复上下文 调度器进行线程调度 处理器高速缓存重新加载 可能导致整个高速缓存区被冲刷，从而带来时间开销 锁竞争才是性能开销的根源 所以，优化方向有： 减少锁粒度、非阻塞锁代替竞争锁等(比如自旋锁，本身没有阻塞，不需要保存上下文信息) 2. 运行时数据区 1. 程序计数器 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 从上面的介绍中我们知道程序计数器主要有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 2. 虚拟机栈 与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。） 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。 OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。 Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 扩展：那么方法/函数如何调用？ Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。 Java 方法有两种返回方式： return 语句。 抛出异常。 不管哪种返回方式都会导致栈帧被弹出 3. 本地方法栈 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。 4. 堆 Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分： 新生代内存(Young Ceneration) 老生代(Old Generation) 永生代(Permanent Generation) JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 动态年龄 “Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。 堆这里最容易出现的就是 OutOfMemoryError 异常，并且出现这种异常之后的表现形式还会有几种，比如： OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。 java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的对内存大小有关！) … 5. 方法区 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。 方法区和永久代的关系 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。 6. 运行时常量池 运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"},{"name":"内存结构","slug":"内存结构","permalink":"https://idea360.cn/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"}]},{"title":"JVM内存模型","slug":"jvm-memory-model","date":"2021-08-05T15:42:44.000Z","updated":"2021-08-05T16:08:03.282Z","comments":true,"path":"2021/08/05/jvm-memory-model/","link":"","permalink":"https://idea360.cn/2021/08/05/jvm-memory-model/","excerpt":"","text":"Java内存模型 在Java JVM系列文章中有朋友问为什么要JVM，Java虚拟机不是已经帮我们处理好了么？同样，学习Java内存模型也有同样的问题，为什么要学习Java内存模型。它们的答案是一致的：能够让我们更好的理解底层原理，写出更高效的代码。 就Java内存模型而言，它是深入了解Java并发编程的先决条件。对于后续多线程中的线程安全、同步异步处理等更是大有裨益。 硬件内存架构 在学习Java内存模型之前，先了解一下计算机硬件内存模型。我们多知道处理器与计算机存储设备运算速度有几个数量级的差别。总不能让处理器总是等待计算机存储设备，这样就没办法显现出处理器的优势。 因此，为了“压榨”处理的性能，达到“高并发”的效果，在处理器和存储设备之间加入了高速缓存（cache）来作为缓冲。 将运算需要使用到的数据复制到缓存中，让运算能够快速进行。当运算完成之后，再将缓存中的结果写入主内存，这样运算器就不用等待主内存的读写操作了。 每个处理器都有自己的高速缓存，同时又共同操作同一块主内存，当多个处理器同时操作主内存时，可能导致数据不一致，因此需要“缓存一致性协议”来保障。比如，MSI、MESI等。 JVM内存结构简单介绍 我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。 在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下： Java内存模型 Java内存模型即Java Memory Model，简称JMM。用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能够达到一致的内存访问效果。 JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 JMM与Java内存结构并不是同一个层次的内存划分，两者基本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义看，主内存主要对应Java堆中的对象实例数据部分，工作内存则对应虚拟机栈的部分区域。 主内存：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。 工作内存：主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。 JMM模型与硬件模型直接的对照关系可简化为下图： 内存之间的交互操作 线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 如上图，本地内存A和B有主内存中共享变量x的副本，初始值都为0。线程A执行之后把x更新为1，存放在本地内存A中。当线程A和线程B需要通信时，线程A首先会把本地内存中x=1值刷新到主内存中，主内存中的x值变为1。随后，线程B到主内存中去读取更新后的x值，线程B的本地内存的x值也变为了1。 在此交互过程中，Java内存模型定义了8种操作来完成，虚拟机实现必须保证每一种操作都是原子的、不可再拆分的（double和long类型例外）。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果需要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8中基本操作时必须满足如下规则。 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 long和double型变量的特殊规则 Java内存模型要求lock，unlock，read，load，assign，use，store，write这8个操作都具有原子性，但对于64位的数据类型（long或double），在模型中定义了一条相对宽松的规定，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load，store，read，write这4个操作的原子性，即long和double的非原子性协定。 如果多线程的情况下double或long类型并未声明为volatile，可能会出现“半个变量”的数值，也就是既非原值，也非修改后的值。 虽然Java规范允许上面的实现，但商用虚拟机中基本都采用了原子性的操作，因此在日常使用中几乎不会出现读取到“半个变量”的情况。 小结 本节课重点介绍了Java内存模型以及内存交互的步骤和操作。下篇文章将重点介绍Java内存模型涉及的几个特征和原则。欢迎关注微信公众号“程序新视界”，第一时间获得最新文章的更新。 本文部分内容引自周志明《深入理解java虚拟机》。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://juejin.im/post/5dbfa0aa51882538ce1a4ebc https://zhuanlan.zhihu.com/p/29881777","categories":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"},{"name":"内存模型","slug":"内存模型","permalink":"https://idea360.cn/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"}]},{"title":"MySQL事务","slug":"mysql-transaction","date":"2021-08-05T15:37:47.000Z","updated":"2021-08-05T16:29:20.464Z","comments":true,"path":"2021/08/05/mysql-transaction/","link":"","permalink":"https://idea360.cn/2021/08/05/mysql-transaction/","excerpt":"","text":"事务隔离级别 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITED YES YES YES READ COMMITED NO YES YES REPEATABLE READ NO NO YES RSERIALIZABLE NO NO NO mysql默认事务隔离级别是Repeatable Read级别 脏读: 读取到了其他事务未提交的数据 不可重复读: A事务读取到了B事务已经提交的数据，造成2次读取的结果不一致 幻读: A事务读取到了B事务新插入的数据 事务实现原理 实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC redo log redo log叫做重做日志，是用来实现事务的持久性。 该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）, 前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。 如下场景：假设银行转账场景 1234567start transaction;select balance from bank where name&#x3D;&quot;zhangsan&quot;;-- 生成 重做日志 balance&#x3D;600update bank set balance &#x3D; balance - 400; -- 生成 重做日志 amount&#x3D;400update finance set amount &#x3D; amount + 400;commit; InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。 为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射， 作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool； 当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。 Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。 于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作； 当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。 redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。 既然redo log也需要在事务提交时将日志写入磁盘，为什么它不直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因： 1、刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。 2、刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。 undo log undo log叫做回滚日志，用于记录数据被修改前的信息。 他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。 undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。 从上图可以了解到数据的变更都伴随着回滚日志的产生： (1) 产生了被修改前数据(zhangsan,1000) 的回滚日志 (2) 产生了被修改前数据(zhangsan,0) 的回滚日志 根据上面流程可以得出如下结论： 每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上 所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。 回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如： (1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句 (2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句 (3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句 当前读与快照读 当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁； 使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作，如下所示： 12345select * from table where ? lock in share mode;select * from table where ? for update;insert into table values (…);update table set ? where ?;delete from table where ?; 注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。 快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现； InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见； MVCC 数据库底层是怎么实现隔离性的呢？都采用了哪些技术呢？ 主要有两个技术：MVCC(多版本并发控制)和锁。 MVCC『多版本并发控制』，与之对应的是『基于锁的并发控制』； MVCC的最大好处：读不加任何锁，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能； InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，使用MVCC，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见； 事务原理分析 1234事务的原子性是通过 undo log 来实现的事务的持久性性是通过 redo log 来实现的事务的隔离性是通过 (读写锁+MVCC)来实现的而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！ RR解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。 MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和undo log。 其中数据的隐藏列包括了该行数据的版本号、删除时间、指向undo log的指针等等； 当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo log，从而实现MVCC。 如何避免脏读？ 当事务A执行查询时，如发现数据已被其他事务修改，且状态为未提交。 此时事务A读取最新数据后，根据数据的undo log执行回滚操作，得到事务B修改前的数据，从而避免了脏读。 如何避免不可重复读？ 当事务A第一次读取数据时，会记录该数据的版本号（数据的版本号是以row为单位记录的），假设版本号为1； 当事务B提交时，该行记录的版本号增加，假设版本号为2； 当事务A再一次读取数据时，发现数据的版本号（2）大于第一次读取时记录的版本号（1），因此会根据undo log执行回滚操作，得到版本号为1时的数据，从而实现了可重复读。 如何避免幻读？ InnoDB实现的RR通过next-key lock机制避免了幻读现象。 next-key lock是行锁的一种，实现相当于record lock(记录锁) + gap lock(间隙锁)； 其特点是不仅会锁住记录本身(record lock的功能)，还会锁定一个范围(gap lock的功能)。 例如： 当事务A在第一次读取0&lt;id&lt;5数据时，标记的不只是id=1的数据，而是将范围(0,5)进行了标记， 这样当T5时刻再次读取0&lt;id&lt;5数据时，便可以发现id=4的数据比之前标记的版本号更高， 此时再结合undo log执行回滚操作，避免了幻读。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://idea360.cn/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"https://idea360.cn/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"MySQL索引","slug":"mysql-index","date":"2021-08-05T15:35:13.000Z","updated":"2021-08-05T16:31:08.976Z","comments":true,"path":"2021/08/05/mysql-index/","link":"","permalink":"https://idea360.cn/2021/08/05/mysql-index/","excerpt":"","text":"摘要 从索引角度谈MySQL优化。 InnoDB 索引的本质 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。 最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法， 例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上, 但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织）， 所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 看一个例子： 图一 图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。 为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。 虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。 数据结构基础我们可以参考数据结构与算法（java版） 普通查找 假设我们不用索引查找，那么会怎么样呢？很惨，我们必须全文顺序检索，直到查到我们需要的数据，时间复杂度为O(n) 二分查找 二分查找的前提是数据是有序数组,有序数组可以利用二分查找法快速的查找特定的值,时间复杂度为O(log2n)。 但是插入数据时很慢，插入的时候需要迭代检索数组直到找到排序位置，并且插入后右侧元素需要依次右移1位，时间复杂度为O(N)。 所以我们需要寻找更优质的数据结构和算法来均衡读写复杂度，于是引出了下边的二叉树。 二叉查找树 二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。 如下图所示就是一棵二叉查找树: 但是我们想一个问题，假设我们数据的插入顺序是由小到大呢，那么数据就会都在我们的右子树，数据结构转为单链表查询，插入、删除的效率将会严重地降低，时间复杂度变为O(n) 因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树 红黑树 红黑树就是一种二叉平衡树。这里我们插一点磁盘的知识帮助理解: 我们数据库查询的瓶颈从来都不是索引本身,也不是CPU,而是IO操作。相对于内存存取，I/O存取的消耗要高几个数量级假设我们的内存可以存放足够大的数据，那么我们是不需要维护索引的，我们可以在内存中直接通过查找算法去快速检索数据。 索引在数据库中是以文件的形式存在的，文件本身是没有计算功能的，它必须加载到内存，通过CPU的计算才会生成树结构进行查询。 但是系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。 这样就决定了我们的数据无法一次取出所有，只能分块取出，当然我们的内存也不能够一次加载大量数据。 InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K。 而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。 当需要查询的数据足够大时，红黑树的树深度会变得很大，由于磁盘读取机制，决定了我们每次读取的数据有限，这样就需要频繁的操作磁盘IO，性能便会下降 B-Tree 由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。 另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质,这里我们暂时不做讨论。 B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。 B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： 每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。 模拟查找关键字29的过程： 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字29在区间（17,35），找到磁盘块1的指针P2。 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】 比较关键字29在区间（26,30），找到磁盘块3的指针P2。 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】 在磁盘块8中的关键字列表中找到关键字29。 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。 B+Tree B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。 从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。 B+Tree相对于B-Tree有几点不同： 非叶子节点只存储键值信息。 所有叶子节点之间都有一个链指针。 数据记录都存放在叶子节点中。 将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。 可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算： InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗3）。也就是说一个深度为3的B+Tree索引可以维护103 * 10^3 * 10^3 = 10亿 条记录。 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。 数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。 上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。 辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。 当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。 所以这里也反映了主键不能太长的原因，同时应该尽量选取自增字段符合B+Tree的数据结构(数据存放在叶子节点) MyISAM MyISAM引擎也使用B+树作为索引结果，不同的是叶节点的data域存放的是数据记录的地址，如图所示： MyISAM的索引与行记录是分开存储的，叫做非聚集索引。 其主键索引与普通索引没有本质差异： 有连续聚集的区域单独存储行记录 主键索引的叶子节点，存储主键与对应行记录的指针 普通索引的叶子结点，存储索引列，与对应行记录的指针 画外音：MyISAM的表可以没有主键。 此外还有Hash索引，但是由于hash的散列性质，单个查找相当快，当我们需要范围查询的时候由于无法排序，会造成全表扫描。 聚集索引与非聚集索引 简单理解就是聚集索引物理顺序存储，非聚集索引随机存储 这里的存储是索引到的数据行，而非索引段本身 InnoDB的主键索引与行记录是存储在一起的，故叫做聚集索引，必须要有主键，通过主键索引效率很高，InnoDB一定有且只有一个聚集索引。 但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。 InnoDB的聚集索引存储数据行本身，普通索引存储主键 以MySQL的InnoDB存储引擎为例，可以有如下解释： 每个索引上包含的字段会有不同，聚集索引包含所有字段，非聚集索引只包含索引字段+主键字段，所以如果在使用非聚集索引后还需要使用其他字段的（包括在where条件中或者select子句中），则需要通过主键索引回表到聚集索引获取其他字段。如果是非聚集索引可以满足SQL语句的所有字段的，则被称为全覆盖索引，没有回表开销。 回表是一个通过主键字段重新查询聚集索引的过程，所以如果在大量记录需要回表的情况下，查询成本会比直接在聚集索引上范围扫描的成本还大。所以对于一些情况，不使用非聚集索引效率反而更高。 MyISAM的索引与行记录是分开存储的，叫做非聚集索引。主键索引和辅助索引是独立的。 其主键索引与普通索引没有本质差异： 有连续聚集的区域单独存储行记录 主键索引的叶子节点，存储主键，与对应行记录的指针 普通索引的叶子结点，存储索引列，与对应行记录的指针 画外音：MyISAM的表可以没有主键。 SQL调优 执行计划中type调优 首先我们创建一张测试表来测试： 12345678910111213141516DROP TABLE IF EXISTS &#96;test_explain_type&#96;;CREATE TABLE &#96;test_explain_type&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;a&#96; int(11) NOT NULL, &#96;b&#96; int(11) NOT NULL, &#96;c&#96; int(11) NOT NULL, PRIMARY KEY (&#96;id&#96;), KEY &#96;index_type&#96; (&#96;a&#96;, &#96;b&#96;) USING BTREE) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;insert into test_explain_type(id,a,b,c) values (3,4,2,4);insert into test_explain_type(id,a,b,c) values (2,7,6,5);insert into test_explain_type(id,a,b,c) values (4,4,1,6);insert into test_explain_type(id,a,b,c) values (1,4,4,9);insert into test_explain_type(id,a,b,c) values (5,2,7,2);insert into test_explain_type(id,a,b,c) values (7,4,0,0); 下边的过程是依据我本地的mysql版本来的 1234567mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.17 |+-----------+1 row in set (0.00 sec) 查看表结构 12345678910mysql&gt; desc test_explain_type;+-------+---------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || a | int(11) | NO | MUL | NULL | || b | int(11) | NO | | NULL | || c | int(11) | NO | | NULL | |+-------+---------+------+-----+---------+----------------+4 rows in set (0.00 sec) 执行查询计划 1234567mysql&gt; explain select * from test_explain_type;+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------+| 1 | SIMPLE | test_explain_type | NULL | ALL | NULL | NULL | NULL | NULL | 6 | 100.00 | NULL |+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec) 上边的执行结果，我们首先要关心的是type参数，type=all,看得出这里走了全表扫描。 首先对结果参数进行说明 1234567891011121314151617181920212223各列的含义如下: id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符. select_type: SELECT 查询的类型. table: 查询的是哪个表 partitions: 匹配的分区 type: join 类型 possible_keys: 此次查询中可能选用的索引 key: 此次查询中确切使用到的索引. ref: 哪个字段或常数与 key 一起被使用 rows: 显示此查询一共扫描了多少行. 这个是一个估计值. filtered: 表示此查询条件所过滤的数据的百分比 extra: 额外的信息 这里重点说明下type： 1234567891011121314type： 连接类型(下面的从好到坏依次解释) system 触发条件：表只有一行，这是一个const type 的特殊情况。 const 触发条件：使用了主键或唯一索引索引的查询，最多只有一行匹配。 eq_ref 触发条件：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件 ref 触发条件：使用非唯一索引扫描，还可见于唯一索引最左原则匹配扫描 range 范围扫描通常出现在in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。 index 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据. 以下两种情况会触发： 1、如果索引是查询的覆盖索引，就是说索引查询的数据可以满足查询中所需的所有数据，则只扫描索引树，不需要回表查询。 在这种情况下，explain 的 Extra 列的结果是 Using index。仅索引扫描通常比ALL快，因为索引的大小通常小于表数据。 2、全表扫描会按索引的顺序来查找数据行。使用索引不会出现在Extra列中。 all 全表扫描 下边我们分别对几种索引连接类型进行说明： 1、index类型 1234567mysql&gt; explain select id from test_explain_type;+----+-------------+-------------------+------------+-------+---------------+------------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------------------+------------+-------+---------------+------------+---------+------+------+----------+-------------+| 1 | SIMPLE | test_explain_type | NULL | index | NULL | index_type | 8 | NULL | 6 | 100.00 | Using index |+----+-------------+-------------------+------------+-------+---------------+------------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 这里全表扫描主键索引id，性能比all略好 2、range类型 1234567mysql&gt; explain select * from test_explain_type where id&gt;1;+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+| 1 | SIMPLE | test_explain_type | NULL | range | PRIMARY | PRIMARY | 4 | NULL | 5 | 100.00 | Using where |+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 这里检索条件是索引字段上的范围值，走range。但是这里需要注意的是，当查询条件为非主键索引字段时，如果范围查询的条件全表满足，就会变成全表扫描，如下： 1234567mysql&gt; explain select * from test_explain_type where a&gt;2;+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | test_explain_type | NULL | ALL | index_type | NULL | NULL | NULL | 6 | 83.33 | Using where |+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 3、ref类型 使用了非主键或者非唯一索引的普通索引(即索引可以重复情况下的) 1234567mysql&gt; explain select * from test_explain_type where a&#x3D;10;+----+-------------+-------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+| 1 | SIMPLE | test_explain_type | NULL | ref | index_type | index_type | 4 | const | 1 | 100.00 | NULL |+----+-------------+-------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec) 4、const类型 使用了主键索引的查询 1234567mysql&gt; explain select * from test_explain_type where id&#x3D;1;+----+-------------+-------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| 1 | SIMPLE | test_explain_type | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL |+----+-------------+-------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.01 sec) 优化分页查询 经常使用LIMIT M,N+ORDER BY来实现分页查询 在没有任何索引条件支持的情况下，需要做大量的文件排序操作（file sort），性能很差 即便有对应的索引，也只是在刚开始时效率比较理想，越往后，性能越差 使用LIMIT M,N时，偏移量M越大，数据库检索的数据也会越多 例如LIMIT 10000,10，数据库需要检索10010条记录，但最后只返回10条记录 优化方案：子查询 + 覆盖索引 123456789101112131415161718192021222324252627282930313233343536-- 使用了索引，扫描了100010行mysql&gt; explain select * from prop_action_reward order by create_time limit 100000,10;+----+-------------+--------------------+-------+---------------+-----------------+---------+------+--------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------------------+-------+---------------+-----------------+---------+------+--------+-------+| 1 | SIMPLE | prop_action_reward | index | NULL | idx_create_time | 5 | NULL | 100010 | NULL |+----+-------------+--------------------+-------+---------------+-----------------+---------+------+--------+-------+-- 耗费了0.19S，性能不太理想mysql&gt; select * from prop_action_reward order by create_time limit 100000,10;....10 rows in set (0.19 sec)-- 查询获取到的100010条记录都返回给客户端了，耗时主要集中在Sending data阶段mysql&gt; show profile for query 21;+----------------------+----------+| Status | Duration |+----------------------+----------+| starting | 0.000037 || checking permissions | 0.000007 || Opening tables | 0.000016 || init | 0.000028 || System lock | 0.000008 || optimizing | 0.000006 || statistics | 0.000010 || preparing | 0.000011 || Sorting result | 0.000005 || executing | 0.000004 || Sending data | 0.192705 || end | 0.000018 || query end | 0.000008 || closing tables | 0.000010 || freeing items | 0.000029 || cleaning up | 0.000085 |+----------------------+----------+ 123456789101112131415161718192021222324252627282930313233343536373839404142-- 子查询用到了覆盖索引（Using index），无需回表mysql&gt; explain select * from prop_action_reward where id &gt; (select id from prop_action_reward order by create_time limit 100000,1) limit 10;+----+-------------+--------------------+-------+---------------+-----------------+---------+------+----------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------------------+-------+---------------+-----------------+---------+------+----------+-------------+| 1 | PRIMARY | prop_action_reward | range | PRIMARY | PRIMARY | 8 | NULL | 47244120 | Using where || 2 | SUBQUERY | prop_action_reward | index | NULL | idx_create_time | 5 | NULL | 94488240 | Using index |+----+-------------+--------------------+-------+---------------+-----------------+---------+------+----------+-------------+-- 耗费了0.03S，提升很大mysql&gt; select * from prop_action_reward where id &gt; (select id from prop_action_reward order by create_time limit 100000,1) limit 10;...10 rows in set (0.03 sec)-- 只会返回10条记录给客户端，所以快很多mysql&gt; show profile for query 24;+----------------------+----------+| Status | Duration |+----------------------+----------+| starting | 0.000064 || checking permissions | 0.000007 || checking permissions | 0.000007 || Opening tables | 0.000019 || init | 0.000030 || System lock | 0.000009 || optimizing | 0.000008 || statistics | 0.000022 || optimizing | 0.000007 || statistics | 0.000011 || preparing | 0.000015 || Sorting result | 0.000005 || executing | 0.000004 || Sending data | 0.028916 || preparing | 0.000013 || executing | 0.000005 || Sending data | 0.000055 || end | 0.000006 || query end | 0.000007 || closing tables | 0.000009 || freeing items | 0.000022 || cleaning up | 0.000013 |+----------------------+----------+ 回表 下边解释下回表查询 普通索引因为无法直接定位行记录，其查询过程在通常情况下是需要扫描两遍索引树的。 1select * from t where name &#x3D; &#39;lisi&#39;; 粉红色的路径需要扫描两遍索引树， 第一遍先通过普通索引定位到主键值id=5， 第二遍再通过聚集索引定位到具体行记录。 这就是所谓的回表查询，即先定位主键值，再根据主键值定位行记录，性能相对于只扫描一遍聚集索引树的性能要低一些。 联合索引 联合索引需要最左匹配。详见联合索引 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 http://blog.codinglabs.org/articles/theory-of-mysql-index.html https://www.cnblogs.com/vianzhang/p/7922426.html http://zhongmingmao.me/2019/09/24/java-performance-high-performance-sql/ https://tech.meituan.com/2014/06/30/mysql-index.html https://mp.weixin.qq.com/s/ny8rE5-w57rsZiRxI6_Aqg https://www.cnblogs.com/duanxz/p/3799045.html https://www.cnblogs.com/duanxz/p/3799045.html","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://idea360.cn/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://idea360.cn/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"MySQL连表分页查询","slug":"mysql-left-join-page","date":"2021-08-04T14:32:22.000Z","updated":"2021-08-04T14:36:24.120Z","comments":true,"path":"2021/08/04/mysql-left-join-page/","link":"","permalink":"https://idea360.cn/2021/08/04/mysql-left-join-page/","excerpt":"","text":"前言 基本背景: mybatis-plus 连表查询 分页 查询条件存在2张表中 如果你看到这里了, 说明你也遇到类似的问题了, 无需再详细描述发生的问题。话不多说, 直接上结果。 实现 123456789101112131415161718192021SELECT q.id, q.question, q.company_id, q.category_id, q.category_name,CASE q.state WHEN 1 THEN &#x27;学习完成&#x27; WHEN 2 THEN &#x27;学习中&#x27; ELSE &#x27;未学习&#x27; END AS state, a.answer, a.voice_url FROM ( SELECT * FROM ai_knowledge WHERE company_id = 12345 ORDER BY id ) AS q LEFT JOIN ai_knowledge_answer a ON q.id = a.question_id WHERE a.answer like &#x27;您%&#x27; LIMIT 0, 10 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"},{"name":"left join","slug":"left-join","permalink":"https://idea360.cn/tags/left-join/"},{"name":"连表","slug":"连表","permalink":"https://idea360.cn/tags/%E8%BF%9E%E8%A1%A8/"},{"name":"分页","slug":"分页","permalink":"https://idea360.cn/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"Java启动参数说明","slug":"java-options","date":"2021-08-04T14:07:16.000Z","updated":"2021-08-05T15:15:04.781Z","comments":true,"path":"2021/08/04/java-options/","link":"","permalink":"https://idea360.cn/2021/08/04/java-options/","excerpt":"","text":"前言 公司 springboot 项目运维脚本中的 JVM 配置没生效, 问题是这个东西还是我写的埋下了坑。谨以此记录警示读者。 参数说明 系统参数 系统级全局变量，该参数在程序中任何位置都可以访问到。优先级最高，覆盖程序中同名配置。 系统参数的标准格式为：-Dargname=argvalue，多个参数之间用空格隔开，如果参数值中间有空格，则用引号括起来。 其中，参数名可以是 Java 默认的，此类参数由 JVM 虚拟机自动识别并生效，例如，-Dfile.encoding=UTF-8 用于指定文件编码格式；也可以是用户自定义的，例如，-Dmy=user，程序中可以读取该参数值，执行相关逻辑。 虚拟机系统参数中设置的参数键值对，在程序中可以用 System.getProperty(“propertyName”) 获取对应参数值。 运行参数 main 方法执行时传入的参数值，如果参数有多个，用空格分开。 main 方法的一般格式为：public static void main(String[] args)，其中，Stringp[] args 就是存储运行参数的变量，在程序中可以直接使用。 springboot的方式, --key=value方式 eg: java [options] -jar --key=value 取值: @Value(&quot;${xxx}&quot;) 示例 123456789101112131415161718192021222324252627282930313233343536@SpringBootApplicationpublic class ApiDemoApplication &#123; @Value(&quot;$&#123;env&#125;&quot;) private String env; /** * Java命令的基本格式: java [-options] class [args...] * * 示例: * java -Dsys.args.author=cuishiying -jar -Dsys.args.data=2021 target/api-demo-0.0.1.jar aa bb cc --env=local * * 结果: * 系统参数: sys.args.author=cuishiying * 系统参数: sys.args.data=2021 * 第0个运行参数为: aa * 第1个运行参数为: bb * 第2个运行参数为: cc * 第3个运行参数为: --env=local * springboot通过@Value参数=local * * @param args 运行参数 */ public static void main(String[] args) &#123; ConfigurableApplicationContext applicationContext = SpringApplication.run(ApiDemoApplication.class, args); System.out.println(String.format(&quot;系统参数: sys.args.author=%s&quot;, System.getProperty(&quot;sys.args.author&quot;))); System.out.println(String.format(&quot;系统参数: sys.args.data=%s&quot;, System.getProperty(&quot;sys.args.data&quot;))); if (args.length &gt; 0) &#123; for (int i = 0; i &lt; args.length; i++) &#123; System.out.println(&quot;第&quot; + i + &quot;个运行参数为: &quot; + args[i]); &#125; &#125; System.out.println(String.format(&quot;springboot通过@Value参数=%s&quot;, applicationContext.getEnvironment().getProperty(&quot;env&quot;))); &#125;&#125; 测试: 12mvn clean packagejava -Dsys.args.author=cuishiying -jar -Dsys.args.data=2021 target/api-demo-0.0.1.jar aa bb cc --env=local 输出结果: 1234567系统参数: sys.args.author&#x3D;cuishiying系统参数: sys.args.data&#x3D;2021第0个运行参数为: aa第1个运行参数为: bb第2个运行参数为: cc第3个运行参数为: --env&#x3D;localspringboot通过@Value参数&#x3D;local 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"}]},{"title":"spring-restdocs","slug":"spring-restdocs","date":"2021-07-28T16:19:01.000Z","updated":"2021-08-15T04:00:46.287Z","comments":true,"path":"2021/07/29/spring-restdocs/","link":"","permalink":"https://idea360.cn/2021/07/29/spring-restdocs/","excerpt":"","text":"示例 项目结构 12345678910111213141516171819202122232425➜ spring-rest-docs-demo tree .├── README.md├── pom.xml├── spring-rest-docs-demo.iml└── src ├── main │ ├── asciidoc │ │ └── index.adoc │ ├── java │ │ └── cn │ │ └── idea360 │ │ └── docs │ │ ├── Order.java │ │ └── SpringRestDocsDemoApplication.java │ └── resources │ ├── application.properties │ ├── static │ └── templates └── test └── java └── cn └── idea360 └── docs └── SpringRestDocsDemoApplicationTests.java pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;spring-rest-docs-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-rest-docs-demo&lt;/name&gt; &lt;description&gt;公众号[当我遇上你]关于spring rest docs的测试&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.idea360.docs.SpringRestDocsDemoApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt; &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-docs&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process-asciidoc&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;backend&gt;html&lt;/backend&gt; &lt;doctype&gt;book&lt;/doctype&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-asciidoctor&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; index.adoc 123456789101112131415161718192021&#x3D; Java Techie Spring REST Docs ExampleThis is an example output for a service running at http:&#x2F;&#x2F;localhost:9091:&#x3D;&#x3D; POST API Example.requestinclude::&#123;snippets&#125;&#x2F;testAddOrder&#x2F;http-request.adoc[].responseinclude::&#123;snippets&#125;&#x2F;testAddOrder&#x2F;http-response.adoc[]&#x3D;&#x3D; GET API Example.requestinclude::&#123;snippets&#125;&#x2F;testGetOrders&#x2F;http-request.adoc[].responseinclude::&#123;snippets&#125;&#x2F;testGetOrders&#x2F;http-response.adoc[]The data which we can see as part of documentation will loaded from MockMvc Test case data Order.java 12345678910111213141516171819202122232425262728package cn.idea360.docs;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@NoArgsConstructor@AllArgsConstructor@Datapublic class Order &#123; /** * 订单号 */ private int orderId; /** * 订单名称 */ private String name; /** * 数量 */ private int quantity; /** * 单价 */ private double price;&#125; 启动类 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.idea360.docs;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;@RestController@SpringBootApplicationpublic class SpringRestDocsDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringRestDocsDemoApplication.class, args); &#125; /** * 生成订单 * @param orders 订单信息 * @return 订单信息 */ @PostMapping(&quot;/placeOrder&quot;) public List&lt;Order&gt; saveOrder(@RequestBody List&lt;Order&gt; orders) &#123; return orders; &#125; /** * 获取订单 * @return 订单清单 */ @GetMapping(&quot;/getOrders&quot;) public List&lt;Order&gt; getOrders() &#123; return Stream.of(new Order(101, &quot;Mobile&quot;, 1, 5700) ,new Order(102, &quot;notebook&quot;, 1, 18488)) .collect(Collectors.toList()); &#125;&#125; 单元测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package cn.idea360.docs;import com.fasterxml.jackson.databind.ObjectMapper;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.restdocs.RestDocumentationContextProvider;import org.springframework.restdocs.RestDocumentationExtension;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;import static org.mockito.internal.verification.VerificationModeFactory.description;import static org.springframework.restdocs.cli.CliDocumentation.curlRequest;import static org.springframework.restdocs.http.HttpDocumentation.httpRequest;import static org.springframework.restdocs.http.HttpDocumentation.httpResponse;import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.documentationConfiguration;import static org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders.get;import static org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders.post;import static org.springframework.restdocs.operation.preprocess.Preprocessors.*;import static org.springframework.restdocs.operation.preprocess.Preprocessors.prettyPrint;import static org.springframework.restdocs.payload.PayloadDocumentation.requestFields;import static org.springframework.restdocs.payload.PayloadDocumentation.responseFields;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@ExtendWith(&#123; RestDocumentationExtension.class, SpringExtension.class&#125;)@SpringBootTest@AutoConfigureRestDocs(outputDir = &quot;target/generated-snippets&quot;)class SpringRestDocsDemoApplicationTests &#123; @Autowired private WebApplicationContext context; private MockMvc mockMvc; List&lt;Order&gt; orders=null; @BeforeEach public void setUp(WebApplicationContext webApplicationContext, RestDocumentationContextProvider restDocumentation) &#123; this.mockMvc = MockMvcBuilders .webAppContextSetup(webApplicationContext) .apply(documentationConfiguration(restDocumentation)) .build(); orders= Stream.of(new Order(101, &quot;Mobile&quot;, 1, 5700) ,new Order(102, &quot;notebook&quot;, 1, 18488)) .collect(Collectors.toList()); &#125; @Test public void testAddOrder() throws Exception &#123; String ordersJson=new ObjectMapper().writeValueAsString(orders); mockMvc.perform(post(&quot;/placeOrder&quot;) .content(ordersJson) .contentType(&quot;application/json&quot;)).andDo(print()) .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.content().json(ordersJson)) .andDo(document(&quot;&#123;methodName&#125;&quot;, preprocessRequest(prettyPrint()), preprocessResponse(prettyPrint()))); &#125; @Test public void testGetOrders() throws Exception &#123; mockMvc.perform(get(&quot;/getOrders&quot;) .contentType(&quot;application/json&quot;)).andDo(print()) .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.content().json(new ObjectMapper().writeValueAsString(orders))) .andDo(document(&quot;&#123;methodName&#125;&quot;, preprocessRequest(prettyPrint()), preprocessResponse(prettyPrint()))); &#125;&#125; 参考 https://github.com/Java-Techie-jt/spring-rest-docs-example.git https://docs.spring.io/spring-restdocs/docs/current/reference/html5/ https://github.com/czarea/spring-rest-docs https://springdoc.org/ https://scacap.github.io/spring-auto-restdocs/ https://github.com/ScaCap/spring-auto-restdocs/tree/master/samples/java-webmvc https://github.com/YeDaxia/JApiDocs https://gitee.com/treeleaf/xDoc https://gitee.com/smart-doc-team/smart-doc","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"docs","slug":"docs","permalink":"https://idea360.cn/tags/docs/"},{"name":"文档","slug":"文档","permalink":"https://idea360.cn/tags/%E6%96%87%E6%A1%A3/"},{"name":"extract javadoc comment","slug":"extract-javadoc-comment","permalink":"https://idea360.cn/tags/extract-javadoc-comment/"}]},{"title":"Git分支管理规范","slug":"git-branch-standard","date":"2021-07-25T09:34:22.000Z","updated":"2021-07-27T15:38:20.187Z","comments":true,"path":"2021/07/25/git-branch-standard/","link":"","permalink":"https://idea360.cn/2021/07/25/git-branch-standard/","excerpt":"","text":"前言 Git分支模型 分支管理规范 1. 分支说明及操作 master 分支 主分支，永远处于稳定状态，对应当前线上版本 以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本 不允许在该分支直接提交代码 develop 分支 开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行 小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行 注： 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险。 feature 分支 功能分支，开发新功能的分支 开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 feature/xxx 开发完成后合并回 develop 分支并且删除该 feature/xxx 分支 release 分支 发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支 当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为release/xxx 发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支 hotfix 分支 紧急修复线上 bug 分支 当线上版本出现 bug 时，从 master 分支切出一个 hotfix/xxx 分支，完成 bug 修复，然后将 hotfix/xxx 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 hotfix/xxx 分支 以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下： master 分支: 线上稳定版本分支, 该分支代码与线上代码是完全一致的。 develop 分支: 开发分支，衍生出 feature 分支和 release 分支 release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除。该分支从 develop 分支创建，创建之后由测试人员发布到测试环境进行测试。 feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除 hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除 2. 项目分支操作流程示例 这部分内容结合日常项目的开发流程，涉及到开发新功能、分支合并、发布新版本以及发布紧急修复版本等操作，展示常用的命令和操作。 切到 develop 分支，更新 develop 最新代码 12git checkout developgit pull --rebase 新建 feature 分支，开发新功能 1234567git checkout -b feature/xxx...git add &lt;files&gt;git commit -m &quot;feat(xxx): commit a&quot;git commit -m &quot;feat(xxx): commit b&quot;# 其他提交... 如果此时 develop 分支有一笔提交，影响到你的 feature 开发，可以 rebase develop 分支，前提是 该 feature 分支只有你自己一个在开发，如果多人都在该分支，需要进行协调： 12345678# 切换到 develop 分支并更新 develop 分支代码git checkout developgit pull --rebase# 切回 feature 分支git checkout feature/xxxgit rebase develop# 如果需要提交到远端，且之前已经提交到远端，此时需要强推(强推需慎重！)git push --force 上述场景也可以通过 git cherry-pick 来实现，有兴趣的可以去了解一下这个指令。 完成 feature 分支，合并到 develop 分支 123456789# 切到 develop 分支，更新下代码git check developgit pull --rebase# 合并 feature 分支git merge feature/xxx --no-ff# 删除 feature 分支git branch -d feature/xxx# 推到远端git push origin develop 当某个版本所有的 feature 分支均合并到 develop 分支，就可以切出 release 分支，准备发布新版本，提交测试并进行 bug fix 12345# 当前在 develop 分支git checkout -b release/xxx# 在 release/xxx 分支进行 bug fixgit commit -m &quot;fix(xxx): xxxxx&quot;... 所有 bug 修复完成，准备发布新版本 12345678910# master 分支合并 release 分支并添加 taggit checkout mastergit merge --no-ff release/xxx --no-ff# 添加版本标记，这里可以使用版本发布日期或者具体的版本号git tag 1.0.0# develop 分支合并 release 分支git checkout developgit merge --no-ff release/xxx# 删除 release 分支git branch -d release/xxx 至此，一个新版本发布完成。 线上出现 bug，需要紧急发布修复版本 123456789101112131415# 当前在 master 分支git checkout master# 切出 hotfix 分支git checkout -b hotfix/xxx... 进行 bug fix 提交# master 分支合并 hotfix 分支并添加 tag(紧急版本)git checkout mastergit merge --no-ff hotfix/xxx --no-ff# 添加版本标记，这里可以使用版本发布日期或者具体的版本号git tag 1.0.1# develop 分支合并 hotfix 分支(如果此时存在 release 分支的话，应当合并到 release 分支)git checkout developgit merge --no-ff hotfix/xxx# 删除 hotfix 分支git branch -d hotfix/xxx 至此，紧急版本发布完成。 3. 提交信息规范 提交信息规范部分参考 Angular.js commit messgae。 git commit 格式 如下： 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 各个部分的说明如下： type 类型，提交的类别 feat: 新功能 fix: 修复 bug docs: 文档变动 style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等 refactor: bug 修复和添加新功能之外的代码改动 perf: 提升性能的改动 test: 添加或修正测试代码 chore: 构建过程或辅助工具和库（如文档生成）的更改 scope 修改范围 主要是这次修改涉及到的部分，简单概括，例如 login、train-order subject 修改的描述 具体的修改描述信息 范例 123feat(detail): 详情页修改样式fix(login): 登录页面错误处理test(list): 列表页添加测试代码 这里对提交规范加几点说明： type + scope 能够控制每笔提交改动的文件尽可能少且集中，避免一次很多文件改动或者多个改动合成一笔。 subject 对于大部分国内项目而已，如果团队整体英文不是较高水平，比较推荐使用中文，方便阅读和检索。 避免重复的提交信息，如果发现上一笔提交没改完整，可以使用 git commit --amend 指令追加改动，尽量避免重复的提交信息。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://jaeger.itscoder.com/dev/2018/09/12/using-git-in-project.html https://www.pengzhenjin.top/archives/团队项目的git分支管理规范 https://developer.51cto.com/art/202011/631672.htm","categories":[{"name":"git","slug":"git","permalink":"https://idea360.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://idea360.cn/tags/git/"}]},{"title":"Java排序号更新逻辑","slug":"java-order","date":"2021-07-25T07:19:02.000Z","updated":"2021-07-25T07:24:50.658Z","comments":true,"path":"2021/07/25/java-order/","link":"","permalink":"https://idea360.cn/2021/07/25/java-order/","excerpt":"","text":"前言 在工作上遇到一个比较奇怪的逻辑, 根据唯一字段排序并且序号不得重复。这样的逻辑很可能会涉及到批量更新, 锁表等, 并不值得推荐。当然有历史原因不得不这样做。好的程序不只建立在程序本身上, 更加建立在优秀的逻辑设计上。本文仅作参考。 实现 首先定义一个需要排序的实体 1234567891011121314151617181920package com.example.javademo.sort;import lombok.Data;/** * @author cuishiying * @date 2021-07-23 */@Datapublic class Node &#123; private Integer id; private String name; private Integer sortIndex; public Node(Integer id, String name, Integer sortIndex) &#123; this.id = id; this.name = name; this.sortIndex = sortIndex; &#125;&#125; 然后就是我们的算法逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158package com.example.javademo.sort;import org.springframework.util.Assert;import java.util.Comparator;import java.util.List;/** * 本排序方法适用于数据量较小的排序, 业务中要求按找1个字段排序且排序值需要唯一 * 优秀的排序方案来源于优秀的产品设计及优秀的业务设计, 如根据排序值+更新时间多字段来决定排序等 * * 排序类型分为几种 * 1. 序号值刚好在目标位置, 无需排序 * 2. 目标位置存在间隙, 可以直接插入 * 3. 目标位置间隙为1, 需要重排 * * @author cuishiying * @date 2021-07-23 */public class SortHandler &#123; /** * 步长 */ private static final Integer STEP = 10; /** * 更新排序值 * @param sortedNodes 参与排序的所有对象(默认正序) * @param targetNodeId 需要调整排序的对象id * @param targetPosition 目标位置(从1开始, index=position-1) */ public void updateSortIndex(List&lt;Node&gt; sortedNodes, Integer targetNodeId, Integer targetPosition) &#123; Assert.isTrue(targetPosition &gt; 0, &quot;序号必须&gt;0&quot;); Node targetNode = sortedNodes.stream().filter(node -&gt; node.getId().equals(targetNodeId)).findFirst().orElse(null); Assert.notNull(targetNode, String.format(&quot;id=%s的对象不存在&quot;, targetNodeId)); // 1. 判断是否存在相同序号的node, 如果存在则重排 long distinctCount = sortedNodes.stream().map(Node::getSortIndex).distinct().count(); if (distinctCount &lt; sortedNodes.size()) &#123; System.out.println(&quot;存在重复序号&quot;); resortIndex(sortedNodes); &#125; // 2. 判断当前位置是否是目标位置 int currentIndex = sortedNodes.indexOf(targetNode); if (currentIndex == targetPosition - 1) &#123; System.out.println(&quot;当前位置即是目标位置, 无需排序&quot;); return; &#125; /** * 3. 判断目标位置是否存在间隙, 可以直接插入。 * a. 如果移动元素当前在left位置, 目标位置在right位置, 则移动后左侧元素会变少, 应该+1的位置寻找目标位置 * eg: N1,N2,N3,N4, 将N2的序号改为3, 则应该在N3和N4之间插入N2, 然后移除原始N2 * b. 如果移动元素当前在right位置, 目标位置在left位置, 则可以直接插入 */ if (currentIndex &lt; targetPosition - 1) &#123; int leftIndex = targetPosition - 1; int rightIndex = targetPosition; if (rightIndex &gt; sortedNodes.size() - 1) &#123; int maxSortIndex = getMaxSortIndex(sortedNodes); targetNode.setSortIndex(maxSortIndex + STEP); System.out.println(&quot;目标右移, 尾部直接插入:&quot;); log(sortedNodes); return; &#125; Integer rightSortIndex = sortedNodes.get(rightIndex).getSortIndex(); Integer leftSortIndex = sortedNodes.get(leftIndex).getSortIndex(); if (rightSortIndex - leftSortIndex &gt; 1) &#123; // 计算所得目标排序号 int targetSortIndex = leftSortIndex + (rightSortIndex - leftSortIndex) / 2; targetNode.setSortIndex(targetSortIndex); System.out.println(&quot;目标右移, 间隙&gt;1, 可以直接插入:&quot;); log(sortedNodes); &#125; else &#123; System.out.println(&quot;目标右移, 间隙&lt;1, 需要重排序&quot;); sortedNodes.add(targetPosition - 1, sortedNodes.remove(sortedNodes.indexOf(targetNode))); resortIndex(sortedNodes); &#125; return; &#125; if (currentIndex &gt; targetPosition - 1) &#123; int leftIndex = targetPosition - 2; int rightIndex = targetPosition - 1; if (leftIndex &lt; 0) &#123; int minSortIndex = getMinSortIndex(sortedNodes); if (minSortIndex &gt; 1) &#123; // 计算所得目标排序号 int targetSortIndex = 1 + (minSortIndex - 1) / 2; targetNode.setSortIndex(targetSortIndex); System.out.println(&quot;目标左移, 间隙&gt;1, 头部直接插入:&quot;); log(sortedNodes); &#125; else &#123; System.out.println(&quot;目标左移, 间隙&lt;1, 需要重排序&quot;); sortedNodes.add(targetPosition - 1, sortedNodes.remove(sortedNodes.indexOf(targetNode))); resortIndex(sortedNodes); &#125; return; &#125; Integer rightSortIndex = sortedNodes.get(rightIndex).getSortIndex(); Integer leftSortIndex = sortedNodes.get(leftIndex).getSortIndex(); if (rightSortIndex - leftSortIndex &gt; 1) &#123; // 计算所得目标排序号 int targetSortIndex = leftSortIndex + (rightSortIndex - leftSortIndex) / 2; targetNode.setSortIndex(targetSortIndex); System.out.println(&quot;目标左移, 间隙&gt;1, 可以直接插入:&quot;); log(sortedNodes); &#125; else &#123; System.out.println(&quot;目标左移, 间隙&lt;1, 需要重排序&quot;); sortedNodes.add(targetPosition - 1, sortedNodes.remove(sortedNodes.indexOf(targetNode))); resortIndex(sortedNodes); &#125; return; &#125; &#125; /** * 获取当前分组最大序号 * @param sortedNodes 原始list * @return 最大序号 */ private int getMaxSortIndex(List&lt;Node&gt; sortedNodes) &#123; return sortedNodes.stream().mapToInt(Node::getSortIndex).max().orElse(1); &#125; /** * 获取当前分组最小序号 * @param sortedNodes 原始list * @return 最小序号 */ private int getMinSortIndex(List&lt;Node&gt; sortedNodes) &#123; return sortedNodes.stream().mapToInt(Node::getSortIndex).min().orElse(1); &#125; /** * 数据整体重排序 * * 需要重排序的时候集合现在内存中做好排序, 然后重新编排序号, 并更新数据库 * sortedNodes.add(targetIndex - 1, sortedNodes.remove(sortedNodes.indexOf(targetNode))); * @param sortedNodes 原始顺序list */ private void resortIndex(List&lt;Node&gt; sortedNodes) &#123; for (int i = 0; i &lt; sortedNodes.size(); i++) &#123; Node node = sortedNodes.get(i); node.setSortIndex(STEP * i + 1); &#125; System.out.println(&quot;重排序:&quot;); log(sortedNodes); &#125; private void log(List&lt;Node&gt; sortedNodes) &#123; sortedNodes.stream().sorted(Comparator.comparing(Node::getSortIndex)).forEach(System.out::println); &#125;&#125; 最后验证下结果是否复合预期 123456789101112131415161718192021222324252627282930313233343536package com.example.javademo.sort;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;/** * @author cuishiying * @date 2021-07-23 */@Slf4jpublic class SortTest &#123; public static void main(String[] args) &#123; // 初始化数据 List&lt;Node&gt; nodes = initData(); System.out.println(&quot;原始数据:&quot;); nodes.forEach(System.out::println); // 更新排序值 SortHandler sortHandler = new SortHandler(); Node targetNode = nodes.get(2); int targetPosition = 3; System.out.printf(&quot;排序计划:node%s -&gt; position%s\\n&quot;, targetNode.getId(), targetPosition); sortHandler.updateSortIndex(nodes, targetNode.getId(), targetPosition); &#125; private static List&lt;Node&gt; initData() &#123; List&lt;Node&gt; data = new ArrayList&lt;&gt;(10); for (int i = 0; i &lt; 5; i++) &#123; Node node = new Node(i + 1, &quot;node&quot; + (i + 1), i * 2 + 1); data.add(node); &#125; return data; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"sort","slug":"sort","permalink":"https://idea360.cn/tags/sort/"},{"name":"排序","slug":"排序","permalink":"https://idea360.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"序号","slug":"序号","permalink":"https://idea360.cn/tags/%E5%BA%8F%E5%8F%B7/"}]},{"title":"spring-cloud-gateway基于spring-cloud-starter-loadbalancer的灰度发布","slug":"spring-cloud-gateway-gray","date":"2021-07-10T11:54:42.000Z","updated":"2021-08-28T13:32:18.129Z","comments":true,"path":"2021/07/10/spring-cloud-gateway-gray/","link":"","permalink":"https://idea360.cn/2021/07/10/spring-cloud-gateway-gray/","excerpt":"","text":"前言 之前写过 spring-cloud-gateway系列文章, 今天再来补充一篇关于灰度发布的。传送门: spring-cloud-gateway简介 spring-cloud-gateway过滤器实践 spring-cloud-gateway静态路由 spring-cloud-gateway动态路由 spring-cloud-gateway限流 spring-cloud-gateway降级 今天的文章主题会按照如下三步曲进行记录: 基于nacos的基础项目搭建 动态路由 灰度方案 之前的文章吃了有些没有版本号和文档上传不完整的亏, 导致很多网友咨询的时候我也不记得细节, 这里我们会贴出完整配置及代码。 此处的灰度方案只是简单的网关灰度演示, 开发中服务间的调用也存在灰度, 后续再分解。 基础环境搭建 很久没有搭建 SpringCloud 项目了, 首先搭建一个基础示例, 供代码调试。 首先, 快速搭建nacos-server, 这里基于 官方文档 压缩包安装。安装完成后访问 http://127.0.0.1:8848/nacos 即可看到 nacos 控制面板 项目创建。我们计划创建2个服务, 一个服务提供者 provider， 一个网关 gateway。项目采用聚合项目的形式。 根目录pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.2.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;modules&gt; &lt;module&gt;provider&lt;/module&gt; &lt;module&gt;gateway&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 服务提供者provider 这里我们计划引入 nacos, 所以先创建一个nacos配置文件 dataId 为 provider.properties, 这里用默认的命名空间 public, 默认分组 DEFAULT_GROUP 1version=2 provider的pom文件如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsdhttp://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/parent&gt; &lt;name&gt;provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.idea360.provider.ProviderApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties配置: 1234567# 应用名称spring.application.name=provider# 应用服务 WEB 访问端口server.port=9001spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 在启动类, 我们增加了服务发现注解 @EnableDiscoveryClient 123456789101112131415package cn.idea360.provider;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; controller逻辑很简单, 只是简单返回版本号 12345678910111213141516171819202122232425262728293031package cn.idea360.provider.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.core.env.Environment;import org.springframework.web.bind.annotation.*;/** * @author cuishiying * @date 2021-01-22 */@RefreshScope@RestController@RequestMapping(&quot;/test&quot;)public class TestController &#123; @Autowired private Environment env; @Value(&quot;$&#123;version:0&#125;&quot;) private String version; /** * http://localhost:9001/test/port * @return */ @GetMapping(&quot;/port&quot;) public Object port() &#123; return String.format(&quot;port=%s, version=%s&quot;, env.getProperty(&quot;local.server.port&quot;), version); &#125;&#125; 网关gateway gateway服务的pom配置如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/parent&gt; &lt;name&gt;gateway&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.2.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.idea360.gateway.GatewayApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 网关同样做服务发现 123456789101112131415package cn.idea360.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 网关核心配置, 这里我们先采用静态路由的方式测试下项目是否有问题 application.yml 123456789101112131415161718192021# 应用服务 WEB 访问端口server: port: 9000# 应用名称spring: application: name: gateway cloud: nacos: config: server-addr: 127.0.0.1:8848 discovery: server-addr: 127.0.0.1:8848 gateway: routes: # http://127.0.0.1:9000/actuator/gateway/routes - id: provider # 路由 ID，保持唯一 uri: lb://provider # uri指目标服务地址，lb代表从注册中心获取服务 predicates: - Path=/provider/** # http://127.0.0.1:9000/provider/port 会转发到 http://localhost:9001/provider/port, 和预期不符合, 需要StripPrefix来处理 filters: - StripPrefix=1 # StripPrefix=1就代表截取路径的个数为1, 这样请求 http://127.0.0.1:9000/provider/test/port 会转发到 http://localhost:9001/test/port 接下来就是激动人心的时刻了, 先测试下服务是否ok. 1234➜ blog git:(master) ✗ curl http://localhost:9001/test/portport=9001, version=2%➜ blog git:(master) ✗ curl http://127.0.0.1:9000/provider/test/portport=9001, version=2% 通过结果可见, 网关的基本配置已经生效了。 基于nacos动态路由 动态路由的实现有2种方式, 一个就是像之前一样改写 RouteDefinitionRepository, 一个就是基于 nacos 的监听器给 RouteDefinitionRepository 动态更新值。实现逻辑大同小异。 基于nacos监听器实现动态路由 配置nacos配置文件 gateway-router.json, 为了避免项目 application.yml 中配置文件影响, 先注释掉 gateway 相关的配置 1234567891011121314151617[&#123; &quot;id&quot;: &quot;provider&quot;, &quot;predicates&quot;: [&#123; &quot;name&quot;: &quot;Path&quot;, &quot;args&quot;: &#123; &quot;_genkey_0&quot;: &quot;/provider/**&quot; &#125; &#125;], &quot;filters&quot;: [&#123; &quot;name&quot;: &quot;StripPrefix&quot;, &quot;args&quot;: &#123; &quot;_genkey_0&quot;: &quot;1&quot; &#125; &#125;], &quot;uri&quot;: &quot;lb://provider&quot;, &quot;order&quot;: 0&#125;] 基于 nacos 监听器实现路由刷新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package cn.idea360.gateway.config;import com.alibaba.nacos.api.NacosFactory;import com.alibaba.nacos.api.config.ConfigService;import com.alibaba.nacos.api.config.listener.Listener;import com.alibaba.nacos.api.exception.NacosException;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.gateway.event.RefreshRoutesEvent;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionWriter;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;import org.springframework.stereotype.Component;import reactor.core.publisher.Mono;import javax.annotation.PostConstruct;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Executor;/** * @author cuishiying * @date 2021-01-22 */@Componentpublic class DynamicGatewayRouteConfig implements ApplicationEventPublisherAware &#123; private String dataId = &quot;gateway-router.json&quot;; private String group = &quot;DEFAULT_GROUP&quot;; @Value(&quot;$&#123;spring.cloud.nacos.config.server-addr&#125;&quot;) private String serverAddr; @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher applicationEventPublisher; private static final List&lt;String&gt; ROUTE_LIST = new ArrayList&lt;String&gt;(); private ObjectMapper objectMapper = new ObjectMapper(); @PostConstruct public void dynamicRouteByNacosListener() &#123; try &#123; ConfigService configService = NacosFactory.createConfigService(serverAddr); configService.getConfig(dataId, group, 5000); configService.addListener(dataId, group, new Listener() &#123; public void receiveConfigInfo(String configInfo) &#123; clearRoute(); try &#123; List&lt;RouteDefinition&gt; gatewayRouteDefinitions = objectMapper.readValue(configInfo, new TypeReference&lt;List&lt;RouteDefinition&gt;&gt;() &#123;&#125;); for (RouteDefinition routeDefinition : gatewayRouteDefinitions) &#123; addRoute(routeDefinition); &#125; publish(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public Executor getExecutor() &#123; return null; &#125; &#125;); &#125; catch (NacosException e) &#123; e.printStackTrace(); &#125; &#125; private void clearRoute() &#123; for (String id : ROUTE_LIST) &#123; this.routeDefinitionWriter.delete(Mono.just(id)).subscribe(); &#125; ROUTE_LIST.clear(); &#125; private void addRoute(RouteDefinition definition) &#123; try &#123; routeDefinitionWriter.save(Mono.just(definition)).subscribe(); ROUTE_LIST.add(definition.getId()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void publish() &#123; this.applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this.routeDefinitionWriter)); &#125; public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125;&#125; 重启网关, 请求 http://127.0.0.1:9000/actuator/gateway/routes 可以发现配置已生效。 1234567891011[ &#123; &quot;predicate&quot;: &quot;Paths: [/provider/**], match trailing slash: true&quot;, &quot;route_id&quot;: &quot;provider&quot;, &quot;filters&quot;: [ &quot;[[StripPrefix parts = 1], order = 1]&quot; ], &quot;uri&quot;: &quot;lb://provider&quot;, &quot;order&quot;: 0 &#125;] 路由测试结果如下: 12➜ blog git:(master) ✗ curl http://127.0.0.1:9000/provider/test/portport=9001, version=2% 基于RouteDefinitionRepository实现动态路由 Spring Cloud Gateway 中加载路由信息分别由以下几个类负责 1、PropertiesRouteDefinitionLocator：从配置文件中读取路由信息(如YML、Properties等) 2、RouteDefinitionRepository：从存储器中读取路由信息(如内存、配置中心、Redis、MySQL等) 3、DiscoveryClientRouteDefinitionLocator：从注册中心中读取路由信息(如Nacos、Eurka、Zookeeper等) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package cn.idea360.gateway.router;import com.alibaba.cloud.nacos.NacosConfigManager;import com.alibaba.nacos.api.config.listener.Listener;import com.alibaba.nacos.api.exception.NacosException;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.JsonMappingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Lists;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.gateway.event.RefreshRoutesEvent;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionRepository;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;import org.springframework.stereotype.Component;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import javax.annotation.PostConstruct;import java.util.List;import java.util.concurrent.Executor;/** * @author cuishiying * @date 2021-01-22 */@Componentpublic class NacosRouteDefinitionRepository implements RouteDefinitionRepository, ApplicationEventPublisherAware &#123; private static final Logger log = LoggerFactory.getLogger(NacosRouteDefinitionRepository.class); @Autowired private NacosConfigManager nacosConfigManager; // 更新路由信息需要的 private ApplicationEventPublisher applicationEventPublisher; private String dataId = &quot;gateway-router.json&quot;; private String group = &quot;DEFAULT_GROUP&quot;; @Value(&quot;$&#123;spring.cloud.nacos.config.server-addr&#125;&quot;) private String serverAddr; private ObjectMapper objectMapper = new ObjectMapper(); @PostConstruct public void dynamicRouteByNacosListener() &#123; try &#123; nacosConfigManager.getConfigService().addListener(dataId, group, new Listener() &#123; public void receiveConfigInfo(String configInfo) &#123; log.info(&quot;自动更新配置...\\r\\n&#123;&#125;&quot;, configInfo); applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this)); &#125; public Executor getExecutor() &#123; return null; &#125; &#125;); &#125; catch (NacosException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() &#123; try &#123; String configInfo = nacosConfigManager.getConfigService().getConfig(dataId, group, 5000); List&lt;RouteDefinition&gt; gatewayRouteDefinitions = objectMapper.readValue(configInfo, new TypeReference&lt;List&lt;RouteDefinition&gt;&gt;() &#123; &#125;); return Flux.fromIterable(gatewayRouteDefinitions); &#125; catch (NacosException e) &#123; e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; e.printStackTrace(); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return Flux.fromIterable(Lists.newArrayList()); &#125; @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route) &#123; return null; &#125; @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId) &#123; return null; &#125; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125;&#125; 测试结果同上。 基于SpringCloud Gateway + nacos 灰度路由 首先需要明白灰度的场景, 因为有不同版本的服务需要共存, 所以新的节点升级的时候必然代码及配置会存在差别, 所以我们根据这种差别来判断服务版本是新版本还是线上稳定版本。这里我们用 prod 和 gray 来标识2个版本。 实现的整体思路： 编写带版本号的灰度路由(负载均衡策略) 编写自定义filter nacos服务配置需要灰度发布的服务的元数据信息以及权重(在服务jar中配置) 注意, 应该先修改nacos配置实现动态路由, 然后再升级灰度节点. 本案例只是简单示例灰度原理。 网关配置 首先排除掉默认的ribbon 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入官方新的负载均衡包 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt; 自定义负载均衡策略 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package cn.idea360.gateway.gray;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.ObjectProvider;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.loadbalancer.reactive.DefaultResponse;import org.springframework.cloud.client.loadbalancer.reactive.EmptyResponse;import org.springframework.cloud.client.loadbalancer.reactive.Request;import org.springframework.cloud.client.loadbalancer.reactive.Response;import org.springframework.cloud.loadbalancer.core.NoopServiceInstanceListSupplier;import org.springframework.cloud.loadbalancer.core.ReactorServiceInstanceLoadBalancer;import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;import org.springframework.http.HttpHeaders;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import java.util.List;import java.util.Random;import java.util.concurrent.atomic.AtomicInteger;import java.util.stream.Collectors;/** * @author cuishiying * @date 2021-01-22 */public class VersionGrayLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123; private ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider; private String serviceId; private final AtomicInteger position; public VersionGrayLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider, String serviceId) &#123; this(serviceInstanceListSupplierProvider, serviceId, new Random().nextInt(1000)); &#125; public VersionGrayLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider, String serviceId, int seedPosition) &#123; this.serviceId = serviceId; this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider; this.position = new AtomicInteger(seedPosition); &#125; @Override public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123; HttpHeaders headers = (HttpHeaders) request.getContext(); ServiceInstanceListSupplier supplier = this.serviceInstanceListSupplierProvider.getIfAvailable(NoopServiceInstanceListSupplier::new); return ((Flux) supplier.get()).next().map(list -&gt; processInstanceResponse((List&lt;ServiceInstance&gt;) list, headers)); &#125; private Response&lt;ServiceInstance&gt; processInstanceResponse(List&lt;ServiceInstance&gt; instances, HttpHeaders headers) &#123; if (instances.isEmpty()) &#123; return new EmptyResponse(); &#125; else &#123; String reqVersion = headers.getFirst(&quot;version&quot;); if (StringUtils.isEmpty(reqVersion)) &#123; return processRibbonInstanceResponse(instances); &#125; List&lt;ServiceInstance&gt; serviceInstances = instances.stream() .filter(instance -&gt; reqVersion.equals(instance.getMetadata().get(&quot;version&quot;))) .collect(Collectors.toList()); if (serviceInstances.size() &gt; 0) &#123; return processRibbonInstanceResponse(serviceInstances); &#125; else &#123; return processRibbonInstanceResponse(instances); &#125; &#125; &#125; /** * 负载均衡器 * 参考 org.springframework.cloud.loadbalancer.core.RoundRobinLoadBalancer#getInstanceResponse * * @author javadaily */ private Response&lt;ServiceInstance&gt; processRibbonInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123; int pos = Math.abs(this.position.incrementAndGet()); ServiceInstance instance = instances.get(pos % instances.size()); return new DefaultResponse(instance); &#125;&#125; 自定义过滤器加载负载均衡策略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package cn.idea360.gateway.gray;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.loadbalancer.LoadBalancerUriTools;import org.springframework.cloud.client.loadbalancer.reactive.DefaultRequest;import org.springframework.cloud.client.loadbalancer.reactive.Request;import org.springframework.cloud.client.loadbalancer.reactive.Response;import org.springframework.cloud.gateway.config.LoadBalancerProperties;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter;import org.springframework.cloud.gateway.support.DelegatingServiceInstance;import org.springframework.cloud.gateway.support.NotFoundException;import org.springframework.cloud.gateway.support.ServerWebExchangeUtils;import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;import org.springframework.core.Ordered;import org.springframework.http.HttpHeaders;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.net.URI;/** * @author cuishiying * @date 2021-01-22 */public class GrayReactiveLoadBalancerClientFilter implements GlobalFilter, Ordered &#123; private static final Log log = LogFactory.getLog(ReactiveLoadBalancerClientFilter.class); private static final int LOAD_BALANCER_CLIENT_FILTER_ORDER = 10150; private final LoadBalancerClientFactory clientFactory; private LoadBalancerProperties properties; public GrayReactiveLoadBalancerClientFilter(LoadBalancerClientFactory clientFactory, LoadBalancerProperties properties) &#123; this.clientFactory = clientFactory; this.properties = properties; &#125; @Override public int getOrder() &#123; return LOAD_BALANCER_CLIENT_FILTER_ORDER; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; URI url = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR); String schemePrefix = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR); if (url != null &amp;&amp; (&quot;grayLb&quot;.equals(url.getScheme()) || &quot;grayLb&quot;.equals(schemePrefix))) &#123; ServerWebExchangeUtils.addOriginalRequestUrl(exchange, url); if (log.isTraceEnabled()) &#123; log.trace(ReactiveLoadBalancerClientFilter.class.getSimpleName() + &quot; url before: &quot; + url); &#125; return this.choose(exchange).doOnNext((response) -&gt; &#123; if (!response.hasServer()) &#123; throw NotFoundException.create(this.properties.isUse404(), &quot;Unable to find instance for &quot; + url.getHost()); &#125; else &#123; URI uri = exchange.getRequest().getURI(); String overrideScheme = null; if (schemePrefix != null) &#123; overrideScheme = url.getScheme(); &#125; DelegatingServiceInstance serviceInstance = new DelegatingServiceInstance((ServiceInstance)response.getServer(), overrideScheme); URI requestUrl = this.reconstructURI(serviceInstance, uri); if (log.isTraceEnabled()) &#123; log.trace(&quot;LoadBalancerClientFilter url chosen: &quot; + requestUrl); &#125; exchange.getAttributes().put(ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR, requestUrl); &#125; &#125;).then(chain.filter(exchange)); &#125; else &#123; return chain.filter(exchange); &#125; &#125; protected URI reconstructURI(ServiceInstance serviceInstance, URI original) &#123; return LoadBalancerUriTools.reconstructURI(serviceInstance, original); &#125; private Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(ServerWebExchange exchange) &#123; URI uri = (URI)exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR); VersionGrayLoadBalancer loadBalancer = new VersionGrayLoadBalancer(clientFactory.getLazyProvider(uri.getHost(), ServiceInstanceListSupplier.class), uri.getHost()); if (loadBalancer == null) &#123; throw new NotFoundException(&quot;No loadbalancer available for &quot; + uri.getHost()); &#125; else &#123; return loadBalancer.choose(this.createRequest(exchange)); &#125; &#125; private Request createRequest(ServerWebExchange exchange) &#123; HttpHeaders headers = exchange.getRequest().getHeaders(); Request&lt;HttpHeaders&gt; request = new DefaultRequest&lt;&gt;(headers); return request; &#125;&#125; 注入过滤器 123456789101112131415161718192021package cn.idea360.gateway.gray;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.cloud.gateway.config.LoadBalancerProperties;import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class GrayGatewayReactiveLoadBalancerClientAutoConfiguration &#123; @Bean @ConditionalOnMissingBean(&#123;GrayReactiveLoadBalancerClientFilter.class&#125;) public GrayReactiveLoadBalancerClientFilter grayReactiveLoadBalancerClientFilter(LoadBalancerClientFactory clientFactory, LoadBalancerProperties properties) &#123; return new GrayReactiveLoadBalancerClientFilter(clientFactory, properties); &#125;&#125; 发布灰度服务 12345678# 应用名称spring.application.name=provider# 应用服务 WEB 访问端口server.port=9002spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.metadata.version = gray 测试, curl -X GET -H &quot;version:gray&quot; -d '&#123;&quot;name&quot;: &quot;admin&quot;&#125;' http://127.0.0.1:9000/provider/test/port 发现会永远路由到 9002 最后 本文到此结束，感谢大家的阅读。欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"nacos","slug":"nacos","permalink":"https://idea360.cn/tags/nacos/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"https://idea360.cn/tags/Spring-Cloud/"},{"name":"springcloud","slug":"springcloud","permalink":"https://idea360.cn/tags/springcloud/"},{"name":"灰度","slug":"灰度","permalink":"https://idea360.cn/tags/%E7%81%B0%E5%BA%A6/"}]},{"title":"Java延时任务","slug":"delay-task","date":"2021-06-26T07:06:15.000Z","updated":"2021-06-26T07:11:24.960Z","comments":true,"path":"2021/06/26/delay-task/","link":"","permalink":"https://idea360.cn/2021/06/26/delay-task/","excerpt":"","text":"前言 很多时候需要做一些延时任务, 但是有些场景可能会丢弃任务, 如下示例演示基于java的延时任务方案。 DelayQueue 首先将任务包装起来 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author cuishiying * @date 2021-06-22 */@Datapublic class DelayTask implements Delayed &#123; private long exeTime; private ChatActionDTO action; /** * 延时任务 * * @param exeTime 延时s * @param action 任务 */ public DelayTask(long exeTime, ChatActionDTO action) &#123; this.exeTime = System.currentTimeMillis() + (exeTime &gt; 0 ? TimeUnit.SECONDS.toMillis(exeTime) : 0); this.action = action; &#125; /** * 代表延时的时间 */ @Override public long getDelay(TimeUnit unit) &#123; return exeTime - System.currentTimeMillis(); &#125; /** * 任务在队列中的排序 */ @Override public int compareTo(Delayed o) &#123; DelayTask t = (DelayTask) o; if (this.exeTime - t.exeTime &lt;= 0) &#123; return -1; &#125; else &#123; return 1; &#125; &#125;&#125; 取出延时任务 1DelayTask delayTask = delayQueue.take(); ScheduledExecutorService 123456789101112131415161718192021222324252627282930313233public class ScheduledMessageHandler implements IMessageHandler&#123; private Map&lt;String, List&lt;ScheduledFuture&lt;?&gt;&gt;&gt; delayQueues = new HashMap&lt;&gt;(); private static final ScheduledExecutorService executor = Executors.newScheduledThreadPool(30); @Override public void sendMessage(Channel channel, ChatDTO chat, Long requestTime, Integer chatId) &#123; cancelDelayMessageFuture(channel); chat.getAction().stream().sorted(Comparator.comparing(ChatActionDTO::getDelayTime).thenComparing(ChatActionDTO::getOrderIndex)).forEach(action -&gt; &#123; ScheduledFuture&lt;?&gt; future = executor.schedule(() -&gt; &#123; channel.writeAndFlush(new TextWebSocketFrame(JsonUtils.to(action))); &#125;, action.getDelayTime(), TimeUnit.SECONDS); addDelayMessageFuture(channel, future); &#125;); &#125; public void addDelayMessageFuture(Channel channel, ScheduledFuture&lt;?&gt; delayMessageFuture)&#123; List&lt;ScheduledFuture&lt;?&gt;&gt; futures = delayQueues.computeIfAbsent(ChannelUtils.getChannelId(channel), k -&gt; new ArrayList&lt;&gt;()); futures.add(delayMessageFuture); &#125; public void cancelDelayMessageFuture(Channel channel)&#123; List&lt;ScheduledFuture&lt;?&gt;&gt; futures = delayQueues.computeIfAbsent(ChannelUtils.getChannelId(channel), k -&gt; new ArrayList&lt;&gt;()); for(ScheduledFuture&lt;?&gt; future : futures)&#123; if(!future.isCancelled() &amp;&amp; !future.isDone())&#123; future.cancel(false); &#125; &#125; delayQueues.remove(ChannelUtils.getChannelId(channel)); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"delay","slug":"delay","permalink":"https://idea360.cn/tags/delay/"},{"name":"延时","slug":"延时","permalink":"https://idea360.cn/tags/%E5%BB%B6%E6%97%B6/"}]},{"title":"Java树结构","slug":"java-tree","date":"2021-06-17T13:49:51.000Z","updated":"2021-06-17T14:16:55.921Z","comments":true,"path":"2021/06/17/java-tree/","link":"","permalink":"https://idea360.cn/2021/06/17/java-tree/","excerpt":"","text":"前言 很久不写业务接口, 最近刚好遇到需要实现树结构, 做下简单总结 逻辑实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.easyliao.demo;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Data;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.stream.Collectors;/** * @author cuishiying * @date 2021-06-17 */public class TreeTest &#123; @Data public static class Node &#123; private Integer id; private String name; private Integer pid; private List&lt;Node&gt; children; public Node(Integer id, String name, Integer pid) &#123; this.id = id; this.name = name; this.pid = pid; &#125; &#125; public static void main(String[] args) throws Exception&#123; Node p0 = new Node(1, &quot;p00&quot;, 0); Node p1 = new Node(2, &quot;p01&quot;, 0); Node p2 = new Node(3, &quot;p10&quot;, 1); Node p3 = new Node(4, &quot;p11&quot;, 1); Node p4 = new Node(5, &quot;p20&quot;, 3); List&lt;Node&gt; nodes = Arrays.asList(p0, p1, p2, p3, p4); List&lt;Node&gt; tree = buildTree(nodes); ObjectMapper objectMapper = new ObjectMapper(); System.out.println(objectMapper.writeValueAsString(tree)); &#125; /** * 单个根节点 * @param pidList 平铺list * @return 树结构 */ public Node buildOneNodeTree(List&lt;Node&gt; pidList)&#123; // pid -&gt; children Map&lt;Integer,List&lt;Node&gt;&gt; pidListMap = pidList.stream().collect(Collectors.groupingBy(Node::getPid)); pidList.forEach(item-&gt;item.setChildren(pidListMap.get(item.getId()))); // 取出顶层节点的对象，本例顶层节点的&quot;PID&quot;为0 return pidListMap.get(0).get(0); &#125; /** * 多个顶层节点 * @param pidList 平铺list * @return 树结构 */ public static List&lt;Node&gt; buildTree(List&lt;Node&gt; pidList)&#123; // pid -&gt; children Map&lt;Integer,List&lt;Node&gt;&gt; pidListMap = pidList.stream().collect(Collectors.groupingBy(Node::getPid)); // 在内存中为同一对象, 所以set后分组也会生效 pidList.forEach(item-&gt;item.setChildren(pidListMap.get(item.getId()))); // 返回结果也改为返回顶层节点的list, 顶层节点的pid=0 return pidListMap.get(0); &#125;&#125; 简单抽象 我们这里做一个简单工具类 首先我们抽象一个接口, 所有实现Tree结构的对象需要实现该接口 12345678910111213141516171819202122232425262728293031323334/** * @author cuishiying * @date 2021-01-22 */public interface TreeNode&lt;T&gt; &#123; /** * 获取节点id * * @return 树节点id */ T getId(); /** * 获取该节点的父节点id * * @return 父节点id */ T getPid(); /** * 设置节点的子节点列表 * * @param children 子节点 */ void setChildren(List&lt;? extends TreeNode&lt;T&gt;&gt; children); /** * 获取所有子节点 * * @return 子节点列表 */ List&lt;? extends TreeNode&lt;T&gt;&gt; getChildren();&#125; 定义基本实现类 1234567891011121314151617181920212223242526272829303132333435363738/** * @author cuishiying * @date 2021-01-22 */@Datapublic class Node implements TreeNode&#123; private Integer id; private String name; private Integer pid; private List&lt;Node&gt; children; public Node(Integer id, String name, Integer pid) &#123; this.id = id; this.name = name; this.pid = pid; &#125; @Override public Object getId() &#123; return id; &#125; @Override public Object getPid() &#123; return pid; &#125; @Override public List&lt;? extends TreeNode&gt; getChildren() &#123; return children; &#125; @Override public void setChildren(List children) &#123; this.children = children; &#125;&#125; 工具类 1234567891011121314 * @author cuishiying * @date 2021-01-22 */public class TreeBuilder &#123; public static List&lt;? extends TreeNode&gt; build(List&lt;? extends TreeNode&gt; nodes) &#123; // pid -&gt; children Map&lt;Object, ? extends List&lt;? extends TreeNode&gt;&gt; pidListMap = nodes.stream().collect(Collectors.groupingBy(TreeNode::getPid)); // 在内存中为同一对象, 所以set后分组也会生效 nodes.forEach(item-&gt;item.setChildren(pidListMap.get(item.getId()))); // 返回结果也改为返回顶层节点的list, 顶层节点的pid=0 return pidListMap.get(0); &#125;&#125; 测试 12345678910111213141516171819/** * @author cuishiying * @date 2021-01-22 */public class TreeTest &#123; public static void main(String[] args) throws Exception &#123; Node p0 = new Node(1, &quot;p00&quot;, 0); Node p1 = new Node(2, &quot;p01&quot;, 0); Node p2 = new Node(3, &quot;p10&quot;, 1); Node p3 = new Node(4, &quot;p11&quot;, 1); Node p4 = new Node(5, &quot;p20&quot;, 3); List&lt;Node&gt; nodes = Arrays.asList(p0, p1, p2, p3, p4); List&lt;Node&gt; tree = (List&lt;Node&gt;) TreeBuilder.build(nodes); ObjectMapper objectMapper = new ObjectMapper(); System.out.println(objectMapper.writeValueAsString(tree)); &#125;&#125; 输出 1234567891011121314151617181920212223242526[&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;p00&quot;, &quot;pid&quot;: 0, &quot;children&quot;: [&#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;p10&quot;, &quot;pid&quot;: 1, &quot;children&quot;: [&#123; &quot;id&quot;: 5, &quot;name&quot;: &quot;p20&quot;, &quot;pid&quot;: 3, &quot;children&quot;: null &#125;] &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;p11&quot;, &quot;pid&quot;: 1, &quot;children&quot;: null &#125;]&#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;p01&quot;, &quot;pid&quot;: 0, &quot;children&quot;: null&#125;] 最后 欢迎大家关注公众号【当我遇上你】支持我。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"tree","slug":"tree","permalink":"https://idea360.cn/tags/tree/"},{"name":"树结构","slug":"树结构","permalink":"https://idea360.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"},{"name":"数","slug":"数","permalink":"https://idea360.cn/tags/%E6%95%B0/"},{"name":"java8","slug":"java8","permalink":"https://idea360.cn/tags/java8/"}]},{"title":"SpringBoot自定义starter之标准化处理","slug":"unified-spring-boot-starter","date":"2021-05-26T10:26:11.000Z","updated":"2021-06-12T05:20:23.694Z","comments":true,"path":"2021/05/26/unified-spring-boot-starter/","link":"","permalink":"https://idea360.cn/2021/05/26/unified-spring-boot-starter/","excerpt":"","text":"前言 许久没更新博客了, 甚是抱歉。工作中需要下沉一些通用组件, 所以这里先做了一个接口标准化包。功能包括: 统一异常处理 统一接口返回格式 统一参数校验(业务无需加@Valid和Validated注解) 实现 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idea360-core&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; spring.factories /resources/META-INF/spring.factories 目录下 12345org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\cn.idea360.unified.UnifiedResponseBodyAdvice,\\cn.idea360.unified.UnifiedExceptionHandler,\\cn.idea360.unified.filter.FilterAutoConfig,\\cn.idea360.unified.interceptor.InterceptorAutoConfig 通用异常处理 返回格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * @author cuishiying * @date 2021-01-22 */public class UnifiedResult&lt;T&gt; implements Serializable &#123; public static final int SUCCESS = 0; public static final int ERROR = -1; private String msg; private int code = SUCCESS; private T data; public UnifiedResult(int code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public static class Builder&lt;T&gt; &#123; private String msg = &quot;OK&quot;; private int code = SUCCESS; private T data; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public Builder&lt;T&gt; data(T data) &#123; this.data = data; return this; &#125; public Builder&lt;T&gt; error(int code, String msg) &#123; this.code = code; this.msg = msg; return this; &#125; public Builder&lt;T&gt; error(int code) &#123; this.code = code; return this; &#125; public UnifiedResult&lt;T&gt; build() &#123; return new UnifiedResult&lt;T&gt;(this.code, this.msg, this.data); &#125; public Builder&lt;T&gt; message(String msg) &#123; this.msg = msg; return this; &#125; &#125;&#125; 异常拦截 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * @author cuishiying * @date 2021-01-22 */@RestControllerAdvicepublic class UnifiedExceptionHandler &#123; private final Logger log = LoggerFactory.getLogger(UnifiedExceptionHandler.class); /** * 参数绑定异常 */ @ExceptionHandler(&#123;BindException.class&#125;) public UnifiedResult exceptionHandler(BindException e) &#123; log.error(&quot;BindException:&quot;, e); BindingResult bindingResult = e.getBindingResult(); return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, Objects.requireNonNull(bindingResult.getFieldError()).getDefaultMessage()).build(); &#125; /** * 参数校验异常 */ @ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;) public UnifiedResult exceptionHandler(MethodArgumentNotValidException e) &#123; log.error(&quot;MethodArgumentNotValidException:&quot;, e); BindingResult bindingResult = e.getBindingResult(); return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, Objects.requireNonNull(bindingResult.getFieldError()).getDefaultMessage()).build(); &#125; /** * 参数验证异常 */ @ExceptionHandler(value = ConstraintViolationException.class) public UnifiedResult handler(ConstraintViolationException e) &#123; return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, e.getMessage()).build(); &#125; /** * 参数类型转换错误 */ @ExceptionHandler(HttpMessageConversionException.class) public UnifiedResult handler(HttpMessageConversionException e) &#123; return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, e.getMessage()).build(); &#125; /** * 参数格式异常 */ @ExceptionHandler(value = HttpMessageNotReadableException.class) public UnifiedResult handler(HttpMessageNotReadableException e) &#123; return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, e.getMessage()).build(); &#125; /** * 请求方式异常 */ @ExceptionHandler(value = HttpRequestMethodNotSupportedException.class) public UnifiedResult handler(HttpRequestMethodNotSupportedException e) &#123; return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, &quot;请求方式错误&quot;).build(); &#125; /** * 媒体类型异常 */ @ExceptionHandler(value = HttpMediaTypeNotSupportedException.class) public UnifiedResult handler(HttpMediaTypeNotSupportedException e) &#123; return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, &quot;媒体类型错误&quot;).build(); &#125; /** * 请求参数丢失 */ @ExceptionHandler(&#123;MissingServletRequestParameterException.class&#125;) public UnifiedResult handler(MissingServletRequestParameterException e) &#123; return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, e.getMessage()).build(); &#125; /** * 统一业务异常 */ @ExceptionHandler(&#123;BsException.class&#125;) public UnifiedResult exceptionHandler(BsException e) &#123; log.error(&quot;BsException:&quot;, e); return new UnifiedResult.Builder&lt;&gt;().error(e.getCode(), e.getMessage()).build(); &#125; /** * 默认异常 */ @ExceptionHandler(value = Throwable.class) public UnifiedResult exceptionHandler(Throwable e) &#123; log.error(&quot;UnifiedExceptionHandler: &#123;&#125;&quot;, ExceptionUtils.getStackTrace(e)); return new UnifiedResult.Builder&lt;&gt;().error(UnifiedResult.ERROR, e.getMessage()).build(); &#125;&#125; 自定义业务异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class BsException extends RuntimeException &#123; private Integer code; private String message; private String stackTrace; private transient Throwable throwable; public BsException() &#123; &#125; public BsException(String message) &#123; super(message); this.code = this.formatErrCode(-1); this.message = message; &#125; public BsException(int code, String message) &#123; super(message); this.code = this.formatErrCode(code); this.message = message; &#125; public BsException(int code, Throwable throwable) &#123; super(throwable); this.code = this.formatErrCode(code); this.message = throwable.getMessage(); this.stackTrace = ExceptionUtils.getStackTrace(throwable); this.throwable = throwable; &#125; public BsException(int code, String message, Throwable throwable) &#123; super(message, throwable); this.code = this.formatErrCode(code); this.message = message; this.throwable = throwable; this.stackTrace = ExceptionUtils.getStackTrace(throwable); &#125; private int formatErrCode(int errCode) &#123; return errCode == 0 ? -1 : errCode; &#125; public Integer getCode() &#123; return this.code; &#125; public String getMessage() &#123; if (!StringUtils.isEmpty(this.message)) &#123; return this.message; &#125; else &#123; return this.throwable != null ? this.throwable.getMessage() : &quot;&quot;; &#125; &#125; public String getStackTrace2String() &#123; return this.stackTrace == null ? &quot;&quot; : this.stackTrace; &#125; public String toString() &#123; Integer var10000 = this.getCode(); return &quot;ErrCode:&quot; + var10000 + &quot;, ErrMsg:&quot; + this.getMessage(); &#125;&#125; 统一包装接口格式 全局格式 首先, 我们应该允许上层配置白名单, 所以先从配置文件读取配置。 123456789101112131415/** * @author cuishiying * @date 2021-06-11 */@ConfigurationProperties(prefix = UnifiedProperties.UNIFIED_PREFIX)public class UnifiedProperties &#123; public static final String UNIFIED_PREFIX = &quot;easyliao.framework.unified&quot;; private final List&lt;String&gt; ignores = new ArrayList&lt;&gt;(); public List&lt;String&gt; getIgnores() &#123; return ignores; &#125;&#125; 然后配置全局返回格式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author cuishiying * @date 2021-01-22 */@EnableConfigurationProperties(UnifiedProperties.class)@RestControllerAdvicepublic class UnifiedResponseBodyAdvice implements ResponseBodyAdvice&lt;Object&gt;, BeanFactoryAware &#123; @Resource private UnifiedProperties unifiedProperties; private static ObjectMapper objectMapper; private static final String[] innerIgnores = new String[]&#123; //过滤swagger相关的请求的接口，不然swagger会提示base-url被拦截 &quot;/swagger-resources&quot;, &quot;/swagger-ui&quot;, &quot;/v3/api-docs&quot; &#125;; @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;// return MappingJackson2HttpMessageConverter.class.isAssignableFrom(converterType) &amp;&amp;// (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class)); return !returnType.getGenericParameterType().equals(UnifiedResult.class) &amp;&amp; !returnType.hasMethodAnnotation(UnifiedIgnore.class); &#125; @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (this.ignoring(request.getURI().toString())) &#123; return body; &#125; if (returnType.getGenericParameterType().equals(String.class)) &#123; try &#123; response.getHeaders().set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); return objectMapper.writeValueAsString(new UnifiedResult.Builder&lt;&gt;().data(body).build()); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;返回String类型错误&quot;); &#125; &#125; return new UnifiedResult.Builder&lt;&gt;().data(body).build(); &#125; private boolean ignoring(String uri) &#123; for (String string : innerIgnores) &#123; if (uri.contains(string)) &#123; return true; &#125; &#125; for (String string : unifiedProperties.getIgnores()) &#123; if (uri.contains(string)) &#123; return true; &#125; &#125; return false; &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; objectMapper = beanFactory.getBean(ObjectMapper.class); &#125;&#125; 无需按标准返回的方法注解 123456789/** * @author cuishiying * @date 2021-05-25 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface UnifiedIgnore &#123;&#125; 参数统一校验 目前只处理了RequestBody类型的参数。 由于Filter拿不到方法相关信息, 所以只能基于 Interceptor 或者 AOP 实现, AOP 实现需要指定 Controller 切面, 需要提取配置参数, 故选择 Interceptor 拦截所有。 注入拦截器 12345678910111213/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class InterceptorAutoConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ValidateInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; 拦截器实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author cuishiying * @date 2021-01-22 */@Componentpublic class ValidateInterceptor implements HandlerInterceptor, BeanFactoryAware &#123; private final Logger log = LoggerFactory.getLogger(getClass()); private static final Validator validator = Validation.byProvider(HibernateValidator.class) .configure() .failFast(true) .buildValidatorFactory() .getValidator(); private static ObjectMapper objectMapper; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (HandlerMethod.class.isInstance(handler)) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; MethodParameter[] methodParameters = handlerMethod.getMethodParameters(); for (MethodParameter arg : methodParameters)&#123; if (arg != null &amp;&amp; arg.hasParameterAnnotation(RequestBody.class) &amp;&amp; !arg.getParameterType().isAssignableFrom(String.class)) &#123; RequestWrapper requestWrapper = new RequestWrapper(request); String body = getRequestBody(requestWrapper); Object o = objectMapper.readValue(body, arg.getParameterType()); Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolations = validator.validate(o); if(!constraintViolations.isEmpty())&#123; throw new ConstraintViolationException(constraintViolations); &#125; &#125; &#125; &#125; return HandlerInterceptor.super.preHandle(request, response, handler); &#125; private String getRequestBody (HttpServletRequest request) throws IOException &#123; return request.getReader().lines().collect(Collectors.joining(System.lineSeparator())); &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; objectMapper = beanFactory.getBean(ObjectMapper.class); &#125;&#125; 由于流只能被消费一次, 所有此处需要处理流消费的问题。这里不能在拦截器包装 HttpServletRequestWrapper 处理。因为流在拦截器消费一次后不会再向下传递。而在 Filter 做 HttpServletRequestWrapper 处理, 流因为中间载体可以被多次消费, 而且向下游传递的是 HttpServletRequestWrapper。 1234567891011121314151617/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class FilterAutoConfig &#123; @Bean public FilterRegistrationBean&lt;RepeatStreamFilter&gt; traceFilterRegistration() &#123; FilterRegistrationBean&lt;RepeatStreamFilter&gt; registration = new FilterRegistrationBean&lt;&gt;(); registration.setOrder(Ordered.HIGHEST_PRECEDENCE + 100); registration.addUrlPatterns(&quot;/*&quot;); registration.setFilter(new RepeatStreamFilter()); return registration; &#125;&#125; 123456789101112131415161718192021/** * @author cuishiying * @date 2021-01-22 */public class RepeatStreamFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; ServletRequest requestWrapper=null; if(request instanceof HttpServletRequest) &#123; requestWrapper = new RequestWrapper((HttpServletRequest)request); &#125; if(requestWrapper==null) &#123; chain.doFilter(request, response); &#125;else &#123; chain.doFilter(requestWrapper, response); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author cuishiying * @date 2021-01-22 */public class RequestWrapper extends HttpServletRequestWrapper &#123; private ByteArrayOutputStream cachedBytes; public RequestWrapper(HttpServletRequest request) &#123; super(request); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; if (cachedBytes == null) cacheInputStream(); return new RequestWrapper.CachedServletInputStream(); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; private void cacheInputStream() throws IOException &#123; cachedBytes = new ByteArrayOutputStream(); IOUtils.copy(super.getInputStream(), cachedBytes); &#125; /* An inputstream which reads the cached request body */ public class CachedServletInputStream extends ServletInputStream &#123; private ByteArrayInputStream input; public CachedServletInputStream() &#123; /* create a new input stream from the cached request body */ input = new ByteArrayInputStream(cachedBytes.toByteArray()); &#125; @Override public int read() throws IOException &#123; return input.read(); &#125; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener listener) &#123; &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】, 您的支持是我写作的最大动力。","categories":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"starter","slug":"starter","permalink":"https://idea360.cn/tags/starter/"},{"name":"接口","slug":"接口","permalink":"https://idea360.cn/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"validator","slug":"validator","permalink":"https://idea360.cn/tags/validator/"},{"name":"异常","slug":"异常","permalink":"https://idea360.cn/tags/%E5%BC%82%E5%B8%B8/"},{"name":"统一","slug":"统一","permalink":"https://idea360.cn/tags/%E7%BB%9F%E4%B8%80/"}]},{"title":"编程规范","slug":"code-format","date":"2021-05-01T03:20:04.000Z","updated":"2021-07-30T12:09:26.712Z","comments":true,"path":"2021/05/01/code-format/","link":"","permalink":"https://idea360.cn/2021/05/01/code-format/","excerpt":"","text":"Java后端开发规范 Git分支管理规范 1. 分支说明及操作 master 分支 主分支，永远处于稳定状态，对应当前线上版本 以 tag 标记一个版本，因此在 master 分支上看到的每一个 tag 都应该对应一个线上版本 不允许在该分支直接提交代码 develop 分支 开发分支，包含了项目最新的功能和代码，所有开发都依赖 develop 分支进行 小的改动可以直接在 develop 分支进行，改动较多时切出新的 feature 分支进行 注： 更好的做法是 develop 分支作为开发的主分支，也不允许直接提交代码。小改动也应该以 feature 分支提 merge request 合并，目的是保证每个改动都经过了强制代码 review，降低代码风险。 feature 分支 功能分支，开发新功能的分支 开发新的功能或者改动较大的调整，从 develop 分支切换出 feature 分支，分支名称为 feature/xxx 开发完成后合并回 develop 分支并且删除该 feature/xxx 分支 release 分支 发布分支，新功能合并到 develop 分支，准备发布新版本时使用的分支 当 develop 分支完成功能合并和部分 bug fix，准备发布新版本时，切出一个 release 分支，来做发布前的准备，分支名约定为release/xxx 发布之前发现的 bug 就直接在这个分支上修复，确定准备发版本就合并到 master 分支，完成发布，同时合并到 develop 分支 hotfix 分支 紧急修复线上 bug 分支 当线上版本出现 bug 时，从 master 分支切出一个 hotfix/xxx 分支，完成 bug 修复，然后将 hotfix/xxx 合并到 master 和 develop 分支(如果此时存在 release 分支，则应该合并到 release 分支)，合并完成后删除该 hotfix/xxx 分支 以上就是在项目中应该出现的分支以及每个分支功能的说明。 其中稳定长期存在的分支只有 master 和 develop 分支，别的分支在完成对应的使命之后都会合并到这两个分支然后被删除。简单总结如下： master 分支: 线上稳定版本分支, 该分支代码与线上代码是完全一致的。 develop 分支: 开发分支，衍生出 feature 分支和 release 分支 release 分支: 发布分支，准备待发布版本的分支，存在多个，版本发布之后删除。该分支从 develop 分支创建，创建之后由测试人员发布到测试环境进行测试。 feature 分支: 功能分支，完成特定功能开发的分支，存在多个，功能合并之后删除 hotfix 分支: 紧急热修复分支，存在多个，紧急版本发布之后删除 2. 提交信息规范 提交信息规范部分参考 Angular.js commit messgae。 git commit 格式 如下： 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 各个部分的说明如下： type 类型，提交的类别 feat: 新功能 fix: 修复 bug docs: 文档变动 style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等 refactor: bug 修复和添加新功能之外的代码改动 perf: 提升性能的改动 test: 添加或修正测试代码 chore: 构建过程或辅助工具和库（如文档生成）的更改 scope 修改范围 主要是这次修改涉及到的部分，简单概括，例如 login、train-order subject 修改的描述 具体的修改描述信息 范例 123feat(detail): 详情页修改样式fix(login): 登录页面错误处理test(list): 列表页添加测试代码 命名规范 1. 服务命名 根据功能模块进行服务命名, 内部纯服务(如dubbo等非web服务)以service结尾, web服务以web结尾。命名结构: 模块-微服务-服务类型。 如支付相关的微服务(pay-bill-web代表支付模块中账单服务) 2. 实体命名 项目中实体命名应该按领域模型命名 实体 说明 VO 接口返回对象 DTO 数据传输对象 DO 数据库操作对象, 对应表结构 注释规范 1. 类注释 类注释必须包含作者+日期+功能描述, 如 123456&#x2F;** * 支付账单 * * @author xxx * @date 2021-01-22 *&#x2F; 2. 方法注释 方法注释中必须包含功能描述+入参说明+返回说明, 如 123456&#x2F;** * 创建 CuratorFramework 对象并连接 Zookeeper * * @param zookeeperProperties zk配置文件 * @return CuratorFramework zk客户端 *&#x2F; 3. 对于多人修改同一方法, 注释中应该标明修改人, 修改日期, 修改说明 12345678910&#x2F;** * 创建 CuratorFramework 对象并连接 Zookeeper * * @param zookeeperProperties zk配置文件 * @return CuratorFramework zk客户端 * * @author: xxx * @date: 2021-01-22 * @modify: 将xxx修改为xxx *&#x2F; 异常处理 运行时异常需继承自统一异常 EasyliaoException, 异常通过全局异常统一返回 12345&lt;dependency&gt; &lt;groupId&gt;com.easyliao&lt;/groupId&gt; &lt;artifactId&gt;easyliao-core&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt;&lt;/dependency&gt; 异常的捕获用于容错处理。绝大部分场景,不允许捕获异常,不要乱加空判断。只有明显不需要关心的异常，如关闭资源的时候的io异常，可以捕获然后什么都不干,其他时候, 不允许捕获异常, 都抛出去到controller处理。空判断大部分时候不需要，你如果写了空判断，你就必须测试为空和不为空二种场景, 要么就不要写空判断。 强调, 有些空判断是要的，如：参数是用户输入的情况下。 数据库 字符集 utf8mb4 排序规则 默认采用不区分大小写的utf8mb4_general_ci 表及字段必须添加COMMENT描述 项目设计 项目中技术设计应该包含: 数据库设计、关键时序设计、服务拓扑关系、接口设计 Review规范 其他 其他未描述到的请参照阿里代码规范 参考 https://xwjie.github.io/rule/exception.html#错误范例","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"规范","slug":"规范","permalink":"https://idea360.cn/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"线程池笔记","slug":"thread-pool-note","date":"2021-04-15T15:33:25.000Z","updated":"2021-04-18T06:53:19.377Z","comments":true,"path":"2021/04/15/thread-pool-note/","link":"","permalink":"https://idea360.cn/2021/04/15/thread-pool-note/","excerpt":"","text":"创建线程池 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.example.demo.thread;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;/** * @author cuishiying * @date 2021-01-22 */public class ThreadPoolFactory &#123; /** * spring线程池 */ public static ThreadPoolTaskExecutor springThreadPool() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 5); // 核心线程数 executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 5); // 最大线程数 executor.setQueueCapacity(500); // 任务队列容量 executor.setThreadNamePrefix(&quot;ali-asr-&quot;); executor.initialize(); return executor; &#125; /** * Java自定义线程池 */ public static ExecutorService newThreadPoolExecutor() &#123; ThreadFactory threadFactory = new ThreadFactory() &#123; private final AtomicInteger id = new AtomicInteger(); @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r); thread.setName(&quot;idea360&quot; + id.getAndIncrement()); return thread; &#125; &#125;; BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;&gt;(500); // 超过队列策略：丢弃 RejectedExecutionHandler rejectedExecutionHandler = new ThreadPoolExecutor.DiscardPolicy(); return new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), Runtime.getRuntime().availableProcessors(), 0L, TimeUnit.MILLISECONDS, workQueue, threadFactory, rejectedExecutionHandler); &#125; /** * Java线程池工具 */ public static ExecutorService newFixedThreadPool() &#123; return Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), r -&gt; &#123; Thread t = new Thread(r); t.setName(&quot;idea360&quot;); t.setDaemon(true); return t; &#125;); &#125; /** * Java线程池工具:调度线程池 */ public static ScheduledExecutorService newScheduledThreadPool() &#123; return Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), r -&gt; &#123; Thread t = new Thread(r); t.setName(&quot;idea360&quot;); t.setDaemon(true); return t; &#125;); &#125;&#125; 基本示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * @author cuishiying * @date 2021-01-22 */public class ThreadTest &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;主线程开始工作：&quot;); long startTime = System.currentTimeMillis(); ExecutorService executorService = ThreadPoolFactory.newThreadPoolExecutor(); futureTask(executorService); long stopTime = System.currentTimeMillis(); System.out.println(&quot;主线程结束，耗时：&quot;+(stopTime - startTime)+&quot;ms&quot;); executorService.shutdown(); &#125; /** * 主线程开始工作： * 主线程结束，耗时：7ms * 线程中的任务，开始运行！ * 正在执行！ * 线程中的任务，结束执行！ */ public static void asyncThread(ExecutorService executorService) &#123; executorService.execute(new RunnableTask()); &#125; /** * 主线程开始工作： * 线程中的任务，开始运行！ * 正在执行！ * 线程中的任务，结束执行！ * 返回值: 当我遇上你~ * 主线程结束，耗时：1072ms */ private static void blockThread(ExecutorService executorService) throws ExecutionException, InterruptedException &#123; Future&lt;String&gt; future = executorService.submit(new CallableTask()); String returnValue = future.get(); System.out.println(&quot;返回值: &quot; + returnValue); &#125; /** * 主线程开始工作： * 线程中的任务，开始运行！ * 正在执行！ * 主线程结束，耗时：61ms * 线程中的任务，结束执行！ * 返回值: 当我遇上你~ */ public static void asyncUnBlockThread(ExecutorService executorService) &#123; ExecutorService secondExecutorService = Executors.newFixedThreadPool(1); Future&lt;String&gt; future = executorService.submit(new CallableTask()); secondExecutorService.execute(() -&gt; &#123; try &#123; String returnValue = future.get(); System.out.println(&quot;返回值: &quot; + returnValue); &#125; catch (InterruptedException|ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; /** * 主线程开始工作： * 线程中的任务，开始运行！ * 正在执行！ * 线程中的任务，结束执行！ * 返回值: 当我遇上你~ * 主线程结束，耗时：1046ms */ public static void futureTask(ExecutorService executorService) throws ExecutionException, InterruptedException &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new CallableTask()); executorService.execute(futureTask); String returnValue = futureTask.get(); System.out.println(&quot;返回值: &quot; + returnValue); &#125; /** * Java8异步任务 * 主线程开始工作： * 线程中的任务，开始运行！ * 正在执行！ * 线程中的任务，结束执行！ * 返回值: 当我遇上你~ * 主线程结束，耗时：1086ms */ public static void asyncTask(ExecutorService executorService) &#123; CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;线程中的任务，开始运行！&quot;); doSomeThing(); System.out.println(&quot;线程中的任务，结束执行！&quot;); return &quot;当我遇上你~&quot;; &#125;, executorService); try &#123; String returnValue = supplyAsync.get();// Blocking System.out.println(&quot;返回值: &quot; + returnValue); &#125; catch (ExecutionException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static class RunnableTask implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;线程中的任务，开始运行！&quot;); doSomeThing(); System.out.println(&quot;线程中的任务，结束执行！&quot;); &#125; &#125; private static class CallableTask implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;线程中的任务，开始运行！&quot;); doSomeThing(); System.out.println(&quot;线程中的任务，结束执行！&quot;); return &quot;当我遇上你~&quot;; &#125; &#125; private static void doSomeThing()&#123; try &#123; System.out.println(&quot;正在执行！&quot;); TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125;&#125; 定时调度 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author cuishiying * @date 2021-01-22 */public class ScheduledTest &#123; /** * 线程中的任务，开始运行！ * 正在执行！ * 线程中的任务，结束执行！ * 线程中的任务，开始运行！ * 正在执行！ * 线程中的任务，结束执行！ * 线程中的任务，开始运行！ * 正在执行！ * 线程中的任务，结束执行！ */ public static void main(String[] args) throws Exception &#123; System.out.println(&quot;主线程开始工作：&quot;); ScheduledExecutorService executorService = ThreadPoolFactory.newScheduledThreadPool(); executorService.scheduleWithFixedDelay(new RunnableTask(), 1L, 2L, TimeUnit.SECONDS); // 主线程执行结束后子线程就不会再执行了 TimeUnit.SECONDS.sleep(10); &#125; private static class RunnableTask implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;线程中的任务，开始运行！&quot;); doSomeThing(); System.out.println(&quot;线程中的任务，结束执行！&quot;); &#125; &#125; private static void doSomeThing()&#123; try &#123; System.out.println(&quot;正在执行！&quot;); TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125;&#125; 并发测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.example.demo.thread;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author cuishiying * @date 2021-01-22 */public class LockTest &#123; private static final Logger log = LoggerFactory.getLogger(LockTest.class); // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; // 初始计数 public static int count = 0; // juc lock private final static Lock lock = new ReentrantLock(); public static void main(String[] args) throws Exception &#123; // 线程池 ExecutorService executorService = Executors.newCachedThreadPool(); // 控制并发 final Semaphore semaphore = new Semaphore(threadTotal); // 闭锁(让主线程等待子线程5000个任务执行完毕) final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; // 此处能够同时获取200个令牌, 然后等待令牌释放 semaphore.acquire(); add(); // 令牌释放后其他任务才能继续执行, 直到5000任务执行完毕 semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; // 计数器-1 countDownLatch.countDown(); &#125;); &#125; // 阻塞主线程, 等待子线程执行完毕(countDownLatch计数器变为0) countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); &#125; private static void add() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 循环屏障 一个线程组的线程需要等待所有线程完成任务后再继续执行下一次任务。可以用于多线程计算数据，最后合并计算结果的场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author cuishiying * @date 2021-01-22 */public class CyclicBarrierTest &#123; private static final Logger log = LoggerFactory.getLogger(CyclicBarrierTest.class); private static CyclicBarrier barrier = new CyclicBarrier(5); /** * 14:34:20.041 [pool-1-thread-1] INFO com.example.demo.thread.CyclicBarrierTest - 0 is ready * 14:34:20.543 [pool-1-thread-2] INFO com.example.demo.thread.CyclicBarrierTest - 1 is ready * 14:34:21.048 [pool-1-thread-3] INFO com.example.demo.thread.CyclicBarrierTest - 2 is ready * 14:34:21.552 [pool-1-thread-4] INFO com.example.demo.thread.CyclicBarrierTest - 3 is ready * 14:34:22.054 [pool-1-thread-5] INFO com.example.demo.thread.CyclicBarrierTest - 4 is ready * 14:34:22.055 [pool-1-thread-5] INFO com.example.demo.thread.CyclicBarrierTest - 4 continue * 14:34:22.055 [pool-1-thread-1] INFO com.example.demo.thread.CyclicBarrierTest - 0 continue * 14:34:22.055 [pool-1-thread-2] INFO com.example.demo.thread.CyclicBarrierTest - 1 continue * 14:34:22.055 [pool-1-thread-3] INFO com.example.demo.thread.CyclicBarrierTest - 2 continue * 14:34:22.055 [pool-1-thread-4] INFO com.example.demo.thread.CyclicBarrierTest - 3 continue * 14:34:22.555 [pool-1-thread-6] INFO com.example.demo.thread.CyclicBarrierTest - 5 is ready * 14:34:23.058 [pool-1-thread-5] INFO com.example.demo.thread.CyclicBarrierTest - 6 is ready * 14:34:23.561 [pool-1-thread-3] INFO com.example.demo.thread.CyclicBarrierTest - 7 is ready * 14:34:24.065 [pool-1-thread-4] INFO com.example.demo.thread.CyclicBarrierTest - 8 is ready * 14:34:24.571 [pool-1-thread-1] INFO com.example.demo.thread.CyclicBarrierTest - 9 is ready * 14:34:24.571 [pool-1-thread-1] INFO com.example.demo.thread.CyclicBarrierTest - 9 continue * 14:34:24.571 [pool-1-thread-6] INFO com.example.demo.thread.CyclicBarrierTest - 5 continue * 14:34:24.571 [pool-1-thread-5] INFO com.example.demo.thread.CyclicBarrierTest - 6 continue * 14:34:24.571 [pool-1-thread-4] INFO com.example.demo.thread.CyclicBarrierTest - 8 continue * 14:34:24.571 [pool-1-thread-3] INFO com.example.demo.thread.CyclicBarrierTest - 7 continue */ public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; TimeUnit.MILLISECONDS.sleep(500); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown(); &#125; private static void race(int threadNum) throws Exception &#123; log.info(&quot;&#123;&#125; is ready&quot;, threadNum); // 所有线程阻塞, 直到barrier计数器变为0 barrier.await(); log.info(&quot;&#123;&#125; continue&quot;, threadNum); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"https://idea360.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"thread","slug":"thread","permalink":"https://idea360.cn/tags/thread/"},{"name":"threadPool","slug":"threadPool","permalink":"https://idea360.cn/tags/threadPool/"}]},{"title":"SpringBoot引入外部配置文件","slug":"spring-boot-property-custom","date":"2021-04-03T11:12:00.000Z","updated":"2021-04-11T05:45:56.728Z","comments":true,"path":"2021/04/03/spring-boot-property-custom/","link":"","permalink":"https://idea360.cn/2021/04/03/spring-boot-property-custom/","excerpt":"","text":"前言 配置预习知识点: PropertyPlaceholderConfigurer, PropertySourcesPlaceholderConfigurer, EnvironmentPostProcessor。 @PropertySource引入外部配置文件 自定义配置文件config.properties 12idea360.username=adminidea360.password=admin 配置bean 123456789101112131415161718192021222324252627282930package cn.idea360.prop;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.core.env.Environment;/** * @author cuishiying * @date 2021-01-22 */@Configuration@ComponentScan(basePackages = &quot;cn.idea360.prop&quot;)@PropertySource(value = &quot;classpath:config.properties&quot;)public class PropertyConfig &#123; @Autowired Environment environment; public PropertyConfig() &#123; System.out.println(&quot;PropertyConfig init&quot;); &#125; public javax.sql.DataSource dataSource()&#123; String user = this.environment.getProperty(&quot;idea360.username&quot;); System.out.println(&quot;user=&quot; + user); // user=admin return null; &#125;&#125; 测试 123456@Testpublic void test09() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(PropertyConfig.class); PropertyConfig bean = applicationContext.getBean(PropertyConfig.class); bean.dataSource();&#125; EnvironmentPostProcessor封装自定义配置文件 一般应用在封装自定义组件及内置配置文件中 内置配置文件 添加配置 1234567891011121314151617181920212223242526272829@Componentpublic class TestEnvironmentPostProcessor implements EnvironmentPostProcessor &#123; private static final Logger logger = LoggerFactory .getLogger(TestEnvironmentPostProcessor.class); @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) &#123; YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean(); // classPath下的yml文件加载 ClassPathResource classPathResource=new ClassPathResource(&quot;test.yml&quot;); yaml.setResources(classPathResource); Properties properties=yaml.getObject(); PropertiesPropertySource propertySource =new PropertiesPropertySource(&quot;TestProperties&quot;, properties); environment.getPropertySources().addLast(propertySource); &#125; // 绑定配置到实体 public static TestConfigProperties buildTestConfigProperties( ConfigurableEnvironment environment) &#123; TestConfigProperties nacosConfigProperties = new TestConfigProperties(); Binder binder = Binder.get(environment); ResolvableType type = ResolvableType.forClass(TestConfigProperties.class); Bindable&lt;?&gt; target = Bindable.of(type).withExistingValue(nacosConfigProperties); binder.bind(TestConfigProperties.PREFIX, target); logger.info(&quot;testConfigProperties : &#123;&#125;&quot;, nacosConfigProperties); return nacosConfigProperties; &#125;&#125; 配置 123456789101112131415161718192021222324@ConfigurationProperties(TestConfigProperties.PREFIX)public class TestConfigProperties &#123; public static final String PREFIX = &quot;idea360&quot;; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 日志 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; resources目录下配置test.yml 123easyliao: name: idea360 password: 123456 META-INF/spring.factories中配置 12org.springframework.boot.env.EnvironmentPostProcessor=\\com.easyliao.framework.config.TestEnvironmentPostProcessor 项目中使用 12@Value(&quot;$&#123;easyliao.name&#125;&quot;)private String name; 替换日志配置文件 替换默认日志格式 123456789101112public class TraceEnvironmentPostProcessor implements EnvironmentPostProcessor &#123; private static final String PROPERTY_SOURCE_NAME = &quot;defaultProperties&quot;; private static final String LEVEL_STR_PARENT = &quot;%5p [%X&#123;traceId:-&#125;]&quot;; @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(1); map.put(&quot;logging.pattern.level&quot;, LEVEL_STR_PARENT); EnvironmentUtils.addOrReplace(environment.getPropertySources(), map, PROPERTY_SOURCE_NAME); &#125;&#125; 12345678910111213141516171819202122public class EnvironmentUtils &#123; public static void addOrReplace(MutablePropertySources propertySources, Map&lt;String, Object&gt; map, String propertySourceName) &#123; MapPropertySource target = null; if (propertySources.contains(propertySourceName)) &#123; PropertySource&lt;?&gt; source = propertySources.get(propertySourceName); if (source instanceof MapPropertySource) &#123; target = (MapPropertySource) source; for (String key : map.keySet()) &#123; if (!target.containsProperty(key)) &#123; target.getSource().put(key, map.get(key)); &#125; &#125; &#125; &#125; if (target == null) &#123; target = new MapPropertySource(propertySourceName, map); &#125; if (!propertySources.contains(propertySourceName)) &#123; propertySources.addLast(target); &#125; &#125;&#125; META-INF/spring.factories中配置 12org.springframework.boot.env.EnvironmentPostProcessor=\\com.easyliao.framework.log.processor.TraceEnvironmentPostProcessor 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力","categories":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/categories/springboot/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"config","slug":"config","permalink":"https://idea360.cn/tags/config/"},{"name":"配置","slug":"配置","permalink":"https://idea360.cn/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"SpringBoot默认【META-INF/spring.factories】文件","slug":"spring-factories","date":"2021-03-30T15:54:17.000Z","updated":"2021-03-30T15:56:44.208Z","comments":true,"path":"2021/03/30/spring-factories/","link":"","permalink":"https://idea360.cn/2021/03/30/spring-factories/","excerpt":"","text":"前言 这里我们贴出来 springboot 默认的 spring.factories, 以便以后分析学习 源码spring.factories 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader&#x3D;\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader# Run Listenersorg.springframework.boot.SpringApplicationRunListener&#x3D;\\org.springframework.boot.context.event.EventPublishingRunListener# Error Reportersorg.springframework.boot.SpringBootExceptionReporter&#x3D;\\org.springframework.boot.diagnostics.FailureAnalyzers# Application Context Initializersorg.springframework.context.ApplicationContextInitializer&#x3D;\\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\org.springframework.boot.context.ContextIdApplicationContextInitializer,\\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer# Application Listenersorg.springframework.context.ApplicationListener&#x3D;\\org.springframework.boot.ClearCachesApplicationListener,\\org.springframework.boot.builder.ParentContextCloserApplicationListener,\\org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\org.springframework.boot.context.FileEncodingApplicationListener,\\org.springframework.boot.context.config.AnsiOutputApplicationListener,\\org.springframework.boot.context.config.ConfigFileApplicationListener,\\org.springframework.boot.context.config.DelegatingApplicationListener,\\org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\org.springframework.boot.context.logging.LoggingApplicationListener,\\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener# Environment Post Processorsorg.springframework.boot.env.EnvironmentPostProcessor&#x3D;\\org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor# Failure Analyzersorg.springframework.boot.diagnostics.FailureAnalyzer&#x3D;\\org.springframework.boot.context.properties.NotConstructorBoundInjectionFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BeanDefinitionOverrideFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BindValidationFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.UnboundConfigurationPropertyFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.NoSuchMethodFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyNameFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyValueFailureAnalyzer# FailureAnalysisReportersorg.springframework.boot.diagnostics.FailureAnalysisReporter&#x3D;\\org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Spring日志源码之JCL","slug":"spring-jcl","date":"2021-03-30T15:25:55.000Z","updated":"2021-03-30T15:28:00.539Z","comments":true,"path":"2021/03/30/spring-jcl/","link":"","permalink":"https://idea360.cn/2021/03/30/spring-jcl/","excerpt":"","text":"源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.logging;/** * A minimal incarnation of Apache Commons Logging&#x27;s &#123;@code LogFactory&#125; API, * providing just the common &#123;@link Log&#125; lookup methods. This is inspired * by the JCL-over-SLF4J bridge and should be source as well as binary * compatible with all common use of the Commons Logging API (in particular: * with &#123;@code LogFactory.getLog(Class/String)&#125; field initializers). * * &lt;p&gt;This implementation does not support Commons Logging&#x27;s original provider * detection. It rather only checks for the presence of the Log4j 2.x API * and the SLF4J 1.7 API in the Spring Framework classpath, falling back to * &#123;@code java.util.logging&#125; if none of the two is available. In that sense, * it works as a replacement for the Log4j 2 Commons Logging bridge as well as * the JCL-over-SLF4J bridge, both of which become irrelevant for Spring-based * setups as a consequence (with no need for manual excludes of the standard * Commons Logging API jar anymore either). Furthermore, for simple setups * without an external logging provider, Spring does not require any extra jar * on the classpath anymore since this embedded log factory automatically * delegates to &#123;@code java.util.logging&#125; in such a scenario. * * &lt;p&gt;&lt;b&gt;Note that this Commons Logging variant is only meant to be used for * infrastructure logging purposes in the core framework and in extensions.&lt;/b&gt; * It also serves as a common bridge for third-party libraries using the * Commons Logging API, e.g. Apache HttpClient, and HtmlUnit, bringing * them into the same consistent arrangement without any extra bridge jars. * * &lt;p&gt;&lt;b&gt;For logging need in application code, prefer direct use of Log4j 2.x * or SLF4J or &#123;@code java.util.logging&#125;.&lt;/b&gt; Simply put Log4j 2.x or Logback * (or another SLF4J provider) onto your classpath, without any extra bridges, * and let the framework auto-adapt to your choice. * * @author Juergen Hoeller (for the &#123;@code spring-jcl&#125; variant) * @since 5.0 */public abstract class LogFactory &#123; /** * Convenience method to return a named logger. * @param clazz containing Class from which a log name will be derived */ public static Log getLog(Class&lt;?&gt; clazz) &#123; return getLog(clazz.getName()); &#125; /** * Convenience method to return a named logger. * @param name logical name of the &lt;code&gt;Log&lt;/code&gt; instance to be returned */ public static Log getLog(String name) &#123; return LogAdapter.createLog(name); &#125; /** * This method only exists for compatibility with unusual Commons Logging API * usage like e.g. &#123;@code LogFactory.getFactory().getInstance(Class/String)&#125;. * @see #getInstance(Class) * @see #getInstance(String) * @deprecated in favor of &#123;@link #getLog(Class)&#125;/&#123;@link #getLog(String)&#125; */ @Deprecated public static LogFactory getFactory() &#123; return new LogFactory() &#123;&#125;; &#125; /** * Convenience method to return a named logger. * &lt;p&gt;This variant just dispatches straight to &#123;@link #getLog(Class)&#125;. * @param clazz containing Class from which a log name will be derived * @deprecated in favor of &#123;@link #getLog(Class)&#125; */ @Deprecated public Log getInstance(Class&lt;?&gt; clazz) &#123; return getLog(clazz); &#125; /** * Convenience method to return a named logger. * &lt;p&gt;This variant just dispatches straight to &#123;@link #getLog(String)&#125;. * @param name logical name of the &lt;code&gt;Log&lt;/code&gt; instance to be returned * @deprecated in favor of &#123;@link #getLog(String)&#125; */ @Deprecated public Log getInstance(String name) &#123; return getLog(name); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709/* * Copyright 2002-2020 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.logging;import java.io.Serializable;import java.util.logging.LogRecord;import org.apache.logging.log4j.Level;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.spi.ExtendedLogger;import org.apache.logging.log4j.spi.LoggerContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.slf4j.spi.LocationAwareLogger;/** * Spring&#x27;s common JCL adapter behind &#123;@link LogFactory&#125; and &#123;@link LogFactoryService&#125;. * Detects the presence of Log4j 2.x / SLF4J, falling back to &#123;@code java.util.logging&#125;. * * @author Juergen Hoeller * @since 5.1 */final class LogAdapter &#123; private static final String LOG4J_SPI = &quot;org.apache.logging.log4j.spi.ExtendedLogger&quot;; private static final String LOG4J_SLF4J_PROVIDER = &quot;org.apache.logging.slf4j.SLF4JProvider&quot;; private static final String SLF4J_SPI = &quot;org.slf4j.spi.LocationAwareLogger&quot;; private static final String SLF4J_API = &quot;org.slf4j.Logger&quot;; private static final LogApi logApi; /** * @author cuishiying * 静态代码块中的代码会在类加载JVM时运行，且只被执行一次 */ static &#123; if (isPresent(LOG4J_SPI)) &#123; if (isPresent(LOG4J_SLF4J_PROVIDER) &amp;&amp; isPresent(SLF4J_SPI)) &#123; // log4j-to-slf4j bridge -&gt; we&#x27;ll rather go with the SLF4J SPI; // however, we still prefer Log4j over the plain SLF4J API since // the latter does not have location awareness support. logApi = LogApi.SLF4J_LAL; &#125; else &#123; // Use Log4j 2.x directly, including location awareness support logApi = LogApi.LOG4J; &#125; &#125; else if (isPresent(SLF4J_SPI)) &#123; // Full SLF4J SPI including location awareness support logApi = LogApi.SLF4J_LAL; &#125; else if (isPresent(SLF4J_API)) &#123; // Minimal SLF4J API without location awareness support logApi = LogApi.SLF4J; &#125; else &#123; // java.util.logging as default logApi = LogApi.JUL; &#125; &#125; private LogAdapter() &#123; &#125; /** * 工厂方法 * Create an actual &#123;@link Log&#125; instance for the selected API. * @param name the logger name */ public static Log createLog(String name) &#123; switch (logApi) &#123; case LOG4J: return Log4jAdapter.createLog(name); case SLF4J_LAL: return Slf4jAdapter.createLocationAwareLog(name); case SLF4J: return Slf4jAdapter.createLog(name); default: // Defensively use lazy-initializing adapter class here as well since the // java.logging module is not present by default on JDK 9. We are requiring // its presence if neither Log4j nor SLF4J is available; however, in the // case of Log4j or SLF4J, we are trying to prevent early initialization // of the JavaUtilLog adapter - e.g. by a JVM in debug mode - when eagerly // trying to parse the bytecode for all the cases of this switch clause. return JavaUtilAdapter.createLog(name); &#125; &#125; private static boolean isPresent(String className) &#123; try &#123; Class.forName(className, false, LogAdapter.class.getClassLoader()); return true; &#125; catch (ClassNotFoundException ex) &#123; return false; &#125; &#125; private enum LogApi &#123;LOG4J, SLF4J_LAL, SLF4J, JUL&#125; private static class Log4jAdapter &#123; public static Log createLog(String name) &#123; return new Log4jLog(name); &#125; &#125; private static class Slf4jAdapter &#123; public static Log createLocationAwareLog(String name) &#123; Logger logger = LoggerFactory.getLogger(name); return (logger instanceof LocationAwareLogger ? new Slf4jLocationAwareLog((LocationAwareLogger) logger) : new Slf4jLog&lt;&gt;(logger)); &#125; public static Log createLog(String name) &#123; return new Slf4jLog&lt;&gt;(LoggerFactory.getLogger(name)); &#125; &#125; private static class JavaUtilAdapter &#123; public static Log createLog(String name) &#123; return new JavaUtilLog(name); &#125; &#125; /** * 告诉编译器忽略指定的警告，不用在编译完成后出现警告信息 */ @SuppressWarnings(&quot;serial&quot;) private static class Log4jLog implements Log, Serializable &#123; private static final String FQCN = Log4jLog.class.getName(); private static final LoggerContext loggerContext = LogManager.getContext(Log4jLog.class.getClassLoader(), false); private final ExtendedLogger logger; public Log4jLog(String name) &#123; LoggerContext context = loggerContext; if (context == null) &#123; // Circular call in early-init scenario -&gt; static field not initialized yet context = LogManager.getContext(Log4jLog.class.getClassLoader(), false); &#125; this.logger = context.getLogger(name); &#125; @Override public boolean isFatalEnabled() &#123; return this.logger.isEnabled(Level.FATAL); &#125; @Override public boolean isErrorEnabled() &#123; return this.logger.isEnabled(Level.ERROR); &#125; @Override public boolean isWarnEnabled() &#123; return this.logger.isEnabled(Level.WARN); &#125; @Override public boolean isInfoEnabled() &#123; return this.logger.isEnabled(Level.INFO); &#125; @Override public boolean isDebugEnabled() &#123; return this.logger.isEnabled(Level.DEBUG); &#125; @Override public boolean isTraceEnabled() &#123; return this.logger.isEnabled(Level.TRACE); &#125; @Override public void fatal(Object message) &#123; log(Level.FATAL, message, null); &#125; @Override public void fatal(Object message, Throwable exception) &#123; log(Level.FATAL, message, exception); &#125; @Override public void error(Object message) &#123; log(Level.ERROR, message, null); &#125; @Override public void error(Object message, Throwable exception) &#123; log(Level.ERROR, message, exception); &#125; @Override public void warn(Object message) &#123; log(Level.WARN, message, null); &#125; @Override public void warn(Object message, Throwable exception) &#123; log(Level.WARN, message, exception); &#125; @Override public void info(Object message) &#123; log(Level.INFO, message, null); &#125; @Override public void info(Object message, Throwable exception) &#123; log(Level.INFO, message, exception); &#125; @Override public void debug(Object message) &#123; log(Level.DEBUG, message, null); &#125; @Override public void debug(Object message, Throwable exception) &#123; log(Level.DEBUG, message, exception); &#125; @Override public void trace(Object message) &#123; log(Level.TRACE, message, null); &#125; @Override public void trace(Object message, Throwable exception) &#123; log(Level.TRACE, message, exception); &#125; private void log(Level level, Object message, Throwable exception) &#123; if (message instanceof String) &#123; // Explicitly pass a String argument, avoiding Log4j&#x27;s argument expansion // for message objects in case of &quot;&#123;&#125;&quot; sequences (SPR-16226) if (exception != null) &#123; this.logger.logIfEnabled(FQCN, level, null, (String) message, exception); &#125; else &#123; this.logger.logIfEnabled(FQCN, level, null, (String) message); &#125; &#125; else &#123; this.logger.logIfEnabled(FQCN, level, null, message, exception); &#125; &#125; &#125; @SuppressWarnings(&quot;serial&quot;) private static class Slf4jLog&lt;T extends Logger&gt; implements Log, Serializable &#123; protected final String name; protected transient T logger; public Slf4jLog(T logger) &#123; this.name = logger.getName(); this.logger = logger; &#125; @Override public boolean isFatalEnabled() &#123; return isErrorEnabled(); &#125; @Override public boolean isErrorEnabled() &#123; return this.logger.isErrorEnabled(); &#125; @Override public boolean isWarnEnabled() &#123; return this.logger.isWarnEnabled(); &#125; @Override public boolean isInfoEnabled() &#123; return this.logger.isInfoEnabled(); &#125; @Override public boolean isDebugEnabled() &#123; return this.logger.isDebugEnabled(); &#125; @Override public boolean isTraceEnabled() &#123; return this.logger.isTraceEnabled(); &#125; @Override public void fatal(Object message) &#123; error(message); &#125; @Override public void fatal(Object message, Throwable exception) &#123; error(message, exception); &#125; @Override public void error(Object message) &#123; if (message instanceof String || this.logger.isErrorEnabled()) &#123; this.logger.error(String.valueOf(message)); &#125; &#125; @Override public void error(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isErrorEnabled()) &#123; this.logger.error(String.valueOf(message), exception); &#125; &#125; @Override public void warn(Object message) &#123; if (message instanceof String || this.logger.isWarnEnabled()) &#123; this.logger.warn(String.valueOf(message)); &#125; &#125; @Override public void warn(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isWarnEnabled()) &#123; this.logger.warn(String.valueOf(message), exception); &#125; &#125; @Override public void info(Object message) &#123; if (message instanceof String || this.logger.isInfoEnabled()) &#123; this.logger.info(String.valueOf(message)); &#125; &#125; @Override public void info(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isInfoEnabled()) &#123; this.logger.info(String.valueOf(message), exception); &#125; &#125; @Override public void debug(Object message) &#123; if (message instanceof String || this.logger.isDebugEnabled()) &#123; this.logger.debug(String.valueOf(message)); &#125; &#125; @Override public void debug(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isDebugEnabled()) &#123; this.logger.debug(String.valueOf(message), exception); &#125; &#125; @Override public void trace(Object message) &#123; if (message instanceof String || this.logger.isTraceEnabled()) &#123; this.logger.trace(String.valueOf(message)); &#125; &#125; @Override public void trace(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isTraceEnabled()) &#123; this.logger.trace(String.valueOf(message), exception); &#125; &#125; protected Object readResolve() &#123; return Slf4jAdapter.createLog(this.name); &#125; &#125; @SuppressWarnings(&quot;serial&quot;) private static class Slf4jLocationAwareLog extends Slf4jLog&lt;LocationAwareLogger&gt; implements Serializable &#123; private static final String FQCN = Slf4jLocationAwareLog.class.getName(); public Slf4jLocationAwareLog(LocationAwareLogger logger) &#123; super(logger); &#125; @Override public void fatal(Object message) &#123; error(message); &#125; @Override public void fatal(Object message, Throwable exception) &#123; error(message, exception); &#125; @Override public void error(Object message) &#123; if (message instanceof String || this.logger.isErrorEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.ERROR_INT, String.valueOf(message), null, null); &#125; &#125; @Override public void error(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isErrorEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.ERROR_INT, String.valueOf(message), null, exception); &#125; &#125; @Override public void warn(Object message) &#123; if (message instanceof String || this.logger.isWarnEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.WARN_INT, String.valueOf(message), null, null); &#125; &#125; @Override public void warn(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isWarnEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.WARN_INT, String.valueOf(message), null, exception); &#125; &#125; @Override public void info(Object message) &#123; if (message instanceof String || this.logger.isInfoEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.INFO_INT, String.valueOf(message), null, null); &#125; &#125; @Override public void info(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isInfoEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.INFO_INT, String.valueOf(message), null, exception); &#125; &#125; @Override public void debug(Object message) &#123; if (message instanceof String || this.logger.isDebugEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, String.valueOf(message), null, null); &#125; &#125; @Override public void debug(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isDebugEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, String.valueOf(message), null, exception); &#125; &#125; @Override public void trace(Object message) &#123; if (message instanceof String || this.logger.isTraceEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.TRACE_INT, String.valueOf(message), null, null); &#125; &#125; @Override public void trace(Object message, Throwable exception) &#123; if (message instanceof String || this.logger.isTraceEnabled()) &#123; this.logger.log(null, FQCN, LocationAwareLogger.TRACE_INT, String.valueOf(message), null, exception); &#125; &#125; @Override protected Object readResolve() &#123; return Slf4jAdapter.createLocationAwareLog(this.name); &#125; &#125; @SuppressWarnings(&quot;serial&quot;) private static class JavaUtilLog implements Log, Serializable &#123; private String name; private transient java.util.logging.Logger logger; public JavaUtilLog(String name) &#123; this.name = name; this.logger = java.util.logging.Logger.getLogger(name); &#125; @Override public boolean isFatalEnabled() &#123; return isErrorEnabled(); &#125; @Override public boolean isErrorEnabled() &#123; return this.logger.isLoggable(java.util.logging.Level.SEVERE); &#125; @Override public boolean isWarnEnabled() &#123; return this.logger.isLoggable(java.util.logging.Level.WARNING); &#125; @Override public boolean isInfoEnabled() &#123; return this.logger.isLoggable(java.util.logging.Level.INFO); &#125; @Override public boolean isDebugEnabled() &#123; return this.logger.isLoggable(java.util.logging.Level.FINE); &#125; @Override public boolean isTraceEnabled() &#123; return this.logger.isLoggable(java.util.logging.Level.FINEST); &#125; @Override public void fatal(Object message) &#123; error(message); &#125; @Override public void fatal(Object message, Throwable exception) &#123; error(message, exception); &#125; @Override public void error(Object message) &#123; log(java.util.logging.Level.SEVERE, message, null); &#125; @Override public void error(Object message, Throwable exception) &#123; log(java.util.logging.Level.SEVERE, message, exception); &#125; @Override public void warn(Object message) &#123; log(java.util.logging.Level.WARNING, message, null); &#125; @Override public void warn(Object message, Throwable exception) &#123; log(java.util.logging.Level.WARNING, message, exception); &#125; @Override public void info(Object message) &#123; log(java.util.logging.Level.INFO, message, null); &#125; @Override public void info(Object message, Throwable exception) &#123; log(java.util.logging.Level.INFO, message, exception); &#125; @Override public void debug(Object message) &#123; log(java.util.logging.Level.FINE, message, null); &#125; @Override public void debug(Object message, Throwable exception) &#123; log(java.util.logging.Level.FINE, message, exception); &#125; @Override public void trace(Object message) &#123; log(java.util.logging.Level.FINEST, message, null); &#125; @Override public void trace(Object message, Throwable exception) &#123; log(java.util.logging.Level.FINEST, message, exception); &#125; private void log(java.util.logging.Level level, Object message, Throwable exception) &#123; if (this.logger.isLoggable(level)) &#123; LogRecord rec; if (message instanceof LogRecord) &#123; rec = (LogRecord) message; &#125; else &#123; rec = new LocationResolvingLogRecord(level, String.valueOf(message)); rec.setLoggerName(this.name); rec.setResourceBundleName(this.logger.getResourceBundleName()); rec.setResourceBundle(this.logger.getResourceBundle()); rec.setThrown(exception); &#125; logger.log(rec); &#125; &#125; protected Object readResolve() &#123; return new JavaUtilLog(this.name); &#125; &#125; @SuppressWarnings(&quot;serial&quot;) private static class LocationResolvingLogRecord extends LogRecord &#123; private static final String FQCN = JavaUtilLog.class.getName(); private volatile boolean resolved; public LocationResolvingLogRecord(java.util.logging.Level level, String msg) &#123; super(level, msg); &#125; @Override public String getSourceClassName() &#123; if (!this.resolved) &#123; resolve(); &#125; return super.getSourceClassName(); &#125; @Override public void setSourceClassName(String sourceClassName) &#123; super.setSourceClassName(sourceClassName); this.resolved = true; &#125; @Override public String getSourceMethodName() &#123; if (!this.resolved) &#123; resolve(); &#125; return super.getSourceMethodName(); &#125; @Override public void setSourceMethodName(String sourceMethodName) &#123; super.setSourceMethodName(sourceMethodName); this.resolved = true; &#125; private void resolve() &#123; StackTraceElement[] stack = new Throwable().getStackTrace(); String sourceClassName = null; String sourceMethodName = null; boolean found = false; for (StackTraceElement element : stack) &#123; String className = element.getClassName(); if (FQCN.equals(className)) &#123; found = true; &#125; else if (found) &#123; sourceClassName = className; sourceMethodName = element.getMethodName(); break; &#125; &#125; setSourceClassName(sourceClassName); setSourceMethodName(sourceMethodName); &#125; @SuppressWarnings(&quot;deprecation&quot;) // setMillis is deprecated in JDK 9 protected Object writeReplace() &#123; LogRecord serialized = new LogRecord(getLevel(), getMessage()); serialized.setLoggerName(getLoggerName()); serialized.setResourceBundle(getResourceBundle()); serialized.setResourceBundleName(getResourceBundleName()); serialized.setSourceClassName(getSourceClassName()); serialized.setSourceMethodName(getSourceMethodName()); serialized.setSequenceNumber(getSequenceNumber()); serialized.setParameters(getParameters()); serialized.setThreadID(getThreadID()); serialized.setMillis(getMillis()); serialized.setThrown(getThrown()); return serialized; &#125; &#125;&#125; 在其他项目中看到类似实现 123456789101112131415161718192021222324252627282930313233343536373839// EnvironmentAware 获取类加载器ConfigurableEnvironment env = (ConfigurableEnvironment)environment;ClassLoader classLoader = env.getClass().getClassLoader();// 判断log4j2public static boolean isLog4j2Usable(ClassLoader classloader) &#123; try &#123; return (classloader.loadClass(&quot;org.apache.logging.slf4j.Log4jLoggerFactory&quot;) != null); &#125; catch (ClassNotFoundException e) &#123; return false; &#125;&#125;// 判断logbackpublic static boolean isLogbackUsable(ClassLoader classloader) &#123; try &#123; return classloader.loadClass(&quot;ch.qos.logback.classic.LoggerContext&quot;) != null; &#125; catch (ClassNotFoundException e) &#123; return false; &#125;&#125;// 根据不同的log包做不同的初始化private static LogEnhancer doInit(ClassLoader classLoader) &#123; LogEnhancer enhancer = null; if(LogEnvUtils.isLog4j2Usable(classLoader)) &#123; enhancer = new DefaultLog4j2Enhancer(classLoader); &#125; else if(LogEnvUtils.isLogbackUsable(classLoader)) &#123; enhancer = new DefaultLogbackEnhancer(classLoader); &#125; else &#123; throw new IllegalStateException(&quot;No applicable logging system found&quot;); &#125; return enhancer;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"log","slug":"log","permalink":"https://idea360.cn/tags/log/"},{"name":"日志","slug":"日志","permalink":"https://idea360.cn/tags/%E6%97%A5%E5%BF%97/"},{"name":"jcl","slug":"jcl","permalink":"https://idea360.cn/tags/jcl/"}]},{"title":"自定义Loaback-Appender","slug":"spring-boot-logback-appender-custom","date":"2021-03-28T13:06:00.000Z","updated":"2021-04-05T01:00:15.306Z","comments":true,"path":"2021/03/28/spring-boot-logback-appender-custom/","link":"","permalink":"https://idea360.cn/2021/03/28/spring-boot-logback-appender-custom/","excerpt":"","text":"前言 本篇主要讲如何自定义lagback日志输出 简单实现 创建一个空的 springboot 项目 自定义 Appender 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.logback.appender;import ch.qos.logback.classic.spi.ILoggingEvent;import ch.qos.logback.core.AppenderBase;import ch.qos.logback.core.Layout;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class MyLogbackAppender extends AppenderBase&lt;ILoggingEvent&gt; &#123; Layout&lt;ILoggingEvent&gt; layout; //自定义配置 String printString; @Override public void start()&#123; //这里可以做些初始化判断 比如layout不能为null , if(layout == null) &#123; addWarn(&quot;Layout was not defined&quot;); &#125; //或者写入数据库 或者redis时 初始化连接等等 super.start(); Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() &#123; @Override public void run() &#123; // 执行资源释放操作 &#125; &#125;)); &#125; @Override public void stop() &#123; //释放相关资源，如数据库连接，redis线程池等等 System.out.println(&quot;logback-stop方法被调用&quot;); if(!isStarted()) &#123; return; &#125; super.stop(); &#125; @Override public void append(ILoggingEvent event) &#123; if (event == null || !isStarted())&#123; return; &#125; // 此处自定义实现输出 // 获取输出值：event.getFormattedMessage() // System.out.print(event.getFormattedMessage()); // 格式化输出 System.out.print(printString + &quot;：&quot; + layout.doLayout(event)); &#125;&#125; 将自定义的appender配置到 logback-spring.xml后启动 springboot 项目, 即可看到自定义的日志输出。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot;&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径 --&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;/home&quot; /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;MyLogback&quot; class=&quot;com.example.logback.appender.MyLogbackAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;!-- 日志收集最低日志级别 --&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;!-- 自定义参数 --&gt; &lt;printString&gt;当我遇上你(logback)&lt;/printString&gt; &lt;/appender&gt; &lt;!-- 自定义包下设置为INFO,则可以看见输出的日志不包含debug输出了 --&gt; &lt;logger name=&quot;cn.lqdev.learning&quot; level=&quot;INFO&quot; /&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;MyLogback&quot; /&gt; &lt;/root&gt; &lt;!-- &lt;shutdownHook class=&quot;ch.qos.logback.core.hook.DelayingShutdownHook&quot;/&gt; --&gt;&lt;/configuration&gt; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://github.com/kekingcn/aliyunlog-spring-boot-starter https://github.com/danielwegener/logback-kafka-appender http://logging.apache.org/log4j/2.x/manual/appenders.html https://github.com/purgeteam/log-trace-spring-boot https://blog.lqdev.cn/2018/08/25/springboot/chapter-twenty-five/","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"logback","slug":"logback","permalink":"https://idea360.cn/tags/logback/"},{"name":"appender","slug":"appender","permalink":"https://idea360.cn/tags/appender/"}]},{"title":"模仿SpringSecurity自定义过滤器链","slug":"spring-security-filter-chain-custom","date":"2021-03-27T12:57:49.000Z","updated":"2021-03-28T06:58:08.040Z","comments":true,"path":"2021/03/27/spring-security-filter-chain-custom/","link":"","permalink":"https://idea360.cn/2021/03/27/spring-security-filter-chain-custom/","excerpt":"","text":"前言 想根据过滤器 filter 来实现 sdk 的一些功能, 但是配置多个过滤器又给调用方带来了配置的复杂性。所以这里模仿 SpringSecurity 中的 DelegatingFilterProxy 和 FilterChainProxy 来实现了一个自定义的 FilterChain。源码参照 spring-boot-starter-security 中的源码, 相关代码位于 spring-security-web 包中 实现 1. 首先我们随意定义2个过滤器 1234567891011121314151617181920212223242526package com.example.filterchain.filter;import javax.servlet.*;import java.io.IOException;/** * @author cuishiying * @date 2021-01-22 */public class AnonymousFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;AnonymousFilter init...&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;AnonymousFilter doFilter...&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println(&quot;AnonymousFilter destroy...&quot;); &#125;&#125; 1234567891011121314151617181920212223242526package com.example.filterchain.filter;import javax.servlet.*;import java.io.IOException;/** * @author cuishiying * @date 2021-01-22 */public class FormAuthenticationFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;FormAuthenticationFilter init...&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;FormAuthenticationFilter doFilter...&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println(&quot;FormAuthenticationFilter destroy...&quot;); &#125;&#125; 2. 用枚举将过自定义滤器管理起来 1234567891011121314151617181920212223import org.springframework.objenesis.instantiator.util.ClassUtils;import javax.servlet.Filter;/** * @author cuishiying * @date 2021-01-22 */public enum DefaultFilter &#123; anon(AnonymousFilter.class), authc(FormAuthenticationFilter.class); private final Class&lt;? extends Filter&gt; filterClass; private DefaultFilter(Class&lt;? extends Filter&gt; filterClass) &#123; this.filterClass = filterClass; &#125; public Filter newInstance() &#123; return (Filter) ClassUtils.newInstance(this.filterClass); &#125;&#125; 3. 代理过滤器 代理过滤器也是 servlet 标准过滤器, 需要能够注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.example.filterchain.filter;import lombok.extern.slf4j.Slf4j;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * @author cuishiying * @date 2021-01-22 */@Slf4jpublic class FilterChainProxy implements Filter &#123; private List&lt;Filter&gt; filters; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; this.filters = new ArrayList&lt;&gt;(); for (DefaultFilter defaultFilter : DefaultFilter.values()) &#123; this.filters.add(defaultFilter.newInstance()); &#125; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) request; log.info(&quot;FilterChainProxy.doFilter.uri:&#123;&#125;&quot;, httpServletRequest.getRequestURI()); doFilterInternal(request, response, chain); &#125; private void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; List&lt;Filter&gt; filters = getFilters(); // 如果当前过滤器链没有匹配的过滤器，则执行下一条过滤器链。 if (filters == null || filters.size() == 0) &#123; chain.doFilter(request, response); return; &#125; // 将所有的过滤器合并成一个虚拟过滤器链。 VirtualFilterChain vfc = new VirtualFilterChain(request, chain, filters); // 执行虚拟过滤器链。 vfc.doFilter(request, response); &#125; public List&lt;Filter&gt; getFilters() &#123; return filters; &#125; public void setFilters(List&lt;Filter&gt; filters) &#123; this.filters = filters; &#125; private class VirtualFilterChain implements FilterChain&#123; // 原始的过滤器链 private final FilterChain originalChain; // 自定义过滤器链 private final List&lt;Filter&gt; additionalFilters; // 自定义过滤器链长度 private final int size; // 当前执行到过滤器链的位置 private int currentPosition = 0; public VirtualFilterChain(ServletRequest request, FilterChain chain, List&lt;Filter&gt; additionalFilters) &#123; this.originalChain = chain; this.additionalFilters = additionalFilters; this.size = additionalFilters.size(); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; if (currentPosition == size) &#123; // 如果当前虚拟过滤器链上的所有过滤器都已经执行完毕，则执行原生过滤器链上的剩余逻辑。 originalChain.doFilter(request, response); &#125; else &#123; currentPosition++; // 获得当前虚拟过滤器链上的下一个过滤器。 Filter nextFilter = additionalFilters.get(currentPosition - 1); nextFilter.doFilter(request, response, this); &#125; &#125; &#125;&#125; 4. 注册过滤器 1234567891011121314151617181920212223242526package com.example.filterchain.config;import com.example.filterchain.filter.FilterChainProxy;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.Ordered;/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean filterChainProxy() &#123; FilterRegistrationBean&lt;FilterChainProxy&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(); filterRegistrationBean.setFilter(new FilterChainProxy()); filterRegistrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE + 100); filterRegistrationBean.setName(&quot;filterChainProxy&quot;); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); filterRegistrationBean.setEnabled(true); return filterRegistrationBean; &#125;&#125; 执行结果 1232021-03-28 14:55:40.405 INFO 11175 --- [nio-8080-exec-1] c.e.filterchain.filter.FilterChainProxy : FilterChainProxy.doFilter.uri:&#x2F;actuator&#x2F;prometheusAnonymousFilter doFilter...FormAuthenticationFilter doFilter... 我们可以看到首先执行了我们的标准代理过滤器 FilterChainProxy, 然后执行自定义的过滤器链 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://liulijun-dev.github.io/2020/02/20/Spring-Security-Source-Code2-filter-Chain2/","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"sdk","slug":"sdk","permalink":"https://idea360.cn/tags/sdk/"},{"name":"security","slug":"security","permalink":"https://idea360.cn/tags/security/"},{"name":"FilterChain","slug":"FilterChain","permalink":"https://idea360.cn/tags/FilterChain/"},{"name":"过滤器链","slug":"过滤器链","permalink":"https://idea360.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/"}]},{"title":"Shiro过滤器链","slug":"spring-shiro-filter-chain-manage","date":"2021-03-27T09:33:26.000Z","updated":"2021-03-28T06:58:27.923Z","comments":true,"path":"2021/03/27/spring-shiro-filter-chain-manage/","link":"","permalink":"https://idea360.cn/2021/03/27/spring-shiro-filter-chain-manage/","excerpt":"","text":"前言 本篇是学习 Shiro 中如何初始化过滤器链的 实践 首先，随便定义几个过滤器 123456789101112131415161718192021/** * @author cuishiying * @date 2021-01-22 */public class AnonymousFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;AnonymousFilter init...&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;AnonymousFilter doFilter...&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println(&quot;AnonymousFilter destroy...&quot;); &#125;&#125; 123456789101112131415161718192021/** * @author cuishiying * @date 2021-01-22 */public class FormAuthenticationFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;AnonymousFilter init...&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;AnonymousFilter doFilter...&quot;); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println(&quot;AnonymousFilter destroy...&quot;); &#125;&#125; 用枚举将过滤器管理起来 12345678910111213141516171819202122232425package com.example.demo.shiro;import org.springframework.objenesis.instantiator.util.ClassUtils;import javax.servlet.Filter;/** * @author cuishiying * @date 2021-01-22 */public enum DefaultFilter &#123; anon(AnonymousFilter.class), authc(FormAuthenticationFilter.class); private final Class&lt;? extends Filter&gt; filterClass; private DefaultFilter(Class&lt;? extends Filter&gt; filterClass) &#123; this.filterClass = filterClass; &#125; public Filter newInstance() &#123; return (Filter) ClassUtils.newInstance(this.filterClass); &#125;&#125; 创建过滤器管理器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.example.demo.shiro;import javax.servlet.Filter;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import java.util.LinkedHashMap;import java.util.Map;/** * @author cuishiying * @date 2021-01-22 */public class DefaultFilterChainManager &#123; private FilterConfig filterConfig; private Map&lt;String, Filter&gt; filters; public DefaultFilterChainManager() &#123; this.filters = new LinkedHashMap&lt;String, Filter&gt;(); addDefaultFilters(false); &#125; public DefaultFilterChainManager(FilterConfig filterConfig) &#123; this.filters = new LinkedHashMap&lt;String, Filter&gt;(); setFilterConfig(filterConfig); addDefaultFilters(true); &#125; private void addDefaultFilters(boolean init) &#123; for (DefaultFilter defaultFilter : DefaultFilter.values()) &#123; addFilter(defaultFilter.name(), defaultFilter.newInstance(), init, false); &#125; &#125; public Map&lt;String, Filter&gt; getFilters() &#123; return filters; &#125; protected void addFilter(String name, Filter filter, boolean init, boolean overwrite) &#123; Filter existing = getFilter(name); if (existing == null) &#123; if (init) &#123; initFilter(filter); &#125; this.filters.put(name, filter); &#125; &#125; public Filter getFilter(String name) &#123; return this.filters.get(name); &#125; protected void initFilter(Filter filter) &#123; FilterConfig filterConfig = getFilterConfig(); if (filterConfig == null) &#123; throw new IllegalStateException(&quot;FilterConfig attribute has not been set. This must occur before filter &quot; + &quot;initialization can occur.&quot;); &#125; try &#123; filter.init(filterConfig); &#125; catch (ServletException e) &#123; throw new RuntimeException(e); &#125; &#125; public FilterConfig getFilterConfig() &#123; return filterConfig; &#125; public void setFilterConfig(FilterConfig filterConfig) &#123; this.filterConfig = filterConfig; &#125;&#125; 测试 1234567public class FilterTest &#123; public static void main(String[] args) &#123; DefaultFilterChainManager defaultFilterChainManager = new DefaultFilterChainManager(); System.out.println(defaultFilterChainManager.getFilters()); // &#123;anon=com.example.demo.shiro.AnonymousFilter@90f6bfd, authc=com.example.demo.shiro.FormAuthenticationFilter@47f6473&#125; &#125;&#125; spring中集成自定义的 FilterChain 一般我们想在spring中注入过滤器，会通过xml或者代码bean注入。这里我们用xml演示, 代码节选自 shiro 123456789&lt;filter&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 123456789101112131415161718192021public class ShiroFilter extends AbstractShiroFilter &#123; /** * Configures this instance based on the existing &#123;@link org.apache.shiro.web.env.WebEnvironment&#125; instance * available to the currently accessible &#123;@link #getServletContext() servletContext&#125;. * * @see org.apache.shiro.web.env.EnvironmentLoaderListener * @since 1.2 */ @Override public void init() throws Exception &#123; WebEnvironment env = WebUtils.getRequiredWebEnvironment(getServletContext()); setSecurityManager(env.getWebSecurityManager()); FilterChainResolver resolver = env.getFilterChainResolver(); if (resolver != null) &#123; setFilterChainResolver(resolver); &#125; &#125;&#125; 12345678910111213141516171819202122public class FilterChainResolver &#123; private DefaultFilterChainManager filterChainManager; public FilterChainResolver() &#123; this.filterChainManager = new DefaultFilterChainManager(); &#125; public FilterChainResolver(FilterConfig filterConfig) &#123; this.filterChainManager = new DefaultFilterChainManager(filterConfig); &#125; public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) &#123; DefaultFilterChainManager filterChainManager = getFilterChainManager(); // 遍历filterChainManager中的过滤器配置, 匹配requestURI与配置的pathPattern, 找出匹配的FilterChain即返回 return null; &#125; public DefaultFilterChainManager getFilterChainManager() &#123; return filterChainManager; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"filter","slug":"filter","permalink":"https://idea360.cn/tags/filter/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"FilterChain","slug":"FilterChain","permalink":"https://idea360.cn/tags/FilterChain/"},{"name":"过滤器链","slug":"过滤器链","permalink":"https://idea360.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/"},{"name":"shiro","slug":"shiro","permalink":"https://idea360.cn/tags/shiro/"}]},{"title":"Java类操作","slug":"java-class","date":"2021-03-27T06:57:57.000Z","updated":"2021-03-27T06:59:17.992Z","comments":true,"path":"2021/03/27/java-class/","link":"","permalink":"https://idea360.cn/2021/03/27/java-class/","excerpt":"","text":"示例 12345public interface UserService &#123;&#125;public class UserServiceImpl implements UserService &#123;&#125; 123456789101112131415161718@SpringBootTestclass DemoApplicationTests &#123; @Test void contextLoads() &#123; UserServiceImpl userServiceImpl = new UserServiceImpl(); // 父类 isAssignableFrom 子类 System.out.println(UserService.class.isAssignableFrom(UserServiceImpl.class)); // true // userServiceImpl是否是UserService实例 System.out.println(userServiceImpl instanceof UserService); // true // UserService能否强转为 System.out.println(UserService.class.isInstance(userServiceImpl)); // true &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"}]},{"title":"基于过滤器实现日志链路跟踪","slug":"log-filter","date":"2021-03-22T15:24:55.000Z","updated":"2021-03-22T15:36:25.409Z","comments":true,"path":"2021/03/22/log-filter/","link":"","permalink":"https://idea360.cn/2021/03/22/log-filter/","excerpt":"","text":"实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.easyliao.framework.log;import com.easyliao.framework.log.utils.RequestUtils;import com.easyliao.framework.log.utils.TraceUtil;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.slf4j.MDC;import org.springframework.web.filter.OncePerRequestFilter;import org.springframework.web.util.ContentCachingRequestWrapper;import org.springframework.web.util.ContentCachingResponseWrapper;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author cuishiying * @date 2021-01-22 */@Slf4jpublic class TraceFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(httpServletRequest); ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(httpServletResponse); //请求头传入存在以请求头传入的为准 String appTraceId = StringUtils.defaultString(httpServletRequest.getHeader(TraceConstant.HTTP_HEADER_TRACE_ID), TraceUtil.generateTraceId()); if (StringUtils.isNotEmpty(appTraceId)) &#123; MDC.put(TraceConstant.LOG_TRACE_ID, appTraceId); &#125; long startTime = System.currentTimeMillis(); try &#123; filterChain.doFilter(requestWrapper, responseWrapper); &#125; finally &#123; if (log.isInfoEnabled()) &#123; long latency = System.currentTimeMillis() - startTime; log.info(&quot;[REQUEST] &#123;&#125;:&#123;&#125; - &#123;&#125;, latency = &#123;&#125;, traceId = &#123;&#125;, header = &#123;&#125;, url-params = &#123;&#125;, form-params = &#123;&#125;, request-body = &#123;&#125;, response = &#123;&#125;&quot;, httpServletRequest.getMethod(), responseWrapper.getStatus(), httpServletRequest.getRequestURL().toString(), latency, MDC.get(TraceConstant.LOG_TRACE_ID), RequestUtils.getHeaders(httpServletRequest), RequestUtils.getUrlParams(httpServletRequest), RequestUtils.getFormParams(httpServletRequest), RequestUtils.getRequestBody(requestWrapper), RequestUtils.getResponseBody(responseWrapper) ); &#125; MDC.clear(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173package com.easyliao.framework.log.utils;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.web.util.ContentCachingRequestWrapper;import org.springframework.web.util.ContentCachingResponseWrapper;import org.springframework.web.util.WebUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.util.*;import java.util.stream.Collectors;/** * 接口参数提取 * @author CUI SHIYING */public class RequestUtils &#123; /** * 将URL请求参数转换成Map * @author show * @param request */ public static Map&lt;String, String&gt; getUrlParams(HttpServletRequest request) &#123; String param = &quot;&quot;; if (Objects.isNull(request.getQueryString())) &#123; return Collections.emptyMap(); &#125; param = URLDecoder.decode(request.getQueryString(), StandardCharsets.UTF_8); Map&lt;String, String&gt; result = new HashMap&lt;&gt;(16); String[] params = param.split(&quot;&amp;&quot;); for (String s : params) &#123; int index = s.indexOf(&quot;=&quot;); result.put(s.substring(0, index), s.substring(index + 1)); &#125; return result; &#125; public static Map&lt;String, String&gt; getFormParams(HttpServletRequest request) &#123; Map&lt;String, String&gt; paramMap = new HashMap&lt;&gt;(); Map&lt;String, String[]&gt; requestMap = request.getParameterMap(); for (Map.Entry&lt;String, String[]&gt; entry : requestMap.entrySet()) &#123; if (entry.getValue().length == 1) &#123; paramMap.put(entry.getKey(), entry.getValue()[0]); &#125; else &#123; String[] values = entry.getValue(); String value = &quot;&quot;; for (String s : values) &#123; value = s + &quot;,&quot;; &#125; value = value.substring(0, value.length() - 1); paramMap.put(entry.getKey(), value); &#125; &#125; return paramMap; &#125; /** * 获取body中参数 * @param request * @return * @throws IOException */ public static String getBodyParams (HttpServletRequest request) throws IOException &#123; return request.getReader().lines().collect(Collectors.joining(System.lineSeparator())).replaceAll(&quot;\\\\s*|\\\\t|\\\\r|\\\\n&quot;, &quot;&quot;); &#125;// /**// * 获取url参数和body参数// * @param request// * @return// * @throws IOException// */// public static Map&lt;String, String&gt; getAllParams(HttpServletRequest request) throws IOException &#123;//// SortedMap&lt;String, String&gt; sortedParams = new TreeMap&lt;&gt;();//// // 获取url参数// Map&lt;String, String&gt; urlParams = getUrlParams(request);// for (Map.Entry entry : urlParams.entrySet()) &#123;// sortedParams.put((String) entry.getKey(), (String) entry.getValue());// &#125;//// // 获取body参数// if (!HttpMethod.GET.name().equals(request.getMethod())) &#123;// Map&lt;String, String&gt; bodyParams = getBodyParams(request);// if (null != bodyParams) &#123;// for (Map.Entry entry : bodyParams.entrySet()) &#123;// sortedParams.put((String) entry.getKey(), (String) entry.getValue());// &#125;// &#125;// &#125;//// // 获取表单参数// Map&lt;String, String&gt; formParams = getFormParams(request);// for (Map.Entry entry : formParams.entrySet()) &#123;// sortedParams.put((String) entry.getKey(), (String) entry.getValue());// &#125;//// return sortedParams;// &#125; public static String obtainParameter(HttpServletRequest request, String parameter) &#123; String result = request.getParameter(parameter); return result == null ? &quot;&quot; : result; &#125; public static boolean isJSONValid(String jsonInString) &#123; try &#123; final ObjectMapper mapper = new ObjectMapper(); mapper.readTree(jsonInString); return true; &#125; catch (IOException e) &#123; return false; &#125; &#125; public static Map&lt;String, String&gt; json2Map(String jsonInString) &#123; ObjectMapper mapper = new ObjectMapper(); Map&lt;String, String&gt; bodyMap = new HashMap&lt;&gt;(); try &#123; bodyMap = mapper.readValue(jsonInString, Map.class); &#125; catch (Exception e) &#123; bodyMap.put(&quot;string_body&quot;, jsonInString); &#125; return bodyMap; &#125; public static Map&lt;String, String&gt; getHeaders(HttpServletRequest request) &#123; Map&lt;String, String&gt; headerMap = new HashMap&lt;&gt;(); Enumeration&lt;String&gt; headerArray = request.getHeaderNames(); while (headerArray.hasMoreElements()) &#123; String headerName = (String) headerArray.nextElement(); headerMap.put(headerName, request.getHeader(headerName)); &#125; return headerMap; &#125; public static String getRequestBody(ContentCachingRequestWrapper request) &#123; ContentCachingRequestWrapper wrapper = WebUtils.getNativeRequest(request, ContentCachingRequestWrapper.class); if (wrapper != null) &#123; byte[] buf = wrapper.getContentAsByteArray(); if (buf.length &gt; 0) &#123; try &#123; return new String(buf, 0, buf.length, wrapper.getCharacterEncoding()).replaceAll(&quot;\\\\s*|\\\\t|\\\\r|\\\\n&quot;, &quot;&quot;); &#125; catch (UnsupportedEncodingException e) &#123; return &quot; - &quot;; &#125; &#125; &#125; return &quot; - &quot;; &#125; public static String getResponseBody(final HttpServletResponse response) throws IOException &#123; String payload = null; ContentCachingResponseWrapper wrapper = WebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class); if (wrapper != null) &#123; byte[] buf = wrapper.getContentAsByteArray(); if (buf.length &gt; 0) &#123; payload = new String(buf, 0, buf.length, wrapper.getCharacterEncoding()); wrapper.copyBodyToResponse(); &#125; &#125; return null == payload ? &quot; - &quot; : payload.replaceAll(&quot;\\\\s*|\\\\t|\\\\r|\\\\n&quot;, &quot;&quot;); &#125;&#125; 参考 https://velog.io/@sixhustle/log","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"log","slug":"log","permalink":"https://idea360.cn/tags/log/"},{"name":"日志","slug":"日志","permalink":"https://idea360.cn/tags/%E6%97%A5%E5%BF%97/"},{"name":"链路跟踪","slug":"链路跟踪","permalink":"https://idea360.cn/tags/%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/"}]},{"title":"自定义DelegatingFilterProxy","slug":"DelegatingFilterProxy","date":"2021-03-21T15:33:40.000Z","updated":"2021-03-21T15:36:02.980Z","comments":true,"path":"2021/03/21/DelegatingFilterProxy/","link":"","permalink":"https://idea360.cn/2021/03/21/DelegatingFilterProxy/","excerpt":"","text":"123456789101112131415161718192021222324/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class WebConfig &#123; @Bean public Filter tokenAuthFilter() &#123; return new TokenAuthFilter(); &#125; /** * 注册filter，统一处理api开头的请求 * @return FilterRegistrationBean */ @Bean public FilterRegistrationBean tokenAuthFilterRegistration() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); // DelegatingFilterProxy把servlet 容器中的filter同spring容器中的bean关联起来, spring会去查找tokenAuthFilter的filter registration.setFilter(new DelegatingFilterProxy(&quot;tokenAuthFilter&quot;)); registration.addUrlPatterns(&quot;/*&quot;); registration.setName(&quot;tokenAuthFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 12345678910111213141516/** * @author cuishiying * @date 2021-01-22 */public class TokenAuthFilter implements Filter &#123; public TokenAuthFilter() &#123; System.out.println(&quot;myFilter&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filter...&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; springboot程序启动即可自动调用TokenAuthFilter","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"filter","slug":"filter","permalink":"https://idea360.cn/tags/filter/"},{"name":"DelegatingFilterProxy","slug":"DelegatingFilterProxy","permalink":"https://idea360.cn/tags/DelegatingFilterProxy/"}]},{"title":"Spring数据脱敏续","slug":"spring-data-masking2","date":"2021-03-15T15:40:32.000Z","updated":"2021-03-15T15:48:57.602Z","comments":true,"path":"2021/03/15/spring-data-masking2/","link":"","permalink":"https://idea360.cn/2021/03/15/spring-data-masking2/","excerpt":"","text":"前言 如你所见, 该篇是jackson序列化操作的再次应用。将数据库中的 FreeMarker 表达式处理为变量返回给前端。同时将前端提交的变量处理为 FreeMarker 表达式存入数据库。 案例 123public enum FieldType &#123; FREE_MARKER&#125; 123456789@Retention(RetentionPolicy.RUNTIME)@JacksonAnnotationsInside@JsonSerialize(using = FieldSerialize.class)@JsonDeserialize(using = FieldDeserialize.class)public @interface FieldHandler &#123; public FieldType value() default FieldType.FREE_MARKER;&#125; 自定义序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Componentpublic class FieldSerialize extends JsonSerializer&lt;String&gt; implements ContextualSerializer &#123; private static FreeMarkerDictService freeMarkerDictService; private FieldType fieldType; public FieldSerialize() &#123; this.fieldType = FieldType.FREE_MARKER;// SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this); &#125; public FieldSerialize(FieldType fieldType) &#123; this.fieldType = fieldType; &#125; @Autowired public FieldSerialize(FreeMarkerDictService freeMarkerDictService) &#123; this.freeMarkerDictService = freeMarkerDictService; &#125; @Override public void serialize(String s, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123; List&lt;AiFreeMarkerDict&gt; freeMarkerDicts = freeMarkerDictService.list(); switch (fieldType) &#123; case FREE_MARKER: jsonGenerator.writeString(FieldUtils.freemarkerExpression2Variable(s, freeMarkerDicts)); break; &#125; &#125; @Override public JsonSerializer&lt;?&gt; createContextual(SerializerProvider serializerProvider, BeanProperty beanProperty) throws JsonMappingException &#123; if (beanProperty != null) &#123; // 为空直接跳过 if (Objects.equals(beanProperty.getType().getRawClass(), String.class)) &#123; // 非 String 类直接跳过 FieldHandler fieldHandler = beanProperty.getAnnotation(FieldHandler.class); if (fieldHandler == null) &#123; fieldHandler = beanProperty.getContextAnnotation(FieldHandler.class); &#125; if (fieldHandler != null) &#123; return new FieldSerialize(fieldHandler.value()); &#125; &#125; return serializerProvider.findValueSerializer(beanProperty.getType(), beanProperty); &#125; return serializerProvider.findNullValueSerializer(beanProperty); &#125;&#125; 反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Componentpublic class FieldDeserialize extends JsonDeserializer&lt;String&gt; implements ContextualDeserializer &#123; private static FreeMarkerDictService freeMarkerDictService; private FieldType fieldType; public FieldDeserialize() &#123; this.fieldType = FieldType.FREE_MARKER;// SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this); &#125; public FieldDeserialize(FieldType fieldType) &#123; this.fieldType = fieldType; &#125; @Autowired public FieldDeserialize(FreeMarkerDictService freeMarkerDictService) &#123; this.freeMarkerDictService = freeMarkerDictService; &#125; @Override public String deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123; List&lt;AiFreeMarkerDict&gt; freeMarkerDicts = freeMarkerDictService.list(); String freeMarkerVariable = jsonParser.getText(); return FieldUtils.freemarkerVariable2Expression(freeMarkerVariable, freeMarkerDicts); &#125; @Override public JsonDeserializer&lt;?&gt; createContextual(DeserializationContext deserializationContext, BeanProperty beanProperty) throws JsonMappingException &#123; if (beanProperty != null) &#123; // 为空直接跳过 if (Objects.equals(beanProperty.getType().getRawClass(), String.class)) &#123; // 非 String 类直接跳过 FieldHandler fieldHandler = beanProperty.getAnnotation(FieldHandler.class); if (fieldHandler == null) &#123; fieldHandler = beanProperty.getContextAnnotation(FieldHandler.class); &#125; if (fieldHandler != null) &#123; return new FieldDeserialize(fieldHandler.value()); &#125; &#125; return deserializationContext.findRootValueDeserializer(beanProperty.getType()); &#125; return deserializationContext.findRootValueDeserializer(beanProperty.getType()); &#125;&#125; 工具 123456789101112131415161718192021222324252627282930313233public class FieldUtils &#123;// public static String freemarkerExpression2Variable(final String expression, final Map&lt;String, AiFreeMarkerDict&gt; freeMarkerDataMap) &#123;// return freeMarkerDataMap.get(expression).getLabel();// &#125;//// public static String freemarkerVariable2Expression(final String variable, final Map&lt;String, AiFreeMarkerDict&gt; freeMarkerDataMap) &#123;// return freeMarkerDataMap.get(variable).getExpression();// &#125; public static String freemarkerExpression2Variable(String expression, final List&lt;AiFreeMarkerDict&gt; freeMarkerDictList) &#123; if (CollectionUtils.isNotEmpty(freeMarkerDictList)) &#123; for (AiFreeMarkerDict freeMarkerDict : freeMarkerDictList) &#123; if (expression.contains(freeMarkerDict.getExpression())) &#123; expression = expression.replace(freeMarkerDict.getExpression(), freeMarkerDict.getVariable()); &#125; &#125; &#125; return expression; &#125; public static String freemarkerVariable2Expression(String variable, final List&lt;AiFreeMarkerDict&gt; freeMarkerDataList) &#123; if (CollectionUtils.isNotEmpty(freeMarkerDataList)) &#123; for (AiFreeMarkerDict freeMarkerDict : freeMarkerDataList) &#123; if (variable.contains(freeMarkerDict.getVariable())) &#123; variable = variable.replace(freeMarkerDict.getVariable(), freeMarkerDict.getExpression()); &#125; &#125; return variable; &#125; throw new FreeMarkerException(&quot;非法变量&quot;); &#125;&#125; 使用只要在需要处理的字段上添加注解即可 123@FieldHandler@ApiModelProperty(value = &quot;提问内容&quot;)private String content; 最终效果: 数据库如下数据 1&lt;#if memory.Country??&gt;$&#123;memory.Country&#125;&lt;&#x2F;#if&gt; api接口返回 1$&#123;memory.Country&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"序列化","slug":"序列化","permalink":"https://idea360.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"反序列化","slug":"反序列化","permalink":"https://idea360.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"MySQL动态表单设计","slug":"dynamic-forms","date":"2021-03-15T15:21:16.000Z","updated":"2021-05-18T12:03:25.328Z","comments":true,"path":"2021/03/15/dynamic-forms/","link":"","permalink":"https://idea360.cn/2021/03/15/dynamic-forms/","excerpt":"","text":"表结构示意 1234567891011121314151617181920212223242526272829303132333435363738394041DROP TABLE IF EXISTS `form`;CREATE TABLE `form` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `owner_id` bigint DEFAULT 0 COMMENT &#x27;所属者, 关联到账号&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#x27;表单信息&#x27;;DROP TABLE IF EXISTS `form_field`;CREATE TABLE `form_field` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `form_id` BIGINT DEFAULT 0 COMMENT &#x27;表单id&#x27;, `field_id` BIGINT DEFAULT 0 COMMENT &#x27;字段id&#x27;, `field_label` VARCHAR(50) DEFAULT NULL COMMENT &#x27;字段名字(用来显示,如姓名,性别)&#x27;, `place_holder` VARCHAR(50) DEFAULT NULL COMMENT &#x27;预期值提示信息&#x27;, `required` int DEFAULT 0 COMMENT &#x27;是否必填 0 否 1 是&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#x27;表单配置&#x27;;DROP TABLE IF EXISTS `option`;CREATE TABLE `option` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `form_field_id` BIGINT DEFAULT 0 COMMENT &#x27;表单字段id&#x27;, `value` BIGINT DEFAULT 0 COMMENT &#x27;下拉项配置&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#x27;下拉项&#x27;;DROP TABLE IF EXISTS `field`;CREATE TABLE `field` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `label` VARCHAR(50) DEFAULT NULL COMMENT &#x27;字段名(如单行输入框、单选框)&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#x27;基础字段&#x27;;DROP TABLE IF EXISTS `form_data`;CREATE TABLE `form_data` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `form_field_id` BIGINT DEFAULT 0 COMMENT &#x27;表单字段id&#x27;, `value` VARCHAR(255) DEFAULT NULL COMMENT &#x27;表单字段数据&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#x27;表单数据&#x27;; 图解 该图示来源于idea中Database, 右击 Diagrams 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"},{"name":"动态","slug":"动态","permalink":"https://idea360.cn/tags/%E5%8A%A8%E6%80%81/"},{"name":"表单","slug":"表单","permalink":"https://idea360.cn/tags/%E8%A1%A8%E5%8D%95/"}]},{"title":"【Spring源码解析】生命周期-BeanPostProcessor在spring底层的应用","slug":"spring-source-code-lifecycle-BeanPostProcessor3","date":"2021-03-14T06:10:50.000Z","updated":"2021-03-14T06:19:06.762Z","comments":true,"path":"2021/03/14/spring-source-code-lifecycle-BeanPostProcessor3/","link":"","permalink":"https://idea360.cn/2021/03/14/spring-source-code-lifecycle-BeanPostProcessor3/","excerpt":"","text":"前言 BeanPostProcessor 是spring定义的后置处理器, 分别会在bean初始化的前后调用。以下是调用时机 123456789101112131415161718192021222324252627282930protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; invokeAwareMethods(beanName, bean); return null; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; 源码分析 我们以 ApplicationContextAwareProcessor 分析, ApplicationContextAwareProcessor 实现了 BeanPostProcessor 接口。 当实现了 BeanPostProcessor 接口的bean被注册时, 会走以下方法 12345678910111213141516171819202122232425262728@Override @Nullable public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware || bean instanceof ApplicationStartupAware)) &#123; return bean; &#125; AccessControlContext acc = null; if (System.getSecurityManager() != null) &#123; acc = this.applicationContext.getBeanFactory().getAccessControlContext(); &#125; if (acc != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; invokeAwareInterfaces(bean); return null; &#125;, acc); &#125; else &#123; invokeAwareInterfaces(bean); &#125; return bean; &#125; 由源码可以, 当bean实现了 Aware 接口时, 会走 invokeAwareInterfaces(bean); 方法。 1234567891011121314151617181920212223private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationStartupAware) &#123; ((ApplicationStartupAware) bean).setApplicationStartup(this.applicationContext.getApplicationStartup()); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125;&#125; 在spring中, Aware 接口是回调接口, 也就是说当我们需要容器中的某些bean时, 可以通过实现 Aware 接口来得到spring内置的一些bean。 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"生命周期","slug":"生命周期","permalink":"https://idea360.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【Spring源码解析】生命周期-BeanPostProcessor原理","slug":"spring-source-code-lifecycle-BeanPostProcessor2","date":"2021-03-14T05:54:57.000Z","updated":"2021-03-14T06:13:03.025Z","comments":true,"path":"2021/03/14/spring-source-code-lifecycle-BeanPostProcessor2/","link":"","permalink":"https://idea360.cn/2021/03/14/spring-source-code-lifecycle-BeanPostProcessor2/","excerpt":"","text":"java debug跟踪 123456789101112131415161718192021222324252627282930protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; invokeAwareMethods(beanName, bean); return null; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125;","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"生命周期","slug":"生命周期","permalink":"https://idea360.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【Spring源码解析】生命周期-BeanPostProcessor-后置处理器","slug":"spring-source-code-lifecycle-BeanPostProcessor1","date":"2021-03-10T14:06:56.000Z","updated":"2021-03-13T05:29:41.775Z","comments":true,"path":"2021/03/10/spring-source-code-lifecycle-BeanPostProcessor1/","link":"","permalink":"https://idea360.cn/2021/03/10/spring-source-code-lifecycle-BeanPostProcessor1/","excerpt":"","text":"前言 123456789101112131415@Componentpublic class CustomBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;postProcessBeforeInitialization...&quot; + beanName); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;postProcessAfterInitialization...&quot; + beanName); return bean; &#125;&#125; 12345678910111213141516171819202122232425262728/** * postProcessBeforeInitialization...beanConfigOfLifeCycle * postProcessAfterInitialization...beanConfigOfLifeCycle * cat constructor... * postProcessBeforeInitialization...cat * cat init... * postProcessAfterInitialization...cat * dog constructor... * postProcessBeforeInitialization...dog * dog init... * postProcessAfterInitialization...dog * car constructor... * postProcessBeforeInitialization...car * car init... * postProcessAfterInitialization...car * 容器创建完成 * car destory... * dog destroy... * cat destroy... */@Testpublic void test07() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfigOfLifeCycle.class); System.out.println(&quot;容器创建完成&quot;); // 关闭容器 applicationContext.close();&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"生命周期","slug":"生命周期","permalink":"https://idea360.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【Spring源码解析】生命周期-@PostConstruct&@PreDestroy","slug":"spring-source-code-lifecycle-PostConstruct-PreDestroy","date":"2021-03-08T16:10:17.000Z","updated":"2021-03-27T08:40:26.054Z","comments":true,"path":"2021/03/09/spring-source-code-lifecycle-PostConstruct-PreDestroy/","link":"","permalink":"https://idea360.cn/2021/03/09/spring-source-code-lifecycle-PostConstruct-PreDestroy/","excerpt":"","text":"前言 请注意，@PostConstruct和@PreDestroy注释都是Java EE的一部分。而且由于Java EE在Java 9中已被弃用，而在Java 11中已被删除，因此我们必须添加一个附加依赖项才能使用这些注释 实现 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617@Componentpublic class Dog &#123; public Dog() &#123; System.out.println(&quot;dog constructor...&quot;); &#125; @PostConstruct public void init() &#123; System.out.println(&quot;dog init...&quot;); &#125; @PreDestroy public void destroy() &#123; System.out.println(&quot;dog destroy...&quot;); &#125;&#125; 123456789@ComponentScan(&quot;cn.idea360.bean&quot;)@Configurationpublic class BeanConfigOfLifeCycle &#123; @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;) public Car car() &#123; return new Car(); &#125;&#125; 1234567891011121314151617181920/** * cat constructor... * cat init... * dog constructor... * dog init... * car constructor... * car init... * 容器创建完成 * car destory... * dog destroy... * cat destroy... */@Testpublic void test07() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfigOfLifeCycle.class); System.out.println(&quot;容器创建完成&quot;); // 关闭容器 applicationContext.close();&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"生命周期","slug":"生命周期","permalink":"https://idea360.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【Spring源码解析】生命周期-InitializingBean和DisposableBean","slug":"spring-source-code-lifecycle-InitializingBean-DisposableBean","date":"2021-03-08T16:10:14.000Z","updated":"2021-03-08T16:15:16.405Z","comments":true,"path":"2021/03/09/spring-source-code-lifecycle-InitializingBean-DisposableBean/","link":"","permalink":"https://idea360.cn/2021/03/09/spring-source-code-lifecycle-InitializingBean-DisposableBean/","excerpt":"","text":"实现 定义bean 12345678910111213141516@Componentpublic class Cat implements InitializingBean, DisposableBean &#123; public Cat() &#123; System.out.println(&quot;cat constructor...&quot;); &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;cat destroy...&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;cat init...&quot;); &#125;&#125; bean注入 123456789@ComponentScan(&quot;cn.idea360.bean&quot;)@Configurationpublic class BeanConfigOfLifeCycle &#123; @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;) public Car car() &#123; return new Car(); &#125;&#125; 测试 1234567891011121314151617/** * cat constructor... * cat init... * car constructor... * car init... * 容器创建完成 * car destory... * cat destroy... */@Testpublic void test07() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfigOfLifeCycle.class); System.out.println(&quot;容器创建完成&quot;); // 关闭容器 applicationContext.close();&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"生命周期","slug":"生命周期","permalink":"https://idea360.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【Spring源码解析】生命周期-@Bean指定初始化和销毁方法","slug":"spring-source-code-lifecycle-bean","date":"2021-03-08T16:01:13.000Z","updated":"2021-03-08T16:06:03.563Z","comments":true,"path":"2021/03/09/spring-source-code-lifecycle-bean/","link":"","permalink":"https://idea360.cn/2021/03/09/spring-source-code-lifecycle-bean/","excerpt":"","text":"实现 定义bean 1234567891011121314public class Car &#123; public Car() &#123; System.out.println(&quot;car constructor...&quot;); &#125; public void init() &#123; System.out.println(&quot;car init...&quot;); &#125; public void destroy() &#123; System.out.println(&quot;car destory...&quot;); &#125;&#125; 注册bean 12345678@Configurationpublic class BeanConfigOfLifeCycle &#123; @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;) public Car car() &#123; return new Car(); &#125;&#125; 测试 1234567891011121314/** * car constructor... * car init... * 容器创建完成 * car destory... */@Testpublic void test06() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfigOfLifeCycle.class); System.out.println(&quot;容器创建完成&quot;); // 关闭容器 applicationContext.close();&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"生命周期","slug":"生命周期","permalink":"https://idea360.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"【Spring源码解析】组件注册-FactoryBean注册组件","slug":"spring-source-code-FactoryBean","date":"2021-03-08T15:41:09.000Z","updated":"2021-03-08T16:02:54.713Z","comments":true,"path":"2021/03/08/spring-source-code-FactoryBean/","link":"","permalink":"https://idea360.cn/2021/03/08/spring-source-code-FactoryBean/","excerpt":"","text":"实现 配置 12345678910111213141516public class PersonFactoryBean implements FactoryBean &#123; @Override public Object getObject() throws Exception &#123; return new Person(&quot;刘德华&quot;, 55); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Person.class; &#125; @Override public boolean isSingleton() &#123; return true; &#125;&#125; 注册 12345678@Configurationpublic class BeanConfig2 &#123; @Bean public PersonFactoryBean personFactoryBean() &#123; return new PersonFactoryBean(); &#125;&#125; 测试 1234567891011121314/** * bean的类型:class cn.idea360.bean.Person * 工厂bean:class cn.idea360.bean.PersonFactoryBean */@Testpublic void test05() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfig2.class); Object personFactoryBean = applicationContext.getBean(&quot;personFactoryBean&quot;); System.out.println(&quot;bean的类型:&quot; + personFactoryBean.getClass()); Object bean = applicationContext.getBean(&quot;&amp;personFactoryBean&quot;); System.out.println(&quot;工厂bean:&quot; + bean.getClass());&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"【Spring源码解析】组件注册-@Condition条件注册bean","slug":"spring-source-code-condition","date":"2021-03-08T14:58:43.000Z","updated":"2021-03-08T16:02:47.819Z","comments":true,"path":"2021/03/08/spring-source-code-condition/","link":"","permalink":"https://idea360.cn/2021/03/08/spring-source-code-condition/","excerpt":"","text":"前言 接上一篇 Spring源码解析之@Lazy懒加载Bean 未添加条件前 配置 1234567891011121314151617181920@Configurationpublic class BeanConfig2 &#123; @Lazy @Bean public Person person() &#123; System.out.println(&quot;容器中注册Person...&quot;); return new Person(&quot;config&quot;, 18); &#125; @Bean(&quot;linux&quot;) public Person person1() &#123; return new Person(&quot;linux&quot;, 20); &#125; @Bean(&quot;windows&quot;) public Person person2() &#123; return new Person(&quot;windows&quot;, 21); &#125;&#125; 测试 1234567891011121314151617/** * person * linux * windows * 容器中注册Person... * &#123;person=Person&#123;name=&#x27;config&#x27;, age=18&#125;, linux=Person&#123;name=&#x27;linux&#x27;, age=20&#125;, windows=Person&#123;name=&#x27;windows&#x27;, age=21&#125;&#125; */@Testpublic void test03() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfig2.class); String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class); for (String name: beanNamesForType) &#123; System.out.println(name); &#125; Map&lt;String, Person&gt; beansOfType = applicationContext.getBeansOfType(Person.class); System.out.println(beansOfType);&#125; 条件注入 条件配置 12345678910111213141516171819202122232425262728@Configurationpublic class BeanConfig2 &#123; @Lazy @Bean public Person person() &#123; System.out.println(&quot;容器中注册Person...&quot;); return new Person(&quot;config&quot;, 18); &#125; @Conditional(&#123;MacCondition.class&#125;) @Bean(&quot;mac&quot;) public Person person0() &#123; return new Person(&quot;mac&quot;, 19); &#125; @Conditional(&#123;LinuxCondition.class&#125;) @Bean(&quot;linux&quot;) public Person person1() &#123; return new Person(&quot;linux&quot;, 20); &#125; @Conditional(&#123;WindowsCondition.class&#125;) @Bean(&quot;windows&quot;) public Person person2() &#123; return new Person(&quot;windows&quot;, 21); &#125;&#125; 条件实现 12345678910111213141516171819/** * @author cuishiying * @date 2021-01-22 */public class MacCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); Environment environment = context.getEnvironment(); BeanDefinitionRegistry registry = context.getRegistry(); String[] beanDefinitionNames = registry.getBeanDefinitionNames(); String property = environment.getProperty(&quot;os.name&quot;); if (property.contains(&quot;Mac&quot;)) &#123; return true; &#125; return false; &#125;&#125; 其他条件类似~ 测试 123456789101112/** * person * mac */@Testpublic void test04() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfig2.class); String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class); for (String name: beanNamesForType) &#123; System.out.println(name); &#125;&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"【Spring源码解析】组件注册-@Lazy懒加载Bean","slug":"spring-source-code-lazy","date":"2021-03-07T10:37:36.000Z","updated":"2021-03-08T16:03:18.174Z","comments":true,"path":"2021/03/07/spring-source-code-lazy/","link":"","permalink":"https://idea360.cn/2021/03/07/spring-source-code-lazy/","excerpt":"","text":"前言 接上一篇 Spring源码解析之@Scope设置组件作用域 实现 配置 12345678910@Configurationpublic class BeanConfig2 &#123; @Lazy @Bean public Person person() &#123; System.out.println(&quot;容器中注册Person...&quot;); return new Person(&quot;config&quot;, 18); &#125;&#125; 测试 12345678@Testpublic void test02() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfig2.class); System.out.println(&quot;ioc容器创建完成&quot;); // 懒加载在调用时候注册bean Person bean = applicationContext.getBean(Person.class); System.out.println(bean);&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"【Spring源码解析】组件注册-@Scope设置组件作用域","slug":"spring-source-code-scope","date":"2021-03-07T10:18:20.000Z","updated":"2021-03-08T16:03:26.967Z","comments":true,"path":"2021/03/07/spring-source-code-scope/","link":"","permalink":"https://idea360.cn/2021/03/07/spring-source-code-scope/","excerpt":"","text":"前言 接上一篇 Spring源码解析之@ComponentScan自定义TypeFilter指定过滤规则 实现 配置 12345678910@Configurationpublic class BeanConfig2 &#123; // singleton prototype @Scope(&quot;singleton&quot;) @Bean public Person person() &#123; return new Person(&quot;config&quot;, 18); &#125;&#125; 测试 1234567891011@Testpublic void test02() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfig2.class); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String name: beanDefinitionNames) &#123; System.out.println(name); &#125; Person bean = applicationContext.getBean(Person.class); Person bean2 = applicationContext.getBean(Person.class); System.out.println(bean2 == bean);&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"【Spring源码解析】组件注册-@ComponentScan自定义TypeFilter指定过滤规则","slug":"spring-source-code-TypeFilter","date":"2021-03-07T09:47:25.000Z","updated":"2021-03-08T16:03:32.748Z","comments":true,"path":"2021/03/07/spring-source-code-TypeFilter/","link":"","permalink":"https://idea360.cn/2021/03/07/spring-source-code-TypeFilter/","excerpt":"","text":"前言 接上一篇 Spring源码解析之@ComponentScan注册bean 实现 自定义过滤器 1234567891011121314151617181920212223public class CustomTypeFilter implements TypeFilter &#123; /** * * @param metadataReader 读取到当前正在扫描的类的信息 * @param metadataReaderFactory 可以获取到其他任何类信息的 */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; // 获取当前类注解信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); // 获取当前正在扫描的类的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); // 获取当前类资源(类的路径) Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); System.out.println(&quot;自定义filter:&quot; + className); if (className.contains(&quot;Service&quot;)) &#123; return true; &#125; return false; &#125;&#125; 配置过滤器 1234567891011@Configuration@ComponentScan(value = &quot;cn.idea360&quot;, includeFilters = &#123; @ComponentScan.Filter(type = FilterType.CUSTOM, value = &#123;CustomTypeFilter.class&#125;)&#125;, useDefaultFilters = false)public class BeanConfig &#123; @Bean public Person person() &#123; return new Person(&quot;config&quot;, 18); &#125;&#125; 测试 输出结果 123456789101112自定义filter:cn.idea360.IocTest自定义filter:cn.idea360.bean.Person自定义filter:cn.idea360.config.CustomTypeFilter自定义filter:cn.idea360.controller.BookController自定义filter:cn.idea360.dao.BookDao自定义filter:cn.idea360.service.BookServiceorg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorybeanConfigbookService 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"【Spring源码解析】组件注册-@ComponentScan注册bean","slug":"spring-source-code-ComponentScan","date":"2021-03-07T06:49:41.000Z","updated":"2021-03-08T16:02:42.205Z","comments":true,"path":"2021/03/07/spring-source-code-ComponentScan/","link":"","permalink":"https://idea360.cn/2021/03/07/spring-source-code-ComponentScan/","excerpt":"","text":"前言 接上一篇 Spring源码解析之注解注册bean 实现 按照平时的开发, 我们创建几个类 123@Controllerpublic class BookController &#123;&#125; 123@Servicepublic class BookService &#123;&#125; 123@Repositorypublic class BookDao &#123;&#125; 配置 123456789@Configuration@ComponentScan(value = &quot;cn.idea360&quot;)public class BeanConfig &#123; @Bean public Person person() &#123; return new Person(&quot;config&quot;, 18); &#125;&#125; 引入单元测试 123456&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 测试 1234567891011class IocTest &#123; @Test public void test01() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfig.class); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String name: beanDefinitionNames) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果 123456789org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorybeanConfigbookControllerbookDaobookServiceperson 可以看出我们添加了注解并在指定包下的bean全部被注册进了容器 如果我们想按注解排除一部分 1234567891011@Configuration@ComponentScan(value = &quot;cn.idea360&quot;, excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;Controller.class&#125;)&#125;)public class BeanConfig &#123; @Bean public Person person() &#123; return new Person(&quot;config&quot;, 18); &#125;&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"【Spring源码解析】组件注册-注解注册bean","slug":"spring-source-code-annotation","date":"2021-03-07T06:25:45.000Z","updated":"2021-03-08T16:02:26.101Z","comments":true,"path":"2021/03/07/spring-source-code-annotation/","link":"","permalink":"https://idea360.cn/2021/03/07/spring-source-code-annotation/","excerpt":"","text":"前言 接上一篇 Spring源码解析之xml注册bean 实现 注解配置 12345678@Configurationpublic class BeanConfig &#123; @Bean public Person person() &#123; return new Person(&quot;config&quot;, 18); &#125;&#125; 测试 1234567891011121314public class MainTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfig.class); Person bean = applicationContext.getBean(Person.class); System.out.println(bean); // Person&#123;name=&#x27;config&#x27;, age=18&#125; String[] namesForType = applicationContext.getBeanNamesForType(Person.class); for (String name: namesForType) &#123; System.out.println(name); // person &#125; &#125;&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"【Spring源码解析】组件注册-xml注册bean","slug":"spring-source-code-xml","date":"2021-03-07T06:19:04.000Z","updated":"2021-03-08T16:03:40.276Z","comments":true,"path":"2021/03/07/spring-source-code-xml/","link":"","permalink":"https://idea360.cn/2021/03/07/spring-source-code-xml/","excerpt":"","text":"前言 以前的spring-bean是通过xml注入bean的。 基础环境 创建一个 maven 项目 引入pom依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.4&lt;/version&gt;&lt;/dependency&gt; 创建一个简单对象 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author cuishiying * @date 2021-01-22 */public class Person &#123; private String name; private Integer age; public Person() &#123; &#125; public Person(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 在xml中注册bean 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;cn.idea360.bean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;17&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789101112/** * @author cuishiying * @date 2021-01-22 */public class MainTest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); Person bean = (Person) applicationContext.getBean(&quot;person&quot;); System.out.println(bean); // Person&#123;name=&#x27;admin&#x27;, age=17&#125; &#125;&#125; 最后 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"xml","slug":"xml","permalink":"https://idea360.cn/tags/xml/"}]},{"title":"logback日志级别动态切换","slug":"logback-level-dynamic","date":"2021-03-06T06:37:12.000Z","updated":"2021-03-11T16:21:05.806Z","comments":true,"path":"2021/03/06/logback-level-dynamic/","link":"","permalink":"https://idea360.cn/2021/03/06/logback-level-dynamic/","excerpt":"","text":"概述 生产环境中经常有需要动态修改日志级别, 现在记录我在生产中的方案。由于生产环境中使用nacos配置中心, 所以该方案基于nacos。 方案 logback-custom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;configuration debug=&quot;true&quot; scan=&quot;true&quot; scanPeriod=&quot;3 seconds&quot;&gt; &lt;!-- 日志输出格式 --&gt; &lt;property name=&quot;log.pattern&quot; value=&quot;[eachbot-nlp-kb-proxy] [%X&#123;ip&#125;] [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;80&#125;] [%method,%line] [%msg]%n&quot;/&gt; &lt;property name=&quot;log.pattern.color&quot; value=&quot;%yellow[eachbot-nlp-kb-proxy] [%X&#123;ip&#125;] [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %highlight[%-5level] %green[%logger&#123;80&#125;] [%method,%line] %highlight[%msg]%n&quot;/&gt; &lt;!-- 日志存放路径 --&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;LOG_PATH&quot; source=&quot;log.path&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;topic&quot; source=&quot;elk.kafka.topic&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;kafkaServers&quot; source=&quot;elk.kafka.servers&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;LOG_LEVEL&quot; source=&quot;log.level&quot;/&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 控制台输出-带颜色 --&gt; &lt;appender name=&quot;console-with-color&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;log.pattern.color&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件输出 --&gt; &lt;appender name=&quot;file_info&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/eachbot-nlp-kb-proxy.info.%d.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=&quot;file_error&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/eachbot-nlp-kb-proxy.error.%d.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- kafka --&gt; &lt;appender name=&quot;kafka_appender&quot; class=&quot;com.github.danielwegener.logback.kafka.KafkaAppender&quot;&gt; &lt;encoder class=&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&gt; &lt;providers&gt; &lt;timestamp&gt; &lt;timeZone&gt;UTC&lt;/timeZone&gt; &lt;/timestamp&gt; &lt;pattern&gt; &lt;pattern&gt; &#123; &quot;app_name&quot;:&quot;eachbot-nlp-kb-proxy&quot;, &quot;ip&quot;:&quot;%X&#123;ip&#125;&quot;, &quot;company_ip&quot;: &quot;%X&#123;companyId&#125;&quot;, &quot;date_time&quot;: &quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&quot;, &quot;thread&quot;: &quot;%thread&quot;, &quot;level&quot;: &quot;%level&quot;, &quot;class&quot;:&quot;%logger&#123;80&#125;&quot;, &quot;method&quot;:&quot;%method,%line&quot;, &quot;message&quot;: &quot;%msg&quot; &#125; &lt;/pattern&gt; &lt;/pattern&gt; &lt;/providers&gt; &lt;/encoder&gt; &lt;!--kafka topic 需要与配置文件里面的topic一致 否则kafka会沉默并鄙视你--&gt; &lt;topic&gt;$&#123;topic&#125;&lt;/topic&gt; &lt;keyingStrategy class=&quot;com.github.danielwegener.logback.kafka.keying.HostNameKeyingStrategy&quot; /&gt; &lt;deliveryStrategy class=&quot;com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy&quot; /&gt; &lt;producerConfig&gt;bootstrap.servers=$&#123;kafkaServers&#125;&lt;/producerConfig&gt; &lt;producerConfig&gt;acks=1&lt;/producerConfig&gt; &lt;producerConfig&gt;linger.ms=1000&lt;/producerConfig&gt; &lt;producerConfig&gt;max.block.ms=0&lt;/producerConfig&gt; &lt;/appender&gt; &lt;!--显示sql--&gt; &lt;logger name=&quot;org.mongodb&quot; level=&quot;warn&quot;/&gt; &lt;logger name=&quot;org.apache.kafka&quot; level=&quot;INFO&quot;/&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;info&quot;/&gt; &lt;root level=&quot;$&#123;LOG_LEVEL:-INFO&#125;&quot;&gt; &lt;appender-ref ref=&quot;console-with-color&quot;/&gt; &lt;appender-ref ref=&quot;file_info&quot;/&gt; &lt;appender-ref ref=&quot;file_error&quot;/&gt; &lt;!-- &lt;appender-ref ref=&quot;kafka_appender&quot;/&gt;--&gt; &lt;/root&gt;&lt;/configuration&gt; 我们只需要在nacos的配置文件中配置 log.level=debug 即可切换日志等级 pom.xml 123456789101112131415&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;local&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profileActive&gt;local&lt;/profileActive&gt; &lt;nacos.servers&gt;127.0.0.1:8848&lt;/nacos.servers&gt; &lt;nacos.namespace&gt;d4009480-1234-4000-1234-15cdef527111&lt;/nacos.namespace&gt; &lt;nacos.username&gt;nacos&lt;/nacos.username&gt; &lt;nacos.password&gt;nacos&lt;/nacos.password&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; bootstrap.yml 123456789101112131415161718spring: application: name: eachbot-nlp-kb-proxy profiles: active: @profileActive@ cloud: nacos: config: server-addr: @nacos.servers@ namespace: @nacos.namespace@ group: EACHBOT file-extension: yaml username: @nacos.username@ password: @nacos.password@ discovery: server-addr: @nacos.servers@ namespace: @nacos.namespace@ group: EACHBOT 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 其他 https://codertang.com/2020/05/08/logger-level-modifier/ https://tech.meituan.com/2017/02/17/change-log-level.html","categories":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"日志","slug":"日志","permalink":"https://idea360.cn/tags/%E6%97%A5%E5%BF%97/"},{"name":"logback","slug":"logback","permalink":"https://idea360.cn/tags/logback/"}]},{"title":"Springboot自定义@EnableXX注解","slug":"spring-boot-starter-enable","date":"2021-02-28T07:50:25.000Z","updated":"2021-03-21T15:37:17.459Z","comments":true,"path":"2021/02/28/spring-boot-starter-enable/","link":"","permalink":"https://idea360.cn/2021/02/28/spring-boot-starter-enable/","excerpt":"","text":"前言 在SpringBoot中，经常可以看到许多以 @Enable 开头的注解，例如：@EnableAutoConfiguration，@EnableAsync……，那么我们是否可以自己定义一个注解呢？ 其实自定义注解最终都是利用到了 ImportBeanDefinitionRegistrar 这个类，通过手动的方式，将一个类注册成为 Bean，然后在进行一系列的操作。相比SPI机制, 该实现相当于手动装配 实现 假设现在有一个需求是要写一个切面，这个切面负责打印controller 的log。但是可能某些系统有自己的日志格式，不太需要这个切面AOP，所以希望可以增加一个开关，然后是按需引用。 下面就来开始写一个这样的demo，项目结构如下： 12345678910111213├── pom.xml└── src ├── main │ ├── java │ │ └── com │ │ ├── anno │ │ │ ├── EnableLog.java │ │ │ ├── LogAop.java │ │ │ └── LogRegister.java │ │ └── example │ │ ├── App.java │ │ ├── controller │ │ │ └── AnnoController.java 在这里为什么会初始化两个文件夹，是因为 @SpringBootApplication 这个注解会默认将当前目录以及它的下级目录下的 Bean 注入到容器中，所以新建一个同级目录anno 就是为了不让 @SpringBootApplication 加载切面。 Controller 1234567891011121314/** * @author cuishiying * @date 2021-01-22 */@RestController@RequestMapping(&quot;/anno&quot;)public class AnnoController &#123; // http://localhost:8080/anno/hello @GetMapping(&quot;/hello&quot;) public Object hello() &#123; return &quot;hello world&quot;; &#125;&#125; 然后请求 http://localhost:8080/anno/hello， 可以看到在控制台没有任何输出。那就说明自定义的切面还没有生效。此时在 Application 上添加我们的自定义注解，添加后代码如下： 1234567@EnableLog@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 此时在此启动项目，你会发现已经已经在控制台有我们的日志log了。 自定义注解实现 首先我们需要注册到spring容器的是aop, 这里先实现AOP切面。 123456789101112131415161718192021/** * @author cuishiying * @date 2021-01-22 */@Slf4j@Aspectpublic class LogAop &#123; @Pointcut(&quot;execution(public * com.example.controller.*.*(..))&quot;) public void req() &#123;&#125; @Around(&quot;req()&quot;) public Object around(ProceedingJoinPoint point) throws Throwable &#123; log.info(&quot;start:&#123;&#125;&quot;, System.currentTimeMillis()); Object proceed = point.proceed(); log.info(&quot;end:&#123;&#125;&quot;, System.currentTimeMillis()); return proceed; &#125;&#125; 然后实现自动注入配置(需要@Import的类) 1234567891011121314151617/** * @author cuishiying * @date 2021-01-22 */public class LogRegister implements ImportBeanDefinitionRegistrar &#123; /** * BeanDefinitionRegistry 将我们的 LogAop 注册成一个Bean，只有当注册成一个 Bean 以后，该切面才会生效 * @param importingClassMetadata * @param registry */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; BeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(LogAop.class).getBeanDefinition(); registry.registerBeanDefinition(&quot;logAspect&quot;, beanDefinition); &#125;&#125; 最后定义注入开关注解 123456@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;LogRegister.class&#125;)public @interface EnableLog &#123;&#125; 再次访问 http://localhost:8080/anno/hello 可以看到aop已经生效了。 122021-02-28 16:24:31.567 INFO 58297 --- [nio-8080-exec-2] com.anno.LogAop : start:16145006715672021-02-28 16:24:31.576 INFO 58297 --- [nio-8080-exec-2] com.anno.LogAop : end:1614500671576 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 http://www.jerome.xin/articles/spring-boot-enable-auto-configure https://blog.csdn.net/u010192145/article/details/110950963 https://my.oschina.net/u/4400801/blog/4489936","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"基础","slug":"基础","permalink":"https://idea360.cn/tags/%E5%9F%BA%E7%A1%80/"},{"name":"配置","slug":"配置","permalink":"https://idea360.cn/tags/%E9%85%8D%E7%BD%AE/"},{"name":"Enable","slug":"Enable","permalink":"https://idea360.cn/tags/Enable/"}]},{"title":"分布式锁","slug":"distributed-lock","date":"2021-02-24T15:00:00.000Z","updated":"2021-03-15T15:36:50.834Z","comments":true,"path":"2021/02/24/distributed-lock/","link":"","permalink":"https://idea360.cn/2021/02/24/distributed-lock/","excerpt":"","text":"ReentrantLock使用 1234567891011121314151617181920212223242526272829// 根据业务将锁缓存在容器中private final Map&lt;String, ReentrantLock&gt; keyLockMap = new ConcurrentHashMap&lt;&gt;();// 方法调用public &lt;T&gt; T get(Object key) &#123; Object value = lookup(key); if (value != null) &#123; return (T) value; &#125; ReentrantLock lock = keyLockMap.computeIfAbsent(key.toString(), s -&gt; &#123; log.trace(&quot;create lock for key : &#123;&#125;&quot;, s); return new ReentrantLock(); &#125;); try &#123; lock.lock(); value = lookup(key); if (value != null) &#123; return (T) value; &#125; &#125; catch (Exception e) &#123; throw new ValueRetrievalException(key, e.getCause()); &#125; finally &#123; lock.unlock(); &#125;&#125; Zookeeper分布式锁 12345678910public interface Lock &#123; /** * Acquire lock */ void getLock() throws Exception; /** * Release lock */ void unlock() throws Exception;&#125; 123456789101112131415161718192021@Slf4jpublic abstract class AbstractTemplateLock implements Lock &#123; @Override public void getLock() &#123; if (tryLock()) &#123; log.info(Thread.currentThread().getName() + &quot;Lock acquired successfully&quot;); &#125; else &#123; //wait for waitLock();//Event listening if the node is deleted, it can be retrieved //Reacquire getLock(); &#125; &#125; protected abstract void waitLock(); protected abstract boolean tryLock(); protected abstract void releaseLock(); @Override public void unlock() &#123; releaseLock(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.lock;import lombok.extern.slf4j.Slf4j;import org.I0Itec.zkclient.IZkDataListener;import org.I0Itec.zkclient.ZkClient;import java.util.concurrent.CountDownLatch;/** * @author cuishiying * @date 2021-01-22 */@Slf4jpublic class ZkTemplateLock extends AbstractTemplateLock &#123; private static final String zkServers = &quot;127.0.0.1:2181&quot;; private static final int sessionTimeout = 8000; private static final int connectionTimeout = 5000; private static final String lockPath = &quot;/lockPath&quot;; private ZkClient client; public ZkTemplateLock() &#123; client = new ZkClient(zkServers, sessionTimeout, connectionTimeout); log.info(&quot;zk client 连接成功:&#123;&#125;&quot;,zkServers); &#125; @Override protected void waitLock() &#123; CountDownLatch latch = new CountDownLatch(1); IZkDataListener listener = new IZkDataListener() &#123; @Override public void handleDataDeleted(String dataPath) throws Exception &#123; System.out.println(&quot;监听到节点被删除&quot;); latch.countDown(); &#125; @Override public void handleDataChange(String dataPath, Object data) throws Exception &#123;&#125; &#125;; //完成 watcher 注册 client.subscribeDataChanges(lockPath, listener); //阻塞自己 if (client.exists(lockPath)) &#123; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //取消watcher注册 client.unsubscribeDataChanges(lockPath, listener); &#125; @Override protected boolean tryLock() &#123; try &#123; client.createEphemeral(lockPath); System.out.println(Thread.currentThread().getName()+&quot;获取到锁&quot;); &#125; catch (Exception e) &#123; log.error(&quot;创建失败&quot;); return false; &#125; return true; &#125; @Override public void releaseLock() &#123; client.delete(this.lockPath); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.example.lock;import lombok.extern.slf4j.Slf4j;import org.I0Itec.zkclient.IZkDataListener;import org.I0Itec.zkclient.ZkClient;import java.util.Collections;import java.util.List;import java.util.concurrent.CountDownLatch;/** * @author cuishiying * @date 2021-01-22 */@Slf4jpublic class ZkSequenTemplateLock extends AbstractTemplateLock &#123; private static final String zkServers = &quot;127.0.0.1:2181&quot;; private static final int sessionTimeout = 8000; private static final int connectionTimeout = 5000; private static final String lockPath = &quot;/lockPath&quot;; private String beforePath; private String currentPath; private ZkClient client; public ZkSequenTemplateLock() &#123; client = new ZkClient(zkServers); if (!client.exists(lockPath)) &#123; client.createPersistent(lockPath); &#125; log.info(&quot;zk client Connection successful:&#123;&#125;&quot;,zkServers); &#125; @Override protected void waitLock() &#123; CountDownLatch latch = new CountDownLatch(1); IZkDataListener listener = new IZkDataListener() &#123; @Override public void handleDataDeleted(String dataPath) throws Exception &#123; System.out.println(&quot;Listening to the node being deleted&quot;); latch.countDown(); &#125; @Override public void handleDataChange(String dataPath, Object data) throws Exception &#123;&#125; &#125;; //Adding a data deletion watcher to the top node essentially starts another thread to listen to the previous node client.subscribeDataChanges(beforePath, listener); //Block yourself if (client.exists(beforePath)) &#123; try &#123; System.out.println(&quot;block&quot;+currentPath); latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //Cancel watcher registration client.unsubscribeDataChanges(beforePath, listener); &#125; @Override protected boolean tryLock() &#123; if (currentPath == null) &#123; //Create a temporary sequence node currentPath = client.createEphemeralSequential(lockPath + &quot;/&quot;, &quot;lock-data&quot;); System.out.println(&quot;current:&quot; + currentPath); &#125; //Get all children and sort them. Temporary node name is a self growing string List&lt;String&gt; childrens = client.getChildren(lockPath); //Sort list, sort in natural order Collections.sort(childrens); if (currentPath.equals(lockPath + &quot;/&quot; + childrens.get(0))) &#123; return true; &#125; else &#123; //If the current node is not ranked first, the previous node information is obtained and assigned to beforePath int curIndex = childrens.indexOf(currentPath.substring(lockPath.length() + 1)); beforePath = lockPath + &quot;/&quot; + childrens.get(curIndex - 1); &#125; System.out.println(&quot;beforePath&quot;+beforePath); return false; &#125; @Override public void releaseLock() &#123; System.out.println(&quot;delete:&quot; + currentPath); client.delete(currentPath); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.lock;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.locks.InterProcessMutex;import org.apache.curator.retry.ExponentialBackoffRetry;import java.util.concurrent.TimeUnit;/** * @author cuishiying * @date 2021-01-22 */public class ZkLockWithCuratorTemplate implements Lock &#123; // zk host address private String host = &quot;localhost&quot;; // zk self increasing storage node private String lockPath = &quot;/curatorLock&quot;; // Retry sleep time private static final int SLEEP_TIME_MS = 1000; // Maximum retries 1000 private static final int MAX_RETRIES = 1000; //Session timeout private static final int SESSION_TIMEOUT = 30 * 1000; //Connection timeout private static final int CONNECTION_TIMEOUT = 3 * 1000; //Cursor core operation class private CuratorFramework curatorFramework; InterProcessMutex lock; public ZkLockWithCuratorTemplate() &#123; curatorFramework = CuratorFrameworkFactory.builder() .connectString(host) .connectionTimeoutMs(CONNECTION_TIMEOUT) .sessionTimeoutMs(SESSION_TIMEOUT) .retryPolicy(new ExponentialBackoffRetry(SLEEP_TIME_MS, MAX_RETRIES)) .build(); curatorFramework.start(); lock = new InterProcessMutex (curatorFramework, lockPath); &#125; @Override public void getLock() throws Exception &#123; //Release lock after 5s timeout lock.acquire(5, TimeUnit.SECONDS); &#125; @Override public void unlock() throws Exception &#123; lock.release(); &#125;&#125; 123456789101112131415161718192021222324252627282930public class CuratorConfig &#123; // zk host地址 private String host; // zk自增存储node private String lockPath; // 重试休眠时间 private static final int SLEEP_TIME_MS = 1000; // 最大重试1000次 private static final int MAX_RETRIES = 1000; //会话超时时间 private static final int SESSION_TIMEOUT = 30 * 1000; //连接超时时间 private static final int CONNECTION_TIMEOUT = 3 * 1000; private CuratorFramework curatorFramework; @Bean public CuratorFramework curatorFramework() &#123; curatorFramework = CuratorFrameworkFactory.builder() .connectString(host) .connectionTimeoutMs(CONNECTION_TIMEOUT) .sessionTimeoutMs(SESSION_TIMEOUT) .retryPolicy(new ExponentialBackoffRetry(SLEEP_TIME_MS, MAX_RETRIES)) .build(); curatorFramework.start(); return curatorFramework; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class LockTest &#123; public static void main(String[] args) &#123; AtomicInteger orderNumber = new AtomicInteger(); Lock lock = new ZkTemplateLock(); CountDownLatch latch = new CountDownLatch(30); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; try &#123; latch.countDown(); latch.await(); try &#123; lock.getLock(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; lock.unlock(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; log.info(Thread.currentThread().getName() + &quot;-----&gt;&quot; + orderNumber.getAndIncrement()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; zookeeper简单实现 12345678910111213141516171819202122232425262728293031323334353637383940@Slf4j@Configurationpublic class ZkLockConfig &#123; @Value(&quot;$&#123;zookeeper.address&#125;&quot;) private String connectString; @Value(&quot;$&#123;zookeeper.timeout&#125;&quot;) private int timeout; @Bean(&quot;zkClient&quot;) public ZooKeeper zkClient() &#123; ZooKeeper zookeeper = null; try &#123; final CountDownLatch connectedSemaphore = new CountDownLatch(1); zookeeper = new ZooKeeper(connectString, timeout, watchedEvent -&gt; &#123; log.info(&quot;Receive watched event: &quot; + watchedEvent.getState()); if(Watcher.Event.KeeperState.SyncConnected == watchedEvent.getState()) &#123; connectedSemaphore.countDown(); &#125; &#125;); // 给一个状态CONNECTING，连接中 log.info(&quot;zk state: &#123;&#125;&quot;, zookeeper.getState()); connectedSemaphore.await(); log.info(&quot;zk连接成功......&quot;); &#125; catch (Exception e) &#123; log.error(&quot;zk连接失败, zookeeper.address=&quot; + connectString, e); &#125; return zookeeper; &#125; @Bean(&quot;zkLock&quot;) @ConditionalOnBean(ZooKeeper.class) public ZkLock zkLock(ZooKeeper zooKeeper) &#123; return new ZkLock(zooKeeper); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Slf4jpublic class ZkLock &#123; public static final String LOCK_LOG = &quot;获取分布式锁, lock=[&#123;&#125;]&quot;; private final ZooKeeper zookeeper; public ZkLock(ZooKeeper zookeeper) &#123; this.zookeeper = zookeeper; &#125; private void acquireDistributedLock(Long companyId, Long groupId) &#123; String path = getLockPath(companyId, groupId); acquireDistributedLock(path); &#125; public void acquireDistributedLock(String path) &#123; try &#123; zookeeper.create(path, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); log.info(LOCK_LOG, path); &#125; catch (Exception e) &#123; int count = 0; while(true) &#123; try &#123; Thread.sleep(1000); zookeeper.create(path, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); &#125; catch (Exception e2) &#123; count++; log.info(&quot;尝试获取[&#123;&#125;]次锁, path=[&#123;&#125;]&quot;, count, path); continue; &#125; log.info(&quot;重试[&#123;&#125;]次后获取到锁, path=[&#123;&#125;]&quot;, count, path); break; &#125; &#125; &#125; public boolean acquireFastFailedDistributedLock(Long companyId, Long groupId) &#123; String path = getLockPath(companyId, groupId); try &#123; zookeeper.create(path, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); log.info(LOCK_LOG, path); return true; &#125; catch (Exception e) &#123; log.info(&quot;获取分布式锁失败, lock=[&#123;&#125;]&quot;, path); &#125; return false; &#125; private void releaseDistributedLock(Long companyId, Long groupId) &#123; String path = getLockPath(companyId, groupId); releaseDistributedLock(path); &#125; public void releaseDistributedLock(String path) &#123; try &#123; zookeeper.delete(path, -1); log.info(&quot;释放分布式锁, path=[&#123;&#125;]&quot;, path); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private String getLockPath(Long companyId, Long groupId) &#123; return String.format(ZK_EXCLUSIVE_LOCK_INNER, companyId, groupId); &#125;&#125; 参考 https://laptrinhx.com/implementation-of-distributed-lock-with-zookeeper-326421370/ https://mp.weixin.qq.com/s/iZvV8cH90ukG79RHGqKjMw","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"https://idea360.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]},{"title":"Vim常用快捷键","slug":"hello-vim","date":"2021-02-23T14:08:36.000Z","updated":"2021-02-23T14:10:19.541Z","comments":true,"path":"2021/02/23/hello-vim/","link":"","permalink":"https://idea360.cn/2021/02/23/hello-vim/","excerpt":"","text":"一、移动光标 h j k l 上 下 左 右 ctrl-y 上移一行 ctrl-e 下移一行 ctrl-u 上翻半页（up） ctrl-d 下翻半页（down） ctrl-f 上翻一页（forward） ctrl-b 下翻一页（backward） w 跳到下一个字首，按标点或单词分割 W 跳到下一个字首，长跳，如end-of-line被认为是一个字 e 跳到下一个字尾 E 跳到下一个字尾，长跳 b 跳到上一个字 B 跳到上一个字，长跳 0 跳至行首，不管有无缩进，就是跳到第0个字符 ^ 跳至行首的第一个字符 $ 跳至行尾 gg 跳至文首 G 调至文尾 5gg/5G 调至第5行 gd 跳至当前光标所在的变量的声明处 fx 在当前行中找x字符，找到了就跳转至 ; 重复上一个f命令，而不用重复的输入fx ***** 查找光标所在处的单词，向下查找 # 查找光标所在处的单词，向上查找 二、删除复制 dd 删除光标所在行 dw 删除一个字(word) d/D 删除到行末 x 删除当前字符 X 删除前一个字符 yy 复制一行 yw 复制一个字 y/Y 复制到行末 p 粘贴粘贴板的内容到当前行的下面 P 粘贴粘贴板的内容到当前行的上面 三、插入模式 i 从当前光标处进入插入模式 I 进入插入模式，并置光标于行首 a 追加模式，置光标于当前光标之后 A 追加模式，置光标于行末 o 在当前行之下新加一行，并进入插入模式 O 在当前行之上新加一行，并进入插入模式 Esc 退出插入模式 四、编辑 J 将下一行和当前行连接为一行 cc 删除当前行并进入编辑模式 cw 删除当前字，并进入编辑模式 c$ 擦除从当前位置至行末的内容，并进入编辑模式 s 删除当前字符并进入编辑模式 S 删除光标所在行并进入编辑模式 xp 交换当前字符和下一个字符 u 撤销 ctrl+r 重做 ~ 切换大小写，当前字符 &gt;&gt; 将当前行右移一个单位 &lt;&lt; 将当前行左移一个单位(一个tab符) == 自动缩进当前行 五、查找替换 /pattern 向后搜索字符串pattern ?pattern 向前搜索字符串pattern &quot;\\c&quot; 忽略大小写 &quot;\\C&quot; 大小写敏感 n 下一个匹配(如果是/搜索，则是向下的下一个，?搜索则是向上的下一个) N 上一个匹配(同上) :%s/old/new/g 搜索整个文件，将所有的old替换为new :%s/old/new/gc 搜索整个文件，将所有的old替换为new，每次都要你确认是否替换 六、退出编辑器 :w 将缓冲区写入文件，即保存修改 :wq 保存修改并退出 :x 保存修改并退出 :q 退出，如果对缓冲区进行过修改，则会提示 :q! 强制退出，放弃修改 七、多文件编辑 vim file1… 同时打开多个文件 :args 显示当前编辑文件 :next 切换到下个文件 :prev 切换到前个文件 **:next！**不保存当前编辑文件并切换到下个文件 **:prev！**不保存当前编辑文件并切换到上个文件 :wnext 保存当前编辑文件并切换到下个文件 :wprev 保存当前编辑文件并切换到上个文件 :first 定位首文件 :last 定位尾文件 ctrl+^ 快速在最近打开的两个文件间切换 :split[sp] 把当前文件水平分割 :split file 把当前窗口水平分割, file :vsplit[vsp] file 把当前窗口垂直分割, file :new file 同split file :close 关闭当前窗口 :only 只显示当前窗口, 关闭所有其他的窗口 :all 打开所有的窗口 :vertical all 打开所有的窗口, 垂直打开 :qall 对所有窗口执行：q操作 :qall! 对所有窗口执行：q!操作 :wall 对所有窗口执行：w操作 :wqall 对所有窗口执行：wq操作 ctrl-w h 跳转到左边的窗口 ctrl-w j 跳转到下面的窗口 ctrl-w k 跳转到上面的窗口 ctrl-w l 跳转到右边的窗口 ctrl-w t 跳转到最顶上的窗口 ctrl-w b 跳转到最底下的窗口 八、多标签编辑 :tabedit file 在新标签中打开文件file :tab split file 在新标签中打开文件file :tabp 切换到前一个标签 :tabn 切换到后一个标签 :tabc 关闭当前标签 :tabo 关闭其他标签 gt 到下一个tab gT 到上一个tab 0gt 跳到第一个tab 5gt 跳到第五个tab 九、执行shell命令 在命令模式下输入&quot;:sh&quot;，可以运行相当于在字符模式下，到输入结束想回到VIM编辑器中用exit，ctrl+D返回VIM编辑器 可以&quot;!command&quot;，运行结束后自动回到VIM编辑器中 用“Ctrl+Z“回到shell，用fg返回编辑 :!make -&gt; 直接在当前目录下运行make指令 十、VIM启动项 -o[n] 以水平分屏的方式打开多个文件 -O[n] 以垂直分屏的方式打开多个文件 十一、自动排版 在粘贴了一些代码之后，vim变得比较乱，只要执行gg=G就能搞定 十二、如何在vim中编译程序 在vim中可以完成make,而且可以将编译的结果也显示在vim里，先执行 :copen 命令，将结果输出的窗口打开，然后执行 :make 编译后的结果就显示在了copen打开的小窗口里了，而且用鼠标双击错误信息，就会跳转到发生错误的行。 十三、buffer操作 buffer状态 - （非活动的缓冲区） a （当前被激活缓冲区） h （隐藏的缓冲区） % （当前的缓冲区） # （交换缓冲区） = （只读缓冲区） + （已经更改的缓冲区） 十四、 VIM 操作目录 1.打开目录 vim . vim a-path/ 2.以下操作在操作目录时生效 p,P,t,u,U,x,v,o,r,s c 使当前打开的目录成为当前目录 d 创建目录 % 创建文件 D 删除文件/目录 - 转到上层目录 gb 转到上一个 bookmarked directory i 改变目录文件列表方式 ^l 刷新当前打开的目录 mf - 标记文件 mu - unmark all marked files mz - Compress/decompress marked files gh 显示/不显示隐藏文件( dot-files) ^h 编辑隐藏文件列表 a 转换显示模式, all - hide - unhide qf diplay infomation about file qb list the bookmarked directories and directory traversal history gi Display information on file mb mc md - 将标记的文件(mf标记文件)使用 diff 模式 me - 编辑标记的文件,只显示一个，其余放入 buffer 中 mh mm - move marked files to marked-file target directory mc - copy mp mr mt vim 中复制,移动文件 mt - 移动到的目录 mf - 标记要移动的文件 mc - 移动/复制 R 移动文件 打开当前编辑文件的目录 :Explore :Hexplore :Nexplore :Pexplore :Sexplore :Texplore :Vexplore","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://idea360.cn/tags/vim/"},{"name":"快捷键","slug":"快捷键","permalink":"https://idea360.cn/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"springboot本地缓存caffeine","slug":"springboot-caffeine","date":"2021-02-18T09:19:18.000Z","updated":"2021-02-23T14:46:06.555Z","comments":true,"path":"2021/02/18/springboot-caffeine/","link":"","permalink":"https://idea360.cn/2021/02/18/springboot-caffeine/","excerpt":"","text":"概述 Guava、Ehcache、Caffeine都是基于JVM堆内存的本地缓存方案, 从功能和性能角度的对比这里不再多做赘述。在实际生产环境中, 为了避免缓存雪崩, 一般会采用多级缓存策略。 Caffeine基本使用 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt; &lt;artifactId&gt;caffeine&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 缓存配置 12345678910111213141516171819/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class CacheConfig &#123; @Bean public Cache&lt;String, Object&gt; caffeineCache() &#123; return Caffeine.newBuilder() // 固定过期时间 .expireAfterWrite(60, TimeUnit.MINUTES) // 初始缓存空间大小 .initialCapacity(100) // 缓存最大条数 .maximumSize(1000) .build(); &#125;&#125; 应用 123456789101112/** * @author cuishiying * @date 2021-01-22 */@Data@ToStringpublic class User &#123; private Long id; private String name;&#125; 123456789101112131415/** * @author cuishiying * @date 2021-01-22 */public interface UserService &#123; void addUser(User user); User getUser(Long id); User updateUser(User user); void deleteUser(Long id);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @author cuishiying * @date 2021-01-22 */@Slf4j@Servicepublic class UserServiceImpl implements UserService &#123; /** * 缓存 * 注意: key存取需要保证类型一致, 如全部使用String.valueOf(id)处理key, 否则操作失败 */ @Resource private Cache&lt;String, Object&gt; cache; /** * 模拟数据库 */ private final Map&lt;Long, User&gt; db = new HashMap&lt;&gt;(); @Override public void addUser(User user) &#123; db.put(user.getId(), user); log.info(&quot;saved to db, user=&#123;&#125;&quot;, user); &#125; @Override public User getUser(Long id) &#123; // 先从缓存中读取 User user = (User) cache.getIfPresent(String.valueOf(id)); if (Objects.nonNull(user)) &#123; log.info(&quot;get from cache, user=&#123;&#125;&quot;, user); return user; &#125; // 如果缓存中不存在, 则从库中查找 user = db.get(id); log.info(&quot;get from db, user=&#123;&#125;&quot;, user); // 如果数据库存在, 则加入缓存 if (Objects.nonNull(user)) &#123; log.info(&quot;saved to cache, user=&#123;&#125;&quot;, user); cache.put(String.valueOf(id), user); &#125; return user; &#125; @Override public User updateUser(User user) &#123; if (!db.containsKey(user.getId())) &#123; return null; &#125; // 更新数据库 User oldUser = db.get(user.getId()); oldUser.setName(user.getName()); db.put(user.getId(), oldUser); // 清除缓存 cache.invalidate(String.valueOf(user.getId())); log.info(&quot;invalidate cache, user=&#123;&#125;&quot;, user); return oldUser; &#125; @Override public void deleteUser(Long id) &#123; // 删除数据库 db.remove(id); // 删除缓存 cache.invalidate(String.valueOf(id)); &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * @author cuishiying * @date 2021-01-22 */@RestControllerpublic class UserController &#123; @Resource private UserService userService; @PostMapping(&quot;/user&quot;) public Object createUser(@RequestBody User user) &#123; userService.addUser(user); return user; &#125; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public Object getUser(@PathVariable Long id) &#123; return userService.getUser(id); &#125; @PutMapping(&quot;/user&quot;) public Object updateUser(@RequestBody User user) &#123; return userService.updateUser(user); &#125; @DeleteMapping(&quot;/user/&#123;id&#125;&quot;) public Object deleteUser(@PathVariable Long id) &#123; userService.deleteUser(id); return id; &#125;&#125; 配合spring-cahce使用 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt;&lt;/dependency&gt; 修改配置文件 将缓存交给spring接管 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.caffeine;import com.github.benmanes.caffeine.cache.Cache;import com.github.benmanes.caffeine.cache.Caffeine;import org.springframework.cache.CacheManager;import org.springframework.cache.caffeine.CaffeineCacheManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.concurrent.TimeUnit;/** * @author cuishiying * @date 2021-01-22 */@Configurationpublic class CacheConfig &#123; @Bean public Cache&lt;String, Object&gt; caffeineCache() &#123; return Caffeine.newBuilder() // 固定过期时间 .expireAfterWrite(60, TimeUnit.MINUTES) // 初始缓存空间大小 .initialCapacity(100) // 缓存最大条数 .maximumSize(1000) .build(); &#125; @Bean(&quot;caffeineCacheManage&quot;) public CacheManager caffeineCacheManage() &#123; CaffeineCacheManager cacheManager = new CaffeineCacheManager(); cacheManager.setCaffeine(Caffeine.newBuilder() // 固定过期时间 .expireAfterWrite(60, TimeUnit.MINUTES) // 初始缓存空间大小 .initialCapacity(100) // 缓存最大条数 .maximumSize(1000)); return cacheManager; &#125;&#125; 重写实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author cuishiying * @date 2021-01-22 */@Slf4j@Service(&quot;caffeineCacheService&quot;)@CacheConfig(cacheNames = &quot;caffeineCacheManage&quot;)public class UserServiceImpl implements UserService &#123; /** * 模拟数据库 */ private final Map&lt;Long, User&gt; db = new HashMap&lt;&gt;(); @Override @CachePut(key = &quot;#user.id&quot;) public void addUser(User user) &#123; db.put(user.getId(), user); log.info(&quot;saved to db, user=&#123;&#125;&quot;, user); &#125; @Override @Cacheable(key = &quot;#id&quot;) public User getUser(Long id) &#123; return db.get(id); &#125; @Override @CacheEvict(key = &quot;#user.id&quot;) public User updateUser(User user) &#123; if (!db.containsKey(user.getId())) &#123; return null; &#125; // 更新数据库 User oldUser = db.get(user.getId()); oldUser.setName(user.getName()); db.put(user.getId(), oldUser); // 清除缓存 log.info(&quot;invalidate cache, user=&#123;&#125;&quot;, user); return oldUser; &#125; @Override @CacheEvict(key = &quot;#id&quot;) public void deleteUser(Long id) &#123; // 删除数据库 db.remove(id); &#125;&#125; 测试 12@Resource(name &#x3D; &quot;caffeineCacheService&quot;)private UserService userService; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"cache","slug":"cache","permalink":"https://idea360.cn/tags/cache/"},{"name":"缓存","slug":"缓存","permalink":"https://idea360.cn/tags/%E7%BC%93%E5%AD%98/"},{"name":"caffeine","slug":"caffeine","permalink":"https://idea360.cn/tags/caffeine/"}]},{"title":"初识SPI","slug":"hello-spi","date":"2021-02-08T07:11:11.000Z","updated":"2021-02-23T14:18:49.049Z","comments":true,"path":"2021/02/08/hello-spi/","link":"","permalink":"https://idea360.cn/2021/02/08/hello-spi/","excerpt":"","text":"前言 先不深究机制及原理，仅是认识SPI是如何生效的。 定义1个接口 123456/** * @author cuishiying * @date 2021-01-22 */public interface IAlgorithm &#123;&#125; 实现类 123456/** * @author cuishiying * @date 2021-01-22 */public class LoopAlgorithm implements IAlgorithm &#123;&#125; 123456/** * @author cuishiying * @date 2021-01-22 */public class RandomAlgorithm implements IAlgorithm &#123;&#125; 在resources下创建目录 META-INF/services/, 并在目录下新建全路径接口文件 12345➜ services pwd&#x2F;Users&#x2F;cuishiying&#x2F;work&#x2F;examples&#x2F;demo-java&#x2F;src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;services➜ services tree.└── com.example.clz.IAlgorithm 在接口中定义实现类 12com.example.clz.LoopAlgorithmcom.example.clz.RandomAlgorithm 测试 1234567891011121314@Slf4jpublic class Main &#123; /** * 15:17:12.924 [main] INFO com.example.clz.Main - 接口实现类: com.example.clz.LoopAlgorithm * 15:17:12.931 [main] INFO com.example.clz.Main - 接口实现类: com.example.clz.RandomAlgorithm */ public static void main(String[] args) &#123; ServiceLoader&lt;IAlgorithm&gt; serviceLoader = ServiceLoader.load(IAlgorithm.class); for (IAlgorithm algorithm : serviceLoader)&#123; log.info(&quot;接口实现类: &#123;&#125;&quot;, algorithm.getClass().getName()); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"spi","slug":"spi","permalink":"https://idea360.cn/tags/spi/"}]},{"title":"java8异步任务CompletableFuture","slug":"java8-CompletableFuture","date":"2021-02-01T10:56:45.000Z","updated":"2021-02-23T14:28:32.104Z","comments":true,"path":"2021/02/01/java8-CompletableFuture/","link":"","permalink":"https://idea360.cn/2021/02/01/java8-CompletableFuture/","excerpt":"","text":"前言 场景接 Java导入包含图片的Excel。从Excel中获取的图片bytes我们需要上传到阿里云的oss服务, 然后将图片的url回填到Excel的图片字段。 基本使用 java8新特性~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.example;import org.junit.jupiter.api.Test;import java.util.Arrays;import java.util.List;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.stream.Collectors;import java.util.stream.Stream;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;/** * @author cuishiying * @date 2021-01-22 */public class CompletableFutureTest &#123; // 获取一个已经完成的 CompletableFuture 对象 @Test void completedFuture() &#123; CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.completedFuture(&quot;当我遇上你&quot;); assertTrue(completableFuture.isDone()); try &#123; assertEquals(&quot;当我遇上你&quot;, completableFuture.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; // 异步任务获取结果 @Test void supplyAsync() &#123; CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; &quot;当我遇上你&quot;); try &#123; assertEquals(&quot;当我遇上你&quot;, supplyAsync.get()); // Blocking &#125; catch (ExecutionException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 异步任务获取结果+自定义线程池 @Test void supplyAsyncWithExecutor() &#123; ExecutorService threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; &quot;当我遇上你&quot;, threadPool); try &#123; assertEquals(&quot;当我遇上你&quot;, supplyAsync.get()); // Blocking &#125; catch (ExecutionException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 异步结果聚合 @Test void returnList() &#123; ExecutorService threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); List&lt;CompletableFuture&lt;String&gt;&gt; futureList = Arrays.asList(&quot;a&quot;, &quot;b&quot;).stream() .map(i -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;当我遇上你:&quot; + i, threadPool)) .collect(Collectors.toList()); // join 操作等待所有异步操作的结果 List&lt;String&gt; stringList = futureList.stream().map(CompletableFuture::join).collect(Collectors.toList()); // [当我遇上你:a, 当我遇上你:b] System.out.println(stringList); &#125; // 1. 创建异步执行任务, 2. 执行成功逻辑(同步), 3. 执行异常逻辑 @Test void thenAccept() &#123; ExecutorService threadPool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); List&lt;CompletableFuture&lt;String&gt;&gt; futureList = Stream.of(&quot;a&quot;, &quot;b&quot;).map(i -&gt; CompletableFuture .supplyAsync(() -&gt; &quot;当我遇上你:&quot; + i, threadPool) // 返回 .thenApply((result) -&gt; &quot;Hello:&quot; + result) // 不返回结果// .thenAccept((result) -&gt; System.out.println(result)) .exceptionally(Throwable::getMessage)).collect(Collectors.toList()); List&lt;String&gt; stringList = futureList.stream().map(CompletableFuture::join).collect(Collectors.toList()); // [Hello:当我遇上你:a, Hello:当我遇上你:b] System.out.println(stringList); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"异步","slug":"异步","permalink":"https://idea360.cn/tags/%E5%BC%82%E6%AD%A5/"},{"name":"CompletableFuture","slug":"CompletableFuture","permalink":"https://idea360.cn/tags/CompletableFuture/"}]},{"title":"Java开发中如何用POI导入包含图片的Excel文件","slug":"java-poi-import-image","date":"2021-01-30T13:44:26.000Z","updated":"2021-02-23T14:25:16.157Z","comments":true,"path":"2021/01/30/java-poi-import-image/","link":"","permalink":"https://idea360.cn/2021/01/30/java-poi-import-image/","excerpt":"","text":"前言 前导知识 Java开发中如何用POI优雅的导出Excel文件, Java开发中如何用POI优雅的导入Excel文件 本篇基于 注解 + 反射 实现Excel导入功能的实现。 原想把图片上传等方法抽象出来封装一个工具jar, 大家根据业务不同实现不同的逻辑, 由于时间原因, 本篇直接返回图片bytes, 在业务层处理~, 大家如有需求，自行修改源码 实现 还是老规矩, 直接上代码, 说明看注释。 定义Excel注解 12345678910111213141516171819202122232425262728293031323334package com.example.excel;import java.lang.annotation.*;/** * @author cuishiying * @date 2021-01-22 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ExcelHeader &#123; enum Type &#123;TEXT, IMAGE&#125;; /** * 表头 * @return */ String value() default &quot;&quot;; /** * 列索引 * @return */ int columnIndex() default 0; /** * 字段类型 * @return */ Type type() default Type.TEXT;&#125; 定义数据基类 由于图片和数据需要做对应并回填到实体字段中, 所以这里抽取了实体基类 123456789101112131415161718192021222324252627/** * @author cuishiying * @date 2021-01-22 */public class ExcelData implements Serializable &#123; /** * 行号 */ @ExcelHeader(value = &quot;行号&quot;) public String rowIndex; public String getRowIndex() &#123; return rowIndex; &#125; public void setRowIndex(String rowIndex) &#123; this.rowIndex = rowIndex; &#125; @Override public String toString() &#123; return &quot;ExcelData&#123;&quot; + &quot;rowIndex=&#x27;&quot; + rowIndex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276package com.example.excel;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.tuple.Pair;import org.apache.poi.hssf.usermodel.HSSFPatriarch;import org.apache.poi.hssf.usermodel.HSSFShape;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFDrawing;import org.apache.poi.xssf.usermodel.XSSFShape;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.springframework.util.ReflectionUtils;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;import java.math.BigDecimal;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.format.DateTimeFormatter;import java.util.*;import java.util.stream.StreamSupport;import static java.util.stream.Collectors.toList;import static java.util.stream.Collectors.toMap;/** * @author cuishiying * @date 2021-01-22 */@Slf4jpublic class ExcelUtils &#123; static DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); private static final String ROW_INDEX = &quot;rowIndex&quot;; public &lt;T extends ExcelData&gt; List&lt;T&gt; importExcel(InputStream inputStream, Class&lt;T&gt; clz) throws Exception &#123; // 返回数据 List&lt;T&gt; list = new ArrayList&lt;&gt;(); Workbook workbook = WorkbookFactory.create(inputStream); // 读取第一个sheet Sheet sheet = workbook.getSheetAt(0); // 获取最大行数(或者sheet.getLastRowNum()) int rownum = sheet.getPhysicalNumberOfRows(); // 反射获取字段 Field[] fields = clz.getDeclaredFields(); // 获取第一行(表头) Row row = sheet.getRow(0); // 获取最大列数 int column = row.getPhysicalNumberOfCells(); // 表头校验 checkExcelHeader(fields, row); log.info(&quot;Excel导入, ts=[&#123;&#125;], rows=[&#123;&#125;], column=[&#123;&#125;]&quot;, LocalDateTime.now(), rownum, column); // 处理行数据 for (int i = 1; i&lt;rownum; i++) &#123; row = sheet.getRow(i); // 遇到空行则结束 if (row == null) &#123; break; &#125; T instance = clz.getDeclaredConstructor().newInstance(); // 处理列数据 for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelHeader.class)) &#123; // 设置属性可访问 ReflectionUtils.makeAccessible(field); Cell cell = getCell(row, field); if (cell == null) &#123; continue; &#125; // 获取列值 Object value = getCellValue(cell); // 设置属性 setFieldValue(instance, field, value); &#125; &#125; setRowIndex(clz, instance, row.getRowNum()); list.add(instance); &#125; if (log.isDebugEnabled()) &#123; log.debug(&quot;上传数据=&#123;&#125;&quot;, list.toString()); &#125; return list; &#125; public List&lt;Image&gt; getImagesFromExcel(InputStream inputStream) throws IOException &#123; Workbook workbook = WorkbookFactory.create(inputStream); // 读取第一个sheet Sheet sheet = workbook.getSheetAt(0); // 获取第一个sheet的图片数据 return getImagesFromExcel(sheet); &#125; /** * 校验表头是否合法 */ private void checkExcelHeader(Field[] fields, Row row) &#123; for (Field field : fields) &#123; if (field.isAnnotationPresent(ExcelHeader.class)) &#123; Cell cell = getCell(row, field); if (cell == null || (Objects.nonNull(getCellValue(cell)) &amp;&amp; !getCellValue(cell).equals(field.getAnnotation(ExcelHeader.class).value()))) &#123; throw new RuntimeException(&quot;Excel格式错误&quot;); &#125; &#125; &#125; &#125; /** * 为每行数据添加行号 */ private &lt;T extends ExcelData&gt; void setRowIndex(Class&lt;T&gt; clz, T instance, Object rowIndex) throws NoSuchFieldException, IllegalAccessException &#123; Field field = clz.getSuperclass().getDeclaredField(ROW_INDEX); ReflectionUtils.makeAccessible(field); setFieldValue(instance, field, rowIndex); &#125; /** * 从Sheet中提取所有图片 */ private List&lt;Image&gt; getImagesFromExcel(Sheet sheet) &#123; if (sheet instanceof XSSFSheet) &#123; // Excel 2007 XSSFDrawing patriarch = (XSSFDrawing) sheet.createDrawingPatriarch(); List&lt;XSSFShape&gt; shapes = patriarch.getShapes(); return convertShape2Image(sheet, shapes); &#125; else if (sheet instanceof HSSFSheet) &#123; // Excel 2003 HSSFPatriarch patriarch = (HSSFPatriarch) sheet.createDrawingPatriarch(); List&lt;HSSFShape&gt; shapes = patriarch.getChildren(); return convertShape2Image(sheet, shapes); &#125; return Collections.emptyList(); &#125; /** * 将Shape转换为图片 */ private List&lt;Image&gt; convertShape2Image(Sheet sheet, Collection&lt;? extends Shape&gt; shapes) &#123; Map&lt;Integer, byte[]&gt; imageByLocations = shapes.stream() .filter(Picture.class::isInstance) .map(s -&gt; (Picture) s) .map(this::toMapEntry) .collect(toMap(Pair::getKey, Pair::getValue)); return StreamSupport.stream(sheet.spliterator(), false) .filter(this::isNotHeader) .map(row -&gt; new Image(String.valueOf(row.getRowNum()), imageByLocations.get(row.getRowNum()))) .collect(toList()); &#125; /** * 判断是否为标题头 */ boolean isNotHeader(Row row) &#123; return row.getRowNum() != 0; &#125; Pair&lt;Integer, byte[]&gt; toMapEntry(Picture picture) &#123; byte[] data = picture.getPictureData().getData(); ClientAnchor anchor = picture.getClientAnchor(); if (log.isDebugEnabled()) &#123; log.debug(&quot;行: &#123;&#125;, 列: &#123;&#125;, 格式: &#123;&#125;&quot;, anchor.getRow1(), anchor.getCol1(), picture.getPictureData().suggestFileExtension()); &#125; return Pair.of(anchor.getRow1(), data); &#125; /** * 图片包装类 */ static class Image &#123; // 行号, 作为唯一id String rowIndex; // 图片数据 byte[] bytes; Image(String rowIndex, byte[] bytes) &#123; this.rowIndex = rowIndex; this.bytes = bytes; &#125; &#125; static class ImageUrl &#123; // 行号, 作为唯一id String rowIndex; // 图片url String url; ImageUrl(String rowIndex, String url) &#123; this.rowIndex = rowIndex; this.url = url; &#125; &#125; private static Object getCellValue(Cell cell) &#123; CellType cellType = cell.getCellType(); Object cellValue = null; switch (cellType) &#123; case STRING: cellValue = cell.getStringCellValue(); break; case BOOLEAN: cellValue = cell.getBooleanCellValue(); break; case ERROR: cellValue = cell.getErrorCellValue(); break; case NUMERIC: // 数值型 if (DateUtil.isCellDateFormatted(cell)) &#123; // 日期类型 Date d = cell.getDateCellValue(); cellValue = dateTimeFormatter.format(LocalDateTime.ofInstant(d.toInstant(), ZoneId.systemDefault())); &#125; else &#123; double numericCellValue = cell.getNumericCellValue(); BigDecimal bdVal = BigDecimal.valueOf(numericCellValue); if ((bdVal + &quot;.0&quot;).equals(Double.toString(numericCellValue))) &#123; // 整型 cellValue = bdVal; &#125; else if (String.valueOf(numericCellValue).contains(&quot;E10&quot;)) &#123; // 科学记数法 cellValue = BigDecimal.valueOf(numericCellValue).toPlainString(); &#125; else &#123; // 浮点型 cellValue = numericCellValue; &#125; &#125; break; default: break; &#125; if (log.isDebugEnabled()) &#123; log.debug(&quot;cellType=&#123;&#125;, cellValue=&#123;&#125;&quot;, cellType.name(), cellValue); &#125; return cellValue; &#125; private static &lt;T&gt; void setFieldValue(T instance, Field field, Object value) throws IllegalAccessException &#123; if (field.getType() == int.class || field.getType() == Integer.class) &#123; field.set(instance, value); &#125; else if (field.getType() == long.class || field.getType() == Long.class) &#123; field.set(instance, value); &#125; else if (field.getType() == double.class || field.getType() == Double.class) &#123; field.set(instance, value); &#125; else if (field.getType() == String.class) &#123; field.set(instance, String.valueOf(value)); &#125; else if (field.getType() == LocalDateTime.class) &#123; field.set(instance, LocalDateTime.parse(String.valueOf(value), dateTimeFormatter)); &#125; &#125; private Cell getCell(Row row, Field field) &#123; ExcelHeader annotation = field.getAnnotation(ExcelHeader.class); return row.getCell(annotation.columnIndex()); &#125; private void saveImage2Disk(byte[] data, String path, String imageName, String ext) throws IOException &#123; String filePath = path + imageName + &quot;.&quot; + ext; log.info(&quot;saveImage2Disk: [&#123;&#125;]&quot;, filePath); FileOutputStream out = new FileOutputStream(filePath); out.write(data); out.close(); &#125;&#125; 测试 假设我们需要导入微信相关信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.excel;import lombok.Data;import lombok.ToString;/** * @author cuishiying * @date 2021-01-22 */@Data@ToString(callSuper = true)public class WeixinData extends ExcelData &#123; /** * 号码池名称 */ @ExcelHeader(value = &quot;号码池名称&quot;, columnIndex = 0) private String name; /** * 微信号 */ @ExcelHeader(value = &quot;微信号&quot;, columnIndex = 1) private String weixin; /** * 微信二维码 */ @ExcelHeader(value = &quot;微信二维码&quot;, columnIndex = 2, type = ExcelHeader.Type.IMAGE) private String qrCode; /** * 权重 */ @ExcelHeader(value = &quot;权重&quot;, columnIndex = 3) private String weight; /** * 启用禁用 */ @ExcelHeader(value = &quot;状态&quot;, columnIndex = 4) private String enable;&#125; 模拟导入Excel文件 123456789101112131415/** * @author cuishiying * @date 2021-01-22 */@Slf4jpublic class Main &#123; public static void main(String[] args) throws Exception &#123; String excelFilePath = &quot;/Users/cuishiying/Desktop/微信号码池导入模板2003.xls&quot;; ExcelUtils excelUtils = new ExcelUtils(); List&lt;WeixinData&gt; weixinData = excelUtils.importExcel(new FileInputStream(excelFilePath), WeixinData.class); List&lt;ExcelUtils.Image&gt; imagesFromExcel = excelUtils.getImagesFromExcel(new FileInputStream(excelFilePath)); log.info(weixinData.toString()); &#125;&#125; 输出结果 121:43:16.084 [main] INFO com.example.excel.Main - [WeixinData(super&#x3D;ExcelData&#123;rowIndex&#x3D;&#39;1&#39;&#125;, name&#x3D;号码池1, weixin&#x3D;mini-code1, qrCode&#x3D;null, weight&#x3D;10.0, enable&#x3D;启用), WeixinData(super&#x3D;ExcelData&#123;rowIndex&#x3D;&#39;2&#39;&#125;, name&#x3D;号码池2, weixin&#x3D;moni-code2, qrCode&#x3D;null, weight&#x3D;20.0, enable&#x3D;启用)] 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"excel","slug":"excel","permalink":"https://idea360.cn/tags/excel/"},{"name":"poi","slug":"poi","permalink":"https://idea360.cn/tags/poi/"}]},{"title":"SpringBoot监控之prometheus","slug":"springboot-prometheus","date":"2021-01-18T12:57:45.000Z","updated":"2021-03-03T15:30:28.501Z","comments":true,"path":"2021/01/18/springboot-prometheus/","link":"","permalink":"https://idea360.cn/2021/01/18/springboot-prometheus/","excerpt":"","text":"前言 配置监控时，我们首要面对的是监控数据如果采集的问题。一般我们可以把监控指标分为两类：基础监控和业务监控。监控的目的无非是为了解服务运行状况、发现服务故障和帮助定位故障原因。 基础监控 包括 CPU、内存、磁盘、端口和进程等机器、网络的操作系统级别的信息。通常情况下，成熟的监控系统（例如开源的 Prometheus、Zabbix 等）均会提供基础监控项的采集能力，这里不做过多介绍。但需要注意的一点，机器级别的基础监控指标一般并不能代表服务的真实运行状况，例如单台实例的故障对一个设计合理的分布式系统来说并不会带来严重后果。所以只有结合业务相关监控指标，基础监控指标才有意义。 业务监控 业务监控指标由业务系统内部的服务产生，一般能够真实反应业务运行状态。设计合理的系统一般都会提供相关监控指标供监控系统采集。监控数据的采集方法一般可以分为以下几大类。 日志：日志可以包含服务运行的方方面面，是重要的监控数据来源。例如，通过 Nginx access 日志可以统计出错误（5xx）、延迟（响应时间）和流量，结合已知的容量上限就可以计算出饱和度。一般除监控系统提供的日志采集插件外，如 Rsyslog、Logstash、Filebeat、Flume 等都是比较优秀的日志采集软件。 JMX：多数 Java 开发的服务均可由 JMX 接口输出监控指标。不少监控系统也有集成 JMX 采集插件，除此之外我们也可通过 jmxtrans、jmxcmd 工具进行采集。 REST：提供 REST API 来进行监控数据的采集，如 Hadoop、ElasticSearch。 OpenMetrics：得益于 Prometheus 的流行，作为 Prometheus 的监控数据采集方案，OpenMetrics 可能很快会成为未来监控的业界标准。目前绝大部分热门开源服务均有官方或非官方的 exporter 可供使用。 命令行：一些服务提供本地的命令来输出监控指标。 主动上报：对于采用 PUSH 模型的监控系统来说，服务可以采取主动上报的方式把监控指标 push 到监控系统，如 Java 服务可使用 Metrics 接口自定义 sink 输出。另外，运维也可以使用自定义的监控插件来完成监控的采集。 埋点：埋点是侵入式的监控数据采集方式，其优点是其可以更灵活地为我们提供业务内部的监控指标，当然缺点也很明显：需要在代码层面动手脚（常常需要研发支持，成本较高）。 其它方式：以上未涵盖的监控指标采集方式，例如 Zookeeper 的四字命令，MySQL 的 show status 命令。 黄金指标 延迟 通讯量 错误 饱和度 搭建环境 12345678# 安装prometheusbrew install prometheus# 安装grafanabrew install grafana# 查看配置文件路径及如何启动brew info prometheus springboot配置 maven依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 123456789101112131415161718management: endpoints: web: exposure: include: prometheus,health,info,metric metrics: export: prometheus: enabled: true tags: application: $&#123;spring.application.name&#125; endpoint: health: show-details: alwaysinfo: app: name: $&#123;spring.application.name&#125; 启动类注入bean 123456789101112131415161718192021222324252627282930313233343536373839@Slf4j@EnableDiscoveryClient@SpringBootApplicationpublic class NlpKbProxyApplication &#123; private static final String line = &quot;\\n----------------------------------------------------------&quot;; public static void main(String[] args) throws UnknownHostException&#123; ConfigurableApplicationContext context = SpringApplication.run(NlpKbProxyApplication.class, args); String swaggerEnabled = context.getEnvironment().getProperty(&quot;swagger.enabled&quot;); afterRun(context, Boolean.parseBoolean(swaggerEnabled)); &#125; private static void afterRun(ConfigurableApplicationContext applicationContext, boolean swaggerEnabled) throws UnknownHostException &#123; if (swaggerEnabled) &#123; AbstractServletWebServerFactory webServerFactory = applicationContext.getBean(AbstractServletWebServerFactory.class); int port = webServerFactory.getPort(); String contextPath = webServerFactory.getContextPath(); log.info(&quot;\\n访问swaggger接口调试 URLs:&quot; + line + &quot;\\n&quot; + &quot;Local: \\t\\thttp://&#123;&#125;:&#123;&#125;&#123;&#125;/swagger-ui/index.html&quot; + line , InetAddress.getLocalHost().getHostAddress(), port, contextPath); log.info(&quot;\\n健康检查 URLs:&quot; + line + &quot;\\n&quot; + &quot;Local: \\t\\thttp://&#123;&#125;:&#123;&#125;&#123;&#125;/actuator&quot; + line , InetAddress.getLocalHost().getHostAddress(), port, contextPath); &#125; &#125; @Bean MeterRegistryCustomizer&lt;MeterRegistry&gt; configurer( @Value(&quot;$&#123;spring.application.name&#125;&quot;) String applicationName) &#123; return (registry) -&gt; registry.config().commonTags(&quot;application&quot;, applicationName); &#125;&#125; metrix指标 访问 http://localhost:8080/actuator, 可以看到 123456789101112131415161718192021222324&#123; &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://localhost:8080/actuator&quot;, &quot;templated&quot;: false &#125;, &quot;health-path&quot;: &#123; &quot;href&quot;: &quot;http://localhost:8080/actuator/health/&#123;*path&#125;&quot;, &quot;templated&quot;: true &#125;, &quot;health&quot;: &#123; &quot;href&quot;: &quot;http://localhost:8080/actuator/health&quot;, &quot;templated&quot;: false &#125;, &quot;info&quot;: &#123; &quot;href&quot;: &quot;http://localhost:8080/actuator/info&quot;, &quot;templated&quot;: false &#125;, &quot;prometheus&quot;: &#123; &quot;href&quot;: &quot;http://localhost:8080/actuator/prometheus&quot;, &quot;templated&quot;: false &#125; &#125;&#125; 系统指标 如果要监控系统基础指标, 此时并没有metrix, 需要在 prometheus.yml 中监听9100端口采集的metrix。 下载系统 node_exporter, 访问 https://prometheus.io/download/, 如图 启动后访问 http://localhost:9100/, 可以看到系统metrix。启动日志如下: 123456789101112131415161718➜ node_exporter-1.1.1.darwin-amd64 .&#x2F;node_exporterlevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:178 msg&#x3D;&quot;Starting node_exporter&quot; version&#x3D;&quot;(version&#x3D;1.1.1, branch&#x3D;HEAD, revision&#x3D;4e837d4da79cc59ee3ed1471ba9a0d9547e95540)&quot;level&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:179 msg&#x3D;&quot;Build context&quot; build_context&#x3D;&quot;(go&#x3D;go1.15.8, user&#x3D;root@f9e5f7d18c30, date&#x3D;20210213-13:38:51)&quot;level&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;filesystem_common.go:74 collector&#x3D;filesystem msg&#x3D;&quot;Parsed flag --collector.filesystem.ignored-mount-points&quot; flag&#x3D;^&#x2F;(dev)($|&#x2F;)level&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;filesystem_common.go:76 collector&#x3D;filesystem msg&#x3D;&quot;Parsed flag --collector.filesystem.ignored-fs-types&quot; flag&#x3D;^devfs$level&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:106 msg&#x3D;&quot;Enabled collectors&quot;level&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;boottimelevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;cpulevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;diskstatslevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;filesystemlevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;loadavglevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;meminfolevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;netdevlevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;textfilelevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;timelevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.925Z caller&#x3D;node_exporter.go:113 collector&#x3D;unamelevel&#x3D;info ts&#x3D;2021-02-26T16:35:39.926Z caller&#x3D;node_exporter.go:195 msg&#x3D;&quot;Listening on&quot; address&#x3D;:9100level&#x3D;info ts&#x3D;2021-02-26T16:35:39.926Z caller&#x3D;tls_config.go:191 msg&#x3D;&quot;TLS is disabled.&quot; http2&#x3D;false 更多exporters: https://prometheus.io/docs/instrumenting/exporters/ 配置prometheus prometheus会主动从应用拉取数据, 所以我们需要配置prometheus。 vim /usr/local/etc/prometheus.yml 123456789101112131415161718192021222324252627282930313233343536global: # 默认每隔15秒执行一次表达式判断告警规则 scrape_interval: 15s # 默认每隔15秒向各个监控端点拉取一次指标数据 evaluation_interval: 15s # scrape_timeout is set to the global default (10s). # Attach these labels to any time series or alerts when communicating with # external systems (federation, remote storage, Alertmanager). external_labels: monitor: &#39;codelab-monitor&#39;rule_files: # 表达式计算和记录，告警规则等自定义的配置文件 # - &quot;first.rules&quot; # - &quot;second.rules&quot;# A scrape configuration containing exactly one endpoint to scrape:# Here it&#39;s Prometheus itself.scrape_configs: - job_name: &quot;prometheus&quot; static_configs: # 两个监控的端点，9090是Prometheus自己，9100是机器的监控组件Node Exporter - targets: [&#39;127.0.0.1:9090&#39;, &#39;127.0.0.1:9100&#39;] - job_name: &#39;demo-java&#39; # job name metrics_path: &#39;&#x2F;actuator&#x2F;prometheus&#39; # 指标获取路径, 默认 &#39;&#x2F;metrics&#39; scrape_interval: 5s # pull模式, 抓取间隔# basic_auth: # Spring Security basic auth # username: &#39;actuator&#39;# password: &#39;actuator&#39; static_configs: - targets: [&#39;127.0.0.1:8080&#39;] # 实例的地址，默认的协议是http labels: instance: demo-java 访问 http://localhost:9090/targets 查看实例 配置grafana grafana默认帐号密码 admin/admin, 访问 http://localhost:3000/ 登录 配置数据源 配置数据源 这里我们选择 prometheus 填写prometheus地址 http://localhost:9090 主题配置 导入dashboard 访问 https://grafana.com/grafana/dashboards 选择 dashboard 主题. 8919主题 1860主题 4701主题 10280主题 12856主题 Docker环境搭建 我们以 windows 环境为例 prometheus 1docker run -d --name&#x3D;prometheus -p 9090:9090 -v E:&#x2F;docker&#x2F;prometheus&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml prom&#x2F;prometheus 下载(https://github.com/prometheus/node_exporter)并运行node_exporter。metrix地址 http://192.168.141.1:9182/metrics prometheus.yml 123456789101112131415161718192021222324252627282930313233343536373839404142# my global configglobal: scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s). # Attach these labels to any time series or alerts when communicating with # external systems (federation, remote storage, Alertmanager). external_labels: monitor: &#x27;codelab-monitor&#x27;# Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.rule_files: # - &quot;first.rules&quot; # - &quot;second.rules&quot;# A scrape configuration containing exactly one endpoint to scrape:# Here it&#x27;s Prometheus itself.scrape_configs: # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config. - job_name: &#x27;prometheus&#x27; # metrics_path defaults to &#x27;/metrics&#x27; # scheme defaults to &#x27;http&#x27;. static_configs: - targets: [&#x27;host.docker.internal:9090&#x27;] # Only works on Docker Desktop for Windows - job_name: &#x27;eachbot-nlp-kb-proxy&#x27; metrics_path: &#x27;/kbp/actuator/prometheus&#x27; # 指标获取路径 # scheme defaults to &#x27;http&#x27;. static_configs: - targets: [&#x27;192.168.141.1:7103&#x27;] labels: instance: eachbot-nlp-kb-proxy - job_name: windows static_configs: - targets: [&#x27;192.168.141.1:9182&#x27;] labels: instance: localhost grafana 1docker run -d --name&#x3D;grafana --restart&#x3D;always -p 3000:3000 grafana&#x2F;grafana 选择windows下dashboard主题10467 业务指标 Metrics 种类 Prometheus 客户端库主要提供四种主要的 Metrics 类型： Counter（计数器） 一种累加的 Metrics，始终增加。典型的应用如：http 请求的个数，结束的任务数，出现的错误数等等。一般在定义Counter类型指标的名称时推荐使用_total作为后缀。 Gauge（测量仪） 一种常规的 Metrics，仪表盘，当前值的一次快照(snapshot)测量，可增可减。典型的应用如：当前同时在线用户数、温度、内存使用率，运行的 goroutines 的个数，可以任意加减。 Histogram(直方图) 可以理解为柱状图，通过分桶(bucket)方式统计样本分布。典型的应用如：请求持续时间，响应大小，可以对观察结果采样，分组及统计。 类型为Histogram的监控指标prometheus_tsdb_compaction_chunk_range_bucket。 123456789101112131415# HELP prometheus_tsdb_compaction_chunk_range Final time range of chunks on their first compaction# TYPE prometheus_tsdb_compaction_chunk_range histogramprometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;100&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;400&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;1600&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;6400&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;25600&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;102400&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;409600&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;1.6384e+06&quot;&#125; 260prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;6.5536e+06&quot;&#125; 780prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;2.62144e+07&quot;&#125; 780prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;+Inf&quot;&#125; 780prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09prometheus_tsdb_compaction_chunk_range_count 780 从样本可以看出, 小于1.6384e+06的样本数为260, 小于 6.5536e+06的样本数为780, 总样本为780. Summary（汇总） 根据样本统计出百分位 类似于Histogram。典型的应用如：请求持续时间，响应大小，提供观测值的 count 和 sum 功能，提供百分位的功能，即可以按百分比划分跟踪结果。 例如，指标prometheus_tsdb_wal_fsync_duration_seconds的指标类型为Summary。 它记录了Prometheus Server中wal_fsync处理的处理时间，通过访问Prometheus Server的/metrics地址，可以获取到以下监控样本数据： 1234567# HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.# TYPE prometheus_tsdb_wal_fsync_duration_seconds summaryprometheus_tsdb_wal_fsync_duration_seconds&#123;quantile&#x3D;&quot;0.5&quot;&#125; 0.012352463prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile&#x3D;&quot;0.9&quot;&#125; 0.014458005prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile&#x3D;&quot;0.99&quot;&#125; 0.017316173prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002prometheus_tsdb_wal_fsync_duration_seconds_count 216 从上面的样本中可以得知当前Prometheus Server进行wal_fsync操作的总次数为216次，耗时2.888716127000002s。其中中位数（quantile=0.5）的耗时为0.012352463，9分位数（quantile=0.9）的耗时为0.014458005s。 表达式 rate[1m]：表示 1 分钟的增长速率，只能用于 counter 类型的数据。 sum：表示 value 求和。 by type：表示将求和后的数据按 metric 原始值中的 type 进行分组。 Legend format：表示指标名称的格式。 Resolution：默认打点步长是 15s，Resolution 表示是否将多个样本数据合并成一个点。 性能指标-接口平均响应时间 5分钟内请求总时间除以总次数得到api响应时间均值 1rate(api_request_duration_milliseconds_sum&#123;route&#x3D;&quot;g&#x2F;search&quot;, method&#x3D;&quot;POST&quot;&#125;[5m]) &#x2F; rate(api_request_duration_milliseconds_count&#123;route&#x3D;&quot;g&#x2F;search&quot;, method&#x3D;&quot;POST&quot;&#125;[5m]) 发现慢接口 1234567topk(20, sum by (route) ( rate(api_request_duration_milliseconds_sum&#123;status_code!&#x3D;&quot;500&quot;, method!&#x3D;&quot;OPTIONS&quot;&#125;[2m]) &#x2F; rate(api_request_duration_milliseconds_count&#123;status_code!&#x3D;&quot;500&quot;, method!&#x3D;&quot;OPTIONS&quot;&#125;[2m]) )) sum byroute 的响应时间 取Top20，得到响应时间慢的API 1topk(10, sum by (route) (rate(api_request_duration_milliseconds_count&#123;status_code!&#x3D;&quot;500&quot;&#125;[5m]))) 稍微调整下可以拿到当前时间请求频繁的接口 失败接口 基于方法和错误码统计Center的整体 rpc 请求错误频率: 1sum by (method, code) (rate(rpc_invoke_cnt_c&#123;job&#x3D;&quot;Center&quot;,code!&#x3D;&quot;0&quot;&#125;[1m])) QPS QPS 的话，可以使用自带的函数 rate，rate(http_requests_total[10s]) 表示以 10s 作为时间单元来统计 QPS。 AOP采集metrix指标 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 123456@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;PrometheusMetricsRegistrar.class&#125;)public @interface EnablePrometheus &#123;&#125; 12345678public class PrometheusMetricsRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; BeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(PrometheusMetricsAspect.class).getBeanDefinition(); registry.registerBeanDefinition(&quot;prometheusMetricsAspect&quot;, beanDefinition); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Component@Aspectpublic class PrometheusMetricsAspect &#123; private final Log logger = LogFactory.getLog(getClass()); @Autowired private CollectorRegistry collectorRegistry; // 折线图 private Counter requestTotal; // 折线图 private Counter requestError; // 折线图 private Histogram apiTimeConsuming; @PostConstruct private void init()&#123; requestTotal = Counter.build().name(&quot;easyliao_http_requests_total&quot;).labelNames(&quot;uri&quot;, &quot;method&quot;, &quot;status&quot;) .help(&quot;http请求总数&quot;).register(collectorRegistry); requestError = Counter.build().name(&quot;easyliao_http_requests_error&quot;).labelNames(&quot;uri&quot;, &quot;method&quot;, &quot;status&quot;) .help(&quot;http请求错误数&quot;).register(collectorRegistry); apiTimeConsuming = Histogram.build().name(&quot;easyliao_api_time_consuming&quot;).labelNames(&quot;uri&quot;, &quot;method&quot;, &quot;status&quot;) .help(&quot;接口耗时&quot;).buckets(0.01, 0.02, 0.05, 0.1, 0.2, 0.5).register(collectorRegistry); &#125; @Pointcut(&quot;@annotation(com.easyliao.monitor.annotation.PrometheusMetrics)&quot;) public void api() &#123;&#125; @Around(value = &quot;api()&quot;) public Object metricsCollector(ProceedingJoinPoint point) throws Throwable &#123; MethodSignature methodSignature = (MethodSignature) point.getSignature(); PrometheusMetrics prometheusMetrics = methodSignature.getMethod().getAnnotation(PrometheusMetrics.class); if (prometheusMetrics != null) &#123; String uri; HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()) .getRequest(); HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()) .getResponse(); if (StringUtils.isNotEmpty(prometheusMetrics.name())) &#123; uri = prometheusMetrics.name(); &#125; else &#123; uri = request.getRequestURI(); &#125; String method = request.getMethod(); int status = response.getStatus(); requestTotal.labels(uri, method, String.valueOf(status)).inc(); Histogram.Timer requestTimer = apiTimeConsuming.labels(uri, method, String.valueOf(status)).startTimer(); Object object; try &#123; object = point.proceed(); &#125; catch (Exception e) &#123; requestError.labels(uri, method, String.valueOf(status)).inc(); throw e; &#125; finally &#123; requestTimer.observeDuration(); &#125; return object; &#125; else &#123; return point.proceed(); &#125; &#125;&#125; 123456789101112@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface PrometheusMetrics &#123; /** * 默认为空,程序使用method signature作为Metric name 如果name有设置值,使用name作为Metric name * * @return */ String name() default &quot;&quot;;&#125; 拦截器采集metrix指标 123456789101112131415161718192021222324/** * 请求总量的监控Counter * * @author cuishiying * @date 2021-01-22 */@Componentpublic class CounterMetrics &#123; @Autowired private CollectorRegistry collectorRegistry; /** * name: 指标的名称 * labelNames: 该metrics拥有的维度label * @return */ @Bean public Counter httpRequestsTotalCounterCollector() &#123; return Counter.build().name(&quot;http_requests_total&quot;).labelNames(&quot;path&quot;, &quot;method&quot;, &quot;code&quot;).help(&quot;http请求总计数&quot;) .register(collectorRegistry); &#125;&#125; 123456789101112131415161718192021/** * 当前正在处理的http请求数 * * @author cuishiying * @date 2021-01-22 */@Componentpublic class GuageMetrics &#123; @Autowired private CollectorRegistry collectorRegistry; @Bean public Gauge httpInprogressRequestsGuageCollector() &#123; return Gauge.build() .name(&quot;http_inprogress_requests&quot;).labelNames(&quot;path&quot;, &quot;method&quot;, &quot;code&quot;) .help(&quot;http当前正在处理的请求数&quot;).register(collectorRegistry); &#125;&#125; 1234567891011121314151617181920212223/** * 自带buckets区间用于统计分布统计图 * * @author cuishiying * @date 2021-01-22 */@Componentpublic class HistogramMetrics &#123; @Autowired private CollectorRegistry collectorRegistry; @Bean public Histogram httpRequestsBytesHistogramCollector() &#123; return Histogram.build().labelNames(&quot;path&quot;, &quot;method&quot;, &quot;code&quot;) .name(&quot;http_requests_bytes_histogram&quot;).help(&quot;http bucket 请求大小区间分布图&quot;) .register(collectorRegistry); &#125;&#125; 1234567891011121314151617181920@Componentpublic class SummaryMetrics &#123; @Autowired private CollectorRegistry collectorRegistry; /** * name: 指标的名称 * labelNames: 该metrics拥有的维度label * @return */ @Bean public Summary httpRequestsBytesSummaryCollector() &#123; return Summary.build() .name(&quot;http_requests_bytes_summary&quot;) .labelNames(&quot;path&quot;, &quot;method&quot;, &quot;code&quot;) .help(&quot;Request bytes &quot;).register(collectorRegistry); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Slf4jpublic class PrometheusInterceptor implements HandlerInterceptor &#123; // http请求总数 @Autowired @Qualifier(&quot;httpRequestsTotalCounterCollector&quot;) private Counter httpRequestsTotalCounterCollector; // 当前正在处理的请求数 @Autowired @Qualifier(&quot;httpInprogressRequestsGuageCollector&quot;) private Gauge httpInprogressRequestsGuageCollector; // http请求内容长度的区间分布图 @Autowired @Qualifier(&quot;httpRequestsBytesHistogramCollector&quot;) private Histogram httpRequestsBytesHistogramCollector; // 百分位数 @Autowired @Qualifier(&quot;httpRequestsBytesSummaryCollector&quot;) private Summary httpRequestsBytesSummaryCollector; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(&quot;Prometheus intercrptor preHandle ...&quot;); String requestURI = request.getRequestURI(); String method = request.getMethod(); int status = response.getStatus(); // 对应 &quot;path&quot;, &quot;method&quot;, &quot;code&quot; 3个纬度 httpRequestsTotalCounterCollector.labels(requestURI, method, String.valueOf(status)).inc(); //当前正在处理的请求数 + 1 httpInprogressRequestsGuageCollector.labels(requestURI, method, String.valueOf(status)).inc(); //请求大小 httpRequestsBytesHistogramCollector.labels(requestURI, method, String.valueOf(status)).observe(request.getContentLength()); // 百分位 httpRequestsBytesSummaryCollector.labels(requestURI, method, String.valueOf(status)).observe(new Random().nextInt(100)); return HandlerInterceptor.super.preHandle(request, response, handler); &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; String requestURI = request.getRequestURI(); String method = request.getMethod(); int status = response.getStatus(); //当前正在处理的请求数 - 1 httpInprogressRequestsGuageCollector.labels(requestURI, method, String.valueOf(status)).dec(); HandlerInterceptor.super.afterCompletion(request, response, handler, ex); &#125;&#125; 1234567891011121314@Configurationpublic class InterceptorConfiguration implements WebMvcConfigurer &#123; @Bean public HandlerInterceptor prometheusInterceptor() &#123; return new PrometheusInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(prometheusInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/quickstart/why-monitor http://code2life.top/2020/02/28/0048-prometheus-in-action-start/ https://www.infoq.cn/article/txmnqw_d7hpi8kyxf4wz https://www.cnblogs.com/chanshuyi/p/07_springboot_custom_index_monitor.html https://www.shuzhiduo.com/A/x9J26NaZJ6/ https://xinlichao.cn/back-end/java/prometheus/ https://gitee.com/ITEater/prometheus-spring-boot-starter https://www.infoq.cn/article/rpzvedlkpocfrnxta2al https://sb-woms.gitbook.io/sb/prometheus/springboot-prometheus-05 https://docs.pingcap.com/zh/tidb/stable/grafana-monitor-best-practices","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"监控","slug":"监控","permalink":"https://idea360.cn/tags/%E7%9B%91%E6%8E%A7/"},{"name":"prometheus","slug":"prometheus","permalink":"https://idea360.cn/tags/prometheus/"}]},{"title":"springboot发布脚本","slug":"springboot-deploy-shell","date":"2021-01-15T08:39:48.000Z","updated":"2021-02-23T14:46:17.686Z","comments":true,"path":"2021/01/15/springboot-deploy-shell/","link":"","permalink":"https://idea360.cn/2021/01/15/springboot-deploy-shell/","excerpt":"","text":"启动脚本 startup.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#! /bin/bash#===========================================================================================# 基础配置#===========================================================================================# 项目名export APPLICATION=&quot;eachbot-kbs&quot;# 项目启动jar包名称export APPLICATION_JAR=$&#123;APPLICATION&#125;.jar# Java指令路径export JAVA=&quot;$JAVA_HOME/bin/java&quot;# 脚本上级绝对目录($0:当前脚本的文件名, $1:代表输入的第一个参数, $2:代表输入的第二个参数)export BASE_DIR=`cd $(dirname $0); pwd`# 默认配置文件路径export DEFAULT_SEARCH_LOCATIONS=&quot;classpath:/,classpath:/config/,file:./,file:./config/&quot;# 配置文件路径export CONFIG_DIR=file:$&#123;BASE_DIR&#125;/conf/,$&#123;DEFAULT_SEARCH_LOCATIONS&#125;# 获取PID指令(PID = $(eval $PID_CMD))export PID_CMD=&quot;ps -ef |grep $APPLICATION_JAR |grep -v grep |awk &#x27;&#123;print \\$2&#125;&#x27;&quot;#===========================================================================================# JVM 虚拟机配置#===========================================================================================JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$&#123;BASE_DIR&#125;/logs/java_heapdump.hprof&quot;JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:-UseLargePages&quot;JAVA_VERSION=$($JAVA -version 2&gt;&amp;1 | sed -E -n &#x27;s/.* version &quot;([0-9]*).*$/\\1/p&#x27;)echo &quot;java version: $JAVA_VERSION&quot;if [[ &quot;$JAVA_VERSION&quot; -ge &quot;9&quot; ]] ; then JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -Xlog:gc*:file=$&#123;BASE_DIR&#125;/logs/gc.log:time,tags:filecount=10,filesize=102400&quot;else JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -Djava.ext.dirs=$&#123;JAVA_HOME&#125;/jre/lib/ext:$&#123;JAVA_HOME&#125;/lib/ext&quot; JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -Xloggc:$&#123;BASE_DIR&#125;/logs/gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M&quot;fi# 启动springboot服务JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -jar $&#123;BASE_DIR&#125;/$&#123;APPLICATION_JAR&#125;&quot;#JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; --spring.config.location=$&#123;CUSTOM_SEARCH_LOCATIONS&#125;&quot;#JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; --logging.config=$&#123;BASEDIR&#125;/conf/logback-custom.xml&quot;JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; --server.max-http-header-size=524288&quot;if [ ! -d &quot;$&#123;BASE_DIR&#125;/logs&quot; ]; then mkdir $&#123;BASE_DIR&#125;/logsfiif [ ! -f &quot;$&#123;BASE_DIR&#125;/logs/start.out&quot; ]; then touch &quot;$&#123;BASE_DIR&#125;/logs/start.out&quot;fi#===========================================================================================# 输出配置信息#===========================================================================================# 当前时间NOW=$(date +&quot;%Y-%m-%m %H:%M:%S&quot;)# 输出当前启动时间echo &quot;================================================ $&#123;NOW&#125; ================================================&quot;# 显示系统信息echo &quot;system info: `uname`&quot;# 输出项目名称echo &quot;application name: $&#123;APPLICATION&#125;&quot;# 输出jar包名称echo &quot;application jar name: $&#123;APPLICATION_JAR&#125;&quot;# 输出项目根目录echo &quot;application root path: $&#123;BASE_DIR&#125;&quot;# 输出项目bin路径echo &quot;application bin path: $&#123;BASE_DIR&#125;&quot;# 输出配置文件路径echo &quot;application conf path: $&#123;CONFIG_DIR&#125;&quot;# 启动日志路径echo &quot;application start logs: $&#123;BASE_DIR&#125;/logs&quot;# 输出java启动参数echo &quot;application start cmd: $JAVA $&#123;JAVA_OPT&#125; &gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;&quot;#===========================================================================================# 启动服务#===========================================================================================PID=$(eval $PID_CMD)if [[ -n $PID ]]; then echo &quot;$APPLICATION is already running,PID is $PID&quot;else nohup $JAVA $&#123;JAVA_OPT&#125; &gt; /dev/null 2&gt;&amp;1 &amp; PID=$(eval $PID_CMD) if [[ -n $PID ]]; then echo &quot;Start $APPLICATION successfully, PID is $PID, you can check the $&#123;BASE_DIR&#125;/logs/start.out&quot; else echo &quot;Failed to start $APPLICATION !!!&quot; fifi 停止脚本 shutdown.sh 12345678910111213141516171819#! /bin/bash# 项目名export APPLICATION=&quot;eachbot-kbs&quot;# 项目启动jar包名称export APPLICATION_JAR=$&#123;APPLICATION&#125;.jar# 查找进程指令export PID_CMD=&quot;ps -ef |grep $APPLICATION_JAR |grep -v grep |awk &#x27;&#123;print \\$2&#125;&#x27;&quot;PID=$(eval $PID_CMD)if [[ -z $PID ]]then echo $&#123;APPLICATION&#125; is already stoppedelse echo kill $&#123;PID&#125; kill -9 $&#123;PID&#125; echo $&#123;APPLICATION&#125; stopped successfullyfi","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"shell","slug":"shell","permalink":"https://idea360.cn/tags/shell/"},{"name":"脚本","slug":"脚本","permalink":"https://idea360.cn/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Java-sdk的开发","slug":"how-to-create-java-sdk","date":"2021-01-03T04:45:41.000Z","updated":"2021-02-23T14:19:07.669Z","comments":true,"path":"2021/01/03/how-to-create-java-sdk/","link":"","permalink":"https://idea360.cn/2021/01/03/how-to-create-java-sdk/","excerpt":"","text":"前言 在公司的开发中, 我们经常会开发一些jar供其他业务小组使用, 在当前 spring 为主的开发环境下, 我们应该如何去包装一个jar让大家更加方便的使用呢？这里就涉及到sdk的开发, 比如kafka出品的 kafka-client 提供核心业务代码, 然后用 spring-kafka 包装 kafka-client 供 spring 更加方便的调用。这里我们模仿这种思路做一个简单的sdk开发流程介绍。 kafka-client的开发 我们通过构造方法简单的读取参数来模拟一个 kafka-client, 能够将读取的变量打印出来即可。 1234567891011121314151617181920212223242526272829303132/** * @author cc * @description 模拟一个客户端sdk * @date 2020-12-30 */public class KafkaClient &#123; public KafkaClient(Properties properties) &#123; this(propsToMap(properties)); &#125; KafkaClient(Map&lt;String, Object&gt; configs) &#123; ClientConfig config = new ClientConfig(configs); &#125; private static Map&lt;String, Object&gt; propsToMap(Properties properties) &#123; Map&lt;String, Object&gt; map = new HashMap(properties.size()); Iterator var2 = properties.entrySet().iterator(); while(var2.hasNext()) &#123; Map.Entry&lt;Object, Object&gt; entry = (Map.Entry)var2.next(); if (!(entry.getKey() instanceof String)) &#123; throw new RuntimeException(entry.getKey().toString() + entry.getValue() + &quot;Key must be a string.&quot;); &#125; String k = (String)entry.getKey(); map.put(k, properties.get(k)); &#125; return map; &#125;&#125; 配置文件对象 1234567public class ClientConfig extends AbstractConfig&#123; public ClientConfig(Map&lt;String, Object&gt; props) &#123; super(props, true); &#125;&#125; 123456789101112public class AbstractConfig &#123; Logger logger = Logger.getLogger(&quot;AbstractConfig&quot;); public AbstractConfig(Map&lt;?, ?&gt; originals, boolean doLog) &#123; for (Map.Entry&lt;?, ?&gt; entry : originals.entrySet()) &#123; if (doLog) &#123; logger.info(&quot;读取到配置文件:[&quot; + entry.getKey() + &quot;:&quot; + entry.getValue() + &quot;]&quot;); &#125; &#125; &#125;&#125; 然后我们测试下效果 1234567891011121314151617public class Test &#123; /** * 1月 03, 2021 12:55:48 下午 cn.idea360.AbstractConfig &lt;init&gt; * 信息: 读取到配置文件:[name:admin] * 1月 03, 2021 12:55:48 下午 cn.idea360.AbstractConfig &lt;init&gt; * 信息: 读取到配置文件:[password:123456] * * @param args */ public static void main(String[] args) &#123; Properties properties = new Properties(); properties.setProperty(&quot;name&quot;, &quot;admin&quot;); properties.setProperty(&quot;password&quot;, &quot;123456&quot;); new KafkaClient(properties); &#125;&#125; 由结果可见，我们的sdk已经可以正常使用, 将jar打包进我们的本地maven仓库, 接下来我们来包装spring-boot-adapter kafka-spring-boot-starter开发 我们自定义的starter要遵守官方推荐的命名规范 xxx-spring-boot-starter。 在我们使用开源社区提供的jar包时发现，好多变量在配置的时候是有提示补全功能的，这个我们也来实现下。 首先引入pom.xml依赖 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idea360-kafka-client&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置类 @ConfigurationProperties 注解即是配置变量补全的关键 1234567891011121314151617181920212223@Configuration@ConfigurationProperties(prefix = &quot;idea360.kafka&quot;)public class DemoProperties &#123; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 将配置信息注入sdk的bean对象 kafka-client 中 123456789101112@Configuration@EnableConfigurationProperties(DemoProperties.class)public class DemoConfig &#123; @Bean public KafkaClient kafkaClient(DemoProperties demoProperties) &#123; Properties properties = new Properties(); properties.setProperty(&quot;name&quot;, demoProperties.getName()); properties.setProperty(&quot;password&quot;, demoProperties.getPassword()); return new KafkaClient(properties); &#125;&#125; 按照spring的spi机制定义自启动类。 在 src/main/resources/META-INF/spring.factories 文件中定义 1org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;cn.idea360.starter.DemoConfig 将我们包装好的starter打包进本地maven仓库 自定义starter测试 创建一个普通的spring-boot项目, pom.xml如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idea360-kafka-spring-boot-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;dea360-kafka-spring-boot-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;idea360-kafka-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.idea360.springdemo.SpringDemoApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置application.properties 1234567# 应用名称spring.application.name=idea360-kafka-spring-boot-demo# 应用服务 WEB 访问端口server.port=8080idea360.kafka.name=adminidea360.kafka.password=123456 这里我们看到已经可以自动提示补全参数了 启动springboot项目, 控制台我们看到上边我们配置的参数已经被正确注入到了 kafka-client 中。 122021-01-03 13:10:53.402 INFO 13169 --- [ main] AbstractConfig : 读取到配置文件:[name:admin]2021-01-03 13:10:53.402 INFO 13169 --- [ main] AbstractConfig : 读取到配置文件:[password:123456] 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"sdk","slug":"sdk","permalink":"https://idea360.cn/tags/sdk/"}]},{"title":"AsyncContext使用案例","slug":"AsyncContext-example1","date":"2020-12-26T09:17:28.000Z","updated":"2021-02-23T14:11:45.477Z","comments":true,"path":"2020/12/26/AsyncContext-example1/","link":"","permalink":"https://idea360.cn/2020/12/26/AsyncContext-example1/","excerpt":"","text":"概述 以下案例不只是AsyncContext，还有其他异步实现方案。 案例1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * @author cc * @description * @since 2020-12-18 * https://juejin.cn/post/6844903621826445319 */@RestControllerpublic class WebAsyncController &#123; private final WebAsyncService asyncService; private final static String ERROR_MESSAGE = &quot;Task error&quot;; private final static String TIME_MESSAGE = &quot;Task timeout&quot;; @Autowired @Qualifier(&quot;taskExecutor&quot;) private ThreadPoolTaskExecutor executor; @Autowired public WebAsyncController(WebAsyncService asyncService) &#123; this.asyncService = asyncService; &#125; /** * http://localhost:8080/completion * @return */ @GetMapping(&quot;/completion&quot;) public WebAsyncTask&lt;String&gt; asyncTaskCompletion() &#123; // 打印处理线程名 out.println(format(&quot;请求处理线程：%s&quot;, currentThread().getName())); // 模拟开启一个异步任务，超时时间为10s WebAsyncTask&lt;String&gt; asyncTask = new WebAsyncTask&lt;&gt;(5 * 1000L, () -&gt; &#123; out.println(format(&quot;异步工作线程：%s&quot;, currentThread().getName())); // 任务处理时间5s，不超时 sleep(3 * 1000L); return asyncService.generateUUID(); &#125;); // 任务执行完成时调用该方法 asyncTask.onCompletion(() -&gt; out.println(&quot;任务执行完成&quot;)); out.println(&quot;继续处理其他事情&quot;); return asyncTask; &#125; /** * http://localhost:8080/exception * @return */ @GetMapping(&quot;/exception&quot;) public WebAsyncTask&lt;String&gt; asyncTaskException() &#123; // 打印处理线程名 out.println(format(&quot;请求处理线程：%s&quot;, currentThread().getName())); // 模拟开启一个异步任务，超时时间为10s WebAsyncTask&lt;String&gt; asyncTask = new WebAsyncTask&lt;&gt;(5 * 1000L, () -&gt; &#123; out.println(format(&quot;异步工作线程：%s&quot;, currentThread().getName())); // 任务处理时间5s，不超时 sleep(3 * 1000L); throw new Exception(ERROR_MESSAGE); &#125;); // 任务执行完成时调用该方法 asyncTask.onCompletion(() -&gt; out.println(&quot;任务执行完成&quot;)); asyncTask.onError(() -&gt; &#123; out.println(&quot;任务执行异常&quot;); return ERROR_MESSAGE; &#125;); out.println(&quot;继续处理其他事情&quot;); return asyncTask; &#125; /** * http://localhost:8080/timeout * @return */ @GetMapping(&quot;/timeout&quot;) public WebAsyncTask&lt;String&gt; asyncTaskTimeout() &#123; // 打印处理线程名 out.println(format(&quot;请求处理线程：%s&quot;, currentThread().getName())); // 模拟开启一个异步任务，超时时间为10s WebAsyncTask&lt;String&gt; asyncTask = new WebAsyncTask&lt;&gt;(5 * 1000L, () -&gt; &#123; out.println(format(&quot;异步工作线程：%s&quot;, currentThread().getName())); // 任务处理时间5s，不超时 sleep(7 * 1000L); return TIME_MESSAGE; &#125;); // 任务执行完成时调用该方法 asyncTask.onCompletion(() -&gt; out.println(&quot;任务执行完成&quot;)); asyncTask.onTimeout(() -&gt; &#123; out.println(&quot;任务执行超时&quot;); return TIME_MESSAGE; &#125;); out.println(&quot;继续处理其他事情&quot;); return asyncTask; &#125; /** * http://localhost:8080/threadPool * @return */ @GetMapping(&quot;/threadPool&quot;) public WebAsyncTask&lt;String&gt; asyncTaskThreadPool() &#123; return new WebAsyncTask&lt;&gt;(10 * 1000L, executor, () -&gt; &#123; out.println(format(&quot;异步工作线程：%s&quot;, currentThread().getName())); return asyncService.generateUUID(); &#125;); &#125;&#125; 123456789101112@Configurationpublic class TaskConfiguration &#123; @Bean(&quot;taskExecutor&quot;) public ThreadPoolTaskExecutor taskExecutor() &#123; ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(5); taskExecutor.setMaxPoolSize(10); taskExecutor.setQueueCapacity(10); taskExecutor.setThreadNamePrefix(&quot;asyncTask&quot;); return taskExecutor; &#125;&#125; 123456@Servicepublic class WebAsyncService &#123; public String generateUUID() &#123; return UUID.randomUUID().toString(); &#125;&#125; 案例2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * @author cc * @description * @since 2020-12-18 * https://lingmoumou.github.io/p/2020/01/30/1326f080/ */@Slf4j@RestController@RequestMapping(&quot;/servlet&quot;)public class AsyncController &#123; /** * http://localhost:8080/servlet/origin * @param request * @param response * @throws Exception */ @RequestMapping(&quot;/origin&quot;) public void origin(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; Thread.sleep(100); response.getWriter().println(&quot;这是【正常】的请求返回&quot;); &#125; /** * http://localhost:8080/servlet/async * @param request * @param response */ @RequestMapping(&quot;/async&quot;) public void todoAsync(HttpServletRequest request,HttpServletResponse response) &#123; AsyncContext asyncContext = request.startAsync(); asyncContext.addListener(new AsyncListener() &#123; @Override public void onTimeout(AsyncEvent event) throws IOException &#123; log.info(&quot;超时了：&quot;); //做一些超时后的相关操作 &#125; @Override public void onStartAsync(AsyncEvent event) throws IOException &#123; log.info(&quot;线程开始&quot;); &#125; @Override public void onError(AsyncEvent event) throws IOException &#123; log.info(&quot;发生错误：&quot;,event.getThrowable()); &#125; @Override public void onComplete(AsyncEvent event) throws IOException &#123; log.info(&quot;执行完成&quot;); //这里可以做一些清理资源的操作 &#125; &#125;); //设置超时时间 asyncContext.setTimeout(200); asyncContext.start(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); log.info(&quot;内部线程：&quot; + Thread.currentThread().getName()); asyncContext.getResponse().setCharacterEncoding(&quot;utf-8&quot;); asyncContext.getResponse().setContentType(&quot;text/html;charset=UTF-8&quot;); asyncContext.getResponse().getWriter().println(&quot;这是【异步】的请求返回&quot;); &#125; catch (Exception e) &#123; log.error(&quot;异常：&quot;,e); &#125; //异步请求完成通知,此时整个请求才完成 //其实可以利用此特性 进行多条消息的推送把连接挂起。。 asyncContext.complete(); &#125; &#125;); //此时之类 request的线程连接已经释放了 log.info(&quot;线程：&quot; + Thread.currentThread().getName()); &#125; /** * http://localhost:8080/servlet/order * @return */ @RequestMapping(&quot;/order&quot;) public Callable&lt;String&gt; order() &#123; log.info(&quot;主线程开始&quot;); Callable&lt;String&gt; result = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info(&quot;副线程开始&quot;); Thread.sleep(1000); log.info(&quot;副线程返回&quot;); return &quot;success&quot;; &#125; &#125;; log.info(&quot;主线程返回&quot;); return result; &#125; @Autowired private MockQueue mockQueue; @Autowired private DeferredResultHolder deferredResultHolder; /** * http://localhost:8080/servlet/order1 * @return * @throws InterruptedException */ @RequestMapping(&quot;/order1&quot;) public DeferredResult&lt;String&gt; order1() throws InterruptedException &#123; log.info(&quot;主线程开始&quot;); String orderNumber= RandomStringUtils.randomNumeric(8); mockQueue.setPlaceOrder(orderNumber); DeferredResult&lt;String&gt; result=new DeferredResult&lt;&gt;(); deferredResultHolder.getMap().put(orderNumber,result); log.info(&quot;主线程返回&quot;); return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031@Slf4j@RestControllerpublic class DeferredResultController &#123; public static ExecutorService FIXED_THREAD_POOL = Executors.newFixedThreadPool(30); // 线程池 /** * http://localhost:8080/deferredresult * @return */ @RequestMapping(&quot;/deferredresult&quot;) public DeferredResult&lt;String&gt; deferredResult()&#123; log.info(&quot;外部线程：&quot; + Thread.currentThread().getName()); //设置超时时间 DeferredResult&lt;String&gt; result = new DeferredResult&lt;String&gt;(60*1000L); //处理超时事件 采用委托机制 result.onTimeout(() -&gt; &#123; log.error(&quot;DeferredResult超时&quot;); result.setResult(&quot;超时了!&quot;); &#125;); result.onCompletion(() -&gt; log.info(&quot;调用完成&quot;)); FIXED_THREAD_POOL.execute(() -&gt; &#123; log.info(&quot;内部线程：&quot; + Thread.currentThread().getName()); //返回结果 result.setResult(&quot;DeferredResult!!&quot;); &#125;); return result; &#125;&#125; 123456789101112@Componentpublic class DeferredResultHolder &#123; private Map&lt;String, DeferredResult&lt;String&gt;&gt; map=new HashMap&lt;String,DeferredResult&lt;String&gt;&gt;(); public Map&lt;String,DeferredResult&lt;String&gt;&gt; getMap()&#123; return map; &#125; public void setMap(Map&lt;String,DeferredResult&lt;String&gt;&gt; map)&#123; this.map=map; &#125;&#125; 1234567891011121314151617181920@Slf4j@Data@Componentpublic class MockQueue &#123; private String placeOrder; private String completeOrder; public void setPlaceOrder(String placeOrder) throws InterruptedException &#123; new Thread(()-&gt;&#123; log.info(&quot;接到下单请求,&quot;+placeOrder); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.completeOrder=placeOrder; log.info(&quot;下单请求处理完毕,&quot;+placeOrder); &#125;).start(); &#125;&#125; 123456789101112131415161718192021222324252627282930@Slf4j@Componentpublic class QueueListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Autowired private MockQueue mockQueue; @Autowired private DeferredResultHolder deferredResultHolder; @Override public void onApplicationEvent(ContextRefreshedEvent event)&#123; new Thread(()-&gt;&#123; while (true)&#123; if(StringUtils.isNotBlank(mockQueue.getCompleteOrder()))&#123; String orderNumber=mockQueue.getCompleteOrder(); log.info(&quot;返回订单处理结果：&quot;+orderNumber); deferredResultHolder.getMap().get(orderNumber).setResult(&quot;place order&quot;); mockQueue.setCompleteOrder(null); &#125;else &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 案例3 123456789101112131415161718192021222324252627282930313233343536/** * @author cc * @description springboot asyncContext 长轮询 * @since 2020-12-18 * https://blog.csdn.net/lovexiaotaozi/article/details/102775350 */@RestController@RequestMapping(&quot;/nacos&quot;)public class NacosLongPollingController extends HttpServlet &#123; @Autowired private NacosLongPollingService nacosLongPollingService; /** * http://localhost:8080/nacos/pull?dataId=1 * @param req * @param resp */ @RequestMapping(&quot;/pull&quot;) @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; String dataId = req.getParameter(&quot;dataId&quot;); if (StringUtils.isEmpty(dataId)) &#123; throw new IllegalArgumentException(&quot;请求参数异常,dataId能为空&quot;); &#125; nacosLongPollingService.doGet(dataId, req, resp); &#125; //为了在浏览器中演示,我这里先用Get请求,dataId可以区分不同应用的请求 @GetMapping(&quot;/push&quot;) public Result push(@RequestParam(&quot;dataId&quot;) String dataId, @RequestParam(&quot;data&quot;) String data) &#123; if (StringUtils.isEmpty(dataId) || StringUtils.isEmpty(data)) &#123; throw new IllegalArgumentException(&quot;请求参数异常,dataId和data均不能为空&quot;); &#125; nacosLongPollingService.push(dataId, data); return ResultUtil.success(); &#125;&#125; 1234public interface NacosLongPollingService &#123; void doGet(String dataId, HttpServletRequest req, HttpServletResponse resp); void push(String dataId, String data);&#125; 12345678910111213141516171819202122232425262728@Servicepublic class NacosLongPollingServiceImpl implements NacosLongPollingService &#123; final ScheduledExecutorService scheduler; final Queue&lt;NacosPullTask&gt; nacosPullTasks; public NacosLongPollingServiceImpl() &#123; scheduler = new ScheduledThreadPoolExecutor(1, r -&gt; &#123; Thread t = new Thread(r); t.setName(&quot;NacosLongPollingTask&quot;); t.setDaemon(true); return t; &#125;); nacosPullTasks = new ConcurrentLinkedQueue&lt;&gt;(); scheduler.scheduleAtFixedRate(() -&gt; System.out.println(&quot;线程存活状态:&quot; + new Date()), 0L, 60, TimeUnit.SECONDS); &#125; @Override public void doGet(String dataId, HttpServletRequest req, HttpServletResponse resp) &#123; // 一定要由当前HTTP线程调用，如果放在task线程容器会立即发送响应 final AsyncContext asyncContext = req.startAsync(); scheduler.execute(new NacosPullTask(nacosPullTasks, scheduler, asyncContext, dataId, req, resp)); &#125; @Override public void push(String dataId, String data) &#123; scheduler.schedule(new NacosPushTask(dataId, data, nacosPullTasks), 0L, TimeUnit.MILLISECONDS); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Slf4jpublic class NacosPullTask implements Runnable &#123; Queue&lt;NacosPullTask&gt; nacosPullTasks; ScheduledExecutorService scheduler; AsyncContext asyncContext; String dataId; HttpServletRequest req; HttpServletResponse resp; Future&lt;?&gt; asyncTimeoutFuture; public NacosPullTask(Queue&lt;NacosPullTask&gt; nacosPullTasks, ScheduledExecutorService scheduler, AsyncContext asyncContext, String dataId, HttpServletRequest req, HttpServletResponse resp) &#123; this.nacosPullTasks = nacosPullTasks; this.scheduler = scheduler; this.asyncContext = asyncContext; this.dataId = dataId; this.req = req; this.resp = resp; &#125; @Override public void run() &#123; asyncTimeoutFuture = scheduler.schedule(() -&gt; &#123; log.info(&quot;10秒后开始执行长轮询任务:&quot; + new Date()); //这里如果remove this会失败,内部类中的this指向的并非当前对象,而是匿名内部类对象 nacosPullTasks.remove(NacosPullTask.this); //sendResponse(null); &#125;, 10, TimeUnit.SECONDS); nacosPullTasks.add(this); &#125; /** * 发送响应 * * @param result */ public void sendResponse(String result) &#123; System.out.println(&quot;发送响应:&quot; + new Date()); //取消等待执行的任务,避免已经响完了,还有资源被占用 if (asyncTimeoutFuture != null) &#123; //设置为true会立即中断执行中的任务,false对执行中的任务无影响,但会取消等待执行的任务 asyncTimeoutFuture.cancel(false); &#125; //设置页码编码 resp.setContentType(&quot;application/json; charset=utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); //禁用缓存 resp.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); resp.setHeader(&quot;Cache-Control&quot;, &quot;no-cache,no-store&quot;); resp.setDateHeader(&quot;Expires&quot;, 0); resp.setStatus(HttpServletResponse.SC_OK); //输出Json流 sendJsonResult(result); &#125; /** * 发送响应流 * * @param result */ private void sendJsonResult(String result) &#123; Result&lt;String&gt; pojoResult = new Result&lt;&gt;(); pojoResult.setCode(200); pojoResult.setSuccess(!StringUtils.isEmpty(result)); pojoResult.setData(result); PrintWriter writer = null; try &#123; writer = asyncContext.getResponse().getWriter(); writer.write(pojoResult.toString()); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; asyncContext.complete(); if (null != writer) &#123; writer.close(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class NacosPushTask implements Runnable &#123; private String dataId; private String data; private Queue&lt;NacosPullTask&gt; nacosPullTasks; public NacosPushTask(String dataId, String data, Queue&lt;NacosPullTask&gt; nacosPullTasks) &#123; this.dataId = dataId; this.data = data; this.nacosPullTasks = nacosPullTasks; &#125; @Override public void run() &#123; Iterator&lt;NacosPullTask&gt; iterator = nacosPullTasks.iterator(); while (iterator.hasNext()) &#123; NacosPullTask nacosPullTask = iterator.next(); if (dataId.equals(nacosPullTask.dataId)) &#123; //可根据内容的MD5判断数据是否发生改变,这里为了演示简单就不写了 //移除队列中的任务,确保下次请求时响应的task不是上次请求留在队列中的task iterator.remove(); //执行数据变更,发送响应 nacosPullTask.sendResponse(data); break; &#125; &#125; &#125;&#125; 123456@Datapublic class Result&lt;T&gt; &#123; private T data; private Integer code; private Boolean success;&#125; 12345678910111213141516public class ResultUtil &#123; public static Result success() &#123; Result result = new Result(); result.setCode(200); result.setSuccess(true); return result; &#125; public static Result success(Object data) &#123; Result result = new Result(); result.setSuccess(true); result.setCode(200); result.setData(data); return result; &#125;&#125; 案例4 1234567891011121314151617181920212223242526272829303132333435public class MyReadListener implements ReadListener &#123; private ServletInputStream inputStream; private AsyncContext asyncContext; public MyReadListener(ServletInputStream input,AsyncContext context)&#123; this.inputStream = input; this.asyncContext = context; &#125; //数据可用时触发执行 @Override public void onDataAvailable() throws IOException &#123; System.out.println(&quot;数据可用时触发执行&quot;); &#125; //数据读完时触发调用 @Override public void onAllDataRead() throws IOException &#123; try &#123; Thread.sleep(3000);//暂停5秒，模拟耗时处理数据 PrintWriter out = asyncContext.getResponse().getWriter(); out.write(&quot;数据读完了&quot;); out.flush(); System.out.println(&quot;数据读完了&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //数据出错触发调用 @Override public void onError(Throwable t)&#123; System.out.println(&quot;数据 出错&quot;); t.printStackTrace(); &#125;&#125; 123456789101112131415161718192021@RestController@RequestMapping(&quot;/ex4&quot;)public class AsyncContextController &#123; // http://localhost:8080/ex4/test @GetMapping(&quot;/test&quot;) public void test(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); AsyncContext actx = request.startAsync();//通过request获得AsyncContent对象 actx.setTimeout(30*3000);//设置异步调用超时时长 ServletInputStream in = request.getInputStream(); //异步读取（实现了非阻塞式读取） in.setReadListener(new MyReadListener(in,actx)); //直接输出到页面的内容(不等异步完成就直接给页面) PrintWriter out = response.getWriter(); out.println(&quot;&lt;h1&gt;直接返回页面，不等异步处理结果了&lt;/h1&gt;&quot;); out.flush(); &#125;&#125; 案例5 123456789101112131415161718192021222324252627282930313233343536@Slf4j@RestController@RequestMapping(&quot;/ex5&quot;)public class AsyncContextController5 &#123; // http://localhost:8080/ex5/test @GetMapping(&quot;/test&quot;) public void test(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); long start = System.currentTimeMillis(); AsyncContext asyncContext = request.startAsync(); CompletableFuture.runAsync(() -&gt; execute( asyncContext, asyncContext.getRequest(), asyncContext.getResponse()) ); log.info(&quot;总耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;); &#125; private void execute(AsyncContext asyncContext, ServletRequest request, ServletResponse response) &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; response.getWriter().append(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; asyncContext.complete(); &#125;&#125; 案例6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Slf4j@RestController@RequestMapping(&quot;/ex6&quot;)public class AsyncContextController6 &#123; // http://localhost:8080/ex6/test @GetMapping(&quot;/test&quot;) public void test(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); AsyncContext asyncContext = request.startAsync(); asyncContext.addListener(new AsyncListener() &#123; @Override public void onTimeout(AsyncEvent event) throws IOException &#123; log.info(&quot;超时了：&quot;); //做一些超时后的相关操作 &#125; @Override public void onStartAsync(AsyncEvent event) throws IOException &#123; // TODO Auto-generated method stub log.info(&quot;线程开始&quot;); &#125; @Override public void onError(AsyncEvent event) throws IOException &#123; log.info(&quot;发生错误：&quot;,event.getThrowable()); &#125; @Override public void onComplete(AsyncEvent event) throws IOException &#123; log.info(&quot;执行完成&quot;); //这里可以做一些清理资源的操作 &#125; &#125;); //设置超时时间 asyncContext.setTimeout(200); //也可以不使用start 进行异步调用// new Thread(new Runnable() &#123;//// @Override// public void run() &#123;// 编写业务逻辑//// &#125;// &#125;).start(); asyncContext.start(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); log.info(&quot;内部线程：&quot; + Thread.currentThread().getName()); asyncContext.getResponse().setCharacterEncoding(&quot;utf-8&quot;); asyncContext.getResponse().setContentType(&quot;text/html;charset=UTF-8&quot;); asyncContext.getResponse().getWriter().println(&quot;这是【异步】的请求返回&quot;); &#125; catch (Exception e) &#123; log.error(&quot;异常：&quot;,e); &#125; //异步请求完成通知 //此时整个请求才完成 //其实可以利用此特性 进行多条消息的推送 把连接挂起。。 asyncContext.complete(); &#125; &#125;); //此时之类 request的线程连接已经释放了 log.info(&quot;线程：&quot; + Thread.currentThread().getName()); &#125;&#125; 参考 https://my.oschina.net/yangzhiwei256/blog/4405842 http://mp.weixin.qq.com/mp/homepage?__biz=MzI4MDM0NTEyMw==&amp;hid=1&amp;sn=9216abeeca54b8d3dc34d5b57ed1851b&amp;scene=18#wechat_redirect https://www.liaochuntao.cn/2019/05/26/java-web-38/#代码流程图 https://istio.tech/2019/08/05/Alibaba-Nacos配置中心服务端处理源码/ https://bebugless.com/blogs/2649801/ http://www.iocoder.cn/Nacos/good-collection/?vip http://www.voycn.com/article/weifuwushizhanwu-nacosjiagouyuanmafenxi-peizhizhongxin https://juejin.cn/post/6844904050840993805 https://www.cnblogs.com/mrhelloworld/p/nacos-config.html https://segmentfault.com/a/1190000018791724 https://blog.csdn.net/lovexiaotaozi/article/details/102775350","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"异步","slug":"异步","permalink":"https://idea360.cn/tags/%E5%BC%82%E6%AD%A5/"},{"name":"AsyncContext","slug":"AsyncContext","permalink":"https://idea360.cn/tags/AsyncContext/"}]},{"title":"设计模式——观察者模式","slug":"design-patterns-observer","date":"2020-12-26T09:10:31.000Z","updated":"2021-02-23T14:15:08.624Z","comments":true,"path":"2020/12/26/design-patterns-observer/","link":"","permalink":"https://idea360.cn/2020/12/26/design-patterns-observer/","excerpt":"","text":"前言 学习设计模式是为了写出更优雅的代码 安卓开发中的监听器 其实认真观察发现，安卓中充斥着大量的监听器, 即观察者模式。下边简单实现下~ 首先创建一个监听器接口 12345public interface OnClickListener &#123; void onClick(View view);&#125; 然后创建一个监听事件，这里是屏幕点击区域 123456789101112131415public class View &#123; private String name; public View(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 被观察者 1234567891011121314public class Button &#123; private OnClickListener listener; public void setOnClickListener(OnClickListener listener) &#123; this.listener = listener; &#125; public void click() &#123; if (listener != null) &#123; listener.onClick(new View(&quot;点击按钮&quot;)); &#125; &#125;&#125; 测试 12345678910111213@Slf4jpublic class Ex1 &#123; public static void main(String[] args) &#123; Button button = new Button(); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view) &#123; log.info(&quot;收到事件: &#123;&#125;&quot;, view.getName()); &#125; &#125;); button.click(); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://idea360.cn/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"生产环境中应该如何使用线程池","slug":"thread-pool-prod","date":"2020-12-26T08:59:20.000Z","updated":"2021-03-22T15:24:27.387Z","comments":true,"path":"2020/12/26/thread-pool-prod/","link":"","permalink":"https://idea360.cn/2020/12/26/thread-pool-prod/","excerpt":"","text":"前言 多线程是Java开发当下无法回避的问题。今天就生产环境线程池的使用做简单记录。 Nacos中线程池的使用 在 nacos 配置中心 client 的源码部分, 有长连接的需求，源码路径 &lt;src/main/java/com/alibaba/nacos/client/config/impl/ClientWorker.java&gt; . ClientWorker(): 12345678910111213141516171819202122final ScheduledExecutorService executorService;this.executorService = Executors .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setName(&quot;com.alibaba.nacos.client.Worker.longPolling.&quot; + agent.getName()); t.setDaemon(true); return t; &#125; &#125;); this.executor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; try &#123; checkConfigInfo(); &#125; catch (Throwable e) &#123; LOGGER.error(&quot;[&quot; + agent.getName() + &quot;] [sub-check] rotate check error&quot;, e); &#125; &#125; &#125;, 1L, 10L, TimeUnit.MILLISECONDS); checkConfigInfo(): 12executorService.execute(new LongPollingRunnable(i));class LongPollingRunnable implements Runnable &#123;&#125; 但是我们知道阿里代码规范中是不推荐使用 Executors 创建线程池的。所以下边贴上我们在实际项目中的使用方式。 外呼 1234567891011121314151617181920212223242526272829303132333435/** * 创建线程池, 多线程处理推送话单数据 */private static final ExecutorService callExecutorService = initThreadPool(&quot;call-handler-&quot;); /** * 初始化线程池 * * @return */private static ExecutorService initThreadPool(String threadNamePrefix) &#123; // 定义线程名称 ThreadFactory namedThreadFactory = new ThreadFactory() &#123; private AtomicInteger id = new AtomicInteger(); @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r); thread.setName(threadNamePrefix + id.getAndIncrement()); return thread; &#125; &#125;; int nThreads = Runtime.getRuntime().availableProcessors(); BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;Runnable&gt;(); // 超过队列策略：丢弃 RejectedExecutionHandler rejectedExecutionHandler = new ThreadPoolExecutor.DiscardPolicy(); //Common Thread Pool ExecutorService executorService = new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, workQueue, namedThreadFactory, rejectedExecutionHandler); return executorService;&#125; spring中配置 12345678910111213141516171819202122232425262728@Configurationpublic class TaskExecutorConfig &#123; // spring中集成 @Bean(name = &quot;taskExecutor&quot;) public TaskExecutor taskExecutor()&#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(Runtime.getRuntime().availableProcessors()); // 核心线程数 executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors()); // 最大线程数 executor.setQueueCapacity(500); // 任务队列容量 executor.setThreadNamePrefix(&quot;upload-excel-&quot;); executor.initialize(); return executor; &#125; @Bean(&quot;uploadOssExecutor&quot;) public ExecutorService uploadOssExecutor() &#123; return Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), r -&gt; &#123; Thread t = new Thread(r); t.setName(&quot;upload-oss&quot;); t.setDaemon(true); return t; &#125;); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"线程池","slug":"线程池","permalink":"https://idea360.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"nacos源码解读","slug":"nacos-open-source","date":"2020-12-12T06:18:15.000Z","updated":"2021-02-23T14:39:11.248Z","comments":true,"path":"2020/12/12/nacos-open-source/","link":"","permalink":"https://idea360.cn/2020/12/12/nacos-open-source/","excerpt":"","text":"console模块 这是我们的后台管理模块， springboot项目 distribution模块 这是我们构建的脚本执行模块 本地启动参数 -Dnacos.home=/Users/cuishiying/work/nacos/distribution -Dnacos.standalone=true 源码构建 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos.gitcd nacos&#x2F;mvn -Prelease-nacos -Dmaven.test.skip&#x3D;true clean install -U ls -al distribution&#x2F;target&#x2F;&#x2F;&#x2F; change the $version to your actual pathcd distribution&#x2F;target&#x2F;nacos-server-$version&#x2F;nacos&#x2F;bin linux启动停止 12sh startup.sh -m standalonesh shutdown.sh","categories":[{"name":"nacos","slug":"nacos","permalink":"https://idea360.cn/categories/nacos/"}],"tags":[{"name":"nacos","slug":"nacos","permalink":"https://idea360.cn/tags/nacos/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"SpringBoot多环境打包","slug":"spring-multi-env-package","date":"2020-12-04T09:56:01.000Z","updated":"2021-02-23T14:45:04.463Z","comments":true,"path":"2020/12/04/spring-multi-env-package/","link":"","permalink":"https://idea360.cn/2020/12/04/spring-multi-env-package/","excerpt":"","text":"pom.xml配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idea360-kafka-spring-boot-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;dea360-kafka-spring-boot-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;idea360-kafka-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profileActive&gt;dev&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;test&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;prod&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;!-- 项目打包完成的包中只包含当前环境文件 --&gt; &lt;include&gt;bootstrap.yml&lt;/include&gt; &lt;include&gt;application.yml&lt;/include&gt; &lt;include&gt;application-$&#123;profileActive&#125;.yml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.idea360.springdemo.SpringDemoApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptors&gt; &lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; assembly.xml打包配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;assembly&gt; &lt;!-- 可自定义，这里指定的是项目环境 --&gt; &lt;!-- spring-boot-assembly-local-1.0.RELEASE.tar.gz --&gt; &lt;id&gt;$&#123;profileActive&#125;-$&#123;project.version&#125;&lt;/id&gt; &lt;!-- 打包的类型，如果有N个，将会打N个类型的包 --&gt; &lt;formats&gt; &lt;format&gt;tar.gz&lt;/format&gt; &lt;!--&lt;format&gt;zip&lt;/format&gt;--&gt; &lt;/formats&gt; &lt;includeBaseDirectory&gt;true&lt;/includeBaseDirectory&gt; &lt;fileSets&gt; &lt;!-- 0755-&gt;即用户具有读/写/执行权限，组用户和其它用户具有读写权限； 0644-&gt;即用户具有读写权限，组用户和其它用户具有只读权限； --&gt; &lt;!-- 将src/bin目录下的所有文件输出到打包后的bin目录中 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;basedir&#125;/src/bin&lt;/directory&gt; &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt; &lt;fileMode&gt;0755&lt;/fileMode&gt; &lt;includes&gt; &lt;include&gt;**.sh&lt;/include&gt; &lt;include&gt;**.bat&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;!-- 指定输出target/classes中的配置文件到config目录中 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;basedir&#125;/target/classes&lt;/directory&gt; &lt;outputDirectory&gt;config&lt;/outputDirectory&gt; &lt;fileMode&gt;0644&lt;/fileMode&gt; &lt;includes&gt; &lt;include&gt;application.yml&lt;/include&gt; &lt;include&gt;bootstrap.yml&lt;/include&gt; &lt;include&gt;application-$&#123;profileActive&#125;.yml&lt;/include&gt; &lt;include&gt;mapper/**/*.xml&lt;/include&gt; &lt;include&gt;static/**&lt;/include&gt; &lt;include&gt;templates/**&lt;/include&gt; &lt;include&gt;*.xml&lt;/include&gt; &lt;include&gt;*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;!-- 将第三方依赖打包到lib目录中 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;basedir&#125;/target/lib&lt;/directory&gt; &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt; &lt;fileMode&gt;0755&lt;/fileMode&gt; &lt;/fileSet&gt; &lt;!-- 将项目启动jar打包到boot目录中 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt; &lt;outputDirectory&gt;boot&lt;/outputDirectory&gt; &lt;fileMode&gt;0755&lt;/fileMode&gt; &lt;includes&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;!-- 包含根目录下的文件 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;basedir&#125;&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;NOTICE&lt;/include&gt; &lt;include&gt;LICENSE&lt;/include&gt; &lt;include&gt;*.md&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;/fileSets&gt;&lt;/assembly&gt; 代码结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.├── README.md├── idea360-kafka-spring-boot-demo.iml├── pom.xml├── src│ ├── bin│ │ ├── restart.sh│ │ ├── shutdown.sh│ │ └── startup.sh│ ├── main│ │ ├── assembly│ │ │ └── assembly.xml│ │ ├── java│ │ │ └── cn│ │ │ └── idea360│ │ │ └── springdemo│ │ │ ├── HelloController.java│ │ │ └── SpringDemoApplication.java│ │ └── resources│ │ ├── application-dev.yml│ │ ├── application-prod.yml│ │ ├── application-test.yml│ │ ├── application.yml│ │ ├── static│ │ └── templates│ └── test│ └── java│ └── cn│ └── idea360│ └── springdemo│ └── SpringDemoApplicationTests.java└── target ├── archive-tmp ├── classes │ ├── application-test.yml │ ├── application.yml │ └── cn │ └── idea360 │ └── springdemo │ ├── HelloController.class │ └── SpringDemoApplication.class ├── generated-sources │ └── annotations ├── generated-test-sources │ └── test-annotations ├── idea360-kafka-spring-boot-demo │ ├── README.md │ ├── bin │ │ ├── restart.sh │ │ ├── shutdown.sh │ │ └── startup.sh │ ├── boot │ │ └── idea360-kafka-spring-boot-demo.jar │ ├── config │ │ ├── application-test.yml │ │ └── application.yml │ └── logs │ ├── back │ ├── idea360-kafka-spring-boot-demo.log │ └── idea360-kafka-spring-boot-demo_startup.log ├── idea360-kafka-spring-boot-demo-test-0.0.1.tar.gz ├── idea360-kafka-spring-boot-demo.jar ├── idea360-kafka-spring-boot-demo.jar.original ├── maven-archiver │ └── pom.properties ├── maven-status │ └── maven-compiler-plugin │ ├── compile │ │ └── default-compile │ │ ├── createdFiles.lst │ │ └── inputFiles.lst │ └── testCompile │ └── default-testCompile │ ├── createdFiles.lst │ └── inputFiles.lst └── test-classes └── cn └── idea360 └── springdemo └── SpringDemoApplicationTests.class application.yml 123456789idea360: kafka: name: admin password: 123456spring: application: name: idea360-kafka-spring-boot-demo profiles: active: @profileActive@ 打包 1mvn clean package -Ptest 解压 1tar zxvf target/idea360-kafka-spring-boot-demo-test-0.0.1.tar.gz -C target 解压后的目录结构 1234567891011121314151617➜ idea360-kafka-spring-boot-demo tree target&#x2F;idea360-kafka-spring-boot-demo target&#x2F;idea360-kafka-spring-boot-demo├── README.md├── bin│ ├── restart.sh│ ├── shutdown.sh│ └── startup.sh├── boot│ └── idea360-kafka-spring-boot-demo.jar├── config│ ├── application-test.yml│ └── application.yml└── logs ├── back ├── idea360-kafka-spring-boot-demo.log └── idea360-kafka-spring-boot-demo_startup.log 查看配置文件是否分环境打包 1234567➜ idea360-kafka-spring-boot-demo ll -al target&#x2F;classes total 16drwxr-xr-x 5 cuishiying staff 160B Jan 6 17:12 .drwxr-xr-x 14 cuishiying staff 448B Jan 6 17:12 ..-rw-r--r-- 1 cuishiying staff 20B Jan 6 17:12 application-test.yml-rw-r--r-- 1 cuishiying staff 170B Jan 6 17:12 application.ymldrwxr-xr-x 3 cuishiying staff 96B Jan 6 17:12 cn 启动 1./target/idea360-kafka-spring-boot-demo/bin/startup.sh 启动脚本startup.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#! /bin/bash#======================================================================# 项目启动shell脚本# boot目录: spring boot jar包# config目录: 配置文件目录# logs目录: 项目运行日志目录# logs/spring-boot-assembly_startup.log: 记录启动日志# logs/back目录: 项目运行日志备份目录# nohup后台运行#======================================================================# 项目名称APPLICATION=&quot;idea360-kafka-spring-boot-demo&quot;# 项目启动jar包名称APPLICATION_JAR=&quot;$&#123;APPLICATION&#125;.jar&quot;# bin目录绝对路径BIN_PATH=$(cd `dirname $0`; pwd)# 进入bin目录cd `dirname $0`# 返回到上一级项目根目录路径cd ..# 打印项目根目录绝对路径# `pwd` 执行系统命令并获得结果BASE_PATH=`pwd`# 外部配置文件绝对目录,如果是目录需要/结尾，也可以直接指定文件# 如果指定的是目录,spring则会读取目录中的所有配置文件CONFIG_DIR=$&#123;BASE_PATH&#125;&quot;/config/&quot;# 项目日志输出绝对路径LOG_DIR=$&#123;BASE_PATH&#125;&quot;/logs&quot;LOG_FILE=&quot;$&#123;APPLICATION&#125;.log&quot;LOG_PATH=&quot;$&#123;LOG_DIR&#125;/$&#123;LOG_FILE&#125;&quot;# 日志备份目录LOG_BACK_DIR=&quot;$&#123;LOG_DIR&#125;/back/&quot;# 项目启动日志输出绝对路径LOG_STARTUP_PATH=&quot;$&#123;LOG_DIR&#125;/$&#123;APPLICATION&#125;_startup.log&quot;# 当前时间NOW=$(date +&quot;%Y-%m-%m-%H-%M-%S&quot;)NOW_PRETTY=$(date +&quot;%Y-%m-%m %H:%M:%S&quot;)# 启动日志STARTUP_LOG=&quot;================================================ $&#123;NOW_PRETTY&#125; ================================================\\n&quot;# 如果logs文件夹不存在,则创建文件夹if [[ ! -d &quot;$&#123;LOG_DIR&#125;&quot; ]]; then mkdir &quot;$&#123;LOG_DIR&#125;&quot;fi# 如果logs/back文件夹不存在,则创建文件夹if [[ ! -d &quot;$&#123;LOG_BACK_DIR&#125;&quot; ]]; then mkdir &quot;$&#123;LOG_BACK_DIR&#125;&quot;fi# 如果项目运行日志存在,则重命名备份if [[ -f &quot;$&#123;LOG_PATH&#125;&quot; ]]; then mv $&#123;LOG_PATH&#125; &quot;$&#123;LOG_BACK_DIR&#125;/$&#123;APPLICATION&#125;_back_$&#123;NOW&#125;.log&quot;fi# 创建新的项目运行日志echo &quot;&quot; &gt; $&#123;LOG_PATH&#125;# 如果项目启动日志不存在,则创建,否则追加echo &quot;$&#123;STARTUP_LOG&#125;&quot; &gt;&gt; $&#123;LOG_STARTUP_PATH&#125;#==========================================================================================# JVM Configuration# -Xmx256m:设置JVM最大可用内存为256m,根据项目实际情况而定，建议最小和最大设置成一样。# -Xms256m:设置JVM初始内存。此值可以设置与-Xmx相同,以避免每次垃圾回收完成后JVM重新分配内存# -Xmn512m:设置年轻代大小为512m。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。# 持久代一般固定大小为64m,所以增大年轻代,将会减小年老代大小。此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8# -XX:MetaspaceSize=64m:存储class的内存大小,该值越大触发Metaspace GC的时机就越晚# -XX:MaxMetaspaceSize=320m:限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序# -XX:-OmitStackTraceInFastThrow:解决重复异常不打印堆栈信息问题#==========================================================================================JAVA_OPT=&quot;-server -Xms256m -Xmx256m -Xmn512m -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=256m&quot;JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:-OmitStackTraceInFastThrow&quot;#=======================================================# 将命令启动相关日志追加到日志文件#=======================================================# 输出项目名称STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application name: $&#123;APPLICATION&#125;\\n&quot;# 输出jar包名称STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application jar name: $&#123;APPLICATION_JAR&#125;\\n&quot;# 输出项目bin路径STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application bin path: $&#123;BIN_PATH&#125;\\n&quot;# 输出项目根目录STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application root path: $&#123;BASE_PATH&#125;\\n&quot;# 打印日志路径STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application log path: $&#123;LOG_PATH&#125;\\n&quot;# 打印JVM配置STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application JAVA_OPT : $&#123;JAVA_OPT&#125;\\n&quot;# 打印启动命令STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application background startup command: nohup java $&#123;JAVA_OPT&#125; -jar $&#123;BASE_PATH&#125;/boot/$&#123;APPLICATION_JAR&#125; --spring.config.location=$&#123;CONFIG_DIR&#125; &gt; $&#123;LOG_PATH&#125; 2&gt;&amp;1 &amp;\\n&quot;#======================================================================# 执行启动命令：后台启动项目,并将日志输出到项目根目录下的logs文件夹下#======================================================================nohup java $&#123;JAVA_OPT&#125; -jar $&#123;BASE_PATH&#125;/boot/$&#123;APPLICATION_JAR&#125; --spring.config.location=$&#123;CONFIG_DIR&#125; &gt; $&#123;LOG_PATH&#125; 2&gt;&amp;1 &amp;#exec java $&#123;JAVA_OPT&#125; -jar $&#123;BASE_PATH&#125;/boot/$&#123;APPLICATION_JAR&#125; --spring.config.location=$&#123;CONFIG_DIR&#125; &quot;$@&quot;# 进程IDPID=$(ps -ef | grep &quot;$&#123;APPLICATION_JAR&#125;&quot; | grep -v grep | awk &#x27;&#123; print $2 &#125;&#x27;)STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application pid: $&#123;PID&#125;\\n&quot;# 启动日志追加到启动日志文件中echo -e $&#123;STARTUP_LOG&#125; &gt;&gt; $&#123;LOG_STARTUP_PATH&#125;# 打印启动日志echo -e $&#123;STARTUP_LOG&#125;# 打印项目日志tail -f $&#123;LOG_PATH&#125; 停止脚本shutdown.sh 1234567891011121314151617181920212223#! /bin/bash#======================================================================# 项目停服shell脚本# 通过项目名称查找到PID# 然后kill -9 pid#======================================================================# 项目名称APPLICATION=&quot;idea360-kafka-spring-boot-demo&quot;# 项目启动jar包名称APPLICATION_JAR=&quot;$&#123;APPLICATION&#125;.jar&quot;PID=$(ps -ef | grep &quot;$&#123;APPLICATION_JAR&#125;&quot; | grep -v grep | awk &#x27;&#123; print $2 &#125;&#x27;)if [[ -z &quot;$PID&quot; ]]then echo $&#123;APPLICATION&#125; is already stoppedelse echo kill $&#123;PID&#125; kill -9 $&#123;PID&#125; echo $&#123;APPLICATION&#125; stopped successfullyfi 重启脚本restart.sh 123456789101112131415161718#! /bin/bash#======================================================================# 项目重启shell脚本# 先调用shutdown.sh停服# 然后调用startup.sh启动服务#======================================================================# 项目名称APPLICATION=&quot;idea360-kafka-spring-boot-demo&quot;# 停服echo stop $&#123;APPLICATION&#125; Application...sh shutdown.sh# 启动服务echo start $&#123;APPLICATION&#125; Application...sh startup.sh 日志管理 如果使用logback进行日志管理, 需要将日志配置文件打包进去即可 pom.xml配置 123456789101112&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;!-- 项目打包完成的包中只包含当前环境文件 --&gt; &lt;include&gt;application.yml&lt;/include&gt; &lt;include&gt;application-$&#123;profileActive&#125;.yml&lt;/include&gt; &lt;include&gt;logback-spring.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt;&lt;/resources&gt; 日志配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;configuration&gt; &lt;contextName&gt;idea360-kafka-spring-boot-demo&lt;/contextName&gt; &lt;!-- 日志输出格式 --&gt; &lt;property name=&quot;log.pattern&quot; value=&quot;[eachbot-flow-service] [%X&#123;ip&#125;] [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;80&#125;] [%method,%line] [%msg]%n&quot;/&gt; &lt;property name=&quot;log.pattern.color&quot; value=&quot;%yellow[eachbot-flow-service] [%X&#123;ip&#125;] [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %highlight[%-5level] %green[%logger&#123;80&#125;] [%method,%line] %highlight[%msg]%n&quot;/&gt; &lt;!-- 日志存放路径 --&gt; &lt;property name=&quot;log.path&quot; value=&quot;logs&quot;/&gt; &lt;!-- 控制台输出-带颜色 --&gt; &lt;appender name=&quot;console-with-color&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;log.pattern.color&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件输出 --&gt; &lt;appender name=&quot;file_info&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/demo.info.%d.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--显示sql--&gt; &lt;logger name=&quot;cn.idea360.springdemo&quot; level=&quot;debug&quot;/&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;console-with-color&quot;/&gt; &lt;appender-ref ref=&quot;file_info&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 启动脚本startup.sh修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#! /bin/bash#======================================================================# 项目启动shell脚本# boot目录: spring boot jar包# config目录: 配置文件目录# logs目录: 项目运行日志目录# logs/spring-boot-assembly_startup.log: 记录启动日志# logs/back目录: 项目运行日志备份目录# nohup后台运行#======================================================================# 项目名称APPLICATION=&quot;idea360-kafka-spring-boot-demo&quot;# 项目启动jar包名称APPLICATION_JAR=&quot;$&#123;APPLICATION&#125;.jar&quot;# bin目录绝对路径BIN_PATH=$(cd `dirname $0`; pwd)# 进入bin目录cd `dirname $0`# 返回到上一级项目根目录路径cd ..# 打印项目根目录绝对路径# `pwd` 执行系统命令并获得结果BASE_PATH=`pwd`# 外部配置文件绝对目录,如果是目录需要/结尾，也可以直接指定文件# 如果指定的是目录,spring则会读取目录中的所有配置文件CONFIG_DIR=$&#123;BASE_PATH&#125;&quot;/config/&quot;# 当前时间NOW=$(date +&quot;%Y-%m-%m-%H-%M-%S&quot;)NOW_PRETTY=$(date +&quot;%Y-%m-%m %H:%M:%S&quot;)#==========================================================================================# JVM Configuration# -Xmx256m:设置JVM最大可用内存为256m,根据项目实际情况而定，建议最小和最大设置成一样。# -Xms256m:设置JVM初始内存。此值可以设置与-Xmx相同,以避免每次垃圾回收完成后JVM重新分配内存# -Xmn512m:设置年轻代大小为512m。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。# 持久代一般固定大小为64m,所以增大年轻代,将会减小年老代大小。此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8# -XX:MetaspaceSize=64m:存储class的内存大小,该值越大触发Metaspace GC的时机就越晚# -XX:MaxMetaspaceSize=320m:限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序# -XX:-OmitStackTraceInFastThrow:解决重复异常不打印堆栈信息问题#==========================================================================================JAVA_OPT=&quot;-server -Xms256m -Xmx256m -Xmn512m -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=256m&quot;JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:-OmitStackTraceInFastThrow&quot;#=======================================================# 将命令启动相关日志追加到日志文件#=======================================================# 输出项目名称STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application name: $&#123;APPLICATION&#125;\\n&quot;# 输出jar包名称STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application jar name: $&#123;APPLICATION_JAR&#125;\\n&quot;# 输出项目bin路径STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application bin path: $&#123;BIN_PATH&#125;\\n&quot;# 输出项目根目录STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application root path: $&#123;BASE_PATH&#125;\\n&quot;# 打印JVM配置STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application JAVA_OPT : $&#123;JAVA_OPT&#125;\\n&quot;# 打印启动命令STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application background startup command: exec java $&#123;JAVA_OPT&#125; -jar $&#123;BASE_PATH&#125;/boot/$&#123;APPLICATION_JAR&#125; --spring.config.location=$&#123;CONFIG_DIR&#125; &quot;$@&quot;\\n&quot;#======================================================================# 执行启动命令：后台启动项目,并将日志输出到项目根目录下的logs文件夹下#======================================================================exec java $&#123;JAVA_OPT&#125; -jar $&#123;BASE_PATH&#125;/boot/$&#123;APPLICATION_JAR&#125; --spring.config.location=$&#123;CONFIG_DIR&#125; &quot;$@&quot;# 进程IDPID=$(ps -ef | grep &quot;$&#123;APPLICATION_JAR&#125;&quot; | grep -v grep | awk &#x27;&#123; print $2 &#125;&#x27;)STARTUP_LOG=&quot;$&#123;STARTUP_LOG&#125;application pid: $&#123;PID&#125;\\n&quot; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://gitee.com/geekidea/spring-boot-assembly/tree/master","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"打包","slug":"打包","permalink":"https://idea360.cn/tags/%E6%89%93%E5%8C%85/"}]},{"title":"Nacos配置中心使用","slug":"hello-nacos","date":"2020-12-03T13:16:59.000Z","updated":"2021-02-23T14:18:37.508Z","comments":true,"path":"2020/12/03/hello-nacos/","link":"","permalink":"https://idea360.cn/2020/12/03/hello-nacos/","excerpt":"","text":"前言 首先放上官网 官网, 一切以官方为准。 安装教程 springboot消费案例 对于springboot多环境配置文件。可以在nacos中用命名空间 namespace 的概念区分。不同的业务隔离，用 group 分组。然后每个业务用 dataId 标识。 配置中心应用 项目参考 SpringBoot多环境打包 中的配置文件。 pom.xml配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idea360-kafka-spring-boot-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;dea360-kafka-spring-boot-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profileActive&gt;dev&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;test&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;prod&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;!-- 项目打包完成的包中只包含当前环境文件 --&gt; &lt;include&gt;bootstrap.yml&lt;/include&gt; &lt;include&gt;application.yml&lt;/include&gt; &lt;include&gt;application-$&#123;profileActive&#125;.yml&lt;/include&gt; &lt;include&gt;logback-spring.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.idea360.springdemo.SpringDemoApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptors&gt; &lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; nacos后台配置 登录 http://localhost:8848/nacos/ , 创建dev命名空间 创建配置文件 在 Nacos Spring Cloud 中，dataId 的完整格式如下： 1$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125; prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profiles.active 即为当前环境对应的 profile。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 prefix.{prefix}.prefix.{file-extension} file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 编辑配置文件 类型选择yaml, 编辑配置信息 spring配置文件 bootstrap.yml namespace和server-addr需要在bootstrap.yml中配置，如果多环境可以在pom.xml中的 中配置 1234567891011121314151617181920212223242526272829&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profileActive&gt;dev&lt;/profileActive&gt; &lt;nacos.servers&gt;127.0.0.1:8848&lt;/nacos.servers&gt; &lt;nacos.namespace&gt;2448da93-0835-420b-ab0f-c2af5f21af03&lt;/nacos.namespace&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;test&lt;/profileActive&gt; &lt;nacos.servers&gt;127.0.0.1:8848&lt;/nacos.servers&gt; &lt;nacos.namespace&gt;493bd17c-ffb4-4d28-bc62-6d2ce583ecfe&lt;/nacos.namespace&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;prod&lt;/profileActive&gt; &lt;nacos.servers&gt;127.0.0.1:8848&lt;/nacos.servers&gt; &lt;nacos.namespace&gt;c0d5d90e-d69f-4ac4-a6b0-ba6e72e03082&lt;/nacos.namespace&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 123456789101112131415spring: application: name: idea360-kafka-spring-boot-demo profiles: active: @profileActive@ cloud: nacos: config: server-addr: 127.0.0.1:8848 namespace: 2448da93-0835-420b-ab0f-c2af5f21af03 group: DEFAULT_GROUP file-extension: yamllogging: level: root: debug application-dev.yml 12server: port: 8080 代码中读取配置文件 1234@Autowiredprivate Environment environment;// 调用String property = environment.getProperty(&quot;spring.profiles.active&quot;); 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"nacos","slug":"nacos","permalink":"https://idea360.cn/tags/nacos/"}]},{"title":"Spring使用Feign代理Http请求","slug":"spring-feign-http","date":"2020-11-17T16:36:37.000Z","updated":"2021-02-23T14:44:26.884Z","comments":true,"path":"2020/11/18/spring-feign-http/","link":"","permalink":"https://idea360.cn/2020/11/18/spring-feign-http/","excerpt":"","text":"前言 在 spring-cloud 中，大家会用 feign 远程调用，以下记录下在 springboot 中代理http简单调用 实现1 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-core&lt;/artifactId&gt; &lt;version&gt;11.0&lt;/version&gt;&lt;/dependency&gt; 服务提供方 123456789101112131415161718/** * @since 2020-11-18 * 服务方 */@RestController@RequestMapping(&quot;/feign&quot;)public class FeignController &#123; @GetMapping(&quot;/get/&#123;id&#125;&quot;) public String test1(@PathVariable Integer id) &#123; return &quot;id1=&quot; + id; &#125; @GetMapping(&quot;/get&quot;) public String test2(@RequestParam Integer id) &#123; return &quot;id2=&quot; + id; &#125;&#125; 服务消费方 1234567891011121314/** * 消费方 * @since 2020-11-18 */public interface TestService &#123; //直接url path中添加参数 @RequestLine(&quot;GET /feign/get/&#123;id&#125;&quot;) String test1(@Param(&quot;id&quot;) Integer id); //url带参数 @RequestLine(&quot;GET /feign/get?id=&#123;id&#125;&quot;) String test2(@Param(&quot;id&quot;) Integer id);&#125; 测试 12345678910111213141516class TestServiceTest &#123; @Test void test1() &#123; TestService testService = Feign.builder().target(TestService.class, &quot;http://127.0.0.1:8080&quot;); String ret = testService.test1(1); System.out.println(ret); &#125; @Test void test2() &#123; TestService testService = Feign.builder().target(TestService.class, &quot;http://127.0.0.1:8080&quot;); String ret = testService.test2(2); System.out.println(ret); &#125;&#125; 实现2 pom.xml 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.github.openfeign/feign-okhttp --&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt; &lt;version&gt;11.0&lt;/version&gt;&lt;/dependency&gt; application.properties 12feign.httpclient.enabled=falsefeign.okhttp.enabled=true 12&#x2F;&#x2F; 启动@EnableFeignClients feign 123456789101112131415@Configuration@ConditionalOnClass(Feign.class)@AutoConfigureBefore(FeignAutoConfiguration.class)public class FeignOkHttpConfig &#123; @Bean public okhttp3.OkHttpClient okHttpClient()&#123; return new okhttp3.OkHttpClient.Builder() .readTimeout(60, TimeUnit.SECONDS) .connectTimeout(60, TimeUnit.SECONDS) .writeTimeout(120, TimeUnit.SECONDS) .connectionPool(new ConnectionPool()) .build(); &#125;&#125; feign代理 1234567891011121314151617181920212223/** * @since 2020-11-18 * * 调用方 */@FeignClient(name = &quot;feignClientProxy&quot;,url = &quot;http://localhost:8080&quot;)public interface FeignClientProxy &#123; @RequestMapping(value = &quot;/feign/get&quot;, method = RequestMethod.GET) @ResponseBody String invoke(@RequestParam(value=&quot;id&quot;) Integer id); /** * 容错处理类，当调用失败时 返回空字符串 */ @Component class DefaultFallback implements FeignClientProxy &#123; @Override public String invoke(@RequestParam(value=&quot;id&quot;) Integer id)&#123; return &quot;err&quot;; &#125; &#125;&#125; 调用方 123456789101112131415161718192021/** * 调用方 * @since 2020-11-18 */@Controller@RequestMapping(&quot;/demo&quot;)public class FeignDemoController &#123; @Autowired FeignClientProxy feignClientProxy; // http://localhost:8080/demo/feign?id=3 @RequestMapping(value = &quot;feign&quot;) @ResponseBody public String testFeign(@RequestParam(name = &quot;id&quot;) Integer id) throws JsonProcessingException &#123; ObjectMapper objectMapper = new ObjectMapper(); String respResponseBody = feignClientProxy.invoke(id); return &quot;调用结果:&quot; + objectMapper.writeValueAsString(respResponseBody); &#125;&#125;","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"http","slug":"http","permalink":"https://idea360.cn/tags/http/"},{"name":"feign","slug":"feign","permalink":"https://idea360.cn/tags/feign/"}]},{"title":"日志链路跟踪","slug":"log-trace","date":"2020-11-15T03:57:43.000Z","updated":"2021-02-24T14:50:15.442Z","comments":true,"path":"2020/11/15/log-trace/","link":"","permalink":"https://idea360.cn/2020/11/15/log-trace/","excerpt":"","text":"方案 链路跟踪有几个方面的问题需要考虑 应用内跟踪(MDC) 服务调用跟踪(HTTP) 实现 日志拦截器 12345678910111213141516171819202122232425public class LogInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //如果有上层调用就用上层的ID String traceId = request.getHeader(Constants.TRACE_ID); if (traceId == null) &#123; traceId = TraceIdUtil.getTraceId(); &#125; MDC.put(Constants.TRACE_ID, traceId); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //调用结束后删除 MDC.remove(Constants.TRACE_ID); &#125;&#125; 123456789@Configurationpublic class InterceptorConfig extends WebMvcConfigurerAdapter &#123; //实现拦截器 要拦截的路径以及不拦截的路径 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //注册自定义拦截器，添加拦截路径和排除拦截路径 registry.addInterceptor(new LogInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; HttpClient拦截器 1234567891011public class HttpClientTraceIdInterceptor implements HttpRequestInterceptor &#123; @Override public void process(HttpRequest httpRequest, HttpContext httpContext) throws HttpException, IOException &#123; String traceId = MDC.get(Constants.TRACE_ID); //当前线程调用中有traceId，则将该traceId进行透传 if (traceId != null) &#123; //添加请求体 httpRequest.addHeader(Constants.TRACE_ID, traceId); &#125; &#125;&#125; 123private static CloseableHttpClient httpClient = HttpClientBuilder.create() .addInterceptorFirst(new HttpClientTraceIdInterceptor()) .build(); OkHttp拦截器 1234567891011121314public class OkHttpTraceIdInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; String traceId = MDC.get(Constants.TRACE_ID); Request request = null; if (traceId != null) &#123; //添加请求体 request = chain.request().newBuilder().addHeader(Constants.TRACE_ID, traceId).build(); &#125; Response originResponse = chain.proceed(request); return originResponse; &#125;&#125; 123private static OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new OkHttpTraceIdInterceptor()) .build(); RestTemplate拦截器 1234567891011public class RestTemplateTraceIdInterceptor implements ClientHttpRequestInterceptor &#123; @Override public ClientHttpResponse intercept(HttpRequest httpRequest, byte[] bytes, ClientHttpRequestExecution clientHttpRequestExecution) throws IOException &#123; String traceId = MDC.get(Constants.TRACE_ID); if (traceId != null) &#123; httpRequest.getHeaders().add(Constants.TRACE_ID, traceId); &#125; return clientHttpRequestExecution.execute(httpRequest, bytes); &#125;&#125; 1restTemplate.setInterceptors(Arrays.asList(new RestTemplateTraceIdInterceptor())); 参考 https://github.com/houbb/auto-log https://github.com/purgeteam/log-trace-spring-boot https://juejin.im/post/6844904101483020295 https://juejin.im/entry/6844903669851242509 https://segmentfault.com/a/1190000020083061 https://juejin.im/post/6844904128351567885","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"log","slug":"log","permalink":"https://idea360.cn/tags/log/"},{"name":"日志","slug":"日志","permalink":"https://idea360.cn/tags/%E6%97%A5%E5%BF%97/"},{"name":"链路跟踪","slug":"链路跟踪","permalink":"https://idea360.cn/tags/%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/"}]},{"title":"Spring源码导入idea","slug":"import-spring-source-code-to-idea","date":"2020-11-15T03:03:19.000Z","updated":"2021-02-23T14:23:12.814Z","comments":true,"path":"2020/11/15/import-spring-source-code-to-idea/","link":"","permalink":"https://idea360.cn/2020/11/15/import-spring-source-code-to-idea/","excerpt":"","text":"前言 学习源码, 如果没有科学上网, 最好切换为国内源。不然等死了~ 构建 spring-framework 导入idea其实在项目根目录下有 import-into-idea.md 说明。 注意: 在idea2018下构建源码始终有各种失败，后来切换为idea2020.2一次成功了。 首先既然阅读源码，免不了需要加注解，所以最好fork一个仓库 1git clone https:&#x2F;&#x2F;github.com&#x2F;qidian360&#x2F;spring-framework.git 一般我们都在某个稳定分支操作，所以下载下来后切换到某个稳定分支 1234567891011# 查看taggit tag# 从tag中检出临时代码git checkout v5.3.1# 将该tag检出分支(注意，分支名和tag名不能相同)git checkout -b 5.3.1# 查看代码修改状态git status build.gradle 项目根目录下 build.gradle 文件 12345678910repositories &#123; maven &#123; url &quot;https://maven.aliyun.com/repository/apache-snapshots&quot; &#125; // maven &#123; url &quot;https://maven.aliyun.com/repository/spring&quot; &#125; maven &#123; url &quot;https://maven.aliyun.com/repository/google&quot; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/central&#x27;&#125; maven &#123; url &quot;https://maven.aliyun.com/repository/public&quot; &#125; maven &#123; url &quot;https://repo.spring.io/snapshot&quot; &#125; mavenCentral() maven &#123; url &quot;https://repo.spring.io/libs-spring-framework-build&quot; &#125;&#125; setting.gradle 项目根目录下setting.gradle(排除掉settings.gradle中的spring-aspects模块) 12345678910111213pluginManagement &#123; repositories &#123; maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;gradle-plugin&#39; &#125; maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;spring-plugin&#39;&#125; maven &#123; url &quot;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&quot; &#125; maven &#123; url &quot;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;central&quot; &#125; gradlePluginPortal() maven &#123; url &#39;https:&#x2F;&#x2F;repo.spring.io&#x2F;plugins-release&#39; &#125; &#125;&#125;&#x2F;&#x2F; 注释掉aspects&#x2F;&#x2F; include &quot;spring-aspects&quot; 安装gradle环境 按目录 gradle/wrapper/gradle-wrapper.properties 下版本安装并配置环境变量 按照官网导入文档导入(import-into-idea.md) 在项目根目录下执行 ./gradlew :spring-oxm:compileTestJava 在项目根目录下执行 ./gradlew :spring-core:compileTestJava 构建成功后即可导入idea 可能的异常处理 Lock file: /Volumes/cuishiying/source-code/spring-framework/buildSrc/.gradle/6.7/executionHistory/executionHistory.lock 1find ~/.gradle -type f -name &quot;*.lock&quot; -delete 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"idea","slug":"idea","permalink":"https://idea360.cn/tags/idea/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"版本归档","slug":"version-archive-sequence","date":"2020-11-13T05:04:32.000Z","updated":"2021-02-23T14:49:24.756Z","comments":true,"path":"2020/11/13/version-archive-sequence/","link":"","permalink":"https://idea360.cn/2020/11/13/version-archive-sequence/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 归档版本号生成 */public abstract class ArchiveSequence &#123; public static Pattern p = Pattern.compile(&quot;[0-9]&#123;1,&#125;&quot;); /** * 归档流水号 userId, date, serial */ private final Map&lt;String, Map&lt;String, AtomicInteger&gt;&gt; archiveNos = new ConcurrentHashMap&lt;String, Map&lt;String, AtomicInteger&gt;&gt;(); /** * 序号最小长度，userid+yyyyMMdd+no */ private final int length = 10; protected abstract String getArchiveNoFromDB(String userId); protected String generateArchiveNo(String userId) &#123; Map&lt;String, AtomicInteger&gt; atomicIntegerMap = archiveNos.computeIfAbsent(userId, k -&gt; initSequence(userId)); AtomicInteger sequence = atomicIntegerMap.get(getLocalDate()); if (Objects.isNull(sequence)) &#123; atomicIntegerMap.clear(); atomicIntegerMap.putIfAbsent(getLocalDate(), new AtomicInteger(0)); &#125; int no = atomicIntegerMap.get(getLocalDate()).incrementAndGet(); if (no &gt; 99) &#123; throw new RuntimeException(&quot;每天最多允许归档99次&quot;); &#125; return String.format(getLocalDate() + &quot;%02d&quot;, no); &#125; private Map&lt;String, AtomicInteger&gt; initSequence(String userId) &#123; String sequence = getArchiveNoFromDB(userId); int startSequence = 0; if (StringUtils.isNotBlank(sequence) &amp;&amp; sequence.length() &gt; length &amp;&amp; isNumeric(sequence.substring(sequence.length() - 10))) &#123; startSequence = Integer.parseInt(sequence.substring(sequence.length() - 2)); &#125; if (startSequence &gt; 99) &#123; throw new RuntimeException(&quot;每天最多允许归档99次&quot;); &#125; HashMap&lt;String, AtomicInteger&gt; map = new HashMap&lt;&gt;(1); map.put(getLocalDate(), new AtomicInteger(startSequence)); return map; &#125; private String getLocalDate() &#123; return DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;).format(LocalDate.now()); &#125; private boolean isNumeric(String s)&#123; Matcher m = p.matcher(s); return m.matches(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"归档","slug":"归档","permalink":"https://idea360.cn/tags/%E5%BD%92%E6%A1%A3/"}]},{"title":"docker实战之ELK","slug":"docker-elk-standalone","date":"2020-11-07T15:50:01.000Z","updated":"2021-02-23T14:16:55.577Z","comments":true,"path":"2020/11/07/docker-elk-standalone/","link":"","permalink":"https://idea360.cn/2020/11/07/docker-elk-standalone/","excerpt":"","text":"docker搭建ELK 首先我们搭建ELK环境, 然后再引入缓存Kafka, 数据流为: 1log--&gt;logstash-agent--&gt;kafka--&gt;logstash--&gt;es--&gt;kibana 首先全局了解下文件结构 1234567891011121314151617181920212223.├── docker-compose.yml├── kafka│ ├── data│ │ └── kafka-logs-e07760a64ec8│ │ ├── cleaner-offset-checkpoint│ │ ├── log-start-offset-checkpoint│ │ ├── meta.properties│ │ ├── recovery-point-offset-checkpoint│ │ ├── replication-offset-checkpoint│ │ └── test-0│ │ ├── 00000000000000000000.index│ │ ├── 00000000000000000000.log│ │ ├── 00000000000000000000.timeindex│ │ └── leader-epoch-checkpoint│ └── docker.sock├── kibana│ └── kibana.yml├── logstash│ └── logstash.conf└── zookeeper ├── data └── datalog docker-compose-elk.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374version: &quot;3&quot;services: elasticsearch: image: elasticsearch:7.7.0 container_name: elasticsearch hostname: elasticsearch environment: - &quot;discovery.type=single-node&quot; ports: - 9200:9200 - 9300:9300 networks: - elknetwork kibana: image: kibana:7.7.0 container_name: kibana hostname: kibana ports: - 5601:5601 volumes: - ./kibana:/usr/share/kibana/config/ links: - elasticsearch:elasticsearch depends_on: - elasticsearch networks: - elknetwork logstash: image: logstash:7.7.0 container_name: logstash hostname: logstash ports: - 9600:9600 - 8089:8089 volumes: - ./logstash:/usr/share/logstash/pipeline/ links: - elasticsearch:elasticsearch depends_on: - elasticsearch networks: - elknetwork zookeeper: image: wurstmeister/zookeeper container_name: zookeeper restart: unless-stopped ports: - &quot;2181:2181&quot; volumes: - ./zookeeper/data:/data - ./zookeeper/datalog:/datalog networks: - elknetwork kafka: image: wurstmeister/kafka container_name: kafka restart: unless-stopped ports: - &quot;9092:9092&quot; environment: KAFKA_ADVERTISED_HOST_NAME: 192.168.124.5 # 用ifconfig查询，或直接填写kafka KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_CREATE_TOPICS: &quot;test:1:1&quot; KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.124.5:9092 ## 修改:宿主机IP volumes: - &quot;./kafka/docker.sock:/var/run/docker.sock&quot; - &quot;./kafka/data/:/kafka&quot; depends_on: - zookeeper networks: - elknetworknetworks: elknetwork: driver: bridge 注意: logstash没数据源时会主动停止进程, 勿慌 kibana.yml 12345server.name: kibanaserver.host: &quot;0&quot;elasticsearch.hosts: [ &quot;http://elasticsearch:9200&quot; ]monitoring.ui.container.elasticsearch.enabled: truei18n.locale: &quot;zh-CN&quot; logstash.conf 123456789input &#123; tcp &#123; port =&gt; 8089 &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;elasticsearch:9200&quot;] &#125;&#125; docker中logstash默认配置(/usr/share/logstash/config/pipelines.yml) 12- pipeline.id: main path.config: &quot;/usr/share/logstash/pipeline&quot; docker中logstash默认配置(/usr/share/logstash/config/logstash.yml) 12http.host: &quot;0.0.0.0&quot;xpack.monitoring.elasticsearch.hosts: [ &quot;http://elasticsearch:9200&quot; ] 熟悉docker中默认配置 123456# 进入docker容器docker exec -it logstash /bin/bash# 查看文件目录ls# 查看docker中配置文件more config/logstash.yaml logstash中 /usr/share/logstash/config/pipelines.yml 将配置文件指向 /usr/share/logstash/pipeline 目录下, 该目录下是我们真实的配置文件目录 kibana中 /usr/share/kibana/config/kibana.yml 可以修改为中文 log4j2通过tcp将日志输出到logstash pom.xml 12345678910111213141516171819 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; --&gt; log4j2-spring.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;OFF&quot; monitorInterval=&quot;60&quot;&gt; &lt;Appenders&gt; &lt;!-- Console 日志，只输出 level 及以上级别的信息，并配置各级别日志输出颜色 --&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;%highlight&#123;%d&#123;yyyy.MM.dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %M() @%L - %msg%n&#125;&#123;FATAL=Bright Red, ERROR=Bright Magenta, WARN=Bright Yellow, INFO=Bright Green, DEBUG=Bright Cyan, TRACE=Bright White&#125;&quot;/&gt; &lt;/Console&gt; &lt;!-- socket 日志，输出日志到 Logstash 中做日志收集 --&gt; &lt;Socket name=&quot;Socket&quot; host=&quot;127.0.0.1&quot; port=&quot;8089&quot; protocol=&quot;TCP&quot;&gt; &lt;JsonLayout properties=&quot;true&quot; compact=&quot;true&quot; eventEol=&quot;true&quot; /&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy.MM.dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %M() @%L - %msg%n&quot;/&gt; &lt;/Socket&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;INFO&quot;&gt; &lt;property name=&quot;hostName&quot;&gt;cuishiying&lt;/property&gt; &lt;property name=&quot;applicationName&quot;&gt;elk-demo&lt;/property&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;Socket&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 测试 12345678910111213141516171819202122232425@RestController@RequestMapping(&quot;/test&quot;)public class LogController &#123; private Logger logger = LogManager.getLogger(LogController.class); // http://127.0.0.1:8080/test/log4j2 @RequestMapping(value = &quot;/log4j2&quot;, method = RequestMethod.GET) public String testLog()&#123; try &#123; MDC.put(&quot;traceid&quot;, String.valueOf(System.currentTimeMillis())); logger.info(&quot;Hello 这是 info message. 信息&quot;); logger.error(&quot;Hello 这是 error message. 报警&quot;); logger.warn(&quot;Hello 这是 warn message. 警告&quot;); logger.debug(&quot;Hello 这是 debug message. 调试&quot;); List&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list.get(2)); &#125; catch (Exception e) &#123; logger.error(&quot;testLog&quot;, e); &#125; finally &#123; MDC.clear(); &#125; return &quot;&quot;; &#125;&#125; 项目启动后，点击management可以看到: logstash会按默认规则自动在ES中创建索引。我们需要手动创建kibana索引， 然后在discover中即可看到日志 用socket方式将日志传输给logstash，如果把logstash停掉然后再启动，日志就无法继续传输了，也就是说socket无法自动重连，这在生产环境中，当然是个隐患。所以生产环境一般会用Logstash-gelf 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration&gt; &lt;Properties&gt; &lt;Property name=&quot;LOG_PATTERN&quot;&gt;&#123;&quot;logger&quot;: &quot;%logger&quot;, &quot;level&quot;: &quot;%level&quot;, &quot;msg&quot;: &quot;%message&quot;&#125;%n&lt;/Property&gt; &lt;/Properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot; follow=&quot;true&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt; &lt;/Console&gt; &lt;Gelf name=&quot;logstash-gelf&quot; host=&quot;udp:127.0.0.1&quot; port=&quot;4567&quot; version=&quot;1.1&quot; ignoreExceptions=&quot;true&quot;&gt; &lt;Field name=&quot;timestamp&quot; pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&quot; /&gt; &lt;Field name=&quot;logger&quot; pattern=&quot;%logger&quot; /&gt; &lt;Field name=&quot;level&quot; pattern=&quot;%level&quot; /&gt; &lt;Field name=&quot;simpleClassName&quot; pattern=&quot;%C&#123;1&#125;&quot; /&gt; &lt;Field name=&quot;className&quot; pattern=&quot;%C&quot; /&gt; &lt;Field name=&quot;server&quot; pattern=&quot;%host&quot; /&gt; &lt;/Gelf&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;INFO&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;logstash-gelf&quot; /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; log4j2将日志输出到kafka log4j2-spring.xml 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;OFF&quot; monitorInterval=&quot;60&quot;&gt; &lt;Properties&gt; &lt;property name=&quot;log_pattern_console&quot;&gt;%highlight&#123;%d&#123;yyyy.MM.dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %M() @%L - %msg%n&#125;&#123;FATAL=Bright Red, ERROR=Bright Magenta, WARN=Bright Yellow, INFO=Bright Green, DEBUG=Bright Cyan, TRACE=Bright White&#125;&lt;/property&gt; &lt;!-- 日志文件默认输出格式;%X&#123;traceid&#125;:链路id;%C:大写,类名;%M:方法名;%l:行号,影响性能;%m:信息;%n:换行 --&gt; &lt;property name=&quot;log_pattern&quot;&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;traceid&#125;] [%-5level] %l - %m%n&lt;/property&gt; &lt;/Properties&gt; &lt;Appenders&gt; &lt;!-- Console 日志，只输出 level 及以上级别的信息，并配置各级别日志输出颜色 --&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;$&#123;log_pattern_console&#125;&quot;/&gt; &lt;/Console&gt; &lt;!-- kafka 日志，输出日志到 Logstash 中做日志收集 --&gt; &lt;Kafka name=&quot;Kafka&quot; topic=&quot;test&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;log_pattern&#125;&quot;/&gt; &lt;Property name=&quot;bootstrap.servers&quot;&gt;localhost:9092&lt;/Property&gt; &lt;/Kafka&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;INFO&quot;&gt; &lt;property name=&quot;hostName&quot;&gt;cuishiying&lt;/property&gt; &lt;property name=&quot;app_name&quot;&gt;elk-demo&lt;/property&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;!--&lt;appender-ref ref=&quot;Socket&quot;/&gt;--&gt; &lt;AppenderRef ref=&quot;Kafka&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 此时，日志可以直接输出到kafka中 log4j2将日志通过kafka输出到elk中 修改logstash.conf, 将输入源设置为kafka, 输出设置为es， 以kafka的topic和日期创建es索引 logstash.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556input &#123; kafka&#123; bootstrap_servers &#x3D;&gt; [&quot;kafka:9092&quot;] topics_pattern &#x3D;&gt; &quot;test*&quot; group_id &#x3D;&gt; &quot;logstash-test-group&quot; consumer_threads &#x3D;&gt; 5 codec &#x3D;&gt; &quot;json&quot; # logstash-kafka 插件输入和输出默认codec为json格式 decorate_events &#x3D;&gt; true #此属性会将当前topic、offset、group、partition等信息也带到message中 auto_offset_reset &#x3D;&gt; &quot;latest&quot; type &#x3D;&gt; &quot;test&quot; #所有插件通用属性,尤其在input里面配置多个数据源时很有用 &#125; kafka&#123; bootstrap_servers &#x3D;&gt; [&quot;kafka:9092&quot;] topics_pattern &#x3D;&gt; &quot;ocpc*&quot; group_id &#x3D;&gt; &quot;logstash-ocpc-group&quot; consumer_threads &#x3D;&gt; 5 codec &#x3D;&gt; &quot;json&quot; decorate_events &#x3D;&gt; true #此属性会将当前topic、offset、group、partition等信息也带到message中 auto_offset_reset &#x3D;&gt; &quot;latest&quot; type &#x3D;&gt; &quot;ocpc&quot; #所有插件通用属性,尤其在input里面配置多个数据源时很有用 &#125;&#125;filter &#123; json &#123; source &#x3D;&gt; &quot;message&quot; &#125; mutate&#123; remove_field &#x3D;&gt; &quot;@version&quot; &#125;&#125;output &#123; if[type] &#x3D;&#x3D; &quot;test&quot; &#123; elasticsearch &#123; hosts &#x3D;&gt; [&quot;elasticsearch:9200&quot;] index &#x3D;&gt; &quot;%&#123;[@metadata][kafka][topic]&#125;-%&#123;app_name&#125;-%&#123;+YYYYMMdd&#125;&quot; manage_template &#x3D;&gt; false # 取消logstash自定义模板功能，进而强制使用es的内置模板 &#125; stdout &#123; codec &#x3D;&gt; rubydebug &#123;metadata &#x3D;&gt; true&#125; #logstash控制台输出日志和@metadata信息 &#125; &#125; if[type] &#x3D;&#x3D; &quot;ocpc&quot; &#123; elasticsearch &#123; hosts &#x3D;&gt; [&quot;elasticsearch:9200&quot;] index &#x3D;&gt; &quot;%&#123;[@metadata][kafka][topic]&#125;-%&#123;+YYYYMMdd&#125;&quot; manage_template &#x3D;&gt; false # 取消logstash自定义模板功能，进而强制使用es的内置模板 &#125; stdout &#123; codec &#x3D;&gt; rubydebug &#123;metadata &#x3D;&gt; true&#125; #logstash控制台输出日志和@metadata信息 &#125; &#125; &#125; 重启docker 1docker-compose restart logstash 访问 http://localhost:5601, 可以看到日志已正常输出到ELK中, 包括异常栈。 日志链路追踪 上边的 MDC 放入traceid的操作可以通过过滤器统一放入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.easyliao.auth.common.filter;​​import com.easyliao.auth.common.utils.IdUtils;import com.easyliao.auth.common.utils.IpUtil;import com.easyliao.auth.common.utils.RequestUtils;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.slf4j.MDC;import org.springframework.core.Ordered;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import org.springframework.web.filter.OncePerRequestFilter;​import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;​@Slf4j@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;logFilter&quot;)@Order(value = Ordered.HIGHEST_PRECEDENCE)@Componentpublic class LogFilter extends OncePerRequestFilter &#123;​ private final String TRACE_ID = &quot;traceid&quot;; private final String IP = &quot;ip&quot;; private final String DEFAULT_TRACE_ID = &quot;0&quot;;​ @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; try &#123; // traceId初始化 initTraceId(httpServletRequest); // 初始化ip initIp(httpServletRequest); // 入口信息 log(httpServletRequest, httpServletResponse); // 执行后续过滤器 filterChain.doFilter(httpServletRequest,httpServletResponse); &#125; finally &#123; afterLog(httpServletRequest, httpServletResponse); &#125; &#125;​ private void log(HttpServletRequest request, HttpServletResponse response)&#123; if (!log.isInfoEnabled()) &#123; return; &#125; log.info(&quot;\\n请求地址: [&#123;&#125;] \\n请求参数: [&#123;&#125;]&quot;, request.getRequestURL().toString(), RequestUtils.getFormParams(request) ); &#125;​ private void afterLog(HttpServletRequest req, HttpServletResponse response) &#123; MDC.remove(TRACE_ID); MDC.remove(IP); &#125;​ private void initIp(HttpServletRequest servletRequest) &#123; MDC.put(IP, IpUtil.getIpAddr(servletRequest)); &#125;​ private void initTraceId(HttpServletRequest request) &#123; //尝试获取http请求中的traceId String traceId = request.getParameter(TRACE_ID);​ //如果当前traceId为空或者为默认traceId，则生成新的traceId if (StringUtils.isBlank(traceId) || this.defaultTraceId(traceId))&#123; traceId = this.genTraceId(); &#125;​ //设置traceId this.setTraceId(traceId); &#125;​ public Boolean defaultTraceId(String traceId) &#123; return DEFAULT_TRACE_ID.equals(traceId); &#125;​ public String genTraceId() &#123; return IdUtils.uuid(); &#125;​ public void setTraceId(String traceId) &#123; //如果参数为空，则设置默认traceId traceId = StringUtils.isBlank(traceId) ? DEFAULT_TRACE_ID : traceId; //将traceId放到MDC中 MDC.put(TRACE_ID, traceId); &#125; public String getTraceId() &#123; //获取 String traceId = MDC.get(TRACE_ID); //如果traceId为空，则返回默认值 return StringUtils.isBlank(traceId) ? DEFAULT_TRACE_ID : traceId; &#125;&#125; logback+kafka+elk pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;elk-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;elk-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.danielwegener&lt;/groupId&gt; &lt;artifactId&gt;logback-kafka-appender&lt;/artifactId&gt; &lt;version&gt;0.2.0-RC2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; logback-spring.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位， 默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。 默认值为false。 --&gt;&lt;!-- &lt;configuration scan=&quot;false&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; --&gt;&lt;configuration&gt; &lt;!-- 日志文件默认输出格式;%X&#123;traceid&#125;:链路id;%C:大写,类名;%M:方法名;%l:行号,影响性能;%m:信息;%n:换行 --&gt; &lt;property name=&quot;log_pattern&quot; value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;traceid&#125;] [%-5level] %L - %m%n&quot;/&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log_pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- This is the kafkaAppender --&gt; &lt;appender name=&quot;kafkaAppender&quot; class=&quot;com.github.danielwegener.logback.kafka.KafkaAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log_pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;topic&gt;test&lt;/topic&gt; &lt;keyingStrategy class=&quot;com.github.danielwegener.logback.kafka.keying.NoKeyKeyingStrategy&quot; /&gt; &lt;deliveryStrategy class=&quot;com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy&quot; /&gt; &lt;!-- Optional parameter to use a fixed partition --&gt; &lt;!-- &lt;partition&gt;0&lt;/partition&gt; --&gt; &lt;!-- Optional parameter to include log timestamps into the kafka message --&gt; &lt;!-- &lt;appendTimestamp&gt;true&lt;/appendTimestamp&gt; --&gt; &lt;!-- each &lt;producerConfig&gt; translates to regular kafka-client config (format: key=value) --&gt; &lt;!-- producer configs are documented here: https://kafka.apache.org/documentation.html#newproducerconfigs --&gt; &lt;!-- bootstrap.servers is the only mandatory producerConfig --&gt; &lt;producerConfig&gt;bootstrap.servers=localhost:9092&lt;/producerConfig&gt; &lt;!-- this is the fallback appender if kafka is not available. --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;appender-ref ref=&quot;kafkaAppender&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; application.properties 1logging.config=classpath:logback-spring.xml 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://medium.com/@harisshafiq08/elk-stack-deployment-through-docker-compose-98ce40ff2fb6 https://2much2learn.com/centralized-logging-with-kafka-and-elk-stack/ https://yangbingdong.com/2018/spring-boot-docker-elk/ https://github.com/Haris3243/docker-elkstack http://liupzmin.com/2018/03/20/bigdata/logstash-consume-from-kafka-to-elasticsearch/","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"elk","slug":"elk","permalink":"https://idea360.cn/tags/elk/"}]},{"title":"真正拖垮你的，是沉没成本","slug":"life-1","date":"2020-11-07T06:02:33.000Z","updated":"2021-02-23T14:36:45.069Z","comments":true,"path":"2020/11/07/life-1/","link":"","permalink":"https://idea360.cn/2020/11/07/life-1/","excerpt":"","text":"我们人生中 90% 的不幸， 都是因为不甘心引起的。 不懂沉没成本 你越坚持，就越被坑 假设你跟朋友去吃自助餐，这家店里的食材都很新鲜，味道很好，你们吃得很饱。 当你们起身准备走的时候，每桌限量一份的黑松露鹅肝，送到了你的面前。 你会怎么做？ 我们大多数人，即使吃饱了， 也会塞下那一份鹅肝。 难怕会撑得难受，甚至因此影响到接下来的逛街、电影等休闲项目，还是会坚持“环保不浪费”的原则，让不堪重负的胃，再加上一层负担。 因为它们很贵、限量，我们付了自助餐的钱，不想亏本。 类似的场景，每天都在我们身边上演。我们可以用一个经济学词汇来解释——沉没成本。 沉没成本，指的是那些发生在过去，我们无法去收回或改变的付出。 这些付出，包括且不限于金钱、时间、精力、感情等等。 听起来好像没感觉？ 但其实人们总是一而再、再而三地栽在沉没成本上面。 为了过去的付出和错误，跟现在的自己较劲，赌气般地做出不理性的决策。 相处了4年的男朋友，即使不喜欢了，也想着先凑合着过过。 等了半个小时公交，你甚至感觉快要中暑了，还想再坚持一下，省个打车钱。 进了一个景点，明知道被坑了，但是“来都来了”，那还是转一圈吧。 为什么我们明知吃了亏，还是无法停下脚步？任由已经付出的东西，对自己施加新的伤害？ 沉没成本考验的 是我们内心的恐惧和自尊 我们都害怕，被证明自己是错的。 因为在面对质疑、遭到损失时，我们大脑中的杏仁体，都会将其识别成攻击，本能地自我防御。 这让我们习惯于，把外界的反馈（尤其是负面反馈）和自我价值，完成绑定。 否认过去的选择，就等于是在否定过去的自己。为了缓解这种痛苦，我们宁愿继续坚持，当初错误的决定。 这是一种最原始的本能。 这种本能的恐惧，导致了“损失厌恶效应”。 我们相比于“获得”的快乐，我们对“损失”更加敏感。 举个例子： 你跳槽到一家新公司，薪资从 6000 直接涨到了 12000，你很开心。 直到你无意中听到部门里另一个新同事，老板给了他 15000，锚定的标准，从 6000 变成了 15000。 于是每月多得 6000 的快乐，马上被自己每月损失了 3000 的悲伤所替代。 生活中，因为“损失厌恶”，为了弥补过去的错误，我们会倾向于继续加码，把更多时间，耗在希望不大的事情上。 除此之外，我们也常常给坚持的事情，套上“拥有物光环”。 社会心理学家西奥迪尼，在《影响力》中提到过一个现象： “赛马场的人们下注之前，会在众多马匹之间犹豫不决；可是一旦下注了某一匹马，这匹马在他们心中，获胜的几率便会大大增加。” 因为我们希望，我们的选择是正确的。 这种愿望，会让我们高估这个选项的未来价值，和事件发生的概率。 因此你已经花了钱在它上面，你不愿意放弃它。 这两种情况，最终都是我们自我防御的本能占了上风，最终影响了我们决策的正确性。 为了证明我们是对的、有价值的，我们宁愿投入很多当下的精力，去给过去填坑，去合理化每一个过去的选择。 于是我们的理性思考能力，彻底失去了用武之地。 别被过去绑架 接受错误，才能避免更大的损失 世上无难事，只要肯放弃。 不能将视线，从过去的事情上移开，将会让我们错过接下来无数次止损的机会。 电信诈骗大家都知道吧，现在我们清楚了他们的套路，可在以前信息流通不发达的时代，被他们骗上钩的人并不少。 骗子们先利用人们不劳而获的心理，许诺大家未来能拿到大钱，让大家交个一百两百的小钱； 然后利用这部分沉没成本，一点一点收线，哄骗对方交更多的钱，达成诈骗的目的。 如果人们一开始，意识到不对就抽身退出，而不是盯着已经打了水漂的钱，就不会有后面更大的悲剧了。 当然了，不止骗子会用，手握更多资源的商家，更是用“沉没成本”设计套路的好手。 凡是有人性弱点的地方，也会带来商机。 最常见的，就是交定金了。 买车、买保险等很多时候，我们总会对产品或服务的某个部分有疑虑，不够满意，只差最后刷卡这一步，迟迟无法下决定。 而商家让我们先交一部分小额的钱，用这部分沉没成本将我们锁定，最终完成大额的交易。 而网购、外卖的满减也是一样。 每次逛淘宝，明明只需要买一瓶 30 多的洗衣液，最后却非要凑天猫超市 199-30 的满减。 不凑齐那 30 块的满减，就是亏了；最后买了一大堆不需要的东西，呆在角落吃灰。 及时放弃，是一种智慧。 能帮助我们避免更大的损失，明晰我们真正想要的东西。 就像山下英子在《断舍离》一书中所说： “不管东西有多贵，有多稀有，能够按照自己是否需要来判断的人，才够强大。” 忘掉沉没成本，及时断舍离，是我们对抗资本家和消费主义最好的利器。 做未来的主人 你该考虑的是机会成本 如果说，沉没成本决定了人们如何看待过去；那么机会成本，则决定了人们如何面对未来。 “机会成本”的经济学概念是指：我现在选了选项 A，如果我转而选择其他 B、C、D…中的某一个，它们所能带给我最高价值。 简单点说，比如周末你有两个小时时间，可以用来打游戏，也可以用来看电影；打游戏带来的快乐和看电影带来的放松，就互为机会成本。 相比于沉没成本，机会成本，才是决定我们未来幸福的那一个。 但却也是在沉没成本面前，被我们忽略的那一个。 ​ 柯达就是个活生生的例子： 上个世纪，柯达是胶片时代的霸主，但很多人却不知道，它才是第一个发明数码相机的公司。 可是他们面对数码相机潜力无限的机会成本，却死守过去胶片时代，技术和市场占有率的优势，放不下投入的人力物力的沉没成本。 最后在数码时代的浪潮下，巨轮倾覆。 所以，我们每一个人做选择时，都要问自己两个问题： 我现在做的事情，对未来能否产生持续积极的影响？ 我现在的决策，有没有被过去的付出所左右？ 想好这两个问题，将会影响我们当下和未来的幸福水平。 没有谁，喜欢被当作一个轻易放弃的人。 同样地，背负着沉重的过去，也让我们难以承受。因为，为一个错误的选择而苦苦坚持，也是一种失败。 这时候恰到好处的放弃，才让我们有机会更快接近，拨云见日的那天。","categories":[{"name":"生活","slug":"生活","permalink":"https://idea360.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://idea360.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"docker实战之kafka单机版","slug":"docker-kafka-standalone","date":"2020-11-05T17:27:01.000Z","updated":"2021-02-23T14:17:15.310Z","comments":true,"path":"2020/11/06/docker-kafka-standalone/","link":"","permalink":"https://idea360.cn/2020/11/06/docker-kafka-standalone/","excerpt":"","text":"docker-compose-kafka-standalone.yml 12345678910111213141516171819202122version: &#x27;3.7&#x27;services: zookeeper: image: wurstmeister/zookeeper container_name: zookeeper ports: - &quot;2181:2181&quot; volumes: - ./zookeeper/data:/data - ./zookeeper/datalog:/datalog kafka: image: wurstmeister/kafka container_name: kafka ports: - &quot;9092:9092&quot; environment: KAFKA_ADVERTISED_HOST_NAME: 192.168.124.5 # 用ifconfig查询，或直接填写kafka KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_CREATE_TOPICS: &quot;test:1:1&quot; volumes: - &quot;./kafka/docker.sock:/var/run/docker.sock&quot; - &quot;./kafka/data/:/kafka&quot;","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"kafka","slug":"kafka","permalink":"https://idea360.cn/tags/kafka/"}]},{"title":"Spring-Security基本使用","slug":"spring-security-example","date":"2020-10-17T08:58:17.000Z","updated":"2021-02-23T14:45:27.537Z","comments":true,"path":"2020/10/17/spring-security-example/","link":"","permalink":"https://idea360.cn/2020/10/17/spring-security-example/","excerpt":"","text":"概述 spring security基本项目搭建。 代码 pom.xml 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 123456spring: thymeleaf: prefix: classpath:/templates/ suffix: .html cache: false mode: HTML templates/login.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; class=&quot;uk-height-1-1&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;OAuth2 SSO Demo&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/uikit/2.26.3/css/uikit.gradient.min.css&quot;/&gt;&lt;/head&gt;&lt;body class=&quot;uk-height-1-1&quot;&gt;&lt;div class=&quot;uk-vertical-align uk-text-center uk-height-1-1&quot;&gt; &lt;div class=&quot;uk-vertical-align-middle&quot; style=&quot;width: 250px;&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;p class=&quot;uk-text-danger&quot; th:if=&quot;$&#123;param.error&#125;&quot;&gt; Login failed ... &lt;/p&gt; &lt;p class=&quot;uk-text-success&quot; th:if=&quot;$&#123;param.logout&#125;&quot;&gt; Logout succeeded. &lt;/p&gt; &lt;form class=&quot;uk-panel uk-panel-box uk-form&quot; method=&quot;post&quot; th:action=&quot;@&#123;/web/login&#125;&quot;&gt; &lt;div class=&quot;uk-form-row&quot;&gt; &lt;input class=&quot;uk-width-1-1 uk-form-large&quot; type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot; value=&quot;user&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;uk-form-row&quot;&gt; &lt;input class=&quot;uk-width-1-1 uk-form-large&quot; type=&quot;password&quot; placeholder=&quot;Password&quot; name=&quot;password&quot; value=&quot;123&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;uk-form-row&quot;&gt; &lt;button class=&quot;uk-width-1-1 uk-button uk-button-primary uk-button-large&quot;&gt;Login&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Main 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@SpringBootApplicationpublic class IdcSecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(IdcSecurityApplication.class, args); &#125; @Configuration @EnableWebSecurity @Order(1) static class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); auth .inMemoryAuthentication() .withUser(&quot;user&quot;).password(passwordEncoder.encode(&quot;123&quot;)).roles(&quot;USER&quot;).and() .withUser(&quot;manager&quot;).password(passwordEncoder.encode(&quot;123&quot;)).roles(&quot;MANAGER&quot;); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.antMatcher(&quot;/web/**&quot;) // the filter chain defined for web request .authorizeRequests() .antMatchers(&quot;/web/report/**&quot;).hasRole(&quot;MANAGER&quot;) .anyRequest().authenticated() .and() .formLogin() // login 的相对路径必须与 security chain 的的相对路径吻合，这里是 /web/**；注意 login 分两步，一步是 Getter 会到 login.html，另外一步是从 login.html -&gt; post -&gt; /web/login/ .loginPage(&quot;/web/login&quot;) // http://localhost:8080/web/login // 允许访问 .permitAll(); &#125; &#125; @Configuration @EnableWebSecurity @Order(2) static class RestSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.antMatcher(&quot;/rest/**&quot;) // the filter chain defined for web request； .csrf().disable() // rest 请求无需 CSRF Token； .authorizeRequests() .antMatchers(&quot;/rest/hello&quot;).hasRole(&quot;USER&quot;) .anyRequest().authenticated() .and() .httpBasic(); &#125; &#125; @Bean PasswordEncoder passwordEncoder()&#123; return PasswordEncoderFactories.createDelegatingPasswordEncoder(); &#125;&#125; IndexContrller 123456789101112131415@Controllerpublic class IndexController &#123; @GetMapping(&quot;/web/login&quot;) public ModelAndView login() &#123; return new ModelAndView(&quot;login&quot;); &#125; @GetMapping @ResponseBody public Object index() &#123; return &quot;hello&quot;; &#125;&#125; 源码 SecurityAutoConfiguration SecurityFilterAutoConfiguration DelegatingFilterProxy EnableWebSecurity WebSecurityConfiguration WebSecurity FilterChainProxy SecurityFilterChain 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://docs.spring.io/spring-security/site/docs/3.2.0.CI-SNAPSHOT/reference/html/security-filter-chain.html","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"security","slug":"security","permalink":"https://idea360.cn/tags/security/"}]},{"title":"Markdown时序图","slug":"markdown-uml-sequence-diagram","date":"2020-10-13T10:28:57.000Z","updated":"2021-02-23T14:38:06.299Z","comments":true,"path":"2020/10/13/markdown-uml-sequence-diagram/","link":"","permalink":"https://idea360.cn/2020/10/13/markdown-uml-sequence-diagram/","excerpt":"","text":"概述 话不多说，先来看看用代码画的时序图的效果。如下图是小程序登陆过程中，小程序、服务器、微信服务器三者交互的时序图： 1234567sequenceDiagram 小程序 -&gt;&gt; 小程序 : wx.login()获取code 小程序 -&gt;&gt; + 服务器 : wx.request()发送code 服务器 -&gt;&gt; + 微信服务器 : code+appid+secret 微信服务器 --&gt;&gt; - 服务器 : openid 服务器 -&gt;&gt; 服务器 : 根据openid确定用户并生成token 服务器 --&gt;&gt; - 小程序 : token 参与者 传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。 123sequenceDiagram participant 客户端 participant 服务器 sequenceDiagram 为每幅时序图的固定开头 participant &lt;参与者名称&gt; 声明（添加）参与者。语句次序即为参与者横向排列的次序，如后续示例所示。 消息 交互时一方对另一方的操作（比如接口调用）或传递出的信息。用单向箭头来表示——实线代表主动发出消息；虚线代表响应；末尾带「X」代表异步消息，无需等待回应。 1234567sequenceDiagram participant 老板L participant 员工A 老板L -&gt;&gt; 员工A : “在这里我们是兄弟！” 老板L -x 员工A : 画个饼 员工A --&gt;&gt; 老板L : 怯怯地鼓掌 消息语句格式为：&lt;参与者&gt; &lt;箭头&gt; &lt;参与者&gt; : &lt;描述文本&gt;。 其中 &lt;箭头&gt; 的写法有： -&gt;&gt;：显示为实线箭头（主动发出消息） –&gt;&gt;：显示为虚线箭头（响应） -x：显示为末尾带「X」的实线箭头（异步消息） 激活框 从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。 画法如下，注意体会箭头符号后的 + 和 - 的使用方法和效果，它们相当于激活框的开关： 12345sequenceDiagram 老板M -&gt;&gt; + 员工B : “不仅996，还要669！” 员工B --&gt;&gt; - 老板M : 怯怯地鼓掌 老板M -&gt;&gt; + 员工B : “悔创本司！” 员工B --&gt;&gt; - 老板M : 怯怯地鼓掌 注解 1234sequenceDiagram Note left of 老板L : 对脸不感兴趣 Note right of 老板M : 对钱不感兴趣 Note over 老板L,老板M : 对996感兴趣 循环 在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。） 12345678sequenceDiagram 网友 -&gt;&gt; + X宝 : 网购钟意的商品 X宝 --&gt;&gt; - 网友 : 下单成功 loop 一天七次 网友 -&gt;&gt; + X宝 : 查看配送进度 X宝 --&gt;&gt; - 网友 : 配送中 end 选择 在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。） 12345678910111213sequenceDiagram 土豪 -&gt;&gt; 取款机 : 查询余额 取款机 --&gt;&gt; 土豪 : 余额 alt 余额 &gt; 5000 土豪 -&gt;&gt; 取款机 : 取上限值 5000 块 else 100 &lt; 余额 &lt; 5000 土豪 -&gt;&gt; 取款机 : 有多少取多少 else 余额 &lt; 100 土豪 -&gt;&gt; 取款机 : 退卡 end 取款机 --&gt;&gt; 土豪 : 退卡 可选 在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。 123456sequenceDiagram 老板们 -&gt;&gt; 员工们 : 开始实行996 opt 永不可能 员工们 --&gt;&gt; 老板们 : 拒绝 end 并行 将消息序列分成多个片段，这些片段并行执行。 123456789101112sequenceDiagram老板C -&gt;&gt; 员工C : 开始实行996par 并行 员工C -&gt;&gt; 员工C : 刷微博and 员工C -&gt;&gt; 员工C : 工作and 员工C -&gt;&gt; 员工C : 刷朋友圈end员工C --&gt;&gt; 老板C : 9点下班 参考 https://dwz.cn/hOMIoH4w","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"markdown","slug":"markdown","permalink":"https://idea360.cn/tags/markdown/"},{"name":"时序图","slug":"时序图","permalink":"https://idea360.cn/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/"}]},{"title":"spring-security-oauth2","slug":"spring-security-oauth2","date":"2020-10-11T08:15:17.000Z","updated":"2021-02-23T14:45:35.440Z","comments":true,"path":"2020/10/11/spring-security-oauth2/","link":"","permalink":"https://idea360.cn/2020/10/11/spring-security-oauth2/","excerpt":"","text":"概述 通过 Spring Security 实现 OAuth 2.0 快速导航。以下案例基于 java11 搭建。 创建 OAuth 2.0 服务 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idc-oauth2&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;idc-oauth2&lt;/name&gt; &lt;description&gt;Spring Boot + Security + OAuth2&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--基础环境--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--OAuth 2.0--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--jdk9以上适配--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 12server: port: 8080 认证服务配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-11 */@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private PasswordEncoder passwordEncoder; @Autowired private UserDetailsService userDetailsService; @Primary @Bean public InMemoryTokenStore inMemoryTokenStore()&#123; return new InMemoryTokenStore(); &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientId&quot;) .secret(passwordEncoder.encode(&quot;secret&quot;)) .authorizedGrantTypes(&quot;authorization_code&quot;, &quot;password&quot; , &quot;refresh_token&quot;, &quot;client_credentials&quot;) //&quot;authorization_code&quot;, .scopes(&quot;all&quot;) .autoApprove(true) .redirectUris(&quot;http://localhost:8080&quot;); &#125; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.tokenStore(inMemoryTokenStore()) .authenticationManager(authenticationManager) .reuseRefreshTokens(false) // 重复使用刷新token .userDetailsService(userDetailsService); // 刷新token需要 &#125; @Override public void configure(AuthorizationServerSecurityConfigurer oauthServer) &#123; //表示支持 client_id 和 client_secret 做登录认证 oauthServer.allowFormAuthenticationForClients(); &#125;&#125; 安全配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-11 */@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private PasswordEncoder passwordEncoder; /** * 默认密码处理器 * @return */ @Bean @ConditionalOnMissingBean(PasswordEncoder.class) public PasswordEncoder passwordEncoder() &#123; return PasswordEncoderFactories.createDelegatingPasswordEncoder(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; /** * 内置帐号密码 * @return */ @Bean public UserDetailsService userDetailsService() &#123; InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;admin&quot;).password(passwordEncoder.encode(&quot;admin&quot;)).roles(&quot;ADMIN&quot;).build()); manager.createUser(User.withUsername(&quot;guest&quot;).password(passwordEncoder.encode(&quot;guest&quot;)).roles(&quot;GUEST&quot;).build()); return manager; &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(&quot;/oauth/**&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin(); &#125;&#125; 非对称加密(这里没有使用) 12345678910111213141516171819202122232425/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-11 */public class KeyConfig &#123; private static final String KEY_STORE_FILE = &quot;.keystore-oauth2-demo&quot;; private static final String KEY_STORE_PASSWORD = &quot;admin1234&quot;; private static final String KEY_ALIAS = &quot;oauth2-demo-key&quot;; private static KeyStoreKeyFactory KEY_STORE_KEY_FACTORY = new KeyStoreKeyFactory(new ClassPathResource(KEY_STORE_FILE), KEY_STORE_PASSWORD.toCharArray()); static final String VERIFIER_KEY_ID = Base64.getEncoder().encodeToString(KeyGenerators.secureRandom(32).generateKey()); static RSAPublicKey getVerifierKey() &#123; return (RSAPublicKey) getKeyPair().getPublic(); &#125; static RSAPrivateKey getSignerKey() &#123; return (RSAPrivateKey) getKeyPair().getPrivate(); &#125; private static KeyPair getKeyPair() &#123; return KEY_STORE_KEY_FACTORY.getKeyPair(KEY_ALIAS); &#125;&#125; 测试 密码模式（password） 申请access_token 1curl -X POST http://localhost:8080/oauth/token?grant_type=password&amp;username=admin&amp;password=admin&amp;client_id=clientId&amp;client_secret=secret 返回access_token 1234567&#123; &quot;access_token&quot;: &quot;dba595be-6bbf-4c6b-8fd3-eac650f40c4e&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;916b2145-0e07-44d2-9a29-b0e6c02b399f&quot;, &quot;expires_in&quot;: 43199, &quot;scope&quot;: &quot;all&quot;&#125; 请求资源 1curl http://localhost:8080/xxx/ping -H &quot;Authorization: Bearer dba595be-6bbf-4c6b-8fd3-eac650f40c4e&quot; 授权码模式（authorization-code） 申请code 1http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?client_id&#x3D;clientId&amp;response_type&#x3D;code&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8080&amp;state&#x3D;123 然后在登录表单填写帐号密码 admin/admin, 返回code和state 1http:&#x2F;&#x2F;localhost:8080&#x2F;?code&#x3D;LHHPXA&amp;state&#x3D;123 申请access_token 1curl -X POST http://localhost:8080/oauth/token?grant_type=authorization_code&amp;code=LHHPXA&amp;redirect_uri=http://localhost:8080&amp;client_id=clientId&amp;client_secret=secret 返回access_token 1234567&#123; &quot;access_token&quot;: &quot;db2c779f-20f6-44df-98e1-5fc46a2fe9c5&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;c7f87939-6801-4269-b745-e306c94130c2&quot;, &quot;expires_in&quot;: 43199, &quot;scope&quot;: &quot;all&quot;&#125; 请求资源 1curl http://localhost:8080/xxx/ping -H &quot;Authorization: Bearer db2c779f-20f6-44df-98e1-5fc46a2fe9c5&quot; 隐藏模式（implicit） 请求access_token 1http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;scope&#x3D;all&amp;client_id&#x3D;clientId&amp;client_secret&#x3D;secret&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8080&amp;state&#x3D;123 然后在登录表单填写帐号密码 admin/admin, 返回access_token和state 1http:&#x2F;&#x2F;localhost:8080&#x2F;#access_token&#x3D;6b8c3fa7-0513-44e3-b7a1-ea89f927010d&amp;token_type&#x3D;bearer&amp;state&#x3D;123&amp;expires_in&#x3D;43167 请求资源 1curl http://localhost:8080/xxx/ping -H &quot;Authorization: Bearer 6b8c3fa7-0513-44e3-b7a1-ea89f927010d&quot; 客户端凭证（client credentials） 申请access_token 1curl -X POST http://localhost:8080/oauth/token -H &quot;Accept: application/json&quot; -d &quot;grant_type=client_credentials&amp;scope=all&amp;client_id=clientId&amp;client_secret=secret&quot; 返回access_token 123456&#123; &quot;access_token&quot;: &quot;a38c2319-30f3-45ef-ab6b-294111e8b207&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires_in&quot;: 43199, &quot;scope&quot;: &quot;all&quot;&#125; 请求资源 1curl http://localhost:8080/xxx/ping -H &quot;Authorization: Bearer a38c2319-30f3-45ef-ab6b-294111e8b20&quot; 刷新token 请求refresh_token 以密码模式中的refresh_token演示 1curl -X POST http://localhost:8080/oauth/token -H &quot;Accept: application/json&quot; -d &quot;grant_type=refresh_token&amp;refresh_token=916b2145-0e07-44d2-9a29-b0e6c02b399f&amp;client_id=clientId&amp;client_secret=secret&quot; 返回access_token 1234567&#123; &quot;access_token&quot;: &quot;fcc85ce0-426d-421f-b2dc-005ebad3f9da&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;54880f4c-b5fe-4163-82c3-ae2e9fd90b85&quot;, &quot;expires_in&quot;: 43199, &quot;scope&quot;: &quot;all&quot;&#125; 请求资源 1curl http://localhost:8080/xxx/ping -H &quot;Authorization: Bearer fcc85ce0-426d-421f-b2dc-005ebad3f9da&quot; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"security","slug":"security","permalink":"https://idea360.cn/tags/security/"}]},{"title":"37.常见面试题翻车合集","slug":"interview-java-37","date":"2020-10-08T06:09:43.000Z","updated":"2020-10-08T06:25:44.838Z","comments":true,"path":"2020/10/08/interview-java-37/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-37/","excerpt":"","text":"常见面试题翻车合集 1.去掉 main 方法的 static 修饰符，程序会怎样？ A：程序无法编译 B：程序正常编译，正常运行 C：程序正常编译，正常运行一下马上退出 D：程序正常编译，运行时报错 答：D 题目解析：运行时异常如下： 错误: main 方法不是类 xxx 中的 static, 请将 main 方法定义为: public static void main(String[] args) 2.以下程序运行的结果是？ 123456789101112public class TestClass &#123; public static void main(String[] args) &#123; System.out.println(getLength()); &#125;int getLength() &#123; private String s = &quot;xyz&quot;; int result = s.length(); return result; &#125;&#125;复制 A：3 B：2 C：4 D：程序无法编译 答：D 题目解析：局部变量 s 不能使用任何修饰符（private/protected/public）修饰，调用的方法要加上 static，否则编译会报错。 3.以下程序有几处错误？ 12345abstract class myAbstractClass private abstract String method()&#123;&#125;;&#125;复制 A：1 B：2 C：3 D：4 答：C 题目解析：类少一个“{”类开始标签、抽象方法不能包含方法体、抽象方法访问修饰符不能为 private，因此总共有 3 处错误。 4.以下程序执行的结果是？ 1234567891011121314class A &#123; public static int x; static &#123; x = B.y + 1; &#125;&#125;public class B &#123; public static int y = A.x + 1; public static void main(String[] args) &#123; System.out.println(String.format(&quot;x=%d,y=%d&quot;, A.x, B.y)); &#125;&#125;复制 A：程序无法编译 B：程序正常编译，运行报错 C：x=1,y=2 D：x=0,y=1 答：C 5.switch 语法可以配合 return 一起使用吗？return 和 break 在 switch 使用上有何不同？ 答：switch 可以配合 return 一起使用。return 和 break 的区别在于 switch 结束之后的代码，比如以下代码： 1234567891011121314151617181920212223String getColor(String color) &#123; switch (color) &#123; case &quot;red&quot;: return &quot;红&quot;; case &quot;blue&quot;: return &quot;蓝&quot;; &#125; return &quot;未知&quot;;&#125;String getColor(String color) &#123; String result = &quot;未知&quot;; switch (color) &#123; case &quot;red&quot;: result = &quot;红&quot;; break; case &quot;blue&quot;: result = &quot;蓝&quot;; &#125; return result;&#125;复制 对于以上这种 switch 之后没有特殊业务处理的程序来说，return 和 break 的效果是等效的。然而，对于以下这种代码： 12345678910111213141516171819202122232425262728String getColor(String color) &#123; switch (color) &#123; case &quot;red&quot;: return &quot;红&quot;; case &quot;blue&quot;: return &quot;蓝&quot;; &#125; return &quot;未知&quot;;&#125;String getColor(String color) &#123; String result = &quot;未知&quot;; switch (color) &#123; case &quot;red&quot;: result = &quot;红&quot;; break; case &quot;blue&quot;: result = &quot;蓝&quot;; &#125; if (result.equals(&quot;未知&quot;)) &#123; result = &quot;透明&quot;; &#125; else &#123; result += &quot;色&quot;; &#125; return result;&#125;复制 如果 switch 之后还有特殊的业务处理，那么 return 和 break 就有很大的区别了。 6.一个栈的入栈顺序是 A、B、C、D、E 则出栈不可能的顺序是？ A：E D C B A B：D E C B A C：D C E A B D：A B C D E 答：C 题目解析：栈是后进先出的，因此： A 选项：入栈顺序 A B C D E 出栈顺序就是 E D C B A 是正确的； B 选项：A B C D 先入栈，D 先出栈，这个时候 E 在入栈，E 在出栈，顺序 D E C B A 也是正确的； C 选项：D 先出栈，说明 A B C 一定已入栈，因为题目说了入栈的顺序是 A B C D E，所以出栈的顺序一定是 C B A，而 D C E A B 的顺序 A 在 B 前面是永远不可能发生的，所以选择是 C； D 选项 A B C D E 依次先入栈、出栈，顺序就是 A B C D E。 7.可以在 finally 块中使用 return吗？ 答：不可以，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 8.FileInputStream 可以实现什么功能？ A：文件夹目录获取 B：文件写入 C：文件读取 D：文件夹目录写入 答：C 题目解析：FileInputStream 是文件读取，FileOutputStream 才是用来写入文件的，FileInputStream 和 FileOutputStream 很容易搞混。 9.以下程序打印的结果是什么？ 123456789101112131415161718Thread t1 = new Thread()&#123; @Override public void run() &#123; System.out.println(&quot;I&#x27;m T1.&quot;); &#125;&#125;;t1.setPriority(3);t1.start();Thread t2 = new Thread()&#123; @Override public void run() &#123; System.out.println(&quot;I&#x27;m T2.&quot;); &#125;&#125;;t2.setPriority(0);t2.start();复制 答：程序报错 java.lang.IllegalArgumentException，setPriority(n) 方法用于设置程序的优先级，优先级的取值为 1-10，当设置为 0 时，程序会报错。 10.如何设置守护线程？ 答：设置 Thead 类的 setDaemon(true) 方法设置当前的线程为守护线程。 守护线程的使用示例如下： 1234567891011Thread daemonThread = new Thread()&#123; @Override public void run() &#123; super.run(); &#125;&#125;;// 设置为守护线程daemonThread.setDaemon(true);daemonThread.start();复制 11.以下说法中关于线程通信的说法错误的是？ A：可以调用 wait()、notify()、notifyAll() 三个方法实现线程通信 B：wait() 必须在 synchronized 方法或者代码块中使用 C：wait() 有多个重载的方法，可以指定等待的时间 D：wait()、notify()、notifyAll() 是 Object 类提供的方法，子类可以重写 答：D 题目解析：wait()、notify()、notifyAll() 都是被 final 修饰的方法，不能再子类中重写。选项 B，使用 wait() 方法时，必须先持有当前对象的锁，否则会抛出异常 java.lang.IllegalMonitorStateException。 12.ReentrantLock 默认创建的是公平锁还是非公平锁？ 答：默认创建的是非公平锁，看以下源码可以得知： 123456789/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125;复制 Nonfair 为非公平的意思，ReentrantLock() 等同于代码 ReentrantLock(false)。 13.ReentrantLock 如何在一段时间内无阻塞尝试访问锁？ 答：使用 tryLock(long timeout, TimeUnit unit) 方法，就可以在一段时间内无堵塞的访问锁。 14.枚举比较使用 equals 还是 ==？ 答：枚举比较调用 equals 和 == 的结果是一样，查看 Enum 的源码可知 equals 其实是直接调用了 ==，源码如下： 12345public final boolean equals(Object other) &#123; return this==other;&#125;复制 15.在 Spring 中使用 @Value 赋值静态变量为什么 null？怎么解决？ 答：因为在 Springframework 框架中，当类加载器加载静态变量时，Spring 上下文尚未加载，因此类加载器不会在 bean 中正确注入静态类，导致了结果为 null。可使用 Setter() 方法给静态变量赋值，代码如下： 12345678910111213141516171819202122232425@Componentpublic class ConfigValue &#123; private static String accessKey; public String getAccessKey() &#123; return accessKey; &#125; @Value(&quot;$&#123;accessKey&#125;&quot;) public void setAccessKey(String accessKey) &#123; ConfigValue.accessKey = accessKey; &#125;&#125;/* * 调用赋值变量 */@Componentpublic class TestClass &#123; @Autowired private ConfigValue configValue; public void method() &#123; // 读取配置文件 configValue.getAccessKey(); &#125;&#125;复制 16.如何自己实现一个定时任务？ 答：启动一个后台线程，循环执行任务。代码示例如下： 12345678910111213141516171819Thread getTocketThread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; // 执行业务方法 TimeUnit.HOURS.sleep(2); // 每两小时执行一次 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;);if (!getTocketThread.isAlive()) &#123; System.out.println(&quot;启动线程&quot;); getTocketThread.start();&#125;复制 17.如何定义一个不定长度的数组？ 答：在 Java 中使用数组必须要指定长度，如果长度不固定可使用 ArrayList、LinkedList 等容器接收完数据，再使用 toArray() 方法转换成固定数组。 18.如何优雅的格式化百分比小数？ 答：使用数字格式化类 DecimalFormat 来处理，具体实现代码如下： 12345double num = 0.37500;DecimalFormat df = new DecimalFormat(&quot;0.0%&quot;);System.out.println(df.format(num)); // 执行结果：37.5%复制 19.什么是跨域问题？为什么会产生跨域问题？ 答：跨域问题指的是不同站点直接，使用 ajax 无法相互调用的问题。跨域问题是浏览器的行为，是为了保证用户信息的安全，防止恶意网站窃取数据，所做的限制，如果没有跨域限制就会导致信息被随意篡改和提交，会导致不可预估的安全问题，所以也会造成不同站点间“正常”请求的跨域问题。 20.跨域的解决方案有哪些？ 答：常见跨域问题的解决方案如下： jsonp（只支持 get 请求）； nginx 请求转发，把不同站点应用配置到同一个域名下； 服务器端设置运行跨域访问，如果使用的是 Spring 框架可通过 @CrossOrigin 注解的方式声明某个类或方法运行跨域访问，或者配置全局跨域配置，请参考以下代码： 123456789101112131415161718192021// 单个跨域配置@CrossOrigin(origins = &quot;http://xxx&quot;, maxAge = 3600)@RestControllerpublic class testController&#123;&#125;// 全局配置@Configurationpublic class CorsConfiguration &#123; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/api/**&quot;).allowedOrigins(&quot;https://xxx&quot;); &#125; &#125;; &#125;&#125;复制 21.什么原因会导致 Nginx 转发时丢失部分 header 信息？该如何解决？ 答：部分 header 信息丢失的原因是，丢失的 header 的 key 值中有下划线，因为 Nginx 转发时，默认会忽略带下划线的 header 信息。 解决方案有两个，一是去掉 key 值中的下划线，二是在 Nginx 的配置文件 http 中添加“underscoresinheaders on;” 不忽略有下划线的 header 信息。 22.如何设计一个高效的系统？ 答：要设计一个高效的系统，通常要包含以下几个方面。 （1）优化代码 代码优化分为两种情况： 代码问题导致系统资源消耗过多的问题，比如，某段代码导致内存溢出，往往是将 JVM 中的内存用完了，这个时候系统的内存资源消耗殆尽了，同时也会引发 JVM 频繁地发生垃圾回收，导致 CPU 100% 以上居高不下，这个时候又消耗了系统的 CPU 资源。这种情况下需要使用相应的排查工具 VisualVM 或 JConsole，找到对应的问题代码再进行优化； 还有一种是非问题代码，这种代码不容易发现，比如，LinkedList 集合如果使用 for 循环遍历，则它的效率是很低的，因为 LinkedList 是链表实现的，如果使用 for 循环获取元素，在每次循环获取元素时，都会去遍历一次 List，这样会降低读的效率，这个时候应该改用 Iterator （迭代器）迭代循环该集合。 （2）设计优化 有很多问题可以通过我们的设计优化来提高程序的执行性能，比如，使用单例模式来减少频繁地创建和销毁对象所带来的性能消耗，从而提高了程序的执行性能。 （3）参数调优 JVM 和 Web 容器的参数调优，对系统的执行性能也是也很大帮助的。比如，我们的业务中会创建大量的大对象，我们可以通过设置，将这些大对象直接放进老年代，这样可以减少年轻代频繁发生小的垃圾回收（Minor GC），减少 CPU 占用时间，从而提升了程序的执行性能。Web 容器的线程池设置以及 Linux 操作系统的内核参数设置，也对程序的运行性能有着很大的影响，我们根据自己的业务场景优化这两项内容。 （4）使用缓存 缓存的使用分为前端和后端： 前端可使用浏览器缓存或者 CDN，CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术； 后端缓存，使用第三方缓存 Redis 或 Memcache 来缓存查询结果，以提高查询的响应速度。 （5）优化数据库 数据库是最宝贵的资源，通常也是影响程序响应速度的罪魁祸首，它的优化至关重要，通常分为以下六个方面： 合理使用数据库引擎 合理设置事务隔离级别，合理使用事务 正确使用 SQL 语句和查询索引 合理分库分表 使用数据库中间件实现数据库读写分离 设置数据库主从读写分离 （6）屏蔽无效和恶意访问 前端禁止重复提交：用户提交之后按钮置灰，禁止重复提交； 用户限流，在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。 （7）搭建分布式环境，使用负载分发 可以把程序部署到多台服务器上，通过负载均衡工具，比如 Nginx，将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"36.JVM 面试题汇总","slug":"interview-java-36","date":"2020-10-08T06:09:40.000Z","updated":"2020-10-08T06:25:34.579Z","comments":true,"path":"2020/10/08/interview-java-36/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-36/","excerpt":"","text":"JVM 面试题汇总 1.什么是 JVM？它有什么作用？ 答：JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，顾名思义它是一个虚拟计算机，也是 Java 程序能够实现跨平台的基础。它的作用是加载 Java 程序，把字节码翻译成机器码再交由 CPU 执行的一个虚拟计算器。 2.JVM 主要组成部分有哪些？ 答：JVM 主要组成部分如下： 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 3.JVM 是如何工作的？ 答：首先程序在执行之前先要把 Java 代码（.java）转换成字节码（.class），JVM 通过类加载器（ClassLoader）把字节码加载到内存中，但字节码文件是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine） 将字节码翻译成底层机器码，再交由 CPU 去执行，CPU 执行的过程中需要调用本地库接口（Native Interface）来完成整个程序的运行。 4.JVM 内存布局是怎样的？ 答：不同虚拟机实现可能略微有所不同，但都会遵从 Java 虚拟机规范，Java 8 虚拟机规范规定，Java 虚拟机所管理的内存将会包括以下几个区域： 程序计数器（Program Counter Register） Java 虚拟机栈（Java Virtual Machine Stacks） 本地方法栈（Native Method Stack） Java 堆（Java Heap） 方法区（Methed Area） ① 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于 JVM 的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确的执行位置，每个线程都有独立的程序计数器。 如果线程正在执行 Java 中的方法，程序计数器记录的就是正在执行虚拟机字节码指令的地址，如果是 Native 方法，这个计数器就为空（undefined），因此该内存区域是唯一一个在 Java 虚拟机规范中没有规定 OutOfMemoryError 的区域。 ② Java 虚拟机栈 Java 虚拟机栈（Java Virtual Machine Stacks）描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个线帧在虚拟机栈中入栈到出栈的过程。 如果线程请求的栈深度大于虚拟机所允许的栈深度就会抛出 StackOverflowError 异常。 如果虚拟机是可以动态扩展的，如果扩展时无法申请到足够的内存就会抛出 OutOfMemoryError 异常。 ③ 本地方法栈 本地方法栈（Native Method Stack）与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。 在 Java 虚拟机规范中对于本地方法栈没有特殊的要求，虚拟机可以自由的实现它，因此在 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。 ④ Java 堆 Java 堆（Java Heap）是 JVM 中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java 堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有的对象都分配在堆上渐渐变得不那么绝对了。 如果在堆中没有内存完成实例分配，并且堆不可以再扩展时，将会抛出 OutOfMemoryError。 Java 虚拟机规范规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可，就像我们的磁盘空间一样。在实现上也可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是可扩展的，通过 -Xmx 和 -Xms 控制。 ⑤ 方法区 方法区（Methed Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 很多人把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是 HotSpot 虚拟机垃圾回收器团队把 GC 分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在 JDK 8 也移除了“永久代”，使用 Native Memory 来实现方法区。 当方法无法满足内存分配需求时会抛出 OutOfMemoryError 异常。 5.在 Java 中负责字节码解释执行的是？ A：应用服务器 B：垃圾回收器 C：虚拟机 D：编译器 答：C 6.静态变量存储在哪个区？ A：栈区 B：堆区 C：全局区 D：常量区 答：C 题目解析：栈区存放函数的参数值，局部变量的值等；堆区存放的是程序员创建的对象；全局区存放全局变量和静态变量；常量区存放常量字符串。 7.垃圾回收算法有哪些？ 答：垃圾回收算法如下。 引用计数器算法：引用计算器判断对象是否存活的算法是这样的，给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加 1，与之相反，每当引用失效的时候就减 1。 可达性分析算法：在主流的语言的主流实现中，比如 Java、C#，甚至是古老的 Lisp 都是使用的可达性分析算法来判断对象是否存活的。这个算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链”。当一个对象到 GC Roots 没有任何引用链相连的时候，证明此对象是可以被回收的。 复制算法：复制算法是将内存分为大小相同的两块，当这一块使用完了，就把当前存活的对象复制到另一块，然后一次性清空当前区块。此算法的缺点是只能利用一半的内存空间。 标记-清除算法：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。 标记-整理：此算法结合了“标记-清除”和“复制”两个算法的优点。分为两个阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 8.哪些对象可以作为引用链的 Root 对象？ 答：引用链的 Root 对象可以为以下内容： Java 虚拟机栈中的引用对象； 本地方法栈中 JNI（既一般说的 Native 方法）引用的对象； 方法区中类静态常量的引用对象； 方法区中常量的引用对象。 9.对象引用关系都有哪些？ 答：不管是引用计数法还是可达性分析算法都与对象的“引用”有关，这说明对象的引用决定了对象的生死，对象的引用关系如下。 强引用：在代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM 认为内存不足时，才会去试图回收软引用指向的对象，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。 弱引用：非必需对象，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 虚引用：也称为幽灵引用或幻影引用，是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当着个对象被收集器回收时收到一条系统通知。 10.内存溢出和内存泄漏的区别是什么？ 答：内存溢出和内存泄漏的区别如下： 内存溢出是指程序申请内存时，没有足够的内存，就会报错 OutOfMemory； 内存泄漏是指垃圾对象无法回收，可以使用 Memory Analyzer 等工具排出内存泄漏。 11.垃圾回收的分类都有哪些？ 答：垃圾回收的分类如下： 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 12.分代垃圾回收器的组成部分有哪些？ 答：分代垃圾回收器是由：新生代（Young Generation）和老生代（Tenured Generation）组成的，默认情况下新生代和老生代的内存比例是 1:2。 13.新生代的组成部分有哪些？ 答：新生代是由：Eden、Form Survivor、To Survivor 三个区域组成的，它们内存默认占比是 8:1:1。 14.新生代垃圾回收是怎么执行的？ 答：新生代垃圾回收的执行过程如下： ① Eden 区 + From Survivor 区存活着的对象复制到 To Survivor 区； ② 清空 Eden 和 From Survivor 分区； ③ From Survivor 和 To Survivor 分区交换（From 变 To，To 变 From）。 15.为什么新生代有两个 Survivor 分区？ 答：当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。 如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。 如果 Survivor 分区是 1 个的话，假设把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。 如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，因此每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。 经过以上对比，可以得出结论，当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。 16.什么是 CMS 垃圾回收器？ 答：CMS（Concurrent Mark Sweep）一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 17.CMS 垃圾回收器有哪些优缺点？ 答：CMS 垃圾回收器的优点是使用多线程，标记清除垃圾的，它缺点如下。 对 CPU 资源要求敏感：CMS 回收器过分依赖于多线程环境，默认情况下，开启的线程数为（CPU 的数量 + 3）/ 4，当 CPU 数量少于 4 个时，CMS 对用户本身的操作的影响将会很大，因为要分出一半的运算能力去执行回收器线程； CMS 无法清除浮动垃圾：浮动垃圾指的是 CMS 清除垃圾的时候，还有用户线程产生新的垃圾，这部分未被标记的垃圾叫做“浮动垃圾”，只能在下次 GC 的时候进行清除； CMS 垃圾回收会产生大量空间碎片：CMS 使用的是标记-清除算法，所有在垃圾回收的时候回产生大量的空间碎片。 18.什么是 G1 垃圾回收器？ 答：G1 垃圾回收器是一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS CG，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。 G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 Region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。 19.垃圾回收的调优参数有哪些？ 答：垃圾回收的常用调优如下： -Xmx:512 设置最大堆内存为 512 M； -Xms:215 初始堆内存为 215 M； -XX:MaxNewSize 设置最大年轻区内存； -XX:MaxTenuringThreshold=5 设置新生代对象经过 5 次 GC 晋升到老年代； -XX:PretrnureSizeThreshold 设置大对象的值，超过这个值的大对象直接进入老生代； -XX:NewRatio 设置分代垃圾回收器新生代和老生代内存占比； -XX:SurvivorRatio 设置新生代 Eden、Form Survivor、To Survivor 占比。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"35.算法常用面试题汇总","slug":"interview-java-35","date":"2020-10-08T06:09:37.000Z","updated":"2020-10-08T06:25:25.119Z","comments":true,"path":"2020/10/08/interview-java-35/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-35/","excerpt":"","text":"算法常用面试题汇总 1.说一下什么是二分法？使用二分法时需要注意什么？如何用代码实现？ 二分法查找（Binary Search）也称折半查找，是指当每次查询时，将数据分为前后两部分，再用中值和待搜索的值进行比较，如果搜索的值大于中值，则使用同样的方式（二分法）向后搜索，反之则向前搜索，直到搜索结束为止。 二分法使用的时候需要注意：二分法只适用于有序的数据，也就是说，数据必须是从小到大，或是从大到小排序的。 1234567891011121314151617181920212223242526272829303132333435363738public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 二分法查找 int[] binaryNums = &#123;1, 6, 15, 18, 27, 50&#125;; int findValue = 27; int binaryResult = binarySearch(binaryNums, 0, binaryNums.length - 1, findValue); System.out.println(&quot;元素第一次出现的位置（从0开始）：&quot; + binaryResult); &#125; /** * 二分查找，返回该值第一次出现的位置（下标从 0 开始） * @param nums 查询数组 * @param start 开始下标 * @param end 结束下标 * @param findValue 要查找的值 * @return int */ private static int binarySearch(int[] nums, int start, int end, int findValue) &#123; if (start &lt;= end) &#123; // 中间位置 int middle = (start + end) / 2; // 中间的值 int middleValue = nums[middle]; if (findValue == middleValue) &#123; // 等于中值直接返回 return middle; &#125; else if (findValue &lt; middleValue) &#123; // 小于中值，在中值之前的数据中查找 return binarySearch(nums, start, middle - 1, findValue); &#125; else &#123; // 大于中值，在中值之后的数据中查找 return binarySearch(nums, middle + 1, end, findValue); &#125; &#125; return -1; &#125;&#125;复制 执行结果如下： 元素第一次出现的位置（从0开始）：4 2.什么是斐波那契数列？用代码如何实现？ 斐波那契数列（Fibonacci Sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711… 在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用。 斐波那契数列之所以又称黄金分割数列，是因为随着数列项数的增加，前一项与后一项之比越来越逼近黄金分割的数值 0.6180339887… 斐波那契数列指的是这样一个数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711… 斐波那契数列的特征：第三项开始（含第三项）它的值等于前两项之和。 斐波那契数列代码实现示例，如下所示： 12345678910111213141516171819202122public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 斐波那契数列 int fibonacciIndex = 7; int fibonacciResult = fibonacci(fibonacciIndex); System.out.println(&quot;下标(从0开始)&quot; + fibonacciIndex + &quot;的值为：&quot; + fibonacciResult); &#125; /** * 斐波那契数列 * @param index 斐波那契数列的下标（从0开始） * @return int */ private static int fibonacci(int index) &#123; if (index == 0 || index == 1) &#123; return index; &#125; else &#123; return fibonacci(index - 1) + fibonacci(index - 2); &#125; &#125;&#125;复制 执行结果如下： 下标(从0开始)7的值为：13 3.一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？请使用代码实现。 先来分析一下，本题目 第一个月：有 1 对小兔子； 第二个月：小兔子变成大兔子； 第三个月：大兔子下了一对小兔子； 第四个月：大兔子又下了一对小兔子，上个月的一对小兔子变成了大兔子； … 最后总结的规律如下列表所示： 月数 1 2 3 4 5 6 7 8 9 10 11 12 … 幼仔对数 1 0 1 1 2 3 5 8 13 21 34 55 … 成兔对数 0 1 1 2 3 5 8 13 21 34 55 89 总对数 1 1 2 3 5 8 13 21 34 55 89 144 可以看出，兔子每个月的总对数刚好符合斐波那契数列，第 12 个月的时候，总共有 144 对兔子。 实现代码如下： 123456789101112131415161718192021public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 兔子的总对数 int rabbitNumber = fibonacci(12); System.out.println(&quot;第 12 个月兔子的总对数是：&quot; + rabbitNumber); &#125; /** * 斐波那契数列 * @param index 斐波那契数列的下标（从0开始） * @return int */ private static int fibonacci(int index) &#123; if (index == 0 || index == 1) &#123; return index; &#125; else &#123; return fibonacci(index - 1) + fibonacci(index - 2); &#125; &#125;&#125;复制 执行结果如下： 第 12 个月兔子的总对数是：144 4.什么是冒泡排序？用代码如何实现？ 冒泡排序（Bubble Sort）算法是所有排序算法中最简单、最基础的一个，它的实现思路是通过相邻数据的交换达到排序的目的。 冒泡排序的执行流程是： 对数组中相邻的数据，依次进行比较； 如果前面的数据大于后面的数据，则把前面的数据交换到后面。经过一轮比较之后，就能把数组中最大的数据排到数组的最后面了； 再用同样的方法，把剩下的数据逐个进行比较排序，最后得到就是从小到大排序好的数据。 冒泡排序算法代码实现，如下所示： 12345678910111213141516171819202122232425262728public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 冒泡排序调用 int[] bubbleNums = &#123;132, 110, 122, 90, 50&#125;; System.out.println(&quot;排序前：&quot; + Arrays.toString(bubbleNums)); bubbleSort(bubbleNums); System.out.println(&quot;排序后：&quot; + Arrays.toString(bubbleNums)); &#125; /** * 冒泡排序 */ private static void bubbleSort(int[] nums) &#123; int temp; for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums.length - i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; &#125; &#125; System.out.print(&quot;第&quot; + i + &quot;次排序：&quot;); System.out.println(Arrays.toString(nums)); &#125; &#125;&#125;复制 执行结果如下： 排序前：[132, 110, 122, 90, 50] 第1次排序：[110, 122, 90, 50, 132] 第2次排序：[110, 90, 50, 122, 132] 第3次排序：[90, 50, 110, 122, 132] 第4次排序：[50, 90, 110, 122, 132] 排序后：[50, 90, 110, 122, 132] 5.什么是选择排序？用代码如何实现？ 选择排序（Selection Sort）算法也是比较简单的排序算法，其实现思路是每一轮循环找到最小的值，依次排到数组的最前面，这样就实现了数组的有序排列。 比如，下面是一组数据使用选择排序的执行流程： 初始化数据：18, 1, 6, 27, 15 第一次排序：1, 18, 6, 27, 15 第二次排序：1, 6, 18, 27, 15 第三次排序：1, 6, 15, 27, 18 第四次排序：1, 6, 15, 18, 27 选择排序算法代码实现，如下所示： 123456789101112131415161718192021222324252627282930313233public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 选择排序调用 int[] selectNums = &#123;18, 1, 6, 27, 15&#125;; System.out.println(&quot;排序前：&quot; + Arrays.toString(selectNums)); selectSort(selectNums); System.out.println(&quot;排序后：&quot; + Arrays.toString(selectNums)); &#125; /** * 选择排序 */ private static void selectSort(int[] nums) &#123; int index; int temp; for (int i = 0; i &lt; nums.length - 1; i++) &#123; index = i; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] &lt; nums[index]) &#123; index = j; &#125; &#125; if (index != i) &#123; temp = nums[i]; nums[i] = nums[index]; nums[index] = temp; &#125; System.out.print(&quot;第&quot; + i + &quot;次排序：&quot;); System.out.println(Arrays.toString(nums)); &#125; &#125;&#125;复制 执行结果如下： 排序前：[18, 1, 6, 27, 15] 第0次排序：[1, 18, 6, 27, 15] 第1次排序：[1, 6, 18, 27, 15] 第2次排序：[1, 6, 15, 27, 18] 第3次排序：[1, 6, 15, 18, 27] 排序后：[1, 6, 15, 18, 27] 6.什么是插入排序？用代码如何实现？ 插入排序（Insertion Sort）算法是指依次把当前循环的元素，通过对比插入到合适位置的排序算法。 比如，下面是一组数据使用插入排序的执行流程： 初始化数据：18, 1, 6, 27, 15 第一次排序：1, 18, 6, 27, 15 第二次排序：1, 6, 18, 27, 15 第三次排序：1, 6, 18, 27, 15 第四次排序：1, 6, 15, 18, 27 插入排序算法代码实现，如下所示： 123456789101112131415161718192021222324252627282930public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 插入排序调用 int[] insertNums = &#123;18, 1, 6, 27, 15&#125;; System.out.println(&quot;排序前：&quot; + Arrays.toString(insertNums)); insertSort(insertNums); System.out.println(&quot;排序后：&quot; + Arrays.toString(insertNums)); &#125; /** * 插入排序 */ private static void insertSort(int[] nums) &#123; int i, j, k; for (i = 1; i &lt; nums.length; i++) &#123; k = nums[i]; j = i - 1; // 对 i 之前的数据，给当前元素找到合适的位置 while (j &gt;= 0 &amp;&amp; k &lt; nums[j]) &#123; nums[j + 1] = nums[j]; // j-- 继续往前寻找 j--; &#125; nums[j + 1] = k; System.out.print(&quot;第&quot; + i + &quot;次排序：&quot;); System.out.println(Arrays.toString(nums)); &#125; &#125;&#125;复制 执行结果如下： 排序前：[18, 1, 6, 27, 15] 第1次排序：[1, 18, 6, 27, 15] 第2次排序：[1, 6, 18, 27, 15] 第3次排序：[1, 6, 18, 27, 15] 第4次排序：[1, 6, 15, 18, 27] 排序后：[1, 6, 15, 18, 27] 7.什么是快速排序？用代码如何实现？ 快速排序（Quick Sort）算法和冒泡排序算法类似，都是基于交换排序思想实现的，快速排序算法是对冒泡排序算法的改进，从而具有更高的执行效率。 快速排序是通过多次比较和交换来实现排序的执行流程如下： 首先设定一个分界值，通过该分界值把数组分为左右两个部分； 将大于等于分界值的元素放到分界值的右边，将小于分界值的元素放到分界值的左边； 然后对左右两边的数据进行独立的排序，在左边数据中取一个分界值，把小于分界值的元素放到分界值的左边，大于等于分界值的元素，放到数组的右边；右边的数据也执行同样的操作； 重复上述操作，当左右各数据排序完成后，整个数组也就完成了排序。 快速排序算法代码实现，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 快速排序调用 int[] quickNums = &#123;18, 1, 6, 27, 15&#125;; System.out.println(&quot;排序前：&quot; + Arrays.toString(quickNums)); quickSort(quickNums, 0, quickNums.length - 1); System.out.println(&quot;排序后：&quot; + Arrays.toString(quickNums)); &#125; /** * 快速排序 */ private static void quickSort(int[] nums, int left, int right) &#123; int f, t; int ltemp = left; int rtemp = right; // 分界值 f = nums[(left + right) / 2]; while (ltemp &lt; rtemp) &#123; while (nums[ltemp] &lt; f) &#123; ++ltemp; &#125; while (nums[rtemp] &gt; f) &#123; --rtemp; &#125; if (ltemp &lt;= rtemp) &#123; t = nums[ltemp]; nums[ltemp] = nums[rtemp]; nums[rtemp] = t; --rtemp; ++ltemp; &#125; &#125; if (ltemp == rtemp) &#123; ltemp++; &#125; if (left &lt; rtemp) &#123; // 递归调用 quickSort(nums, left, ltemp - 1); &#125; if (right &gt; ltemp) &#123; // 递归调用 quickSort(nums, rtemp + 1, right); &#125; &#125;&#125;复制 执行结果如下： 排序前：[18, 1, 6, 27, 15] 排序后：[1, 6, 15, 18, 27] 8.什么是堆排序？用代码如何实现？ 堆排序（Heap Sort）算法是利用堆结构和二叉树的一些特性来完成排序的。 堆结构是一种树结构，准确来说是一个完全二叉树。完全二叉树每个节点应满足以下条件： 如果按照从小到大的顺序排序，要求非叶节点的数据要大于等于，其左、右子节点的数据； 如果按照从大到小的顺序排序，要求非叶节点的数据小于等于，其左、右子节点的数据。 可以看出，堆结构对左、右子节点的大小没有要求，只规定叶节点要和子节点（左、右）的数据满足大小关系。 比如，下面是一组数据使用堆排序的执行流程： 堆排序算法代码实现，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Lesson7_4 &#123; public static void main(String[] args) &#123; // 堆排序调用 int[] heapNums = &#123;18, 1, 6, 27, 15&#125;; System.out.println(&quot;堆排序前：&quot; + Arrays.toString(heapNums)); heapSort(heapNums, heapNums.length); System.out.println(&quot;堆排序后：&quot; + Arrays.toString(heapNums)); &#125; /** * 堆排序 * @param nums 待排序数组 * @param n 堆大小 */ private static void heapSort(int[] nums, int n) &#123; int i, j, k, temp; // 将 nums[0,n-1] 建成大根堆 for (i = n / 2 - 1; i &gt;= 0; i--) &#123; // 第 i 个节点，有右子树 while (2 * i + 1 &lt; n) &#123; j = 2 * i + 1; if ((j + 1) &lt; n) &#123; // 右左子树小于右子树，则需要比较右子树 if (nums[j] &lt; nums[j + 1]) &#123; // 序号增加 1，指向右子树 j++; &#125; &#125; if (nums[i] &lt; nums[j]) &#123; // 交换数据 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; // 堆被破坏，重新调整 i = j; &#125; else &#123; // 左右子节点均大，则堆未被破坏，不需要调整 break; &#125; &#125; &#125; for (i = n - 1; i &gt; 0; i--) &#123; // 与第 i 个记录交换 temp = nums[0]; nums[0] = nums[i]; nums[i] = temp; k = 0; // 第 i 个节点有右子树 while (2 * k + 1 &lt; i) &#123; j = 2 * k + 1; if ((j + 1) &lt; i) &#123; // 右左子树小于右子树，则需要比较右子树 if (nums[j] &lt; nums[j + 1]) &#123; // 序号增加 1，指向右子树 j++; &#125; &#125; if (nums[k] &lt; nums[j]) &#123; // 交换数据 temp = nums[k]; nums[k] = nums[j]; nums[j] = temp; // 堆被破坏，重新调整 k = j; &#125; else &#123; // 左右子节点均大，则堆未被破坏，不需要调整 break; &#125; &#125; // 输出每步排序结果 System.out.print(&quot;第&quot; + (n - i) + &quot;次排序：&quot;); System.out.println(Arrays.toString(nums)); &#125; &#125;&#125;复制 执行结果如下： 堆排序前：[18, 1, 6, 27, 15] 第1次排序：[18, 15, 6, 1, 27] 第2次排序：[15, 1, 6, 18, 27] 第3次排序：[6, 1, 15, 18, 27] 第4次排序：[1, 6, 15, 18, 27] 堆排序后：[1, 6, 15, 18, 27] 总结 对于应届毕业生来说，算法是大厂必考的一大重点科目，因为对于没有太多实际项目经验的应届生来说，考察的重点是逻辑思考能力和学习力，这两项能力的掌握情况都体现在算法上，因此除了本文的这些内容外，对于校招的同学来说还需要配合 LeeCode，来把算法这一关的能力构建起来，对于社招的同学来说，一般算法问到的可能性相对比较少，最常见的算法问题应该就是对冒泡和快排的掌握情况了，对于这两个算法来说，最好能到达手写代码的情况。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"34.设计模式常见面试题汇总","slug":"interview-java-34","date":"2020-10-08T06:09:32.000Z","updated":"2020-10-08T06:25:15.735Z","comments":true,"path":"2020/10/08/interview-java-34/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-34/","excerpt":"","text":"设计模式常见面试题汇总 1.说一下设计模式？你都知道哪些？ 答：设计模式总共有 23 种，总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。 分类 包含 关注点 创建型模式 工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式 关注于对象的创建，同时隐藏创建逻辑 结构型模式 适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式 关注类和对象之间的组合 行为型模式 责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式 关注对象之间的通信 下面会对常用的设计模式分别做详细的说明。 2.什么是单例模式？ 答：单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。 优点：不会频繁地创建和销毁对象，浪费系统资源。 使用场景：IO 、数据库连接、Redis 连接等。 单例模式代码实现： 12345678class Singleton &#123; private static Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125;&#125;复制 单例模式调用代码： 123456789public class Lesson7_3 &#123; public static void main(String[] args) &#123; Singleton singleton1 = Singleton.getInstance(); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton1 == singleton2); &#125;&#125;复制 程序的输出结果：true 可以看出以上单例模式是在类加载的时候就创建了，这样会影响程序的启动速度，那如何实现单例模式的延迟加载？在使用时再创建？ 单例延迟加载代码： 123456789101112// 单例模式-延迟加载版class SingletonLazy &#123; private static SingletonLazy instance; public static SingletonLazy getInstance() &#123; if (instance == null) &#123; instance = new SingletonLazy(); &#125; return instance; &#125;&#125;复制 以上为非线程安全的，单例模式如何支持多线程？ 使用 synchronized 来保证，单例模式的线程安全代码： 1234567891011class SingletonLazy &#123; private static SingletonLazy instance; public static synchronized SingletonLazy getInstance() &#123; if (instance == null) &#123; instance = new SingletonLazy(); &#125; return instance; &#125;&#125;复制 3.什么是简单工厂模式？ 答：简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。 优点： 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象； 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量； 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点： 不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑； 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。 简单工厂示意图如下： 简单工厂代码实现： 12345678910111213141516171819class Factory &#123; public static String createProduct(String product) &#123; String result = null; switch (product) &#123; case &quot;Mocca&quot;: result = &quot;摩卡&quot;; break; case &quot;Latte&quot;: result = &quot;拿铁&quot;; break; default: result = &quot;其他&quot;; break; &#125; return result; &#125;&#125;复制 4.什么是抽象工厂模式？ 答：抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。 比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。 抽象工厂实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class AbstractFactoryTest &#123; public static void main(String[] args) &#123; // 抽象工厂 String result = (new CoffeeFactory()).createProduct(&quot;Latte&quot;); System.out.println(result); // output:拿铁 &#125;&#125;// 抽象工厂abstract class AbstractFactory&#123; public abstract String createProduct(String product);&#125;// 啤酒工厂class BeerFactory extends AbstractFactory&#123; @Override public String createProduct(String product) &#123; String result = null; switch (product) &#123; case &quot;Hans&quot;: result = &quot;汉斯&quot;; break; case &quot;Yanjing&quot;: result = &quot;燕京&quot;; break; default: result = &quot;其他啤酒&quot;; break; &#125; return result; &#125;&#125;/* * 咖啡工厂 */class CoffeeFactory extends AbstractFactory&#123; @Override public String createProduct(String product) &#123; String result = null; switch (product) &#123; case &quot;Mocca&quot;: result = &quot;摩卡&quot;; break; case &quot;Latte&quot;: result = &quot;拿铁&quot;; break; default: result = &quot;其他咖啡&quot;; break; &#125; return result; &#125;&#125;复制 5.什么是观察者模式？ 观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 优点： 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色； 观察者模式在观察目标和观察者之间建立一个抽象的耦合； 观察者模式支持广播通信； 观察者模式符合开闭原则（对拓展开放，对修改关闭）的要求。 缺点： 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间； 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃； 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 在观察者模式中有如下角色： Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象； ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知； Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己； ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 观察者模式实现代码如下。 1）定义观察者（消息接收方） 1234567891011121314151617181920212223/* * 观察者（消息接收方） */interface Observer &#123; public void update(String message);&#125;/* * 具体的观察者（消息接收方） */class ConcrereObserver implements Observer &#123; private String name; public ConcrereObserver(String name) &#123; this.name = name; &#125; @Override public void update(String message) &#123; System.out.println(name + &quot;：&quot; + message); &#125;&#125;复制 2）定义被观察者（消息发送方） 12345678910111213141516171819202122232425262728293031323334/* * 被观察者（消息发布方） */interface Subject &#123; // 增加订阅者 public void attach(Observer observer); // 删除订阅者 public void detach(Observer observer); // 通知订阅者更新消息 public void notify(String message);&#125;/* * 具体被观察者（消息发布方） */class ConcreteSubject implements Subject &#123; // 订阅者列表（存储信息） private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); @Override public void attach(Observer observer) &#123; list.add(observer); &#125; @Override public void detach(Observer observer) &#123; list.remove(observer); &#125; @Override public void notify(String message) &#123; for (Observer observer : list) &#123; observer.update(message); &#125; &#125;&#125;复制 3）代码调用 12345678910111213141516public class ObserverTest &#123; public static void main(String[] args) &#123; // 定义发布者 ConcreteSubject concreteSubject = new ConcreteSubject(); // 定义订阅者 ConcrereObserver concrereObserver = new ConcrereObserver(&quot;老王&quot;); ConcrereObserver concrereObserver2 = new ConcrereObserver(&quot;Java&quot;); // 添加订阅 concreteSubject.attach(concrereObserver); concreteSubject.attach(concrereObserver2); // 发布信息 concreteSubject.notify(&quot;更新了&quot;); &#125;&#125;复制 程序执行结果如下： 老王：更新了 Java：更新了 6.什么是装饰器模式？ 答：装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 装饰器模式的关键：装饰器中使用了被装饰的对象。 比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子…，这个执行过程就是装饰者模式，实现代码如下。 1）定义顶层对象，定义行为 12345interface IPerson &#123; void show();&#125;复制 2）定义装饰器超类 123456789101112class DecoratorBase implements IPerson&#123; IPerson iPerson; public DecoratorBase(IPerson iPerson)&#123; this.iPerson = iPerson; &#125; @Override public void show() &#123; iPerson.show(); &#125;&#125;复制 3）定义具体装饰器 1234567891011121314151617181920212223242526class Jacket extends DecoratorBase &#123; public Jacket(IPerson iPerson) &#123; super(iPerson); &#125; @Override public void show() &#123; // 执行已有功能 iPerson.show(); // 定义新行为 System.out.println(&quot;穿上夹克&quot;); &#125;&#125;class Hat extends DecoratorBase &#123; public Hat(IPerson iPerson) &#123; super(iPerson); &#125; @Override public void show() &#123; // 执行已有功能 iPerson.show(); // 定义新行为 System.out.println(&quot;戴上帽子&quot;); &#125;&#125;复制 4）定义具体对象 12345678class LaoWang implements IPerson&#123; @Override public void show() &#123; System.out.println(&quot;什么都没穿&quot;); &#125;&#125;复制 5）装饰器模式调用 12345678910public class DecoratorTest &#123; public static void main(String[] args) &#123; LaoWang laoWang = new LaoWang(); Jacket jacket = new Jacket(laoWang); Hat hat = new Hat(jacket); hat.show(); &#125;&#125;复制 7.什么是模板方法模式？ 答：模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。 优点： 提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中； 实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。 以给冰箱中放水果为例，比如，我要放一个香蕉：开冰箱门 → 放香蕉 → 关冰箱门；如果我再要放一个苹果：开冰箱门 → 放苹果 → 关冰箱门。可以看出它们之间的行为模式都是一样的，只是存放的水果品类不同而已，这个时候就非常适用模板方法模式来解决这个问题，实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738/* * 添加模板方法 */abstract class Refrigerator &#123; public void open() &#123; System.out.println(&quot;开冰箱门&quot;); &#125; public abstract void put(); public void close() &#123; System.out.println(&quot;关冰箱门&quot;); &#125;&#125;class Banana extends Refrigerator &#123; @Override public void put() &#123; System.out.println(&quot;放香蕉&quot;); &#125;&#125;class Apple extends Refrigerator &#123; @Override public void put() &#123; System.out.println(&quot;放苹果&quot;); &#125;&#125;/* * 调用模板方法 */public class TemplateTest &#123; public static void main(String[] args) &#123; Refrigerator refrigerator = new Banana(); refrigerator.open(); refrigerator.put(); refrigerator.close(); &#125;&#125;复制 程序执行结果： 开冰箱门 放香蕉 关冰箱门 8.什么是代理模式？ 代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 优点： 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度； 可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。 缺点： 由于使用了代理模式，因此程序的性能没有直接调用性能高； 使用代理模式提高了代码的复杂度。 举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App 就相当于是飞机票的代理商。 代理模式实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839/* * 定义售票接口 */interface IAirTicket &#123; void buy();&#125;/* * 定义飞机场售票 */class AirTicket implements IAirTicket &#123; @Override public void buy() &#123; System.out.println(&quot;买票&quot;); &#125;&#125;/* * 代理售票平台 */class ProxyAirTicket implements IAirTicket &#123; private AirTicket airTicket; public ProxyAirTicket() &#123; airTicket = new AirTicket(); &#125; @Override public void buy() &#123; airTicket.buy(); &#125;&#125;/* * 代理模式调用 */public class ProxyTest &#123; public static void main(String[] args) &#123; IAirTicket airTicket = new ProxyAirTicket(); airTicket.buy(); &#125;&#125;复制 9.什么是策略模式？ 答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。 优点：遵循了开闭原则，扩展性良好。 缺点：随着策略的增加，对外暴露越来越多。 以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。 策略模式实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * 声明旅行 */interface ITrip &#123; void going();&#125;class Bike implements ITrip &#123; @Override public void going() &#123; System.out.println(&quot;骑自行车&quot;); &#125;&#125;class Drive implements ITrip &#123; @Override public void going() &#123; System.out.println(&quot;开车&quot;); &#125;&#125;/* * 定义出行类 */class Trip &#123; private ITrip trip; public Trip(ITrip trip) &#123; this.trip = trip; &#125; public void doTrip() &#123; this.trip.going(); &#125;&#125;/* * 执行方法 */public class StrategyTest &#123; public static void main(String[] args) &#123; Trip trip = new Trip(new Bike()); trip.doTrip(); &#125;&#125;复制 程序执行的结果： 骑自行车 10.什么是适配器模式？ 答：适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。 优点： 可以让两个没有关联的类一起运行，起着中间转换的作用； 灵活性好，不会破坏原有的系统。 缺点：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。 以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC 的适配器，如下图所示： 适配器实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * 传统的充电线 MicroUSB */interface MicroUSB &#123; void charger();&#125;/* * TypeC 充电口 */interface ITypeC &#123; void charger();&#125;class TypeC implements ITypeC &#123; @Override public void charger() &#123; System.out.println(&quot;TypeC 充电&quot;); &#125;&#125;/* * 适配器 */class AdapterMicroUSB implements MicroUSB &#123; private TypeC typeC; public AdapterMicroUSB(TypeC typeC) &#123; this.typeC = typeC; &#125; @Override public void charger() &#123; typeC.charger(); &#125;&#125;/* * 测试调用 */public class AdapterTest &#123; public static void main(String[] args) &#123; TypeC typeC = new TypeC(); MicroUSB microUSB = new AdapterMicroUSB(typeC); microUSB.charger(); &#125;&#125;复制 程序执行结果： TypeC 充电 11.JDK 类库常用的设计模式有哪些？ 答：JDK 常用的设计模式如下： 1）工厂模式 java.text.DateFormat 工具类，它用于格式化一个本地日期或者时间。 12345public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Locale locale);复制 加密类 1234KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;DESede&quot;);Cipher cipher = Cipher.getInstance(&quot;DESede&quot;);复制 2）适配器模式 把其他类适配为集合类 1234List&lt;Integer&gt; arrayList = java.util.Arrays.asList(new Integer[]&#123;1,2,3&#125;);List&lt;Integer&gt; arrayList = java.util.Arrays.asList(1,2,3);复制 3）代理模式 如 JDK 本身的动态代理。 1234567891011121314151617181920212223242526272829303132333435363738394041interface Animal &#123; void eat();&#125;class Dog implements Animal &#123; @Override public void eat() &#123; System.out.println(&quot;The dog is eating&quot;); &#125;&#125;class Cat implements Animal &#123; @Override public void eat() &#123; System.out.println(&quot;The cat is eating&quot;); &#125;&#125;// JDK 代理类class AnimalProxy implements InvocationHandler &#123; private Object target; // 代理对象 public Object getInstance(Object target) &#123; this.target = target; // 取得代理对象 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;调用前&quot;); Object result = method.invoke(target, args); // 方法调用 System.out.println(&quot;调用后&quot;); return result; &#125;&#125;public static void main(String[] args) &#123; // JDK 动态代理调用 AnimalProxy proxy = new AnimalProxy(); Animal dogProxy = (Animal) proxy.getInstance(new Dog()); dogProxy.eat();&#125;复制 4）单例模式 全局只允许有一个实例，比如： 123Runtime.getRuntime();复制 5）装饰器 为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。 1234567java.io.BufferedInputStream(InputStream); java.io.DataInputStream(InputStream); java.io.BufferedOutputStream(OutputStream); java.util.zip.ZipOutputStream(OutputStream); java.util.Collections.checkedList(List list, Class type) ;复制 6）模板方法模式 定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。 比如，Arrays.sort() 方法，它要求对象实现 Comparable 接口。 1234567891011121314151617181920212223class Person implements Comparable&#123; private Integer age; public Person(Integer age)&#123; this.age = age; &#125; @Override public int compareTo(Object o) &#123; Person person = (Person)o; return this.age.compareTo(person.age); &#125;&#125;public class SortTest()&#123; public static void main(String[] args)&#123; Person p1 = new Person(10); Person p2 = new Person(5); Person p3 = new Person(15); Person[] persons = &#123;p1,p2,p3&#125;; //排序 Arrays.sort(persons); &#125;&#125;复制 12.IO 使用了什么设计模式？ 答：IO 使用了适配器模式和装饰器模式。 适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法； 装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。 13.Spring 中都使用了哪些设计模式？ 答：Spring 框架使用的设计模式如下。 代理模式：在 AOP 中有使用 单例模式：bean 默认是单例模式 模板方法模式：jdbcTemplate 工厂模式：BeanFactory 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件 适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"33.Redis 面试题汇总","slug":"interview-java-33","date":"2020-10-08T06:09:29.000Z","updated":"2020-10-08T06:25:05.157Z","comments":true,"path":"2020/10/08/interview-java-33/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-33/","excerpt":"","text":"Redis 面试题汇总 1.Redis 使用场景有哪些？ 答：Redis 使用场景如下： 记录帖子点赞数、点击数、评论数 缓存近期热帖 缓存文章详情信息 记录用户会话信息 2.Redis 有哪些功能？ 答：Redis 功能如下： 数据缓存功能 分布式锁的功能 支持数据持久化 支持事务 支持消息队列 3.Redis 支持哪些数据类型？ 答：Redis 支持的数据类型如下： String 字符串 List 列表 Set 无序集合 ZSet 有序集合 Hash 哈希类型 4.Redis 相比 Memcached 有哪些优势？ 答：Redis 相比 Memcached 优势如下： Memcached 所有的值均是简单的字符串，Redis 支持更为丰富的数据类型 Redis 的速度比 Memcached 要快 Redis 可以持久化 Redis 可以设置过期时间 Redis 支持主从同步 5.Redis 支持哪些淘汰策略？ 答：Redis 淘汰策略如下： noeviction：禁止淘汰数据； allkeys-lru：尝试回收最少使用的键，使得新添加的数据有空间存放； volatile-lru：尝试回收最少使用的键，但仅限于在过期集合的键，使得新添加的数据有空间存放； allkeys-random：回收随机的键使得新添加的数据有空间存放； volatile-random：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键； volatile-ttl：回收在过期集合的键，并且优先回收存活时间较短的键，使得新添加的数据有空间存放。 6.官方为什么不支持 Windows 版本？ 答：Redis 官方是不支持 Windows 版的，因为目前 Linux 版本已经相当稳定，如果开发 Windows 版本，反而会带来兼容性等问题。 7.为什么 Redis 是单线程的？ 答：因为 Redis 的瓶颈最有可能是机器内存或者网络带宽，而非单线程，既然单线程不是 Redis 的性能瓶颈，并且单线程又比较容易实现，所以 Redis 就选择使用单线程来实现。 单线程并不代表运行速度就慢，比如，Nginx 和 NodeJs 都是单线程高性能的代表。 8.为什么 Redis 需要把所有数据放到内存中？ 答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘，这样 Redis 就拥有了快速查询和数据持久化等特征。 9.在 Redis 中 key 的最大容量是多少？ 答：最大容量 512 MB，官方说明如下图所示： 10.Jedis 和 Redisson 有什么区别？ 答：Jedis 和 Redisson 的区别如下： Jedis 是 Redis 的 Java 实现客户端，其 API 提供了比较全面的 Redis 命令的支持； Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 11.Redis 如何设置过期时间？如何设置永久有效？ 答：Redis 通过 expire() 方法设置过期时间，语法：redis.expire(key, expiration)。当 expire 的过期时间设置为 -1 时，表示永不过期。 12.如何保证 Redis 的数据一致性？ 答：可使用以下方法来保证 Redis 的数据一致性： 合理设置缓存的过期时间； 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。 13.Redis 的数据结构是什么？它有什么优缺点？ 答：Redis 的数据结构是跳跃表，跳跃表是一种基于链表的扩展，跳跃表还是一个链表，是一个有序的链表，在遍历的时候基于比较，但普通链表只能遍历，跳跃表加入了一个层的概念，层级越高元素越少，每次先从高层查找，直到找到合适的位置，从图中可以看到高层的节点远远少于底层的节点数，从而实现了跳跃式查找。 跳跃表优点： 实现比红黑树简单 比红黑树更容易扩展 红黑树插入删除时为了平衡高度需要旋转附近节点，高并发需要锁，跳跃表不需要考虑 跳跃表缺点： 比红黑树占用更多的内存，每个节点的大小取决于该节点层数 空间局部性差导致缓存命中率低，比红黑树略慢 14.Redis 为什么用跳跃表来存储？ 答：第一是因为红黑树存储比较复杂，调整涉及到多个节点的并发修改；第二是越接近根节点的地方越容易产生竞争，即使是不同叶子节点的操作由于平衡操作也可能逐级向上涉及到接近根的节点，而跳跃表可以用 CAS（Compare And Swap）来并发操作节点，比较容易实现，且更加局部化。 15.什么是缓存穿透？如何解决？ 答：缓存穿透是指查询一个一定不存在的数据，由于缓存中没有，因而每次需要从数据库中查询，但数据库也没有相应的数据，所以不会写入缓存，这就将导致每次请求都会去数据库查询，这种行为就叫缓存穿透。 解决方案是不管查询数据库是否有数据，都缓存起来，只不过把没有数据的缓存结果的过期时间设置为比较短的一个值，比如 3 分钟。 16.什么是缓存雪崩，该如何解决？ 答：指缓存由于某些原因，比如，宕机或者缓存大量过期等，从而导致大量请求到达后端数据库，进而导致数据库崩溃的情况。 解决缓存雪崩的方案如下： 分析业务功能，尽量让缓存的失效时间点均匀分布； 使用 Redis 主备，保证缓存系统的高可用。 17.什么是缓存预热？有几种实现方式？ 答：缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。 缓存预热的实现方式，可分为以下两种： 数据量不大的时候，工程启动的时候进行加载缓存动作； 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新。 18.在 Java 程序中如何使用 Redis？ 答：在 Java 程序中可使用 Jedis 来操作 Redis，使用步骤如下： 1）添加 Jedis 引用 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;复制 2）连接并操作 Redis 123456789Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);// 存值jedis.set(&quot;hello&quot;,&quot;world&quot;);// 取值jedis.get(&quot;hello&quot;);// 关闭连接jedis.close();复制 19.什么是 Redis 持久化？如何进行 Redis 持久化？ 答：Redis 持久化是指将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 有以下两种持久化方案： RDB（Redis DataBase）：是指在制定的时间间隔内将内存中的数据集快照写入磁盘； AOF（Append Only File）：该机制将以日志的形式记录服务器所处理的每一个写操作，在 Redis 服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。 Redis 默认支持的持久化方式是 RDB 方式。 20.RDB 和 AOF 有什么区别？ 答：RDB 和 AOF 的区别如下： RDB 可能会引起一定程度的数据丢失，AOF 不会造成数据丢失 RDB 的启动效率更高 AOF 占用的空间比 RDB 大，AOF 的同步速度比 RDB 慢 总体来说如果对数据的完整性要求不高，RDB 是最好的解决方案，反之则选择 AOF。 21.Redis 的监控工具都有哪些？ 答：常用的 Redis 监控工具如下： Redis-stat：采用 Ruby 开发，基于 Redis 的 info 命令来统计，不影响 Redis 的性能； RedisLive：采用 Python 开发的可视化及查询分析工具，它是通过监控脚本来 Redis 提供的 MONITOR 命令从被监控 Redis 实例中获取数据，并存储到 Redis 的监控实例中。 22.如何定位 Redis 的慢查询？ 答：使用 slowlog get 来定位慢查询操作，如下所示： 127.0.0.1:6379&gt; slowlog get (integer) 0 (integer) 1565937939 (integer) 28003 “lpush” “list” “1” “2” “6” “3” “4” “9” “8” 其中： 表示慢查询记录 id 表示发起命令的时间戳 表示命令耗时，单位为微秒 表示该条记录的命令及参数 23.SAVE 和 BGSAVE 有什么区别？ 答：SAVE 和 BGSAVE 都是用于 Redis 持久化的，它们的区别如下： SAVE 直接调用 rdbSave 函数（用于 Redis 持久化的函数），阻塞 Redis 主进程，直到保存完成为止，在主进程阻塞期间，服务器不能处理客户端的任何请求； BGSAVE 则会创建一个子进程，子进程负责调用 rdbSave 函数，并在保存完成之后向主进程发送完成信号，Redis 服务器在 BGSAVE 执行期间仍然可以继续处理客户端的请求。 24.Redis 是如何实现同步的？ 答：Redis 可以实现主从同步和从从同步。当第一次同步时，主节点做一次 BGSAVE，并同时将后续修改操作记录到内存中，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存，加载完成后再通知主节点将期间修改的操作记录，同步到复制节点进行重放，这样就完成了同步过程。 25.Redis 可以切换数据库吗？如何切换？ 答：Redis 不像 MySQL 等关系型数据库那样有数据库的概念，不同的数据存在不同的数据库中，Redis 数据库是由一个整数索引标识，而不是一个数据库名称，默认情况下客户端连接到数据库 0，可以在配置文件中控制数据库总数，默认是 16 个。 可以使用 select index 来切换数据库，如下所示： 127.0.0.1:6379&gt; select 0 OK 26.Redis 有哪些集群策略？ 答：Redis 集群策略有以下 3 种： 主从策略：1 台机器作为写操作，另外 2 台作为读操作，类似于 MySQL 的主从方式； 哨兵策略：增加 1 台机器作为哨兵，监控 3 台主从机器，当主节点挂机的时候，机器内部进行选举，从集群中从节点里指定一台机器升级为主节点，从而实现高可用。当主节点恢复的时候，加入到从节点中继续提供服务； 集群策略：Redis 3.0 之后增加了集群的概念，可实现多主多从的结构，实现真正的高可用。 27.Redis 集群方案都有哪些？ 答：Redis 集群实现方案如下： Twemproxy 是 Twitter 开源的 Redis 代理，它的使用和普通 Redis 完全一致，它会以一个代理的身份接收请求，并使用 hash 算法将请求转接到具体 Redis，将结果再返回 Twemproxy； Codis 是开源解决方案，也是目前用的最多的集群方案，基本和 Twemproxy 效果一致，但它支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点； Redis Cluster 是 Redis 3.0 自带的集群方案，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点； 业务代码层实现，创建几个独立的 Redis 实例，在代码层对 key 进行 hash 计算，然后去对应的 Redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复、实例的监控等。 28.Redis 如何做内存优化？ 答：把相关的信息整体存储，而不是把每个信息独立存储，这样就可以有效的减少内存使用。 29.分布式锁设计时需要注意哪些事项？ 答：通常分布式锁在设计时，需同时满足以下四个约束条件。 互斥性：在任意时刻，只有一个客户端能持有锁。 安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其他客户端能加锁。 可用性：就 Redis 而言，当提供锁服务的 Redis master 节点发生宕机等不可恢复性故障时，slave 节点能够升主并继续提供服务，支持客户端加锁和解锁；对基于分布式一致性算法实现的锁服务，如 ETCD 而言，当 leader 节点宕机时，follow 节点能够选举出新的 leader 继续提供锁服务。 对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即，客户端 A 不能把客户端 B 加的锁给解了。 30.Redis 集群实现的原理是什么？ 答：集群的实现原理和集群的实现方式有关，如下所述： Redis Sentinal 着眼于高可用，在 Master 宕机时会自动将 Slave 提升为 Master，继续提供服务； Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。 31.Redis 常见的性能问题有哪些？ 答：Redis 常见性能问题如下： 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，因此主服务器最好不要写内存快照； Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"32.MySQL 面试题汇总","slug":"interview-java-32","date":"2020-10-08T06:09:27.000Z","updated":"2020-10-08T06:24:54.917Z","comments":true,"path":"2020/10/08/interview-java-32/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-32/","excerpt":"","text":"MySQL 面试题汇总 1.说一下 MySQL 执行一条查询语句的内部执行过程？ 答：MySQL 执行一条查询的流程如下： 客户端先通过连接器连接到 MySQL 服务器； 连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器； 分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器； 优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好； 优化器执行完就进入执行器，执行器则开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。 2.MySQL 查询缓存有什么优缺点？ 答：MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。 3.MySQL 的常用引擎都有哪些？ 答：MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。 4.常用的存储引擎 InnoDB 和 MyISAM 有什么区别？ 答：InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们其他主要区别如下： InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复； InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁； InnoDB 支持外键，MyISAM 不支持外键； MyISAM 性能比 InnoDB 高； MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好； InnoDB 主键查询性能高于 MyISAM。 5.什么叫回表查询？ 答：普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。 6.如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？ 答：不是，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。 7.一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？ 答：如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。 8.什么是独立表空间和共享表空间？它们的区别是什么？ 答：共享表空间指的是数据库的所有表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，因此表依然很大，而独立表空间如果删除表就会清除空间。 9.清空表的所有数据性能最好的语句是？ A：delete from t B：delete t C：drop table t D：truncate table t 答：D 题目解析：truncate 清除表数据不会写日志，delete 要写日志，因此 truncate 的效率要高于 delete。 10.唯一索引和普通索引哪个性能更好？ 答：唯一索引和普通索引的性能对比分为以下两种情况： 对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别； 对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比普通索引要多了判断操作，从而性能就比普通索引性能要低。 11.left join 和 right join 的区别是什么？ 答：left join 和 right join 的区别如下： left join（左联结），返回左表全部记录和右表联结字段相等的记录； right join（右联结），返回右表全部记录和左表联结字段相等的记录。 12.什么是最左匹配原则？它的生效原则有哪些？ 答：最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，指的是索引以最左边为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)： where a=1 只使用了索引 a； where a=1 and b=2 只使用了索引 a,b； where a=1 and b=2 and c=3 使用a,b,c； where b=1 or where c=1 不使用索引； where a=1 and c=3 只使用了索引 a； where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。 13.以下 or 查询有什么问题吗？该如何优化？ select * from t where num=10 or num=20; 答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为： select * from t where num=10 union select * from t where num=20; 14.事务是什么？它有什么特性？ 答：事务是一系列的数据库操作，是数据库应用的基本单位。 在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下： 原子性（Atomic），要么全部执行，要么全部不执行； 一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态； 隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务； 持久性（Durability），事务提交后，其结果永久保存在数据库中。 15.MySQL 中有几种事务隔离级别？分别是什么？ 答：MySQL 中有四种事务隔离级别，分别是： read uncommited，未提交读，读到未提交数据； read committed，读已提交，也叫不可重复读，两次读取到的数据不一致； repetable read，可重复读； serializable，串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。 MySQL 默认使用 repetable read 的事务隔离级别。 16.如何设置 MySQL 的事务隔离级别？ 答：MySQL 事务隔离级别 mysql.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置： transaction-isolation = REPEATABLE-READ 可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。 17.MySQL 出现了中文乱码该如何解决？ 答：解决 MySQL 中文乱码的问题，可以设置全局编码或设置某个数据库或表的编码为 utf8。 设置全局编码： 12345set character_set_client=&#x27;utf8&#x27;;set character_set_connection=&#x27;utf8&#x27;;set character_set_results=&#x27;utf8&#x27;;复制 设置数据库的编码： 123alter database db character set utf8;复制 设置表的编码： 123alter table t character set utf8;复制 18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？ 答：因为 B 树、Hash、红黑树或二叉树存在以下问题。 B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。 Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。 红黑树：树的高度随着数据量增加而增加，IO 代价高。 19.MySQL 是如何处理死锁？ 答：MySQL 对待死锁常见的两种策略： 通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时； 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。 20.什么是全局锁？它的应用场景有哪些？ 答：全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全量逻辑备份，这个时候整个库会处于完全的只读状态。 21.使用全局锁会导致什么问题？ 答：使用全局锁会使整个系统不能执行更新操作，所有的更新业务会出于等待状态；如果你是在从库进行备份，则会导致主从同步严重延迟。 22.InnoDB 存储引擎有几种锁算法？ 答：InnoDB 的锁算法包括以下三种： Record Lock — 单个行记录上的锁； Gap Lock — 间隙锁，锁定一个范围，不包括记录本身； Next-Key Lock — 锁定一个范围，包括记录本身。 23.InnoDB 如何实现行锁？ 答：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁。使用 for update 来实现行锁，具体脚本如下： select * from t where id=1 for update 其中 id 字段必须有索引。 24.MySQL 性能指标都有哪些？如何得到这些指标？ 答：MySQL 最重要的性能指标有以下两个： QPS（Queries Per Second），每秒查询数，一台数据库每秒能够处理的查询次数； TPS（Transactions Per Second），每秒处理事务数。 这些性能指标可以通过 show status 来查询当前数据库状态的结果信息中估算出来，show status 会有 300 多条状态信息记录，其中以下这些信息 QPS 和 TPS 有关系： Uptime，服务器已经运行的时间，单位秒； Questions，已经发送给数据库查询数； Com_select，查询次数，实际查询次数； Com_insert，插入次数； Com_delete，删除次数； Com_update，更新次数； Com_commit，事务次数； Com_rollback，回滚次数。 25.MySQL 中的重要日志分为哪几个？ ① 错误日志：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为： mv hostname.err hostname.err.old mysqladmin flush-logs ② 查询日志：查询日志在 MySQL 中被称为 general log（通用日志），查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下: insert 查询为了避免数据冲突，如果此前插入过数据，则当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错； update 时也会查询因为更新的时候很可能会更新某一块数据； delete 查询，只删除符合条件的数据； 因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。 查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，因此，可以根据自己的实际情况来决定是否开启查询日志。 查询日志模式是关闭的，可以通过以下命令开启查询日志： set global general_log=1 set global log_output=‘table’; general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。 ③ 慢日志：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句： set global slow_query_log=‘ON’; 使用 set global slow_query_log=‘ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。因此如果要永久生效，就要修改配置文件 my.cnf，设置 slow_query_log=1 并重启 MySQL 服务器。 ④ redo log（重做日志）：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。 ⑤ undo log（回滚日志）：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 ySQL 5.6 中，undo log 的存放位置还可以通过变量 innodb_undo_directory 来自定义存放目录，默认值为“.”表示 datadir 目录。 ⑥ bin log（二进制日志）：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。 binlog 的作用如下： 恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复； 复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步； 审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。 除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。 binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。 通过以下命令来查询 binlog 是否开启： show variables like ‘log_%’; binlog 格式分为 STATEMENT、ROW 和 MIXED 三种。 STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，因此相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间，并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL，比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如，InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制。 ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，因此，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，因此可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等。 MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT_USER()、ROW_COUNT() 等无法确定的函数。 26.redo log 和 binlog 有什么区别？ redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下： redo log 是物理日志，记录的是“在某个数据页上做了什么修改”； binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”； redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用； redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的，“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，因此 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。 27.慢查询日志的获取方式有哪些？ 答：慢查询日志的常见获取方式如下。 使用 MySQL 自带功能，开启慢查询日志，在 MySQL 的安装目录下找到 my.cnf 文件设置 slow-query-log=On 开启慢查询，慢查询默认时长为 10s，默认存储文件名为 host_name-slow.log。 使用三方开源方案 zabbix，zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案，能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。 28.如何定位慢查询？ 答：使用 MySQL 中的 explain 分析执行语句，比如： explain select * from t where id=5; 如下图所示： 其中： id — 选择标识符，id 越大优先级越高，越先被执行 select_type — 表示查询的类型。 table — 输出结果集的表 partitions — 匹配的分区 type — 表示表的连接类型 possible_keys — 表示查询时，可能使用的索引 key — 表示实际使用的索引 key_len — 索引字段的长度 ref— 列与索引的比较 rows — 大概估算的行数 filtered — 按表条件过滤的行百分比 Extra — 执行情况的描述和说明 其中最重要的就是 type 字段，type 值类型如下： all — 扫描全表数据 index — 遍历索引 range — 索引范围查找 index_subquery — 在子查询中使用 ref unique_subquery — 在子查询中使用 eq_ref ref_or_null — 对 null 进行索引的优化的 ref fulltext — 使用全文索引 ref — 使用非唯一索引查找数据 eq_ref — 在 join 查询中使用主键或唯一索引关联 const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点 29.MySQL 中常见的读写分离方案有哪些？ 答：MySQL 中常见的读写分离方案通常为以下两种： 使用 MySQL 官方提供的数据库代理产品 MySql ProxySQL 搭建自动分配的数据库读写分离环境； 在程序层面配置多数据源使用代码实现读写分离。 30.怎样保证主备数据库无延迟？ 答：通常保证主备数据库无延迟有以下三种方法。 每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds_behind_master 参数是用来衡量主备延迟时间的长短。 对比位点确保主备无延迟。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。 对比 GTID 集合确保主备无延迟。Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。 31.什么是 MySQL 多实例，如何配置 MySQL 多实例？ 答：MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种： 一个实例一个配置文件，不同端口； 同一配置文件（my.cnf）下配置不同实例，基于 MySQL 的 d_multi 工具。 32.表的优化策略有哪些？ 「参考答案」常见的大表优化策略如下。 读写分离，主库负责写，从库负责读。 垂直分区，根据数据属性单独拆表甚至单独拆库。 水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。 33.数据库分片方案有哪些？ 「参考答案」数据库分片方案有哪些？ 答：数据库创建的分片方案有两种方式：客户端代理方式和中间件代理方式。 客户端代理 — 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现，比如 Sharding-JDBC、阿里 TDDL 等。 中间件代理 — 在应用层和数据层中间加了一个代理层。分片逻辑统一维护在中间件服务中，比如 MyCat、网易的 DDB 都是中间件代理的典型代表。 34.查询语句的优化方案有哪些？ 「参考答案」常见优化方案如下： 不做列运算，把计算都放入各个业务系统实现； 查询语句尽可能简单，大语句拆小语句，减少锁时间； 不使用 select * 查询； or 查询改写成 in 查询； 不用函数和触发器； 避免 %xx 查询； 少用 join 查询； 使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123； 尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描； 列表数据使用分页查询，每页数据量不要太大。 35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？ 「参考答案」可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下： 定期断开空闲的长连接； 如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql_reset_connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"31.Java 分布式框架面试题合集","slug":"interview-java-31","date":"2020-10-08T06:09:23.000Z","updated":"2020-10-08T06:24:44.447Z","comments":true,"path":"2020/10/08/interview-java-31/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-31/","excerpt":"","text":"Java 分布式框架面试题合集 1.什么是 ZooKeeper？ 答：ZooKeeper 是一个开源的分布式应用程序协调服务，是一个典型的分布式数据一致性解决方案。设计目的是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的系统，并以一系列简单易用的原子操作提供给用户使用。 2.ZooKeeper 提供了哪些功能？ 答：ZooKeeper 主要提供以下功能： 分布式服务注册与订阅：在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，如 Dubbo。 分布式配置中心：发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。 命名服务：在分布式系统中，通过命名服务客户端应用能够根据指定名字来获取资源、服务地址和提供者等信息。 分布式锁：这个主要得益于 ZooKeeper 为我们保证了数据的强一致性。 3.ZooKeeper 有几种搭建模式？ 答：ZooKeeper 通常有三种搭建模式： 单机模式：zoo.cfg 中只配置一个 server.id 就是单机模式了，此模式一般用在测试环境，如果当前主机宕机，那么所有依赖于当前 ZooKeeper 服务工作的其他服务器都不能进行正常工作； 伪分布式模式：在一台机器启动不同端口的 ZooKeeper，配置到 zoo.cfg 中，和单机模式相同，此模式一般用在测试环境； 分布式模式：多台机器各自配置 zoo.cfg 文件，将各自互相加入服务器列表，上面搭建的集群就是这种完全分布式。 4.ZooKeeper 有哪些特性？ 答： ZooKeeper 特性如下： 顺序一致性（Sequential Consistency）：来自相同客户端提交的事务，ZooKeeper 将严格按照其提交顺序依次执行； 原子性（Atomicity）：于 ZooKeeper 集群中提交事务，事务将“全部完成”或“全部未完成”，不存在“部分完成”； 单一系统镜像（Single System Image）：客户端连接到 ZooKeeper 集群的任意节点，其获得的数据视图都是相同的； 可靠性（Reliability）：事务一旦完成，其产生的状态变化将永久保留，直到其他事务进行覆盖； 实时性（Timeliness）：事务一旦完成，客户端将于限定的时间段内，获得最新的数据。 5.以下关于 ZooKeeper 描述错误的是？ A：所有的节点都具有稳定的存储能力 B：ZooKeeper 任意节点之间都能够进行通信（消息发送 &amp; 接收） C：为了提高性能，ZooKeeper 允许同一份数据存在一部分节点写成功，另一部分节点写失败 D：ZooKeeper 集群运行期间，只要半数以上节点存活，ZooKeeper 就能正常服务 答：C 题目解析：ZooKeeper 不允许同一份数据存在一部分节点写成功，另一部分节点写失败的情况，这不符合 ZooKeeper“一致性”的原则。 6.ZooKeeper 如何实现分布式锁？ 答：ZooKeeper 实现分布式锁的步骤如下： 客户端连接 ZooKeeper，并在 /lock 下创建临时的且有序的子节点，第一个客户端对应的子节点为 /lock/lock-10000000001，第二个为 /lock/lock-10000000002，以此类推。 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听刚好在自己之前一位的子节点删除消息，获得子节点变更通知后重复此步骤直至获得锁； 执行业务代码； 完成业务流程后，删除对应的子节点释放锁。 整体流程如下图所示： 7.ZooKeeper 如何实现分布式事务？ 答：ZooKeeper 实现分布式事务，类似于两阶段提交，总共分为以下 4 步： 客户端先给 ZooKeeper 节点发送写请求； ZooKeeper 节点将写请求转发给 Leader 节点，Leader 广播给集群要求投票，等待确认； Leader 收到确认，统计投票，票数过半则提交事务； 事务提交成功后，ZooKeeper 节点告知客户端。 8.集群中为什么要有主节点？ 答：在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，这就是主节点存在的意义。 9.Dubbo 是什么？ 答：Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 10.Dubbo 有哪些特性？ 答：Dubbo 特性如下： 面向接口代理的高性能 RPC 调用：提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节； 智能负载均衡：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量； 服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知； 高度可扩展能力：遵循微内核+插件的设计原则，所有核心能力如 Protocol、Transport、Serialization 被设计为扩展点，平等对待内置实现和第三方实现； 运行期流量调度：内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能； 可视化的服务治理与运维：提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。 11.Dubbo 有哪些核心组件？ 答：Dubbo 核心组件如下： Provider：服务提供方 Consumer：服务消费方 Registry：服务注册与发现的注册中心 Monitor：主要用来统计服务的调用次数和调用时间 Container：服务的运行容器 12.Dubbo 有哪些负载均衡策略？ 答：Dubbo 负责均衡策略如下： 随机负载均衡（Random LoadBalance）：按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重； 轮询负载均衡（RoundRobin LoadBalance）：按公约后的权重设置轮询比率，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上； 最少活跃调用数负载均衡（LeastActive LoadBalance）：使用最少活跃调用数，活跃数指调用前后计数差； 哈希负载均衡（ConsistentHash LoadBalance）：使用哈希值转发，相同参数的请求总是发到同一提供者。 负载均衡配置如下： 服务端服务级别 123&lt;dubbo:service interface=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot; /&gt;复制 客户端服务级别 123&lt;dubbo:reference interface=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot; /&gt;复制 服务端方法级别 12345&lt;dubbo:service interface=&quot;xxx&quot;&gt; &lt;dubbo:method name=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:service&gt;复制 客户端方法级别 12345&lt;dubbo:reference interface=&quot;xxx&quot;&gt; &lt;dubbo:method name=&quot;xxx&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:reference&gt;复制 13.Dubbo 不支持以下哪种协议？ A：dubbo:// B：rmi:// C：redis:// D：restful:// 答：D 题目解析：restful 是一种编程规范，并不是一种传输协议，也不被 Dubbo 支持。 14.Dubbo 默认使用什么注册中心，还有别的选择吗？ 答：推荐使用 ZooKeeper 作为注册中心，还有 Nacos、Redis、Simple 注册中心（普通的 Dubbo 服务）。 15.Dubbo 支持多注册中心吗？ 答：Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。 多注册中心注册： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;dubbo:application name=&quot;world&quot; /&gt; &lt;!-- 多注册中心配置 --&gt; &lt;dubbo:registry id=&quot;hangzhouRegistry&quot; address=&quot;10.20.141.150:9090&quot; /&gt; &lt;dubbo:registry id=&quot;qingdaoRegistry&quot; address=&quot;10.20.141.151:9010&quot; default=&quot;false&quot; /&gt; &lt;!-- 向多个注册中心注册 --&gt; &lt;dubbo:service interface=&quot;com.alibaba.hello.api.HelloService&quot; version=&quot;1.0.0&quot; ref=&quot;helloService&quot; registry=&quot;hangzhouRegistry,qingdaoRegistry&quot; /&gt;&lt;/beans&gt;复制 16.Dubbo 支持的连接方式有哪些？ 答：Dubbo 支持的主要连接方式有：组播、直连和 ZooKeeper 等注册中心。 ① 组播方式，不需要启动任何中心节点，只要广播地址一样，就可以互相发现。 提供方启动时广播自己的地址 消费方启动时广播订阅请求 提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 unicast=false，则广播给订阅者 消费方收到提供方地址时，连接该地址进行 RPC 调用 组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段：224.0.0.0 ~ 239.255.255.255 配置 123&lt;dubbo:registry address&#x3D;&quot;multicast:&#x2F;&#x2F;224.5.6.7:1234&quot; &#x2F;&gt;复制 或 123&lt;dubbo:registry protocol&#x3D;&quot;multicast&quot; address&#x3D;&quot;224.5.6.7:1234&quot; &#x2F;&gt;复制 为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明 unicast=false，否则只会有一个消费者能收到消息；当服务者和消费者运行在同一台机器上，消费者同样需要声明 unicast=false，否则消费者无法收到消息，导致 No provider available for the service 异常： 123&lt;dubbo:registry address&#x3D;&quot;multicast:&#x2F;&#x2F;224.5.6.7:1234?unicast&#x3D;false&quot; &#x2F;&gt;复制 或 12345&lt;dubbo:registry protocol&#x3D;&quot;multicast&quot; address&#x3D;&quot;224.5.6.7:1234&quot;&gt; &lt;dubbo:parameter key&#x3D;&quot;unicast&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;&lt;&#x2F;dubbo:registry&gt;复制 ② 直连方式，注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。 123&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;N/A&quot; file=&quot;./.dubbo-platform&quot;/&gt;复制 将 Simple 注册中心暴露成 Dubbo 服务： 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.3.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt; &lt;!-- 当前应用信息配置 --&gt; &lt;dubbo:application name&#x3D;&quot;simple-registry&quot; &#x2F;&gt; &lt;!-- 暴露服务协议配置 --&gt; &lt;dubbo:protocol port&#x3D;&quot;9090&quot; &#x2F;&gt; &lt;!-- 暴露服务配置 --&gt; &lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.registry.RegistryService&quot; ref&#x3D;&quot;registryService&quot; registry&#x3D;&quot;N&#x2F;A&quot; ondisconnect&#x3D;&quot;disconnect&quot; callbacks&#x3D;&quot;1000&quot;&gt; &lt;dubbo:method name&#x3D;&quot;subscribe&quot;&gt;&lt;dubbo:argument index&#x3D;&quot;1&quot; callback&#x3D;&quot;true&quot; &#x2F;&gt;&lt;&#x2F;dubbo:method&gt; &lt;dubbo:method name&#x3D;&quot;unsubscribe&quot;&gt;&lt;dubbo:argument index&#x3D;&quot;1&quot; callback&#x3D;&quot;false&quot; &#x2F;&gt;&lt;&#x2F;dubbo:method&gt; &lt;&#x2F;dubbo:service&gt; &lt;!-- 简单注册中心实现，可自行扩展实现集群和状态同步 --&gt; &lt;bean id&#x3D;&quot;registryService&quot; class&#x3D;&quot;org.apache.dubbo.registry.simple.SimpleRegistryService&quot; &#x2F;&gt;&lt;&#x2F;beans&gt;复制 引用 Simple Registry 服务： 123&lt;dubbo:registry address&#x3D;&quot;127.0.0.1:9090&quot; &#x2F;&gt;复制 或者： 123&lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.registry.RegistryService&quot; group&#x3D;&quot;simple&quot; version&#x3D;&quot;1.0.0&quot; ... &gt;复制 或者： 123&lt;dubbo:registry address&#x3D;&quot;127.0.0.1:9090&quot; group&#x3D;&quot;simple&quot; version&#x3D;&quot;1.0.0&quot; &#x2F;&gt;复制 适用性说明：此 SimpleRegistryService 只是简单实现，不支持集群，可作为自定义注册中心的参考，但不适合直接用于生产环境。 ③ ZooKeeper 注册中心，Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 流程说明： 服务提供者启动时：向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者启动时：订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址，并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址 支持以下功能： 当提供者出现断电等异常停机时，注册中心能自动删除提供者信息 当注册中心重启时，能自动恢复注册数据，以及订阅请求 当会话过期时，能自动恢复注册数据，以及订阅请求 当设置 &lt;dubbo:registry check=&quot;false&quot; /&gt; 时，记录失败注册和订阅请求，后台定时重试 可通过 &lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt; 设置 zookeeper 登录信息 可通过 &lt;dubbo:registry group=&quot;dubbo&quot; /&gt; 设置 zookeeper 的根节点，不设置将使用无根树 支持 * 号通配符 &lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;，可订阅服务的所有分组和所有版本的提供者 Zookeeper 使用 在 provider 和 consumer 中增加 zookeeper 客户端 jar 包依赖： 1234567&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt; &lt;version&gt;3.3.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;复制 Dubbo 支持 zkclient 和 curator 两种 Zookeeper 客户端实现： 注意：在 2.7.x 的版本中已经移除了 zkclient 的实现，如果要使用 zkclient 客户端，需要自行拓展。 使用 zkclient 客户端 从 2.2.0 版本开始缺省为 zkclient 实现，以提升 zookeeper 客户端的健状性。zkclient 是 Datameer 开源的一个 Zookeeper 客户端实现。 缺省配置： 123&lt;dubbo:registry ... client&#x3D;&quot;zkclient&quot; &#x2F;&gt;复制 或： 123dubbo.registry.client&#x3D;zkclient复制 或： 123zookeeper:&#x2F;&#x2F;10.20.153.10:2181?client&#x3D;zkclient复制 需依赖或直接下载： 1234567&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;&#x2F;groupId&gt; &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt; &lt;version&gt;0.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;复制 使用 curator 客户端 从 2.3.0 版本开始支持可选 curator 实现。Curator 是 Netflix 开源的一个 Zookeeper 客户端实现。 如果需要改为 curator 实现，请配置： 123&lt;dubbo:registry ... client&#x3D;&quot;curator&quot; &#x2F;&gt;复制 或： 123dubbo.registry.client&#x3D;curator复制 或： 123zookeeper:&#x2F;&#x2F;10.20.153.10:2181?client&#x3D;curator复制 需依赖或直接下载： 1234567&lt;dependency&gt; &lt;groupId&gt;com.netflix.curator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;复制 Zookeeper 单机配置: 123&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;10.20.153.10:2181&quot; &#x2F;&gt;复制 或： 123&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; &#x2F;&gt;复制 Zookeeper 集群配置： 123&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;10.20.153.10:2181?backup&#x3D;10.20.153.11:2181,10.20.153.12:2181&quot; &#x2F;&gt;复制 或： 123&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181&quot; &#x2F;&gt;复制 同一 Zookeeper，分成多组注册中心： 1234&lt;dubbo:registry id&#x3D;&quot;chinaRegistry&quot; protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; group&#x3D;&quot;china&quot; &#x2F;&gt;&lt;dubbo:registry id&#x3D;&quot;intlRegistry&quot; protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; group&#x3D;&quot;intl&quot; &#x2F;&gt;复制 17.什么是服务熔断？ 答：在应用系统服务中，当依赖服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，临时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。 18.Dubbo 可以对结果进行缓存吗？支持的缓存类型都有哪些？ 答：可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。 Dubbo 支持的缓存类型有： lru 基于最近最少使用原则删除多余缓存，保持最热的数据被缓存； threadlocal 当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问； jcache 集成，可以桥接各种缓存实现。 配置如下： 123&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; cache=&quot;lru&quot; /&gt;复制 或 12345&lt;dubbo:reference interface=&quot;com.foo.BarService&quot;&gt; &lt;dubbo:method name=&quot;findBar&quot; cache=&quot;lru&quot; /&gt;&lt;/dubbo:reference&gt;复制 19.Dubbo 有几种集群容错模式？ 答：Dubbo 集群容错模式如下。 ① Failover Cluster 失败自动切换，当出现失败，重试其他服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数（不含第一次）。 重试次数配置如下： 123&lt;dubbo:service retries=&quot;2&quot; /&gt;复制 或 123&lt;dubbo:reference retries=&quot;2&quot; /&gt;复制 或 12345&lt;dubbo:reference&gt; &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;&lt;/dubbo:reference&gt;复制 ② Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 ③ Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 ④ Failback Cluster 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 ⑤ Forking Cluster 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。 ⑥ Broadcast Cluster 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"30.消息队列面试题汇总","slug":"interview-java-30","date":"2020-10-08T06:09:20.000Z","updated":"2020-10-08T06:24:34.162Z","comments":true,"path":"2020/10/08/interview-java-30/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-30/","excerpt":"","text":"消息队列面试题汇总 1.消息队列的应用场景有哪些？ 答：消息队列的应用场景如下。 应用解耦，比如，用户下单后，订单系统需要通知库存系统，假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。订单系统与库存系统耦合，这个时候如果使用消息队列，可以返回给用户成功，先把消息持久化，等库存系统恢复后，就可以正常消费减去库存了。 削峰填谷，比如，秒杀活动，一般会因为流量过大，从而导致流量暴增，应用挂掉，这个时候加上消息队列，服务器接收到用户的请求后，首先写入消息队列，假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。 日志系统，比如，客户端负责将日志采集，然后定时写入消息队列，消息队列再统一将日志数据存储和转发。 2.RabbitMQ 有哪些优点？ 答：RabbitMQ 的优点如下： 可靠性，RabbitMQ 的持久化支持，保证了消息的稳定性； 高并发，RabbitMQ 使用了 Erlang 开发语言，Erlang 是为电话交换机开发的语言，天生自带高并发光环和高可用特性； 集群部署简单，正是因为 Erlang 使得 RabbitMQ 集群部署变的非常简单； 社区活跃度高，因为 RabbitMQ 应用比较广泛，所以社区的活跃度也很高； 解决问题成本低，因为资料比较多，所以解决问题的成本也很低； 支持多种语言，主流的编程语言都支持，如 Java、.NET、PHP、Python、JavaScript、Ruby、Go 等； 插件多方便使用，如网页控制台消息管理插件、消息延迟插件等。 3.RabbitMQ 有哪些重要的角色？ 答：RabbitMQ 包含以下三个重要的角色： 生产者：消息的创建者，负责创建和推送数据到消息服务器； 消费者：消息的接收方，用于处理数据和确认消息； 代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。 4.RabbitMQ 有哪些重要的组件？它们有什么作用？ 答：RabbitMQ 包含的重要组件有：ConnectionFactory（连接管理器）、Channel（信道）、Exchange（交换器）、Queue（队列）、RoutingKey（路由键）、BindingKey（绑定键） 等重要的组件，它们的作用如下： ConnectionFactory（连接管理器）：应用程序与 RabbitMQ 之间建立连接的管理器，程序代码中使用； Channel（信道）：消息推送使用的通道； Exchange（交换器）：用于接受、分配消息； Queue（队列）：用于存储生产者的消息； RoutingKey（路由键）：用于把生成者的数据分配到交换器上； BindingKey（绑定键）：用于把交换器的消息绑定到队列上。 运行流程，如下图所示： 5.什么是消息持久化？ 答：消息持久化是把消息保存到物理介质上，以防止消息的丢失。 6.RabbitMQ 要实现消息持久化，需要满足哪些条件？ 答：RabbitMQ 要实现消息持久化，必须满足以下 4 个条件： 投递消息的时候 durable 设置为 true，消息持久化，代码：channel.queueDeclare(x, true, false, false, null)，参数 2 设置为 true 持久化； 设置投递模式 deliveryMode 设置为 2（持久），代码：channel.basicPublish(x, x, MessageProperties.PERSISTENTTEXTPLAIN,x)，参数 3 设置为存储纯文本到磁盘； 消息已经到达持久化交换器上； 消息已经到达持久化的队列。 7.消息持久化有哪些缺点？如何缓解？ 答：消息持久化的缺点是很消耗性能，因为要写入硬盘要比写入内存性能较低很多，从而降低了服务器的吞吐量。可使用固态硬盘来提高读写速度，以达到缓解消息持久化的缺点。 8.如何使用 Java 代码连接 RabbitMQ？ 答：使用 Java 代码连接 RabbitMQ 有以下两种方式： 方式一： 1234567891011121314151617public static Connection GetRabbitConnection() &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(Config.UserName); factory.setPassword(Config.Password); factory.setVirtualHost(Config.VHost); factory.setHost(Config.Host); factory.setPort(Config.Port); Connection conn = null; try &#123; conn = factory.newConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn;&#125;复制 方式二： 1234567891011121314151617public static Connection GetRabbitConnection2() &#123; ConnectionFactory factory = new ConnectionFactory(); // 连接格式：amqp://userName:password@hostName:portNumber/virtualHost String uri = String.format(&quot;amqp://%s:%s@%s:%d%s&quot;, Config.UserName, Config.Password, Config.Host, Config.Port, Config.VHost); Connection conn = null; try &#123; factory.setUri(uri); factory.setVirtualHost(Config.VHost); conn = factory.newConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn;&#125;复制 9.使用 Java 代码编写一个 RabbitMQ 消费和生产的示例？ 答：代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static void main(String[] args) &#123; publisher(); // 生产消息 consumer(); // 消费消息&#125;/** * 推送消息 */public static void publisher() &#123; // 创建一个连接 Connection conn = ConnectionFactoryUtil.GetRabbitConnection(); if (conn != null) &#123; try &#123; // 创建通道 Channel channel = conn.createChannel(); // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】 channel.queueDeclare(Config.QueueName, false, false, false, null); String content = String.format(&quot;当前时间：%s&quot;, new Date().getTime()); // 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性-routing headers，此属性为MessageProperties.PERSISTENT_TEXT_PLAIN用于设置纯文本消息存储到硬盘；参数四：消息主体】 channel.basicPublish(&quot;&quot;, Config.QueueName, null, content.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;已发送消息：&quot; + content); // 关闭连接 channel.close(); conn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * 消费消息 */public static void consumer() &#123; // 创建一个连接 Connection conn = ConnectionFactoryUtil.GetRabbitConnection(); if (conn != null) &#123; try &#123; // 创建通道 Channel channel = conn.createChannel(); // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】 channel.queueDeclare(Config.QueueName, false, false, false, null); // 创建订阅器，并接受消息 channel.basicConsume(Config.QueueName, false, &quot;&quot;, new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String routingKey = envelope.getRoutingKey(); // 队列名称 String contentType = properties.getContentType(); // 内容类型 String content = new String(body, &quot;utf-8&quot;); // 消息正文 System.out.println(&quot;消息正文：&quot; + content); channel.basicAck(envelope.getDeliveryTag(), false); // 手动确认消息【参数说明：参数一：该消息的index；参数二：是否批量应答，true批量确认小于index的消息】 &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;复制 10.RabbitMQ 交换器类型有哪些？ 答：RabbitMQ 消费类型也就是交换器（Exchange）类型有以下四种： direct：轮询方式 headers：轮询方式，允许使用 header 而非路由键匹配消息，性能差，几乎不用 fanout：广播方式，发送给所有订阅者 topic：匹配模式，允许使用正则表达式匹配消息 RabbitMQ 默认的是 direct 方式。 11.RabbitMQ 如何确保每个消息能被消费？ 答：RabbitMQ 使用 ack 消息确认的方式保证每个消息都能被消费，开发者可根据自己的实际业务，选择 channel.basicAck() 方法手动确认消息被消费。 12.RabbitMQ 接收到消息之后必须消费吗？ 答：RabbitMQ 接收到消息之后可以不消费，在消息确认消费之前，可以做以下两件事： 拒绝消息消费，使用 channel.basicReject(消息编号, true) 方法，消息会被分配给其他订阅者； 设置为死信队列，死信队列是用于专门存放被拒绝的消息队列。 13.topic 模式下发布了一个路由键为“com.mq.rabbit.error”的消息，请问以下不能接收到消息的是？ A：cn.mq.rabbit.* B：#.error C：cn.mq.* D：cn.mq.# 答：C 题目解析：“*”用于匹配一个分段（用“.”分割）的内容，“#”用于匹配 0 和多个字符。 14.以下可以获取历史消息的是？ A：topic 交换器 B：fanout 交换器 C：direct 交换器 D：以上都不是 答：C 题目解析：fanout 和 topic 都是广播形式的，因此无法获取历史消息，而 direct 可以。 15.RabbitMQ 包含事务功能吗？如何使用？ 答：RabbitMQ 包含事务功能，主要是对信道（Channel）的设置，主要方法有以下三个： channel.txSelect() 声明启动事务模式； channel.txComment() 提交事务； channel.txRollback() 回滚事务。 16.RabbitMQ 的事务在什么情况下是无效的？ 答：RabbitMQ 的事务在 autoAck=true 也就是自动消费确认的时候，事务是无效的。因为如果是自动消费确认，RabbitMQ 会直接把消息从队列中移除，即使后面事务回滚也不能起到任何作用。 17.Kafka 可以脱离 ZooKeeper 单独使用吗？ 答：Kafka 不能脱离 ZooKeeper 单独使用，因为 Kafka 使用 ZooKeeper 管理和协调 Kafka 的节点服务器。 18.Kafka 有几种数据保留的策略？ 答：Kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。 19.Kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 Kafka 将如何处理？ 答：这个时候 Kafka 会执行数据清除工作，时间和大小不论哪个满足条件，都会清空数据。 20.什么情况会导致 Kafka 运行变慢？ 答：以下情况可导致 Kafka 运行变慢： CPU 性能瓶颈 磁盘读写瓶颈 网络瓶颈 21.使用 Kafka 集群需要注意什么？ 答：Kafka 集群使用需要注意以下事项： 集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低； 集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"29.对数据库的基本操作步骤 + 面试题","slug":"interview-java-29","date":"2020-10-08T06:09:17.000Z","updated":"2020-10-08T06:24:17.750Z","comments":true,"path":"2020/10/08/interview-java-29/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-29/","excerpt":"","text":"对数据库的基本操作步骤 + 面试题 MyBatis 最初的设计是基于 XML 配置文件的，但随着 Java 的发展（Java 1.5 开始引入注解）和 MyBatis 自身的迭代升级，终于在 MyBatis 3 之后就开始支持基于注解的开发了。 下面我们使用 Spring Boot + MyBatis 注解的方式，来实现对数据库的基本操作，具体实现步骤如下。 MyBatis 注解版 1）创建数据表 12345678910drop table if exists `t_user`;create table `t_user` ( `id` bigint(20) not null auto_increment comment &#x27;主键id&#x27;, `username` varchar(32) default null comment &#x27;用户名&#x27;, `password` varchar(32) default null comment &#x27;密码&#x27;, `nick_name` varchar(32) default null, primary key (`id`)) engine=innodb auto_increment=1 default charset=utf8;复制 2）添加依赖 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;复制 3）增加配置文件 在 application.yml 文件中添加以下内容： 12345678910spring: datasource: url: jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Drivermybatis: type-aliases-package: com.interview.model复制 4）创建实体类 1234567891011121314151617181920212223242526272829303132333435363738public class UserEntity implements Serializable &#123; private static final long serialVersionUID = -5980266333958177105L; private Integer id; private String userName; private String passWord; private String nickName; public UserEntity(String userName, String passWord, String nickName) &#123; this.userName = userName; this.passWord = passWord; this.nickName = nickName; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125;&#125;复制 5）增加 Mapper 文件 12345678910111213141516171819202122232425262728293031323334public interface UserMapper &#123; @Select(&quot;select * from t_user&quot;) @Results(&#123; @Result(property = &quot;nickName&quot;, column = &quot;nick_name&quot;) &#125;) List&lt;UserEntity&gt; getAll(); @Select(&quot;select * from t_user where id = #&#123;id&#125;&quot;) @Results(&#123; @Result(property = &quot;nickName&quot;, column = &quot;nick_name&quot;) &#125;) UserEntity getOne(Long id); @Insert(&quot;insert into t_user(username,password,nick_name) values(#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;nickName&#125;)&quot;) void insert(UserEntity user); @Update(&quot;update t_user set username=#&#123;userName&#125;,nick_name=#&#123;nickName&#125; where id =#&#123;id&#125;&quot;) void update(UserEntity user); @Update(&#123;&quot;&lt;script&gt; &quot;, &quot;update t_user &quot;, &quot;&lt;set&gt;&quot;, &quot; &lt;if test=&#x27;userName != null&#x27;&gt;userName=#&#123;userName&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;nickName != null&#x27;&gt;nick_name=#&#123;nickName&#125;,&lt;/if&gt;&quot;, &quot; &lt;/set&gt; &quot;, &quot;where id=#&#123;id&#125; &quot;, &quot;&lt;/script&gt;&quot;&#125;) void updateUserEntity(UserEntity user); @Delete(&quot;delete from t_user where id =#&#123;id&#125;&quot;) void delete(Long id);&#125;复制 使用 @Select、@Insert、@Update、@Delete、@Results、@Result 等注解来替代 XML 配置文件。 6）添加 Mapper 包扫描 在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。 123456789@SpringBootApplication@MapperScan(&quot;com.interview.mapper&quot;)public class MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125;&#125;复制 7）编写测试代码 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class MybatisApplicationTests &#123; @Autowired private UserMapper userMapper; @Test public void testInsert() &#123; userMapper.insert(new UserEntity(&quot;laowang&quot;, &quot;123456&quot;, &quot;老王&quot;)); Assert.assertEquals(1, userMapper.getAll().size()); &#125;&#125;复制 相关面试题 1.MyBatis 有哪些优缺点？ 答：MyBatis 优缺点如下： 优点： 相比于 JDBC 需要编写的代码更少 使用灵活，支持动态 SQL 提供映射标签，支持对象与数据库的字段关系映射 缺点： SQL 语句依赖于数据库，数据库移植性差 SQL 语句编写工作量大，尤其在表、字段比较多的情况下 总体来说，MyBatis 是一个非常不错的持久层解决方案，它专注于 SQL 本身，非常灵活，适用于需求变化较多的互联网项目，也是当前国内主流的 ORM 框架。 2.以下不属于 MyBatis 优点的是？ A：可以灵活的编辑 SQL 语句 B：很好的支持不同数据库之间的迁移 C：能够很好的和 Spring 框架集成 D：提供映射标签支持对象和数据库的字段映射 答：B 题目解析：因为 MyBatis 需要自己编写 SQL 语句，但每个数据库的 SQL 语句有略有差异，所以 MyBatis 不能很好的支持不同数据库之间的迁移。 3.MyBatis 和 Hibernate 有哪些不同？ 答：MyBatis 和 Hibernate 都是非常优秀的 ORM 框架，它们的区别如下： 灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便； 可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差； 开发效率：Hibernate 对 SQL 语句做了封装，让开发者可以直接使用，因此开发效率更高； 学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。 4.“#”和“$”有什么区别？ 答：“#”是预编译处理，“$”是字符替换。 在使用“#”时，MyBatis 会将 SQL 中的参数替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。 5.在 MyBatis 中怎么解决实体类属性名和表字段名不一致的问题？ 答：通常的解决方案有以下两种方式。 ① 在 SQL 语句中重命名为实体类的属性名，可参考以下配置： 12345&lt;select id=&quot;selectorder&quot; parametertype=&quot;int&quot; resultetype=&quot;com.interview.order&quot;&gt; select order_id id, order_no orderno form order where order_id=#&#123;id&#125;;&lt;/select&gt;复制 ② 通过 &lt;resultMap&gt; 映射对应关系，可参考以下配置： 1234567891011&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.interview.mybatislearning.model.UserEntity&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&gt; &lt;result column=&quot;username&quot; property=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;password&quot; property=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;nick_name&quot; property=&quot;nickName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;&lt;/resultMap&gt; &lt;select id=&quot;getAll&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from t_user&lt;/select&gt;复制 6.在 MyBatis 中如何实现 like 查询？ 答：可以在 Java 代码中添加 SQL 通配符来实现 like 查询，这样也可以有效的防治 SQL 注入，具体实现如下： Java 代码： 1234String name = &quot;%wang%&quot;:List&lt;User&gt; list = mapper.likeName(name);复制 Mapper 配置： 12345&lt;select id=&quot;likeName&quot;&gt; select * form t_user where name like #&#123;name&#125;;&lt;/select&gt;复制 7.MyBatis 有几种分页方式？ 答：MyBatis 的分页方式有以下两种： 逻辑分页，使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索； 物理分页，自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据形式。 8.RowBounds 是一次性查询全部结果吗？为什么？ 答：RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据。因为 MyBatis 是对 JDBC 的封装，在 JDBC 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在执行 next() 的时候，去查询更多的数据。 就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，要取 4 次才能把钱取完。对于 JDBC 来说也是一样，这样做的好处是可以有效的防止内存溢出。 9.为什么阿里巴巴不允许使用 HashMap 或 Hashtable 作为查询结果集直接输出？ 答：因为使用 HashMap 或 Hashtable 作为查询结果集直接输出，会导致值类型不可控，给调用人员造成困扰，给系统带来更多不稳定的因素。 10.什么是动态 SQL？ 答：动态 SQL 是指可以根据不同的参数信息来动态拼接的不确定的 SQL 叫做动态 SQL，MyBatis 动态 SQL 的主要元素有：if、choose/when/otherwise、trim、where、set、foreach 等。 以 if 标签的使用为例： 1234567891011121314&lt;select id=&quot;findUser&quot; parameterType=&quot;com.interview.entity.User&quot; resultType=&quot;com.interview.entity.User&quot;&gt; select * from t_user where &lt;if test=&quot;id!=null&quot;&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password!=null&quot;&gt; and password = #&#123;password&#125; &lt;/if&gt;&lt;/select&gt;复制 11.为什么不建议在程序中滥用事务？ 答：因为事务的滥用会影响数据的 QPS（每秒查询率），另外使用事务的地方还要考虑各方面回滚的方案，如缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 12.如何开启 MyBatis 的延迟加载？ 答：只需要在 mybatis-config.xml 设置 &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; 即可打开延迟缓存功能，完整配置文件如下： 12345678&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt;复制 13.什么是 MyBatis 的一级缓存和二级缓存？ 答：MyBatis 缓存如下： 一级缓存是 SqlSession 级别的，是 MyBatis 自带的缓存功能，并且无法关闭，因此当有两个 SqlSession 访问相同的 SQL 时，一级缓存也不会生效，需要查询两次数据库； 二级缓存是 Mapper 级别的，只要是同一个 Mapper，无论使用多少个 SqlSession 来操作，数据都是共享的，多个不同的 SqlSession 可以共用二级缓存，MyBatis 二级缓存默认是关闭的，需要使用时可手动开启，二级缓存也可以使用第三方的缓存，比如，使用 Ehcache 作为二级缓存。 手动开启二级缓存，配置如下： 12345678&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt;复制 14.如何设置 Ehcache 为 MyBatis 的二级缓存？ 答：可直接在 XML 中配置开启 EhcacheCache，代码如下： 1234567891011121314151617&lt;mapper namespace=&quot;com.interview.repository.ClassesReposirory&quot;&gt; &lt;!-- 开启二级缓存 --&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot; &gt; &lt;!-- 缓存创建以后，最后一次访问缓存的时间至失效的时间间隔 --&gt; &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt; &lt;!-- 缓存自创建时间起至失效的时间间隔--&gt; &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt; &lt;!-- 缓存回收策略，LRU 移除近期最少使用的对象 --&gt; &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt; &lt;/cache&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;java.lang.Long&quot; resultType=&quot;com.interview.entity.Classes&quot;&gt; select * from classes where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;复制 15.MyBatis 有哪些拦截器？如何实现拦截功能？ 答：MyBatis 提供的连接器有以下 4 种。 Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作。 StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存。 ParameterHandler：拦截参数的处理。 ResultSetHandler：拦截结果集的处理。 拦截功能具体实现如下： 123456789101112131415161718@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)public class TestInterceptor implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; Object target = invocation.getTarget(); //被代理对象 Method method = invocation.getMethod(); //代理方法 Object[] args = invocation.getArgs(); //方法参数 // 方法拦截前执行代码块 Object result = invocation.proceed(); // 方法拦截后执行代码块 return result; &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125;&#125;复制 总结 通过本文可以看出 MyBatis 注解版和 XML 版的主要区别是 Mapper 中的代码，注解版把之前在 XML 的 SQL 实现，全部都提到 Mapper 中了，这样就省去了配置 XML 的麻烦。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"28.MyBatis 核心组件 + 面试题","slug":"interview-java-28","date":"2020-10-08T06:09:14.000Z","updated":"2020-10-08T06:24:08.461Z","comments":true,"path":"2020/10/08/interview-java-28/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-28/","excerpt":"","text":"MyBatis 核心组件 + 面试题 MyBatis 介绍 MyBatis 是一款优秀的 ORM（Object Relational Mapping，对象关系映射）框架，它可以通过对象和数据库之间的映射，将程序中的对象自动存储到数据库中。它是 Apache 提供的一个开源项目，之前的名字叫做 iBatis，2010 年迁移到了 Google Code，并且将名字改为我们现在所熟知的 MyBatis，又于 2013 年 11 月迁移到了 Github。 MyBatis 提供了普通 SQL 查询、事务、存储过程等功能，它的优缺点如下。 优点： 相比于 JDBC 需要编写的代码更少 使用灵活，支持动态 SQL 提供映射标签，支持对象与数据库的字段关系映射 缺点： SQL 语句依赖于数据库，数据库移植性差 SQL 语句编写工作量大，尤其在表、字段比较多的情况下 总体来说，MyBatis 是一个非常优秀和灵活的数据持久化框架，适用于需求多变的互联网项目，也是当前主流的 ORM 框架。 MyBatis 重要组件 MyBatis 中的重要组件如下： Mapper 配置：用于组织具体的查询业务和映射数据库的字段关系，可以使用 XML 格式或 Java 注解格式来实现； Mapper 接口：数据操作接口也就是通常说的 DAO 接口，要和 Mapper 配置文件中的方法一一对应； Executor：MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 执行的； SqlSession：类似于 JDBC 中的 Connection，可以用 SqlSession 实例来直接执行被映射的 SQL 语句； SqlSessionFactory：SqlSessionFactory 是创建 SqlSession 的工厂，可以通过 SqlSession openSession() 方法创建 SqlSession 对象。 MyBatis 执行流程 MyBatis 完整执行流程如下图所示： MyBatis 执行流程说明： 首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。 创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。 创建会话，根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含了对数据库操作的增、删、改、查方法。 创建执行器，因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。 封装 SQL 对象，在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。 操作数据库，拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。 MyBatis XML 版 MyBatis 使用分为两个版本：XML 版和 Java 注解版。接下来我们使用 Spring Boot 结合 MyBatis 的 XML 版，来实现对数据库的基本操作，步骤如下。 1）创建数据表 12345678910drop table if exists `t_user`;create table `t_user` ( `id` bigint(20) not null auto_increment comment &#x27;主键id&#x27;, `username` varchar(32) default null comment &#x27;用户名&#x27;, `password` varchar(32) default null comment &#x27;密码&#x27;, `nick_name` varchar(32) default null, primary key (`id`)) engine=innodb auto_increment=1 default charset=utf8;复制 2）添加依赖 在项目添加对 MyBatis 和 MySQL 支持的依赖包，在 pom.xml 文件中添加如下代码： 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt;复制 mybatis-spring-boot-starter 是 MyBatis 官方帮助我们快速集成 Spring Boot 提供的一个组件包，mybatis-spring-boot-starter 2.1.0 对应 MyBatis 的版本是 3.5.2。 3）增加配置文件 在 application.yml 文件中添加以下内容： 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Drivermybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml type-aliases-package: com.interview.mybatislearning.model复制 其中： mybatis.config-location：配置 MyBatis 基础属性； mybatis.mapper-locations：配置 Mapper 对应的 XML 文件路径； mybatis.type-aliases-package：配置项目中实体类包路径。 注：如果配置文件使用的是 application.properties，配置内容是相同的，只是内容格式不同。 4）创建实体类 1234567891011121314151617181920212223242526272829303132333435363738public class UserEntity implements Serializable &#123; private static final long serialVersionUID = -5980266333958177104L; private Integer id; private String userName; private String passWord; private String nickName; public UserEntity(String userName, String passWord, String nickName) &#123; this.userName = userName; this.passWord = passWord; this.nickName = nickName; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125;&#125;复制 5）创建 XML 文件 mybatis-config.xml（基础配置文件）： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias=&quot;Integer&quot; type=&quot;java.lang.Integer&quot;/&gt; &lt;typeAlias alias=&quot;Long&quot; type=&quot;java.lang.Long&quot;/&gt; &lt;typeAlias alias=&quot;HashMap&quot; type=&quot;java.util.HashMap&quot;/&gt; &lt;typeAlias alias=&quot;LinkedHashMap&quot; type=&quot;java.util.LinkedHashMap&quot;/&gt; &lt;typeAlias alias=&quot;ArrayList&quot; type=&quot;java.util.ArrayList&quot;/&gt; &lt;typeAlias alias=&quot;LinkedList&quot; type=&quot;java.util.LinkedList&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt;复制 mybatis-config.xml 主要是为常用的数据类型设置别名，用于减少类完全限定名的长度，比如：resultType=&quot;Integer&quot; 完整示例代码如下： 1234567&lt;select id=&quot;getAllCount&quot; resultType=&quot;Integer&quot;&gt; select count(*) from t_user&lt;/select&gt;复制 UserMapper.xml（业务配置文件）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.interview.mybatislearning.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.interview.mybatislearning.model.UserEntity&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&gt; &lt;result column=&quot;username&quot; property=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;password&quot; property=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;nick_name&quot; property=&quot;nickName&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot; &gt; id, username, password, nick_name &lt;/sql&gt; &lt;sql id=&quot;Base_Where_List&quot;&gt; &lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt; and userName = #&#123;userName&#125; &lt;/if&gt; &lt;/sql&gt; &lt;select id=&quot;getAll&quot; resultMap=&quot;BaseResultMap&quot; &gt; SELECT &lt;include refid=&quot;Base_Column_List&quot; /&gt; FROM t_user &lt;/select&gt; &lt;select id=&quot;getOne&quot; parameterType=&quot;Long&quot; resultMap=&quot;BaseResultMap&quot; &gt; SELECT &lt;include refid=&quot;Base_Column_List&quot; /&gt; FROM t_user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.interview.mybatislearning.model.UserEntity&quot; &gt; INSERT INTO t_user (username,password,nick_name) VALUES (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;nickName&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.interview.mybatislearning.model.UserEntity&quot; &gt; UPDATE t_user SET &lt;if test=&quot;userName != null&quot;&gt;username = #&#123;userName&#125;,&lt;/if&gt; &lt;if test=&quot;passWord != null&quot;&gt;password = #&#123;passWord&#125;,&lt;/if&gt; nick_name = #&#123;nickName&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;Long&quot; &gt; DELETE FROM t_user WHERE id =#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt;复制 以上配置我们增加了增删改查等基础方法。 6）增加 Mapper 文件 此步骤我们需要创建一个与 XML 对应的业务 Mapper 接口，代码如下： 123456789public interface UserMapper &#123; List&lt;UserEntity&gt; getAll(); UserEntity getOne(Long id); void insert(UserEntity user); void update(UserEntity user); void delete(Long id);&#125;复制 7）添加 Mapper 包扫描 在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。 123456789@SpringBootApplication@MapperScan(&quot;com.interview.mybatislearning.mapper&quot;)public class MyBatisLearningApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyBatisLearningApplication.class, args); &#125;&#125;复制 8）编写测试代码 经过以上步骤之后，整个 MyBatis 的集成就算完成了。接下来我们写一个单元测试，验证一下。 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class MybatislearningApplicationTests &#123; @Resource private UserMapper userMapper; @Test public void testInsert() &#123; userMapper.insert(new UserEntity(&quot;laowang&quot;, &quot;123456&quot;, &quot;老王&quot;)); Assert.assertEquals(1, userMapper.getAll().size()); &#125;&#125;复制 总结 通过本文我们知道 MyBatis 是一个优秀和灵活的数据持久化框架，MyBatis 包含 Mapper 配置、Mapper 接口、Executor、SqlSession、SqlSessionFactory 等几个重要的组件，知道了 MyBatis 基本流程：MyBatis 首先加载 Mapper 配置和 SQL 映射文件，通过创建会话工厂得到 SqlSession 对象，再执行 SQL 语句并返回操作信息。我们也使用 XML 的方式，实现了 MyBatis 对数据库的基础操作。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"27.Spring Boot 的创建方式 + 面试题","slug":"interview-java-27","date":"2020-10-08T06:09:11.000Z","updated":"2020-10-08T06:23:59.275Z","comments":true,"path":"2020/10/08/interview-java-27/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-27/","excerpt":"","text":"Spring Boot 的创建方式 + 面试题 为什么要用 Spring Boot？ Spring Boot 来自于 Spring 大家族，是 Spring 官方团队（Pivotal 团队）提供的全新框架，它的诞生解决了 Spring 框架使用较为繁琐的问题。Spring Boot 的核心思想是约定优于配置，让开发人员不需要配置任何 XML 文件，就可以像 Maven 整合 Jar 包一样，整合并使用所有框架。 Spring Boot 特性 秒级构建一个项目； 便捷的对外输出格式，如 REST API、WebSocket、Web 等； 简洁的安全集成策略； 内嵌容器运行，如 Tomcat、Jetty； 强大的开发包，支持热启动； 自动管理依赖； 自带应用监控。 Spring Boot 2 对系统环境的要求 Java 8+ Gradle 4+ or Maven 3.2+ Tomcat 8+ Spring Boot 使用 在开始之前，我们先来创建一个Spring Boot 项目。 Spring Boot 有两种快速创建的方式：Spring 官网在线网站创建和 IntelliJ IDEA 的 Spring Initializr 创建，下面分别来看。 创建 Spring Boot 项目 1）在线网站创建 在浏览器输入 https://start.spring.io，页面打开如下图所示： 填写相应的项目信息，选择对应的 Spring Boot 和 Java 版本点击 “Generate the project”按钮下载项目压缩文件，解压后用 IDEA 打开即可。 其中 Group 和 Artifact 是 Maven 项目用来确认依赖项目的标识，比如： 1234567&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;复制 Group 对应的是配置文件的 groupId，相当于项目的包名；而 Artifact 对应的是配置文件的 artifactId，相当于项目名。 2）使用 IntelliJ IDEA 创建 ① 新建项目 → 选择 Spring Initialzr，如下图所示： ② 点击 Next 按钮，填写对应的项目信息（和在线网站创建的字段基本相同），如下图所示： ③ 点击 Next 按钮，选择相应的依赖信息，如下图所示： ④ 点击 Next 按钮，选择项目保存的路径，点击 Finish 创建项目完成，如下图所示： 创建一个 Web 应用 1）pom.xml 中添加 Web 模块的依赖，如下所示： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;复制 2）创建后台代码 123456789101112import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/index&quot;) public String index(String name) &#123; return &quot;Hello, &quot; + name; &#125;&#125;复制 3）启动并访问项目 项目的启动类是标识了 @Spring BootApplication 的类，代码如下所示： 12345678910import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootlearningApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootlearningApplication.class, args); &#125;&#125;复制 启动并访问 http://localhost:8080/index?name=laowang 效果如下： 到目前为止 Spring Boot 的项目就创建并正常运行了。 设置配置文件 Spring Boot 的配置文件，是 resources 目录下 application.properties 文件，如下图所示： 可以在配置文件中设置很多关于 Spring 框架的配置，格式如下配置所示： 123456# 项目运行端口server.port=8086# 请求编码格式server.tomcat.uri-encoding=UTF-8复制 Spring Boot 的其他功能开发和 Spring 相同（Spring Boot 2 是基于 Spring Framework 5 构建的），本文就不过多的介绍了，感兴趣的朋友可以点击这里查看 Spring Boot 发布 Spring Boot 项目的发布方式有两种： 内置容器运行 外置容器（Tomcat）运行 内置容器运行 1）打包应用 使用窗口命令，在 pom.xml 同级目录下： mvn clean package -Dmaven.test.skip=true Dmaven.test.skip=true 表示不执行测试用例，也不编译测试用例类。 2）启动应用 后台启动 Java 程序， 命令如下： nohup java -jar springbootlearning-0.0.1-SNAPSHOT.jar &amp; 停止程序 首先查询 Java 程序的 pid ps -ef|grep java 再停止程序 kill -9 pid 操作如下图所示： 扩展内容 指定程序运行日志文件 nohup java -jar springbootlearning-0.0.1-SNAPSHOT.jar 1&gt;&gt;logs 2&gt;&gt;errlog &amp; 其中： 1：表示普通日志 2：表示错误日志 外置容器（Tomcat）运行 1）排除内置 Tomcat 1234567&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;复制 将 scope 属性设置为 provided，表示打包不会包含此依赖。 2）配置启动类 在项目的启动类中继承 Spring BootServletInitializer 并重写 configure() 方法： 123456789101112@SpringBootApplicationpublic class PackageApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(PackageApplication.class); &#125; public static void main(String[] args) &#123; SpringApplication.run(PackageApplication.class, args); &#125;&#125;复制 3）打包应用 使用窗口命令，在 pom.xml 同级目录下： mvn clean package -Dmaven.test.skip=true 4）部署应用 打包完成会在 target 目录下生成：项目名 + 版本号.war 文件，复制到 Tomcat 的 webapps 目录下，运行 Tomcat 即可。 相关面试题 1.Spring Boot 2.0 支持最低的 JDK 版本是？ A：JDK 6 B：JDK 7 C：JDK 8 D：JDK 9 答：C 2.Spring、Spring Boot、Spring Cloud 是什么关系？ 答：它们都是来自于 Spring 大家庭，Spring Boot 是在 Spring 框架的基础上开发而来，让更加方便使用 Spring；Spring Cloud 是依赖于 Spring Boot 而构建的一套微服务治理框架。 3.Spring Boot 项目有哪些优势？ 答：Spring Boot 项目优势如下： 开发变得简单，提供了丰富的解决方案，快速集成各种解决方案提升开发效率； 配置变得简单，提供了丰富的 Starters，集成主流开源产品往往只需要简单的配置即可； 部署变得简单，其本身内嵌启动容器，仅仅需要一个命令即可启动项目，结合 Jenkins、Docker 自动化运维非常容易实现； 监控变得简单，自带监控组件，使用 Actuator 轻松监控服务各项状态。 4.如何将 Spring Boot 项目打包成 war 包？ 答：在 pom.xml 里设置 &lt;packaging&gt;war&lt;/packaging&gt; 。 5.在 Maven 项目中如何修改打包名称？ 答：在 pom.xml 文件的 build 节点中，添加 finalName 节点并设置为要的名称即可，配置如下： 12345&lt;build&gt; &lt;finalName&gt;warName&lt;/finalName&gt;&lt;/build&gt;复制 6.Ant、Maven、Gradle 有什么区别？ 答：Ant、Maven、Gradle 是 Java 领域中主要有三大构建工具，它们的区别如下： Ant（AnotherNeatTool）诞生于 2000 年，是由 Java 编写，采用 XML 作为构建脚本，这样就允许你在任何环境下运行构建。Ant 是 Java 领域最早的构建工具，不过因为操作复杂，慢慢的已经被淘汰了； Maven 诞生于 2004 年，目的是解决程序员使用 Ant 所带来的一些问题，它的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性； Gradle 诞生于 2009 年，是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化建构工具。它使用一种基于 Groovy 的特定领域语言来声明项目设置，而不是传统的 XML。结合了前两者的优点，在此基础之上做了很多改进，它具有 Ant 的强大和灵活，又有 Maven 的生命周期管理且易于使用。 Spring Boot 官方支持 Maven 和 Gradle 作为项目构建工具。Gradle 虽然有更好的理念，但是相比 Maven 来讲其行业使用率偏低，并且 Spring Boot 官方默认使用 Maven。 9.Spring Boot 热部署有几种方式？ 答：Spring Boot 热部署主要有两种方式：Spring Loaded、Spring-boot-devtools。 方式 1：Spring Loaded 在 pom.xml 文件中添加如下依赖： 12345678910111213141516&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;mainClass&gt;此处为入口类&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt;复制 方式 2：Spring-boot-devtools 在 pom.xml 文件中添加如下依赖： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;复制 10.Spring Boot 2.0 可以在 Tomcat 7 运行吗？为什么？ 答：Spring Boot 2.0 无法在 Tomcat 7 上运行。因为 Spring Boot 2.0 使用的是 Spring Framework 5，Spring Framework 5 使用的是 Servlet 3.1，而 Tomcat 7 最高支持到 Servlet 3.0，所以 Spring Boot 2.0 无法在 Tomcat 7 上运行。 11.如何使用 Jetty 代替 Tomcat？ 答：在 spring-boot-starter-web 移除现有的依赖项，添加 Jetty 依赖，配置如下： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;复制 12.Spring Boot 不支持以下哪个内嵌容器？ A：Tomcat B：Jetty C：Undertow D：Nginx 答：D 题目解析：Jetty 容器支持如下： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;复制 Undertow 容器支持如下： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt;复制 13.Spring Boot 中配置文件有几种格式？ 答：Spring Boot 中有 .properties 和 .yml 两种配置文件格式，它们主要的区别是书写格式不同。 .properties 配置文件格式如下： 123app.user.name = hellojava复制 .yml 配置文件格式如下： 12345app: user: name: hellojava 复制 14.项目中有两个配置 application.properties 和 application.yml，以下说法正确的是？ A：application.properties 的内容会被忽略，只会识别 application.yml 的内容。 B：两个配置文件同时有效，有相同配置时，以 application.properties 文件为主。 C：application.yml 的内容会被忽略，只会识别 application.properties 的内容。 D：两个配置文件同时有效，有相同配置时，以 application.yml 文件为主。 答：B 15.RequestMapping 和 GetMapping 有什么不同？ 答：RequestMapping 和 GetMapping 区别如下： RequestMapping 可以支持 GET、POST、PUT 请求； GetMapping 是一个组合注解，相当于 @RequestMapping(method = RequestMethod.GET)。 16.以下关于 @RestController 和 @Controller 说法正确的？ A：@Controller 返回 JSON 数据 B：@RestController 返回 JSON 数据 C：@APIController 返回 JSON 数据 D：以上都对 答：B 17.Spring Cache 常用的缓存注解有哪些？ 答：Spring Cache 常用注解如下： @Cacheable：用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值； @CachePut：使用它标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中； CacheEvict：是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有方法的执行都会触发缓存的清除操作。 18.Spring Boot Admin 和 Spring Boot Actuator 的关系是什么？ 答：Spring Boot Admin 使用了 Spring Boot Actuator 接口进行 UI 美化封装的监控工具，它以图形化的方式查询单个应用的详细状态，也可以使用 Spring Boot Admin 来监控整个集群的状态。 19.如何理解 Spring Boot 中的 Stater？ 答：Stater 可以理解为启动器，它是方便开发者快速集成其他框架到 Spring 中的一种技术。比如，spring-boot-starter-data-jpa 就是把 JPA 快速集成到 Spring 中。 20.常见的 starter 有哪些? 答：常见的 starter 如下： spring-boot-starter-web：Web 开发支持 spring-boot-starter-data-jpa：JPA 操作数据库支持 spring-boot-starter-data-redis：Redis 操作支持 spring-boot-starter-data-solr：Solr 权限支持 mybatis-spring-boot-starter：MyBatis 框架支持 21.Spring Boot Starter JDBC 和 Spring JDBC 有什么关系？ 答：spring-boot-starter-jdbc 是 Spring Boot 针对 JDBC 的使用提供了对应的 Starter 包，在 Spring JDBC 上做了进一步的封装，方便在 Spring Boot 生态中更好的使用 JDBC。 22.Spring Boot 有哪几种读取配置的方式？ 答：Spring Boot 可以通过 @Value、@Environment、@ConfigurationProperties 这三种方式来读取。 例如，配置文件内容如下： 123app.name=中文复制 ① Value 方式 1234@Value(&quot;$&#123;app.name&#125;&quot;)private String appName;复制 ② Environment 方式 123456789101112public class HelloController &#123; @Autowired private Environment environment; @RequestMapping(&quot;/index&quot;) public String index(String hiName) &#123; // 读取配置文件 String appName = environment.getProperty(&quot;app.name&quot;); return &quot;Hello, &quot; + hiName + &quot; |@&quot; + appName; &#125;&#125;复制 ③ ConfigurationProperties 方式 123456789101112131415@ConfigurationProperties(prefix = &quot;app&quot;)public class HelloController &#123; // 读取配置文件，必须有 setter 方法 private String name; public void setName(String name) &#123; this.name = name; &#125; @RequestMapping(&quot;/index&quot;) public String index(String hiName) &#123; System.out.println(&quot;appname:&quot; + name); return &quot;Hello, &quot; + hiName + &quot; |@&quot; + appName; &#125;&#125;复制 23.使用 @Value 读取中文乱码是什么原因？如何处理？ 答：这是因为配置文件的编码格式导致的，需要把编码格式设置为 UTF-8，如下图所示： 设置完成之后，重新启动 IDEA 就可以正常显示中文了。 总结 通过本文我们学习了 Spring Boot 的两种创建方式：在线网站创建和 IntelliJ IDEA 方式创建。知道了 Spring Boot 发布的两种方式：内置容器和外置 Tomcat，知道了 Spring Boot 项目特性，以及配置文件 .properties 和 .yml 的差异，掌握了读取配置文件的三种方式：@Value、@Environment、@ConfigurationProperties。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"26.Spring MVC 核心组件 + 面试题","slug":"interview-java-26","date":"2020-10-08T06:09:07.000Z","updated":"2020-10-08T06:23:48.955Z","comments":true,"path":"2020/10/08/interview-java-26/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-26/","excerpt":"","text":"Spring MVC 核心组件 + 面试题 Spring MVC 介绍 Spring MVC（Spring Web MVC）是 Spring Framework 提供的 Web 组件，它的实现基于 MVC 的设计模式：Controller（控制层）、Model（模型层）、View（视图层），提供了前端路由映射、视图解析等功能，让 Java Web 开发变得更加简单，也属于 Java 开发中必须要掌握的热门框架。 执行流程 Spring MVC 的执行流程如下： 客户端发送请求至前端控制器（DispatcherServlet） 前端控制器根据请求路径，进入对应的处理器 处理器调用相应的业务方法 处理器获取到相应的业务数据 处理器把组装好的数据交还给前端控制器 前端控制器将获取的 ModelAndView 对象传给视图解析器（ViewResolver） 前端控制器获取到解析好的页面数据 前端控制器将解析好的页面返回给客户端 流程如下图所示： 核心组件 Spring MVC 的核心组件如下列表所示： DispatcherServlet：核心处理器（也叫前端控制器），负责调度其他组件的执行，可降低不同组件之间的耦合性，是整个 Spring MVC 的核心模块。 Handler：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。 HandlerMapping：DispatcherServlet 是通过 HandlerMapping 将请求映射到不同的 Handler。 HandlerInterceptor：处理器拦截器，是一个接口，如果我们需要做一些拦截处理，可以来实现这个接口。 HandlerExecutionChain：处理器执行链，包括两部分内容，即 Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外拦截处理，可以添加拦截器设置）。 HandlerAdapter：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作包括表单数据的验证、数据类型的转换、将表单数据封装到 POJO 等，这一系列的操作，都是由 HandlerAdapter 来完成，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。 ModelAndView：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。 ViewResolver：视图解析器，DispatcherServlet 通过它将逻辑视图解析成物理视图，最终将渲染结果响应给客户端。 自动类型转换 自动类型转换指的是，Spring MVC 可以将表单中的字段，自动映射到实体类的对应属性上，请参考以下示例。 1. JSP 页面代码 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;add&quot;&gt; 名称：&lt;input type=&quot;input&quot; name=&quot;name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;input&quot; name=&quot;age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot; 提交 &quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;复制 2. 编写实体类 12345678910111213141516171819public class PersonDTO &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;复制 3. 编写控制器 1234567891011import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class PersonController &#123; @RequestMapping(value = &quot;/add&quot;, produces = &quot;text/plain;charset=utf-8&quot;) public String add(PersonVO person) &#123; return person.getName() + &quot;:&quot; + person.getAge(); &#125;&#125;复制 4. 执行结果 执行结果如下图所示： 中文乱码处理 业务的操作过程中可能会出现中文乱码的情况，以下是处理中文乱码的解决方案。 第一步，在 web.xml 添加编码过滤器，配置如下： 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;复制 第二步，设置 RequestMapping 的 produces 属性，指定返回值类型和编码，如下所示： 123@RequestMapping(value = &quot;/add&quot;, produces = &quot;text/plain;charset=utf-8&quot;)复制 拦截器 在 Spring MVC 中可以通过配置和实现 HandlerInterceptor 接口，来实现自己的拦截器。 1. 配置全局拦截器 在 Spring MVC 的配置文件中，添加如下配置： 12345&lt;mvc:interceptors&gt; &lt;bean class=&quot;com.learning.core.MyInteceptor&quot;&gt;&lt;/bean&gt;&lt;/mvc:interceptors&gt;复制 2. 添加拦截器实现代码 拦截器的实现代码如下： 123456789101112131415161718192021222324252627import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 拦截器 **/public class MyInteceptor implements HandlerInterceptor &#123; // 在业务处理器处理请求之前被调用 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); return true; &#125; // 在业务处理器处理请求完成之后，生成视图之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); &#125; // 在 DispatcherServlet 完全处理完请求之后被调用 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion&quot;); &#125;&#125;复制 参数验证 1. pom.xml 添加验证依赖包 配置如下： 12345678&lt;!-- Hibernate 参数验证包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.17.Final&lt;/version&gt;&lt;/dependency&gt;复制 2. 开启注解验证 在 Spring MVC 的配置文件中，添加如下配置信息： 123&lt;mvc:annotation-driven /&gt;复制 3. 编写控制器 代码如下： 1234567891011121314151617181920212223242526272829303132import com.google.gson.JsonObject;import com.learning.pojo.PersonDTO;import org.springframework.validation.BindingResult;import org.springframework.validation.ObjectError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class PersonController &#123; @RequestMapping(value = &quot;/check&quot;, produces = &quot;text/plain;charset=utf-8&quot;) public String check(@Validated PersonDTO person, BindingResult bindResult) &#123; // 需要 import com.google.gson.Gson JsonObject result = new JsonObject(); StringBuilder errmsg = new StringBuilder(); if (bindResult.hasErrors()) &#123; List&lt;ObjectError&gt; errors = bindResult.getAllErrors(); for (ObjectError error : errors) &#123; errmsg.append(error.getDefaultMessage()); &#125; result.addProperty(&quot;status&quot;, -1); &#125; else &#123; result.addProperty(&quot;status&quot;, 1); &#125; result.addProperty(&quot;errmsg&quot;, errmsg.toString()); return result.toString(); &#125;&#125;复制 4. 编写实体类 代码如下： 12345678910111213141516171819202122import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;public class PersonDTO &#123; @NotNull(message = &quot;姓名不能为空&quot;) private String name; @Min(value = 18,message = &quot;年龄不能低于18岁&quot;) private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;复制 更多验证注解，如下所示： 注解 运行时检查 @AssertFalse 被注解的元素必须为 false @AssertTrue 被注解的元素必须为 true @DecimalMax(value) 被注解的元素必须为一个数字，其值必须小于等于指定的最大值 @DecimalMin(Value) 被注解的元素必须为一个数字，其值必须大于等于指定的最小值 @Digits(integer=, fraction=) 被注解的元素必须为一个数字，其值必须在可接受的范围内 @Future 被注解的元素必须是日期，检查给定的日期是否比现在晚 @Max(value) 被注解的元素必须为一个数字，其值必须小于等于指定的最大值 @Min(value) 被注解的元素必须为一个数字，其值必须大于等于指定的最小值 @NotNull 被注解的元素必须不为 null @Null 被注解的元素必须为 null @Past(java.util.Date/Calendar) 被注解的元素必须过去的日期，检查标注对象中的值表示的日期比当前早 @Pattern(regex=, flag=) 被注解的元素必须符合正则表达式，检查该字符串是否能够在 match 指定的情况下被 regex 定义的正则表达式匹配 @Size(min=, max=) 被注解的元素必须在制定的范围（数据类型：String、Collection、Map、Array） @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个 map，则对其中的值部分进行校验 @CreditCardNumber 对信用卡号进行一个大致的验证 @Email 被注释的元素必须是电子邮箱地址 @Length(min=, max=) 被注解的对象必须是字符串的大小必须在制定的范围内 @NotBlank 被注解的对象必须为字符串，不能为空，检查时会将空格忽略 @NotEmpty 被注释的对象必须不为空（数据：String、Collection、Map、Array） @Range(min=, max=) 被注释的元素必须在合适的范围内（数据：BigDecimal、BigInteger、String、byte、short、int、long 和原始类型的包装类） @URL(protocol=, host=, port=, regexp=, flags=) 被注解的对象必须是字符串，检查是否是一个有效的 URL，如果提供了 protocol、host 等，则该 URL 还需满足提供的条件 5. 执行结果 执行结果，如下图所示： 访问 Spring MVC 官方说明文档：http://1t.click/H7a 相关面试题 1. 简述一下 Spring MVC 的执行流程？ 答：前端控制器（DispatcherServlet） 接收请求，通过映射从 IoC 容器中获取对应的 Controller 对象和 Method 方法，在方法中进行业务逻辑处理组装数据，组装完数据把数据发给视图解析器，视图解析器根据数据和页面信息生成最终的页面，然后再返回给客户端。 2. POJO 和 JavaBean 有什么区别？ 答：POJO 和 JavaBean 的区别如下： POJO（Plain Ordinary Java Object）普通 Java 类，具有 getter/setter 方法的普通类都就可以称作 POJO，它是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 JavaBean 是 Java 语言中的一种可重用组件，JavaBean 的构造函数和行为必须符合特定的约定：这个类必须有一个公共的缺省构造函数；这个类的属性使用 getter/setter 来访问，其他方法遵从标准命名规范；这个类应是可序列化的。 简而言之，当一个 POJO 可序列化，有一个无参的构造函数，它就是一个 JavaBean。 3. 如何实现跨域访问？ 答：常见的跨域的实现方式有两种：使用 JSONP 或者在服务器端设置运行跨域。服务器运行跨域的代码如下： 12345678910111213141516171819import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MyConfiguration &#123; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的请求规则 registry.addMapping(&quot;/api/**&quot;); &#125; &#125;; &#125;&#125;复制 4. 以下代码描述正确的是？ 123456@RequestMapping(value=&quot;/list&quot;,params=&#123;&quot;age=10&quot;&#125;public String list()&#123; // do something&#125;复制 A：age 参数不传递的时候，默认值是 10 B：age 参数可以为空 C：age 参数不能为空 D：以上都不对 答：C 题目解析：params={“age=10”} 表示必须包含 age 参数，且值必须等于 10。 5. @RequestMapping 注解的常用属性有哪些？ 答：@RequestMapping 常用属性如下： value：指定 URL 请求的实际地址，用法：@RequestMapping(value=&quot;/index&quot;)； method：指定请求的 method 类型，如 GET/POST/PUT/DELETE 等，用法：@RequestMapping(value=&quot;/list&quot;,method=RequestMethod.POST)； params：指定请求参数中必须包含的参数名称，如果不存在该名称，则无法调用此方法，用法：@RequestMapping(value=&quot;/list&quot;,params={“name”,“age”})。 6. 访问以下接口不传递任何参数的情况下，执行的结果是？ 1234567@RequestMapping(value=&quot;/list&quot;)@ResponseBodypublic String list(int id)&#123; return &quot;id=&quot;+id;&#125;复制 A：id=0 B：id= C：页面报错 500 D：id=null 答：C 题目解析：页面报错会提示：可选的参数“id”不能转为 null，因为基本类型不能赋值 null，所以会报错。 7.访问页面时显示 403 代表的含义是？ A：服务器繁忙 B：找不到该页面 C：禁止访问 D：服务器跳转中 答：C 题目解析：常用 HTTP 状态码及对应的含义： 400：错误请求，服务器不理解请求的语法 401：未授权，请求要求身份验证 403：禁止访问，服务器拒绝请求 500：服务器内部错误，服务器遇到错误，无法完成请求 502：错误网关，服务器作为网关或代理，从上游服务器收到无效响应 504：网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求 8.forward 和 redirect 有什么区别？ 答：forward 和 redirect 区别如下： forward 表示请求转发，请求转发是服务器的行为；redirect 表示重定向，重定向是客户端行为； forward 是服务器请求资源，服务器直接访问把请求的资源转发给浏览器，浏览器根本不知道服务器的内容是从哪来的，因此它的地址栏还是原来的地址；redirect 是服务端发送一个状态码告诉浏览器重新请求新的地址，因此地址栏显示的是新的 URL； forward 转发页面和转发到的页面可以共享 request 里面的数据；redirect 不能共享数据； 从效率来说，forward 比 redirect 效率更高。 9. 访问以下接口不传递任何参数的情况下，执行的结果是？ 1234567@RequestMapping(value=&quot;/list&quot;)@ResponseBodypublic String list(Integer id)&#123; return &quot;id=&quot;+id;&#125;复制 A：id=0 B：id= C：页面报错 500 D：id=null 答：D 题目解析：包装类可以赋值 null，不会报错。 10. Spring MVC 中如何在后端代码中实现页面跳转？ 答：在后端代码中可以使用 forward:/index.jsp 或 redirect:/index.jsp 完成页面跳转，前者 URL 地址不会发生改变，或者 URL 地址会发生改变，完整跳转代码如下： 123456@RequestMapping(&quot;/redirect&quot;)public String redirectTest()&#123; return &quot;redirect:/index.jsp&quot;;&#125;复制 11. Spring MVC 的常用注解有哪些？ 答：Spring MVC 的常用注解如下： @Controller：用于标记某个类为控制器； @ResponseBody ：标识返回的数据不是 html 标签的页面，而是某种格式的数据，如 JSON、XML 等； @RestController：相当于 @Controller 加 @ResponseBody 的组合效果； @Component：标识为 Spring 的组件； @Configuration：用于定义配置类； @RequestMapping：用于映射请求地址的注解； @Autowired：自动装配对象； @RequestHeader：可以把 Request 请求的 header 值绑定到方法的参数上。 12. 拦截器的使用场景有哪些？ 答：拦截器的典型使用场景如下： 日志记录：可用于记录请求日志，便于信息监控和信息统计； 权限检查：可用于用户登录状态的检查； 统一安全处理：可用于统一的安全效验或参数的加密 / 解密等。 13. Spring MVC 如何排除拦截目录？ 答：在 Spring MVC 的配置文件中，添加 ，用于排除拦截目录，完整配置的示例代码如下： 12345678910&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;!-- 排除拦截地址 --&gt; &lt;mvc:exclude-mapping path=&quot;/api/**&quot; /&gt; &lt;bean class=&quot;com.learning.core.MyInteceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;复制 14.@Validated 和 @Valid 有什么区别 ？ 答：@Validated 和 @Valid 都用于参数的效验，不同的是： @Valid 是 Hibernate 提供的效验机制，Java 的 JSR 303 声明了 @Valid 这个类接口，而 Hibernate-validator 对其进行了实现；@Validated 是 Spring 提供的效验机制，@Validation 是对 @Valid 进行了二次封装，提供了分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制； @Valid 可用在成员对象的属性字段验证上，而 @Validated 不能用在成员对象的属性字段验证上，也就是说 @Validated 无法提供嵌套验证。 15.Spring MVC 有几种获取 request 的方式？ 答：Spring MVC 获取 request 有以下三种方式： ① 从请求参数中获取 示例代码： 1234567@RequestMapping(&quot;/index&quot;)@ResponseBodypublic void index(HttpServletRequest request)&#123; // do something&#125;复制 该方法实现的原理是 Controller 开始处理请求时，Spring 会将 request 对象赋值到方法参数中。 ② 通过 RequestContextHolder上下文获取 request 对象 示例代码： 123456789@RequestMapping(&quot;/index&quot;)@ResponseBodypublic void index()&#123; ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes(); HttpServletRequest request = servletRequestAttributes.getRequest(); // do something&#125;复制 ③ 通过自动注入的方式 12345678@Controllerpublic class HomeController&#123; @Autowired private HttpServletRequest request; // 自动注入 request 对象 // do something&#125;复制 总结 本文我们了解了 Spring MVC 运行的 8 个步骤和它的 8 大核心组件，也尝试了 Spring MVC 方面的类型转换，可将表单自动转换为实体对象，也使用 Hibernate 的验证功能优雅地实现了参数的验证，还可以通过配置和实现 HandlerInterceptor 接口来自定义拦截器，相信有了这些知识，可以帮助我们更高效地开发 Web 和接口项目。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"25.Spring 核心功能演示 + 面试题","slug":"interview-java-25","date":"2020-10-08T06:09:04.000Z","updated":"2020-10-08T06:23:39.086Z","comments":true,"path":"2020/10/08/interview-java-25/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-25/","excerpt":"","text":"Spring 核心功能演示 + 面试题 Spring Framework 简称 Spring，是 Java 开发中最常用的框架，地位仅次于 Java API，就连近几年比较流行的微服务框架 SpringBoot，也是基于 Spring 实现的，SpringBoot 的诞生是为了让开发者更方便地使用 Spring，因此 Spring 在 Java 体系中的地位可谓首屈一指。 当然，如果想要把 Spring 所有功能都讲的一清二楚，远远不是一两篇文章能够做到的，但幸运的是，Spring 的基础资料可以很轻易的搜索到，那么我们本讲主要的目的就是把 Spring 中的核心知识点和常见面试题分享给大家，希望对大家能有所帮助。 Spring 介绍 Spring 是一个开源框架，为了解决企业应用程序开发复杂性而创建的，Spring 的概念诞生于 2002 年，于 2003 年正式发布第一个版本 Spring Framework 0.9。下面一起来看 Spring 各个版本的更新特性和它的发展变化吧。 Spring 1.x 此版本主要是为了解决企业应用程序开发复杂性而创建的，当时 J2EE 应用的经典架构是分层架构：表现层、业务层、持久层，最流行的组合就是 SSH（Struts、Spring、Hibernate）。 Spring 1.x 仅支持基于 XML 的配置，确保用户代码不依赖 Spring，它主要包含了以下功能模块：aop、beans、ejb、jdbc、jndi、orm、transation、validation、web 等。 Spring 2.x Spring 2.x 的改动并不是很大，主要是在 Spring 1.x 的基础上增加了几个新模块，如 ehcache、jms、jmx、scripting、stereotype 等。 Spring 3.x Spring 3.x 开始不止支持 XML 的配置，还扩展了基于 Java 类的配置，还增加了 Expression、Instructment、Tomcat、oxm 等组件，同时将原来的 Web 细分为：Portlet、Servlet。 Spring 4.x Spring 4.x 扩充了 Groovy、Messaging、WebMvc、Tiles2、WebSocket 等功能组件，同时 Spring 还适配了 Java 版本，全面支持 Java 8.0、Lambda 表达式等。随着 RESTful 架构风格被越来越多的用户所采用，Spring 4.x 也提供了 RestController 等注解新特性。 Spring 5.x Spring 5.x 紧跟 Java 相关技术的更新迭代，不断适配 Java 的新版本，同时不断重构优化自身核心框架代码，支持函数式、响应式编程模型等。 Spring 核心 Spring 核心包括以下三个方面： 控制反转（Ioc） 依赖注入（DI） 面向切面编程（AOP） 下面分别来看它的这些特性。 控制反转（IoC） 控制反转（Inversion of Control，IoC），顾名思义所谓的控制反转就是把创建对象的权利交给框架去控制，而不需要人为地去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。 比如，你去某地旅游不再用自己亲自为订购 A 酒店还是 B 酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。 依赖注入（DI） 依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 IoC 和 DI 的关系 IoC 是 Spring 中一个极为重要的概念，而 DI 则是实现 IoC 的方法和手段。 接下来，我们来看依赖注入的常见实现方式有哪些？ 依赖注入的常见实现方式如下： setter 注入 构造方法注入 注解注入 1）setter 注入 Java 代码： 123456789public class UserController &#123; // 注入 UserService 对象 private UserService userService; public void setUserService(UserService userService)&#123; this.userService = userService; &#125;&#125;复制 XML 配置： 1234567&lt;bean name=&quot;userController&quot; class=&quot;com.learning.controller.UserController&quot;&gt; &lt;!-- 依赖注入 --&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name=&quot;userService&quot; class=&quot;com.learning.dao.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;复制 Bean 标签的常用属性说明： id：为实例化对象起名称，根据 id 值可以得到我们配置的实例化对象，id 属性的名称原则上可以任意命名，但是能包含任何特殊符号； class：创建对象所在类的全路径； name：功能和 id 属性一样，但是现在一般不用；与 id 的区别在于：name 属性值里可以包含特殊符号，但是 id 不可以； scope：一般最常用的有两个值： Singleton：单例模式，整个应用程序，只创建 bean 的一个实例；Prototype：原型模式，每次注入都会创建一个新的 bean 实例，Spring 默认的是单例模式。 2）构造方法注入 Java 代码： 12345678public class UserController &#123; private UserService userService; public UserController(UserService userService)&#123; this.userService = userService; &#125;&#125;复制 XML 配置： 1234567&lt;bean name=&quot;userController&quot; class=&quot;com.learning.controller.UserController&quot;&gt; &lt;!-- 依赖注入 --&gt; &lt;constructor-arg ref=&quot;userService&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name=&quot;userService&quot; class=&quot;com.learning.dao.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt; 复制 3）注解注入 1234567891011121314@Controllerpublic class UserController &#123; // 使用注解自动注入 @Autowired() private UserService userService; // do something&#125;// 创建依赖对象@Servicepublic class UserService &#123; // do something &#125;复制 创建依赖对象的常见注解：@Component、@Controller、@Service、@Repository。 总结：可以看出注解的方式要比传统的 XML（setter 和构造器注入）实现注入更为方便，同时注解方式也是官方力推的依赖注入最佳使用方式。 面向切面编程（AOP） 面向切面编程（Aspect Oriented Programming，AOP），它就好比将系统按照功能分类，每一个类别就是一个“切面”，我们再针对不同的切面制定相应的规则，类似开发模式被称为面向切面编程。 AOP 使用场景 日志系统 安全统一效验 AOP 优点 集中处理某一类问题，方便维护 逻辑更加清晰 降低模块间的耦合度 AOP 相关概念 Join point：连接点，程序执行期间的某一个点，例如执行方法或处理异常时候的点，在 Spring AOP 中，连接点总是表示方法的执行。 Advice：通知，通知分为方法执行前通知，方法执行后通知、环绕通知等。许多 AOP 框架（包括 Spring）都将通知建模为拦截器，在连接点周围维护一系列拦截器（形成拦截器链），对连接点的方法进行增强。 Pointcut：切点，匹配连接点（Join point）的表达式，是 AOP 的核心，并且 Spring 默认使用 AspectJ 作为切入点表达式语言。 Aspect：切面，是一个跨越多个类的模块化的关注点，它是通知（Advice）和切点（Pointcut）合起来的抽象，它定义了一个切点（Pointcut）用来匹配连接点（Join point），也就是需要对需要拦截的那些方法进行定义。 Target object：目标对象，被一个或者多个切面（Aspect）通知的对象，也就是需要被 AOP 进行拦截对方法进行增强（使用通知）的对象，也称为被通知的对象。由于在 AOP 里面使用运行时代理，因而目标对象一直是被代理的对象。 AOP proxy：AOP 代理，为了实现切面（Aspect）功能使用 AOP 框架创建一个对象，在 Spring 框架里面一个 AOP 代理指的是 JDK 自身的动态代理或 CGLIB 实现的动态代理。 Weaving：把切面加入到对象，并创建出代理对象的过程。 Advisor：一个 Advisor 相当于一个小型的切面，不同的是它只有一个通知（Advice），Advisor 在事务管理里面会经常遇到。 AOP 代码实现 AOP 的示例我们就以开车为例，开车的完成流程是这样的：巡视车体及周围情况 → 发动 → 开车 → 熄火 → 锁车。 当然我们的主要目的是“开车”，但在开车之前和开完车之后，我们要做一些其他的工作，这些“其他”的工作，可以理解为 AOP 编程。 1）创建类和方法 1234567891011package com.learning.aop;import org.springframework.stereotype.Component;@Component(&quot;person&quot;)public class Person &#123; public void drive() &#123; System.out.println(&quot;开车&quot;); &#125;&#125;复制 2）创建 AOP 拦截 1234567891011121314151617181920212223package com.learning.aop;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Component@Aspectpublic class CarAop &#123; @Before(&quot;execution(* com.learning.aop.Person.drive())&quot;) public void before() &#123; System.out.println(&quot;巡视车体及周围情况&quot;); System.out.println(&quot;发动&quot;); &#125; @After(&quot;execution(* com.learning.aop.Person.drive())&quot;) public void after() &#123; System.out.println(&quot;熄火&quot;); System.out.println(&quot;锁车&quot;); &#125;&#125;复制 3）XML 配置注入扫描包路径 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.learning&quot;/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;复制 4）创建测试类 123456789101112131415package com.learning.aop;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class PersonTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person landlord = context.getBean(&quot;person&quot;, Person.class); landlord.drive(); &#125;&#125;复制 运行测试代码，执行结果如下： 巡视车体及周围情况 发动 开车 熄火 锁车 AspectJ 注解说明： @Before — 前置通知，在连接点方法前调用； @Around — 环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法； @After — 后置通知，在连接点方法后调用； @AfterReturning — 返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常； @AfterThrowing — 异常通知，当连接点方法异常时调用。 相关面试题 1.@Value 注解的作用是什么？ 答：基于 @Value 的注解可以读取 properties 配置文件，使用如下: @Value(&quot;#{configProperties[‘jdbc.username’]}&quot;) private String userName; 以上为读取 configProperties 下的 jdbc.username 配置。 2.Spring 通知类型有哪些？ 答：Spring 通知类型总共有 5 种：前置通知、环绕通知、后置通知、异常通知、最终通知。 前置通知（Before advice）：在目标方法执行之前执行的通知。在某连接点（ join point ）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。 环绕通知（Around Advice）：在目标方法执行之前和之后都可以执行额外代码的通知，也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 后置通知（After (finally) advice）：目标方法执行之后（某连接点退出的时候）执行的通知（不论是正常返回还是异常退出）。 异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。 最终通知（After returning advice）：在某连接点（join point）正常完成后执行的通知，例如，一个方法没有抛出任何异常，正常返回。 3.怎么理解 Spring 中的 IOC 容器？ 答：Spring IOC 就是把创建对象的权利交给框架去控制，而不需要人为的去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。 比如，去某地旅游不再用自己亲自为订购 A 酒店还是 B 酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。 4.怎么理解 Spring 中的依赖注入？ 答：依赖注入是指组件之间的依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 5.IoC 和 DI 有什么关系？ 答：IoC 是 Spring 中一个极为重要的概念，提供了对象管理的功能，从而省去了人为创建麻烦，而 DI 正是实现 IoC 的方法和手段。 6.@Component 和 @Bean 有什么区别？ 答：它们的作用对象不同：@Component 作用于类，而 @Bean 注解作用于方法。 @Component 通常是通过类路径扫描来自动侦测和装配对象到 Spring 容器中，比如 @ComponentScan 注解就是定义扫描路径中的类装配到 Spring 的 Bean 容器中；@Bean 注解是告诉 Spring 这是某个类的实例，当我需要用它的时把它给我，@Bean 注解比 @Component 注解自定义性更强，很多地方我们只能通过 @Bean 注解来注册 Bean，比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean 来实现，比如以下示例，只能通过 @Bean 注解来实现： 12345678public class WireThirdLibClass &#123; @Bean public ThirdLibClass getThirdLibClass() &#123; return new ThirdLibClass(); &#125;&#125;复制 7.Spring 中 bean 的作用域有几种类型？ 答：Spring 中 bean 的作用域有四种类型，如下列表： 单例（Singleton）：整个应用程序，只创建 bean 的一个实例； 原型（Prototype）：每次注入都会创建一个新的 bean 实例； 会话（Session）：每个会话创建一个 bean 实例，只在 Web 系统中有效； 请求（Request）：每个请求创建一个 bean 实例，只在 Web 系统中有效。 Spring 默认的是单例模式。 8.什么是 Spring 的内部 bean？ 答：当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了定义 inner Bean，在 Spring 的基于 XML 的配置元数据中，可以在 &lt;property/&gt; 或 &lt;constructor-arg/&gt; 元素内使用 &lt;bean/&gt; 元素，内部 bean 通常是匿名的，它们的 Scope 一般是 prototype。 9.Spring 注入方式有哪些？ 答：Spring 的注入方式包含以下五种： setter 注入 构造方法注入 注解注入 静态工厂注入 实例工厂注入 其中最常用的是前三种，官方推荐使用的是注解注入，相对使用更简单，维护成本更低，更直观。 10.在 Spring 中如何操作数据库？ 答：在 Spring 中操作数据库，可以使用 Spring 提供的 JdbcTemplate 对象，JdbcTemplate 类提供了很多便利的方法，比如把数据库数据转变成基本数据类型或对象，执行自定义的 SQL 语句，提供了自定义的数据错误处理等，JdbcTemplate 使用示例如下： 123456789101112131415161718192021222324@Autowiredprivate JdbcTemplate jdbcTemplate;// 新增@GetMapping(&quot;save&quot;)public String save()&#123; String sql = &quot;INSERT INTO USER (USER_NAME,PASS_WORD) VALUES (&#x27;laowang&#x27;,&#x27;123&#x27;)&quot;; int rows = jdbcTemplate.update(sql); return &quot;执行成功，影响&quot; + rows + &quot;行&quot;;&#125;// 删除@GetMapping(&quot;del&quot;)public String del(int id)&#123; int rows= jdbcTemplate.update(&quot;DELETE FROM USER WHERE ID = ?&quot;,id); return &quot;执行成功，影响&quot; + rows + &quot;行&quot;;&#125;// 查询@GetMapping(&quot;getMapById&quot;)public Map getMapById(Integer id)&#123; String sql = &quot;SELECT * FROM USER WHERE ID = ?&quot;; Map map= jdbcTemplate.queryForMap(sql,id); return map;&#125;复制 11.Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？ 答：Spring 的 JdbcTemplate 是对 JDBC API 的封装，提供更多的功能和更便利的操作，比如 JdbcTemplate 拥有： JdbcTemplate 是线程安全的； 实例化操作比较简单，仅需要传递 DataSource； 自动完成资源的创建和释放工作； 创建一次 JdbcTemplate，到处可用，避免重复开发。 12.Spring 有几种实现事务的方式？ 答：Spring 实现事务有两种方式：编程式事务和声明式事务。 编程式事务，使用 TransactionTemplate 或 PlatformTransactionManager 实现，示例代码如下： 12345678910111213141516171819private final TransactionTemplate transactionTemplate;public void add(User user) throws Exception&#123; // Spring编码式事务，回调机制 transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() &#123; @Override public Object doInTransaction(TransactionStatus status) &#123; try &#123; userMapper.insertSelective(user); &#125; catch (Exception e) &#123; // 异常，设置为回滚 status.setRollbackOnly(); throw e; &#125; return null; &#125; &#125;);&#125;复制 如果有异常，调用 status.setRollbackOnly() 回滚事务，否则正常执行 doInTransaction() 方法，正常提交事务。 如果事务控制的方法不需要返回值，就可以使用 TransactionCallbackWithoutResult（TransactionCallback 接口的抽象实现类）示例代码如下： 1234567891011121314151617public void add(User user) throws Exception &#123; // Spring编码式事务，回调机制 transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus status) &#123; try &#123; userMapper.insertSelective(user); &#125; catch (Exception e) &#123; // 异常，设置为回滚 status.setRollbackOnly(); throw e; &#125; &#125; &#125;);&#125;复制 声明式事务，底层是建立在 Spring AOP 的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。 声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现，示例代码如下： 12345678910@Transactionalpublic void save() &#123; User user = new User(&quot;laowang&quot;); userMapper.insertSelective(user); if (true) &#123; throw new RuntimeException(&quot;异常&quot;); &#125;&#125;复制 抛出异常，事务会自动回滚，如果方法正常执行，则会自动提交事务。 13.Spring 事务隔离级别有哪些？ 答：Spring 的注入方式包含以下五种： ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么； ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）； ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别； ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别； ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 默认值为 ISOLATION_DEFAULT 遵循数据库的事务隔离级别设置。 14.Spring 声明式事务无效可能的原因有哪些？ 答：可能的原因如下： MySQL 使用的是 MyISAM 引擎，而 MyISAM 是不支持事务的； @Transactional 使用在非 public 方法上，@Transactional 注解只能支持 public 级别，其他类型声明的事务不会生效； @Transactional 在同一个类中无事务方法 A() 内部调用有事务方法 B()，那么此时 B() 事物不会生效。Spring 中的 AOP 的底层实现原理是什么？ 答：Spring AOP 的底层实现原理就是动态代理。Spring AOP 的动态代理有两种实现方式，对于接口使用的是 JDK 自带的动态代理来实现的，而对比非接口使用的是 CGLib 来实现的，关于动态代理的详细内容，可参考前面【反射和动态代理】的那篇文章。 15.Spring 中的 Bean 是线程安全的吗？ 答：Spring 中的 Bean 默认是单例模式，Spring 框架并没有对单例 Bean 进行多线程的封装处理，因此默认的情况 Bean 并非是安全的，最简单保证 Bean 安全的举措就是设置 Bean 的作用域为 Prototype（原型）模式，这样每次请求都会新建一个 Bean。 16.说一下 Spring 中 Bean 的生命周期？ 答：Spring 中 Bean 的生命周期如下： ① 实例化 Bean：对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 Bean 时，或初始化 Bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 Bean； ② 设置对象属性（依赖注入）：实例化后的对象被封装在 BeanWrapper 对象中，紧接着 Spring 根据 BeanDefinition 中的信息以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入； ③ 处理 Aware 接口：Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean： 如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String BeanId) 方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值； 如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory() 方法，传递的是 Spring 工厂自身； 如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext(ApplicationContext) 方法，传入 Spring 上下文； ④ BeanPostProcessor：如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s) 方法； ⑤ InitializingBean 与 init-method：如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法； ⑥ 如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s) 方法；由于这个方法是在 Bean 初始化结束时调用的，因而可以被应用于内存或缓存技术； 以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。 ⑦ DisposableBean：当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy() 方法； ⑧ destroy-method：最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。 17.Spring 有哪些优点? 答：Spring 优点如下： 开源免费的热门框架，稳定性高、解决问题成本低； 方便集成各种优秀的框架； 降低了代码耦合性，通过 Spring 提供的 IoC 容器，我们可以将对象之间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合； 方便程序测试，在 Spring 里，测试变得非常简单，例如：Spring 对 Junit 的支持，可以通过注解方便的测试 Spring 程序； 降低 Java EE API 的使用难度，Spring 对很多难用的 Java EE API（如 JDBC、JavaMail、远程调用等）提供了一层封装，通过 Spring 的简易封装，让这些 Java EE API 的使用难度大为降低。 18.Spring 和 Struts 的区别？ 答：Spring 和 Struts 区别如下： Spring 特性如下： 具备 IOC/DI、AOP 等通用能力，提高研发效率 除了支持 Web 层建设以外，还提供了 J2EE 整体服务 方便与其他不同技术结合使用，如 Hibernate、MyBatis 等 Spring 拦截机制是方法级别 Struts 特性如下： 是一个基于 MVC 模式的一个 Web 层的处理 Struts 拦截机制是类级别 19.Spring、SpringBoot、SpringCloud 的区别是什么？ 答：它们的区别如下： Spring Framework 简称 Spring，是整个 Spring 生态的基础。 Spring Boot 是一个快速开发框架，让开发者可以迅速搭建一套基于 Spring 的应用程序，并且将常用的 Spring 模块以及第三方模块，如 MyBatis、Hibernate 等都做了很好的集成，只需要简单的配置即可使用，不需要任何的 XML 配置文件，真正做到了开箱即用，同时默认支持 JSON 格式的数据，使用 Spring Boot 进行前后端分离开发也非常便捷。 Spring Cloud 是一套整合了分布式应用常用模块的框架，使得开发者可以快速实现微服务应用。作为目前非常热门的技术，有关微服务的话题总是在各种场景下被大家讨论，企业的招聘信息中也越来越多地出现对于微服务架构能力的要求。 20.Spring 中都是用了哪些设计模式？ 答：Spring 中使用的设计模式如下： 工厂模式：通过 BeanFactory、ApplicationContext 来创建 bean 都是属于工厂模式； 单例、原型模式：创建 bean 对象设置作用域时，就可以声明 Singleton（单例模式）、Prototype（原型模式）； 察者模式：Spring 可以定义一下监听，如 ApplicationListener 当某个动作触发时就会发出通知； 责任链模式：AOP 拦截器的执行； 策略模式：在创建代理类时，如果代理的是接口使用的是 JDK 自身的动态代理，如果不是接口使用的是 CGLIB 实现动态代理。 总结 通过本节内容我们充分的了解了 Spring 的核心：IoC、DI、AOP，也是用代码演示了 Spring 核心功能的示例，其中可以发现的是 Spring 正在从之前的 XML 配置编程变为 Java 注解编程，注解编程让 Spring 更加轻量化简单化了，这一点在我们后面介绍 SpringBoot 的时候，会让你更加感同身受。对于开发者来说，只有真正掌握了 Spring，才能称得上是一名合格的 Java 工程师。当然，学习的目的是为了更好的应用，因此现在就一起动手实践起来吧。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"24.Java 中的各种锁和 CAS + 面试题","slug":"interview-java-24","date":"2020-10-08T06:09:00.000Z","updated":"2020-10-08T06:23:29.540Z","comments":true,"path":"2020/10/08/interview-java-24/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-24/","excerpt":"","text":"Java 中的各种锁和 CAS + 面试题 如果说快速理解多线程有什么捷径的话，那本文介绍的各种锁无疑是其中之一，它不但为我们开发多线程程序提供理论支持，还是面试中经常被问到的核心面试题之一。因此下面就让我们一起深入地学习一下这些锁吧。 乐观锁和悲观锁 悲观锁和乐观锁并不是某个具体的“锁”而是一种并发编程的基本概念。乐观锁和悲观锁最早出现在数据库的设计当中，后来逐渐被 Java 的并发包所引入。 悲观锁 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观地认为，不加锁的并发操作一定会出问题。 乐观锁 乐观锁正好和悲观锁相反，它获取数据的时候，并不担心数据被修改，每次获取数据的时候也不会加锁，只是在更新数据的时候，通过判断现有的数据是否和原数据一致来判断数据是否被其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新。 公平锁和非公平锁 根据线程获取锁的抢占机制，锁又可以分为公平锁和非公平锁。 公平锁 公平锁是指多个线程按照申请锁的顺序来获取锁。 非公平锁 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。 ReentrantLock 提供了公平锁和非公平锁的实现。 公平锁：new ReentrantLock(true) 非公平锁：new ReentrantLock(false) 如果构造函数不传任何参数的时候，默认提供的是非公平锁。 独占锁和共享锁 根据锁能否被多个线程持有，可以把锁分为独占锁和共享锁。 独占锁 独占锁是指任何时候都只有一个线程能执行资源操作。 共享锁 共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。比如 Java 中的 ReentrantReadWriteLock 就是共享锁的实现方式，它允许一个线程进行写操作，允许多个线程读操作。 ReentrantReadWriteLock 共享锁演示代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ReadWriteLockTest &#123; public static void main(String[] args) throws InterruptedException &#123; final MyReadWriteLock rwLock = new MyReadWriteLock(); // 创建读锁 r1 和 r2 Thread r1 = new Thread(new Runnable() &#123; @Override public void run() &#123; rwLock.read(); &#125; &#125;, &quot;r1&quot;); Thread r2 = new Thread(new Runnable() &#123; @Override public void run() &#123; rwLock.read(); &#125; &#125;, &quot;r2&quot;); r1.start(); r2.start(); // 等待同时读取线程执行完成 r1.join(); r2.join(); // 开启写锁的操作 new Thread(new Runnable() &#123; @Override public void run() &#123; rwLock.write(); &#125; &#125;, &quot;w1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; rwLock.write(); &#125; &#125;, &quot;w2&quot;).start(); &#125; static class MyReadWriteLock &#123; ReadWriteLock lock = new ReentrantReadWriteLock(); public void read() &#123; try &#123; lock.readLock().lock(); System.out.println(&quot;读操作，进入 | 线程：&quot; + Thread.currentThread().getName()); Thread.sleep(3000); System.out.println(&quot;读操作，退出 | 线程：&quot; + Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.readLock().unlock(); &#125; &#125; public void write() &#123; try &#123; lock.writeLock().lock(); System.out.println(&quot;写操作，进入 | 线程：&quot; + Thread.currentThread().getName()); Thread.sleep(3000); System.out.println(&quot;写操作，退出 | 线程：&quot; + Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; &#125;&#125;复制 以上程序执行结果如下： 读操作，进入 | 线程：r1 读操作，进入 | 线程：r2 读操作，退出 | 线程：r1 读操作，退出 | 线程：r2 写操作，进入 | 线程：w1 写操作，退出 | 线程：w1 写操作，进入 | 线程：w2 写操作，退出 | 线程：w2 可重入锁 可重入锁指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码。 自旋锁 自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。 CAS 与 ABA CAS（Compare and Swap）比较并交换，是一种乐观锁的实现，是用非阻塞算法来代替锁定，其中 java.util.concurrent 包下的 AtomicInteger 就是借助 CAS 来实现的。 但 CAS 也不是没有任何副作用，比如著名的 ABA 问题就是 CAS 引起的。 ABA 问题描述 老王去银行取钱，余额有 200 元，老王取 100 元，但因为程序的问题，启动了两个线程，线程一和线程二进行比对扣款，线程一获取原本有 200 元，扣除 100 元，余额等于 100 元，此时阿里给老王转账 100 元，于是启动了线程三抢先在线程二之前执行了转账操作，把 100 元又变成了 200 元，而此时线程二对比自己事先拿到的 200 元和此时经过改动的 200 元值一样，就进行了减法操作，把余额又变成了 100 元。这显然不是我们要的正确结果，我们想要的结果是余额减少了 100 元，又增加了 100 元，余额还是 200 元，而此时余额变成了 100 元，显然有悖常理，这就是著名的 ABA 的问题。 执行流程如下。 线程一：取款，获取原值 200 元，与 200 元比对成功，减去 100 元，修改结果为 100 元。 线程二：取款，获取原值 200 元，阻塞等待修改。 线程三：转账，获取原值 100 元，与 100 元比对成功，加上 100 元，修改结果为 200 元。 线程二：取款，恢复执行，原值为 200 元，与 200 元对比成功，减去 100 元，修改结果为 100 元。 最终的结果是 100 元。 ABA 问题的解决 常见解决 ABA 问题的方案加版本号，来区分值是否有变动。以老王取钱的例子为例，如果加上版本号，执行流程如下。 线程一：取款，获取原值 200_V1，与 200_V1 比对成功，减去 100 元，修改结果为 100_V2。 线程二：取款，获取原值 200_V1 阻塞等待修改。 线程三：转账，获取原值 100_V2，与 100_V2 对比成功，加 100 元，修改结果为 200_V3。 线程二：取款，恢复执行，原值 200_V1 与现值 200_V3 对比不相等，退出修改。 最终的结果为 200 元，这显然是我们需要的结果。 在程序中，要怎么解决 ABA 的问题呢？ 在 JDK 1.5 的时候，Java 提供了一个 AtomicStampedReference 原子引用变量，通过添加版本号来解决 ABA 的问题，具体使用示例如下： 12345678String name = &quot;老王&quot;;String newName = &quot;Java&quot;;AtomicStampedReference&lt;String&gt; as = new AtomicStampedReference&lt;String&gt;(name, 1);System.out.println(&quot;值：&quot; + as.getReference() + &quot; | Stamp：&quot; + as.getStamp());as.compareAndSet(name, newName, as.getStamp(), as.getStamp() + 1);System.out.println(&quot;值：&quot; + as.getReference() + &quot; | Stamp：&quot; + as.getStamp());复制 以上程序执行结果如下： 值：老王 | Stamp：1 值：Java | Stamp：2 相关面试题 1.synchronized 是哪种锁的实现？为什么？ 答：synchronized 是悲观锁的实现，因为 synchronized 修饰的代码，每次执行时会进行加锁操作，同时只允许一个线程进行操作，所以它是悲观锁的实现。 2.new ReentrantLock() 创建的是公平锁还是非公平锁？ 答：非公平锁，查看 ReentrantLock 的实现源码可知。 123456789/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125;复制 3.synchronized 使用的是公平锁还是非公平锁？ 答：synchronized 使用的是非公平锁，并且是不可设置的。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择，所以这也是 synchronized 使用非公平锁原由。 4.为什么非公平锁吞吐量大于公平锁？ 答：比如 A 占用锁的时候，B 请求获取锁，发现被 A 占用之后，堵塞等待被唤醒，这个时候 C 同时来获取 A 占用的锁，如果是公平锁 C 后来者发现不可用之后一定排在 B 之后等待被唤醒，而非公平锁则可以让 C 先用，在 B 被唤醒之前 C 已经使用完成，从而节省了 C 等待和唤醒之间的性能消耗，这就是非公平锁比公平锁吞吐量大的原因。 5.volatile 的作用是什么？ 答：volatile 是 Java 虚拟机提供的最轻量级的同步机制。 当变量被定义成 volatile 之后，具备两种特性： 保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，修改的新值对于其他线程是可见的（可以立即得知的）； 禁止指令重排序优化，普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。 6.volatile 对比 synchronized 有什么区别？ 答：synchronized 既能保证可见性，又能保证原子性，而 volatile 只能保证可见性，无法保证原子性。比如，i++ 如果使用 synchronized 修饰是线程安全的，而 volatile 会有线程安全的问题。 7.CAS 是如何实现的？ 答： CAS（Compare and Swap）比较并交换，CAS 是通过调用 JNI（Java Native Interface）的代码实现的，比如，在 Windows 系统 CAS 就是借助 C 语言来调用 CPU 底层指令实现的。 8.CAS 会产生什么问题？应该怎么解决？ 答：CAS 是标准的乐观锁的实现，会产生 ABA 的问题（详见正文）。 ABA 通常的解决办法是添加版本号，每次修改操作时版本号加一，这样数据对比的时候就不会出现 ABA 的问题了。 9.以下说法错误的是？ A：独占锁是指任何时候都只有一个线程能执行资源操作 B：共享锁指定是可以同时被多个线程读取和修改 C：公平锁是指多个线程按照申请锁的顺序来获取锁 D：非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁 答：B 题目解析：共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。 总结 本文介绍了 Java 中各种锁，明白了 Java 程序中比较常用的为非公平锁而非公平锁，原因在于非公平锁的吞吐量要更大，并且发生线程“饥饿”的情况很少，是风险远小于收益的事所以可以广而用之。又重点介绍了 CAS 和著名的 ABA 的问题，以及解决 ABA 的常见手段：添加版本号，可以通过 Java 自身提供的 AtomicStampedReference（原子引用变量）来解决 ABA 的问题，至此我们对 Java 多线程的了解又向前迈了一大步。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"23.Java 并发包中的高级同步工具 + 面试题","slug":"interview-java-23","date":"2020-10-08T06:08:57.000Z","updated":"2020-10-08T06:23:20.735Z","comments":true,"path":"2020/10/08/interview-java-23/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-23/","excerpt":"","text":"Java 并发包中的高级同步工具 + 面试题 Java 中的并发包指的是 java.util.concurrent（简称 JUC）包和其子包下的类和接口，它为 Java 的并发提供了各种功能支持，比如： 提供了线程池的创建类 ThreadPoolExecutor、Executors 等； 提供了各种锁，如 Lock、ReentrantLock 等； 提供了各种线程安全的数据结构，如 ConcurrentHashMap、LinkedBlockingQueue、DelayQueue 等； 提供了更加高级的线程同步结构，如 CountDownLatch、CyclicBarrier、Semaphore 等。 在前面的章节中我们已经详细地介绍了线程池的使用、线程安全的数据结构等，本文我们就重点学习一下 Java 并发包中更高级的线程同步类：CountDownLatch、CyclicBarrier、Semaphore 和 Phaser 等。 CountDownLatch 介绍和使用 CountDownLatch（闭锁）可以看作一个只能做减法的计数器，可以让一个或多个线程等待执行。 CountDownLatch 有两个重要的方法： countDown()：使计数器减 1； await()：当计数器不为 0 时，则调用该方法的线程阻塞，当计数器为 0 时，可以唤醒等待的一个或者全部线程。 CountDownLatch 使用场景： 以生活中的情景为例，比如去医院体检，通常人们会提前去医院排队，但只有等到医生开始上班，才能正式开始体检，医生也要给所有人体检完才能下班，这种情况就要使用 CountDownLatch，流程为：患者排队 → 医生上班 → 体检完成 → 医生下班。 CountDownLatch 示例代码如下： 12345678910111213141516171819202122232425// 医院闭锁CountDownLatch hospitalLatch = new CountDownLatch(1);// 患者闭锁CountDownLatch patientLatch = new CountDownLatch(5);System.out.println(&quot;患者排队&quot;);ExecutorService executorService = Executors.newCachedThreadPool();for (int i = 0; i &lt; 5; i++) &#123; final int j = i; executorService.execute(() -&gt; &#123; try &#123; hospitalLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;体检：&quot; + j); patientLatch.countDown(); &#125;);&#125;System.out.println(&quot;医生上班&quot;);hospitalLatch.countDown();patientLatch.await();System.out.println(&quot;医生下班&quot;);executorService.shutdown();复制 以上程序执行结果如下： 患者排队 医生上班 体检：4 体检：0 体检：1 体检：3 体检：2 医生下班 执行流程如下图： CyclicBarrier 介绍和使用 CyclicBarrier（循环屏障）通过它可以实现让一组线程等待满足某个条件后同时执行。 CyclicBarrier 经典使用场景是公交发车，为了简化理解我们这里定义，每辆公交车只要上满 4 个人就发车，后面来的人都会排队依次遵循相应的标准。 它的构造方法为 CyclicBarrier(int parties,Runnable barrierAction) 其中，parties 表示有几个线程来参与等待，barrierAction 表示满足条件之后触发的方法。CyclicBarrier 使用 await() 方法来标识当前线程已到达屏障点，然后被阻塞。 CyclicBarrier 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.*;public class CyclicBarrierTest &#123; public static void main(String[] args) throws InterruptedException &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(4, new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;发车了&quot;); &#125; &#125;); for (int i = 0; i &lt; 4; i++) &#123; new Thread(new CyclicWorker(cyclicBarrier)).start(); &#125; &#125; static class CyclicWorker implements Runnable &#123; private CyclicBarrier cyclicBarrier; CyclicWorker(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 2; i++) &#123; System.out.println(&quot;乘客：&quot; + i); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;复制 以上程序执行结果如下： 乘客：0 乘客：0 乘客：0 乘客：0 发车了 乘客：1 乘客：1 乘客：1 乘客：1 发车了 执行流程如下图： Semaphore 介绍和使用 Semaphore（信号量）用于管理多线程中控制资源的访问与使用。Semaphore 就好比停车场的门卫，可以控制车位的使用资源。比如来了 5 辆车，只有 2 个车位，门卫可以先放两辆车进去，等有车出来之后，再让后面的车进入。 Semaphore 示例代码如下： 123456789101112131415161718Semaphore semaphore = new Semaphore(2);ThreadPoolExecutor semaphoreThread = new ThreadPoolExecutor(10, 50, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());for (int i = 0; i &lt; 5; i++) &#123; semaphoreThread.execute(() -&gt; &#123; try &#123; // 堵塞获取许可 semaphore.acquire(); System.out.println(&quot;Thread：&quot; + Thread.currentThread().getName() + &quot; 时间：&quot; + LocalDateTime.now()); TimeUnit.SECONDS.sleep(2); // 释放许可 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;);&#125;复制 以上程序执行结果如下： Thread：pool-1-thread-1 时间：2019-07-10 21:18:42 Thread：pool-1-thread-2 时间：2019-07-10 21:18:42 Thread：pool-1-thread-3 时间：2019-07-10 21:18:44 Thread：pool-1-thread-4 时间：2019-07-10 21:18:44 Thread：pool-1-thread-5 时间：2019-07-10 21:18:46 执行流程如下图： Phaser 介绍和使用 Phaser（移相器）是 JDK 7 提供的，它的功能是等待所有线程到达之后，才继续或者开始进行新的一组任务。 比如有一个旅行团，我们规定所有成员必须都到达指定地点之后，才能发车去往景点一，到达景点之后可以各自游玩，之后必须全部到达指定地点之后，才能继续发车去往下一个景点，类似这种场景就非常适合使用 Phaser。 Phaser 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Lesson5_6 &#123; public static void main(String[] args) throws InterruptedException &#123; Phaser phaser = new MyPhaser(); PhaserWorker[] phaserWorkers = new PhaserWorker[5]; for (int i = 0; i &lt; phaserWorkers.length; i++) &#123; phaserWorkers[i] = new PhaserWorker(phaser); // 注册 Phaser 等待的线程数，执行一次等待线程数 +1 phaser.register(); &#125; for (int i = 0; i &lt; phaserWorkers.length; i++) &#123; // 执行任务 new Thread(new PhaserWorker(phaser)).start(); &#125; &#125; static class PhaserWorker implements Runnable &#123; private final Phaser phaser; public PhaserWorker(Phaser phaser) &#123; this.phaser = phaser; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; | 到达&quot; ); phaser.arriveAndAwaitAdvance(); // 集合完毕发车 try &#123; Thread.sleep(new Random().nextInt(5) * 1000); System.out.println(Thread.currentThread().getName() + &quot; | 到达&quot; ); phaser.arriveAndAwaitAdvance(); // 景点 1 集合完毕发车 Thread.sleep(new Random().nextInt(5) * 1000); System.out.println(Thread.currentThread().getName() + &quot; | 到达&quot; ); phaser.arriveAndAwaitAdvance(); // 景点 2 集合完毕发车 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Phaser 每个阶段完成之后的事件通知 static class MyPhaser extends Phaser&#123; @Override protected boolean onAdvance(int phase, int registeredParties) &#123; // 每个阶段执行完之后的回调 switch (phase) &#123; case 0: System.out.println(&quot;==== 集合完毕发车 ====&quot;); return false; case 1: System.out.println(&quot;==== 景点1集合完毕，发车去下一个景点 ====&quot;); return false; case 2: System.out.println(&quot;==== 景点2集合完毕，发车回家 ====&quot;); return false; default: return true; &#125; &#125; &#125;&#125;复制 以上程序执行结果如下： Thread-0 | 到达 Thread-4 | 到达 Thread-3 | 到达 Thread-1 | 到达 Thread-2 | 到达 ==== 集合完毕发车 ==== Thread-0 | 到达 Thread-4 | 到达 Thread-1 | 到达 Thread-3 | 到达 Thread-2 | 到达 ==== 景点1集合完毕，发车去下一个景点 ==== Thread-4 | 到达 Thread-3 | 到达 Thread-2 | 到达 Thread-1 | 到达 Thread-0 | 到达 ==== 景点2集合完毕，发车回家 ==== 执行流程如下图： 相关面试题 1.以下哪个类用于控制某组资源的访问权限？ A：Phaser B：Semaphore C：CountDownLatch D：CyclicBarrier 答：B 2.以下哪个类不能被重用？ A：Phaser B：Semaphore C：CountDownLatch D：CyclicBarrier 答：C 3.以下哪个方法不属于 CountDownLatch 类？ A：await() B：countDown() C：getCount() D：release() 答：D 题目解析：release() 是 Semaphore 的释放许可的方法，CountDownLatch 类并不包含此方法。 4.CyclicBarrier 与 CountDownLatch 有什么区别？ 答：CyclicBarrier 与 CountDownLatch 本质上都是依赖 volatile 和 CAS 实现的，它们区别如下： CountDownLatch 只能使用一次，而 CyclicBarrier 可以使用多次。 CountDownLatch 是手动指定等待一个或多个线程执行完成再执行，而 CyclicBarrier 是 n 个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。 5.以下哪个类不包含 await() 方法？ A：Semaphore B：CountDownLatch C：CyclicBarrier 答：A 6.以下程序执行花费了多长时间？ 12345678910111213141516Semaphore semaphore = new Semaphore(2);ThreadPoolExecutor semaphoreThread = new ThreadPoolExecutor(10, 50, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());for (int i = 0; i &lt; 3; i++) &#123; semaphoreThread.execute(() -&gt; &#123; try &#123; semaphore.release(); System.out.println(&quot;Hello&quot;); TimeUnit.SECONDS.sleep(2); semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;);&#125;复制 A：1s 以内 B：2s 以上 答：A 题目解析：循环先执行了 release() 也就是释放许可的方法，因此程序可以一次性执行 3 个线程，同时会在 1s 以内执行完。 7.Semaphore 有哪些常用的方法？ 答：常用方法如下： acquire()：获取一个许可。 release()：释放一个许可。 availablePermits()：当前可用的许可数。 acquire(int n)：获取并使用 n 个许可。 release(int n)：释放 n 个许可。 8.Phaser 常用方法有哪些？ 答：常用方法如下： register()：注册新的参与者到 Phaser arriveAndAwaitAdvance()：等待其他线程执行 arriveAndDeregister()：注销此线程 forceTermination()：强制 Phaser 进入终止态 isTerminated()：判断 Phaser 是否终止 9.以下程序是否可以正常执行？“发车了”打印了多少次？ 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.*;public class TestMain &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(4, new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;发车了&quot;); &#125; &#125;); for (int i = 0; i &lt; 4; i++) &#123; new Thread(new CyclicWorker(cyclicBarrier)).start(); &#125; &#125; static class CyclicWorker implements Runnable &#123; private CyclicBarrier cyclicBarrier; CyclicWorker(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 2; i++) &#123; System.out.println(&quot;乘客：&quot; + i); try &#123; cyclicBarrier.await(); System.out.println(&quot;乘客 II：&quot; + i); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;复制 答：可以正常执行，因为执行了两次 await()，所以“发车了”打印了 4 次。 总结 本文我们介绍了四种比 synchronized 更高级的线程同步类，其中 CountDownLatch、CyclicBarrier、Phaser 功能比较类似都是实现线程间的等待，只是它们的侧重点有所不同，其中 CountDownLatch 一般用于等待一个或多个线程执行完，才执行当前线程，并且 CountDownLatch 不能重复使用；CyclicBarrier 用于等待一组线程资源都进入屏障点再共同执行；Phaser 是 JDK 7 提供的功能更加强大和更加灵活的线程辅助工具，等待所有线程达到之后，继续或开始新的一组任务，Phaser 提供了动态增加和消除线程同步个数功能。而 Semaphore 提供的功能更像锁，用于控制一组资源的访问权限。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"22.线程安全之 synchronized 和 ReentrantLock + 面试题","slug":"interview-java-22","date":"2020-10-08T06:08:54.000Z","updated":"2020-10-08T06:23:12.335Z","comments":true,"path":"2020/10/08/interview-java-22/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-22/","excerpt":"","text":"线程安全之 synchronized 和 ReentrantLock + 面试题 前面我们介绍了很多关于多线程的内容，在多线程中有一个很重要的课题需要我们攻克，那就是线程安全问题。线程安全问题指的是在多线程中，各线程之间因为同时操作所产生的数据污染或其他非预期的程序运行结果。 线程安全 1）非线程安全事例 比如 A 和 B 同时给 C 转账的问题，假设 C 原本余额有 100 元，A 给 C 转账 100 元，正在转的途中，此时 B 也给 C 转了 100 元，这个时候 A 先给 C 转账成功，余额变成了 200 元，但 B 事先查询 C 的余额是 100 元，转账成功之后也是 200 元。当 A 和 B 都给 C 转账完成之后，余额还是 200 元，而非预期的 300 元，这就是典型的线程安全的问题。 2）非线程安全代码示例 上面的内容没看明白没关系，下面来看非线程安全的具体代码： 12345678910111213141516171819class ThreadSafeTest &#123; static int number = 0; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; addNumber()); Thread thread2 = new Thread(() -&gt; addNumber()); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(&quot;number：&quot; + number); &#125; public static void addNumber() &#123; for (int i = 0; i &lt; 10000; i++) &#123; ++number; &#125; &#125;&#125;复制 以上程序执行结果如下： number：12085 每次执行的结果可能略有差异，不过几乎不会等于（正确的）累计之和 20000。 3）线程安全的解决方案 线程安全的解决方案有以下几个维度： 数据不共享，单线程可见，比如 ThreadLocal 就是单线程可见的； 使用线程安全类，比如 StringBuffer 和 JUC（java.util.concurrent）下的安全类（后面文章会专门介绍）； 使用同步代码或者锁。 线程同步和锁 1）synchronized ① synchronized 介绍 synchronized 是 Java 提供的同步机制，当一个线程正在操作同步代码块（synchronized 修饰的代码）时，其他线程只能阻塞等待原有线程执行完再执行。 ② synchronized 使用 synchronized 可以修饰代码块或者方法，示例代码如下： 12345678910// 修饰代码块synchronized (this) &#123; // do something&#125;// 修饰方法synchronized void method() &#123; // do something&#125;复制 使用 synchronized 完善本文开头的非线程安全的代码。 方法一：使用 synchronized 修饰代码块，代码如下： 1234567891011121314151617181920212223242526272829class ThreadSafeTest &#123; static int number = 0; public static void main(String[] args) throws InterruptedException &#123; Thread sThread = new Thread(() -&gt; &#123; // 同步代码 synchronized (ThreadSafeTest.class) &#123; addNumber(); &#125; &#125;); Thread sThread2 = new Thread(() -&gt; &#123; // 同步代码 synchronized (ThreadSafeTest.class) &#123; addNumber(); &#125; &#125;); sThread.start(); sThread2.start(); sThread.join(); sThread2.join(); System.out.println(&quot;number：&quot; + number); &#125; public static void addNumber() &#123; for (int i = 0; i &lt; 10000; i++) &#123; ++number; &#125; &#125;&#125;复制 以上程序执行结果如下： number：20000 方法二：使用 synchronized 修饰方法，代码如下： 12345678910111213141516171819class ThreadSafeTest &#123; static int number = 0; public static void main(String[] args) throws InterruptedException &#123; Thread sThread = new Thread(() -&gt; addNumber()); Thread sThread2 = new Thread(() -&gt; addNumber()); sThread.start(); sThread2.start(); sThread.join(); sThread2.join(); System.out.println(&quot;number：&quot; + number); &#125; public synchronized static void addNumber() &#123; for (int i = 0; i &lt; 10000; i++) &#123; ++number; &#125; &#125;&#125;复制 以上程序执行结果如下： number：20000 ③ synchronized 实现原理 synchronized 本质是通过进入和退出的 Monitor 对象来实现线程安全的。 以下面代码为例： 123456789public class SynchronizedTest &#123; public static void main(String[] args) &#123; synchronized (SynchronizedTest.class) &#123; System.out.println(&quot;Java&quot;); &#125; &#125;&#125;复制 当我们使用 javap 编译之后，生成的字节码如下： 1234567891011121314151617181920212223242526272829303132Compiled from &quot;SynchronizedTest.java&quot;public class com.interview.other.SynchronizedTest &#123; public com.interview.other.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // class com/interview/other/SynchronizedTest 2: dup 3: astore_1 4: monitorenter 5: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 8: ldc #4 // String Java 10: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 13: aload_1 14: monitorexit 15: goto 23 18: astore_2 19: aload_1 20: monitorexit 21: aload_2 22: athrow 23: return Exception table: from to target type 5 15 18 any 18 21 18 any&#125;复制 可以看出 JVM（Java 虚拟机）是采用 monitorenter 和 monitorexit 两个指令来实现同步的，monitorenter 指令相当于加锁，monitorexit 相当于释放锁。而 monitorenter 和 monitorexit 就是基于 Monitor 实现的。 2）ReentrantLock ① ReentrantLock 介绍 ReentrantLock（再入锁）是 Java 5 提供的锁实现，它的功能和 synchronized 基本相同。再入锁通过调用 lock() 方法来获取锁，通过调用 unlock() 来释放锁。 ② ReentrantLock 使用 ReentrantLock 基础使用，代码如下： 123456Lock lock = new ReentrantLock();lock.lock(); // 加锁// 业务代码...lock.unlock(); // 解锁复制 使用 ReentrantLock 完善本文开头的非线程安全代码，请参考以下代码： 1234567891011121314151617181920212223242526272829303132333435public class LockTest &#123; static int number = 0; public static void main(String[] args) throws InterruptedException &#123; // ReentrantLock 使用 Lock lock = new ReentrantLock(); Thread thread1 = new Thread(() -&gt; &#123; try &#123; lock.lock(); addNumber(); &#125; finally &#123; lock.unlock(); &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; try &#123; lock.lock(); addNumber(); &#125; finally &#123; lock.unlock(); &#125; &#125;); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(&quot;number：&quot; + number); &#125; public static void addNumber() &#123; for (int i = 0; i &lt; 10000; i++) &#123; ++number; &#125; &#125;&#125;复制 尝试获取锁 ReentrantLock 可以无阻塞尝试访问锁，使用 tryLock() 方法，具体使用如下： 1234567891011121314151617181920212223242526Lock reentrantLock = new ReentrantLock();// 线程一new Thread(() -&gt; &#123; try &#123; reentrantLock.lock(); Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; reentrantLock.unlock(); &#125;&#125;).start();// 线程二new Thread(() -&gt; &#123; try &#123; Thread.sleep(1 * 1000); System.out.println(reentrantLock.tryLock()); Thread.sleep(2 * 1000); System.out.println(reentrantLock.tryLock()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start();复制 以上代码执行结果如下： false true 尝试一段时间内获取锁 tryLock() 有一个扩展方法 tryLock(long timeout, TimeUnit unit) 用于尝试一段时间内获取锁，具体实现代码如下： 12345678910111213141516171819202122232425Lock reentrantLock = new ReentrantLock();// 线程一new Thread(() -&gt; &#123; try &#123; reentrantLock.lock(); System.out.println(LocalDateTime.now()); Thread.sleep(2 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; reentrantLock.unlock(); &#125;&#125;).start();// 线程二new Thread(() -&gt; &#123; try &#123; Thread.sleep(1 * 1000); System.out.println(reentrantLock.tryLock(3, TimeUnit.SECONDS)); System.out.println(LocalDateTime.now()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start();复制 以上代码执行结果如下： 2019-07-05 19:53:51 true 2019-07-05 19:53:53 可以看出锁在休眠了 2 秒之后，就被线程二直接获取到了，所以说 tryLock(long timeout, TimeUnit unit) 方法内的 timeout 参数指的是获取锁的最大等待时间。 ③ ReentrantLock 注意事项 使用 ReentrantLock 一定要记得释放锁，否则该锁会被永久占用。 相关面试题 1.ReentrantLock 常用的方法有哪些？ 答：ReentrantLock 常见方法如下： lock()：用于获取锁 unlock()：用于释放锁 tryLock()：尝试获取锁 getHoldCount()：查询当前线程执行 lock() 方法的次数 getQueueLength()：返回正在排队等待获取此锁的线程数 isFair()：该锁是否为公平锁 2.ReentrantLock 有哪些优势？ 答：ReentrantLock 具备非阻塞方式获取锁的特性，使用 tryLock() 方法。ReentrantLock 可以中断获得的锁，使用 lockInterruptibly() 方法当获取锁之后，如果所在的线程被中断，则会抛出异常并释放当前获得的锁。ReentrantLock 可以在指定时间范围内获取锁，使用 tryLock(long timeout,TimeUnit unit) 方法。 3.ReentrantLock 怎么创建公平锁？ 答：new ReentrantLock() 默认创建的为非公平锁，如果要创建公平锁可以使用 new ReentrantLock(true)。 4.公平锁和非公平锁有哪些区别？ 答：公平锁指的是线程获取锁的顺序是按照加锁顺序来的，而非公平锁指的是抢锁机制，先 lock() 的线程不一定先获得锁。 5.ReentrantLock 中 lock() 和 lockInterruptibly() 有什么区别？ 答：lock() 和 lockInterruptibly() 的区别在于获取线程的途中如果所在的线程中断，lock() 会忽略异常继续等待获取线程，而 lockInterruptibly() 则会抛出 InterruptedException 异常。 题目解析：执行以下代码，在线程中分别使用 lock() 和 lockInterruptibly() 查看运行结果，代码如下： 123456789101112131415161718192021 Lock interruptLock = new ReentrantLock();interruptLock.lock();Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; interruptLock.lock(); //interruptLock.lockInterruptibly(); // java.lang.InterruptedException &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;);thread.start();TimeUnit.SECONDS.sleep(1);thread.interrupt();TimeUnit.SECONDS.sleep(3);System.out.println(&quot;Over&quot;);System.exit(0);复制 执行以下代码会发现使用 lock() 时程序不会报错，运行完成直接退出；而使用 lockInterruptibly() 则会抛出异常 java.lang.InterruptedException，这就说明：在获取线程的途中如果所在的线程中断，lock() 会忽略异常继续等待获取线程，而 lockInterruptibly() 则会抛出 InterruptedException 异常。 6.synchronized 和 ReentrantLock 有什么区别？ 答：synchronized 和 ReentrantLock 都是保证线程安全的，它们的区别如下： ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作； ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁； ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等； ReentrantLock 性能略高于 synchronized。 7.ReentrantLock 的 tryLock(3, TimeUnit.SECONDS) 表示等待 3 秒后再去获取锁，这种说法对吗？为什么？ 答：不对，tryLock(3, TimeUnit.SECONDS) 表示获取锁的最大等待时间为 3 秒，期间会一直尝试获取，而不是等待 3 秒之后再去获取锁。 8.synchronized 是如何实现锁升级的？ 答：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，JVM（Java 虚拟机）让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否尤其线程 id 一致，如果一致则可以直接使用，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，不会阻塞，执行一定次数之后就会升级为重量级锁，进入阻塞，整个过程就是锁升级的过程。 总结 本文介绍了线程同步的两种方式 synchronized 和 ReentrantLock，其中 ReentrantLock 使用更加灵活，效率也率高，不过 ReentrantLock 只能修饰代码块，使用 ReentrantLock 需要开发者手动释放锁，如果忘记释放则该锁会一直被占用。synchronized 使用场景更广，可以修饰普通方法、静态方法和代码块等。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"21.ThreadLocal 有什么用 + 面试题","slug":"interview-java-21","date":"2020-10-08T06:08:50.000Z","updated":"2020-10-08T06:23:03.748Z","comments":true,"path":"2020/10/08/interview-java-21/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-21/","excerpt":"","text":"ThreadLocal 有什么用 + 面试题 什么是 ThreadLocal？ ThreadLocal 诞生于 JDK 1.2，用于解决多线程间的数据隔离问题。也就是说 ThreadLocal 会为每一个线程创建一个单独的变量副本。 ThreadLocal 有什么用？ ThreadLocal 最典型的使用场景有两个： ThreadLocal 可以用来管理 Session，因为每个人的信息都是不一样的，所以就很适合用 ThreadLocal 来管理； 数据库连接，为每一个线程分配一个独立的资源，也适合用 ThreadLocal 来实现。 其中，ThreadLocal 也被用在很多大型开源框架中，比如 Spring 的事务管理器，还有 Hibernate 的 Session 管理等，既然 ThreadLocal 用途如此广泛，那接下来就让我们共同看看 ThreadLocal 要怎么用？ThreadLocal 使用中要注意什么？以及 ThreadLocal 的存储原理等，一起来看吧。 ThreadLocal 基础使用 ThreadLocal 常用方法有 set(T)、get()、remove() 等，具体使用请参考以下代码。 123456789101112ThreadLocal threadLocal = new ThreadLocal();// 存值threadLocal.set(Arrays.asList(&quot;老王&quot;, &quot;Java 面试题&quot;));// 取值List list = (List) threadLocal.get();System.out.println(list.size());System.out.println(threadLocal.get());//删除值threadLocal.remove();System.out.println(threadLocal.get());复制 以上程序执行结果如下： 2 [老王, Java 面试题] null ThreadLocal 所有方法，如下图所示： ThreadLocal 数据共享 既然 ThreadLocal 设计的初衷是解决线程间信息隔离的，那 ThreadLocal 能不能实现线程间信息共享呢？ 答案是肯定的，只需要使用 ThreadLocal 的子类 InheritableThreadLocal 就可以轻松实现，来看具体实现代码： 12345ThreadLocal inheritableThreadLocal = new InheritableThreadLocal();inheritableThreadLocal.set(&quot;老王&quot;);new Thread(() -&gt; System.out.println(inheritableThreadLocal.get())).start();复制 以上程序执行结果如下： 老王 从以上代码可以看出，主线程和新创建的线程之间实现了信息共享。 ThreadLocal 高级用法 内存溢出代码演示 下面我们用代码实现 ThreadLocal 内存溢出的情况，请参考以下代码。 123456789101112131415161718192021222324252627282930313233class ThreadLocalTest &#123; static ThreadLocal threadLocal = new ThreadLocal(); static Integer MOCK_MAX = 10000; static Integer THREAD_MAX = 100; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(THREAD_MAX); for (int i = 0; i &lt; THREAD_MAX; i++) &#123; executorService.execute(() -&gt; &#123; threadLocal.set(new ThreadLocalTest().getList()); System.out.println(Thread.currentThread().getName()); &#125;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; executorService.shutdown(); &#125; List getList() &#123; List list = new ArrayList(); for (int i = 0; i &lt; MOCK_MAX; i++) &#123; list.add(&quot;Version：JDK 8&quot;); list.add(&quot;ThreadLocal&quot;); list.add(&quot;Author：老王&quot;); list.add(&quot;DateTime：&quot; + LocalDateTime.now()); list.add(&quot;Test：ThreadLocal OOM&quot;); &#125; return list; &#125;&#125;复制 设置 JVM（Java 虚拟机）启动参数 -Xmx=100m （最大运行内存 100 M），运行程序不久后就会出现如下异常： 此时我们用 VisualVM 观察到程序运行的内存使用情况，发现内存一直在缓慢地上升直到内存超出最大值，从而发生内存溢出的情况。 内存使用情况，如下图所示： 内存溢出原理分析 在开始之前，先来看下 ThreadLocal 是如何存储数据的。 首先，找到 ThreadLocal.set() 的源码，代码如下（此源码基于 JDK 8）： 12345678910public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;复制 可以看出 ThreadLocal 首先获取到 ThreadLocalMap 对象，然后再执行 ThreadLocalMap.set() 方法，进而打开此方法的源码，代码如下： 123456789101112131415161718192021222324private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125;复制 从整个代码可以看出，首先 ThreadLocal 并不存储数据，而是依靠 ThreadLocalMap 来存储数据，ThreadLocalMap 中有一个 Entry 数组，每个 Entry 对象是以 K/V 的形式对数据进行存储的，其中 K 就是 ThreadLocal 本身，而 V 就是要存储的值，如下图所示： 可以看出：一个 Thread 中只有一个 ThreadLocalMap，每个 ThreadLocalMap 中存有多个 ThreadLocal，ThreadLocal 引用关系如下： 其中：实线代表强引用，虚线代表弱引用（弱引用具有更短暂的生命周期，在执行垃圾回收时，一旦发现只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存）。 看到这里我们就理解了 ThreadLocal 造成内存溢出的原因：如果 ThreadLocal 没有被直接引用（外部强引用），在 GC（垃圾回收）时，由于 ThreadLocalMap 中的 key 是弱引用，所以一定就会被回收，这样一来 ThreadLocalMap 中就会出现 key 为 null 的 Entry，并且没有办法访问这些数据，如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 并且永远无法回收，从而造成内存泄漏。 ThreadLocal 的正确使用方法 既然已经知道了 ThreadLocal 内存溢出的原因，那解决办法就很清晰了，只需要在使用完 ThreadLocal 之后，调用remove() 方法，清除掉 ThreadLocalMap 中的无用数据就可以了。 正确使用的完整示例代码如下： 1234567891011121314151617181920212223242526272829303132333435class ThreadLocalTest &#123; static ThreadLocal threadLocal = new ThreadLocal(); static Integer MOCK_MAX = 10000; static Integer THREAD_MAX = 100; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(THREAD_MAX); for (int i = 0; i &lt; THREAD_MAX; i++) &#123; executorService.execute(() -&gt; &#123; threadLocal.set(new ThreadLocalTest().getList()); System.out.println(Thread.currentThread().getName()); // 移除对象 threadLocal.remove(); &#125;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; executorService.shutdown(); &#125; List getList() &#123; List list = new ArrayList(); for (int i = 0; i &lt; MOCK_MAX; i++) &#123; list.add(&quot;Version：JDK 8&quot;); list.add(&quot;ThreadLocal&quot;); list.add(&quot;Author：老王&quot;); list.add(&quot;DateTime：&quot; + LocalDateTime.now()); list.add(&quot;Test：ThreadLocal OOM&quot;); &#125; return list; &#125;&#125;复制 可以看出核心代码，我们添加了一句 threadLocal.remove() 命令就解决了内存溢出的问题，这个时候运行代码观察，发现内存的值一直在一个固定的范围内，如下图所示： 这样就解决了 ThreadLocal 内存溢出的问题了。 相关面试题 1.ThreadLocal 为什么是线程安全的？ 答：ThreadLocal 为每一个线程维护变量的副本，把共享数据的可见范围限制在同一个线程之内，因此 ThreadLocal 是线程安全的，每个线程都有属于自己的变量。 2.ThreadLocal 如何共享数据？ 答：通过 ThreadLocal 的子类 InheritableThreadLocal 可以天然的支持多线程间的信息共享。 3.以下程序打印的结果是 true 还是 false？ 123456789ThreadLocal threadLocal = new InheritableThreadLocal();threadLocal.set(&quot;老王&quot;);ThreadLocal threadLocal2 = new ThreadLocal();threadLocal2.set(&quot;老王&quot;);new Thread(() -&gt; &#123; System.out.println(threadLocal.get().equals(threadLocal2.get()));&#125;).start();复制 答：false。 题目分析：因为 threadLocal 使用的是 InheritableThreadLocal（共享本地线程），所以 threadLocal.get() 结果为 老王 ，而 threadLocal2 使用的是 ThreadLocal，因此在新线程中 threadLocal2.get() 的结果为 null ，因而它们比较的最终结果为 false。 4.ThreadLocal 为什么会发生内存溢出？ 答：ThreadLocal 造成内存溢出的原因：如果 ThreadLocal 没有被直接引用（外部强引用），在 GC（垃圾回收）时，由于 ThreadLocalMap 中的 key 是弱引用，所以一定就会被回收，这样一来 ThreadLocalMap 中就会出现 key 为 null 的 Entry，并且没有办法访问这些数据，如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 并且永远无法回收，从而造成内存泄漏。 5.解决 ThreadLocal 内存溢出的关键代码是什么？ 答：关键代码为 threadLocal.remove() ，使用完 ThreadLocal 之后，调用remove() 方法，清除掉 ThreadLocalMap 中的无用数据就可以避免内存溢出了。 6.ThreadLocal 和 Synchonized 有什么区别？ 答：ThreadLocal 和 Synchonized 都用于解决多线程并发访问，防止任务在共享资源上产生冲突，但是 ThreadLocal 与 Synchronized 有本质的区别，Synchronized 用于实现同步机制，是利用锁的机制使变量或代码块在某一时刻只能被一个线程访问，是一种 “以时间换空间” 的方式；而 ThreadLocal 为每一个线程提供了独立的变量副本，这样每个线程的（变量）操作都是相互隔离的，这是一种 “以空间换时间” 的方式。 总结 ThreadLocal 的主要方法是 set(T) 和 get()，用于多线程间的数据隔离，ThreadLocal 也提供了 InheritableThreadLocal 子类，用于实现多线程间的数据共享。但使用 ThreadLocal 一定要注意用完之后使用 remove() 清空 ThreadLocal，不然会操作内存溢出的问题。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"20.线程池之 Executors + 面试题","slug":"interview-java-20","date":"2020-10-08T06:08:47.000Z","updated":"2020-10-08T06:22:53.705Z","comments":true,"path":"2020/10/08/interview-java-20/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-20/","excerpt":"","text":"线程池之 Executors + 面试题 线程池的创建分为两种方式：ThreadPoolExecutor 和 Executors，上一节学习了 ThreadPoolExecutor 的使用方式，本节重点来看 Executors 是如何创建线程池的。 Executors 可以创建以下六种线程池。 FixedThreadPool(n)：创建一个数量固定的线程池，超出的任务会在队列中等待空闲的线程，可用于控制程序的最大并发数。 CachedThreadPool()：短时间内处理大量工作的线程池，会根据任务数量产生对应的线程，并试图缓存线程以便重复使用，如果限制 60 秒没被使用，则会被移除缓存。 SingleThreadExecutor()：创建一个单线程线程池。 ScheduledThreadPool(n)：创建一个数量固定的线程池，支持执行定时性或周期性任务。 SingleThreadScheduledExecutor()：此线程池就是单线程的 newScheduledThreadPool。 WorkStealingPool(n)：Java 8 新增创建线程池的方法，创建时如果不设置任何参数，则以当前机器处理器个数作为线程个数，此线程池会并行处理任务，不能保证执行顺序。 下面分别来看以上六种线程池的具体代码使用。 FixedThreadPool 使用 创建固定个数的线程池，具体示例如下： 12345678910111213ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2);for (int i = 0; i &lt; 3; i++) &#123; fixedThreadPool.execute(() -&gt; &#123; System.out.println(&quot;CurrentTime - &quot; + LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;);&#125;复制 以上程序执行结果如下： CurrentTime - 2019-06-27 20:58:58 CurrentTime - 2019-06-27 20:58:58 CurrentTime - 2019-06-27 20:58:59 根据执行结果可以看出，newFixedThreadPool(2) 确实是创建了两个线程，在执行了一轮（2 次）之后，停了一秒，有了空闲线程，才执行第三次。 CachedThreadPool 使用 根据实际需要自动创建带缓存功能的线程池，具体代码如下： 1234567891011121314ExecutorService cachedThreadPool = Executors.newCachedThreadPool();for (int i = 0; i &lt; 10; i++) &#123; cachedThreadPool.execute(() -&gt; &#123; System.out.println(&quot;CurrentTime - &quot; + LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;);&#125;复制 以上程序执行结果如下： CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 CurrentTime - 2019-06-27 21:24:46 根据执行结果可以看出，newCachedThreadPool 在短时间内会创建多个线程来处理对应的任务，并试图把它们进行缓存以便重复使用。 SingleThreadExecutor 使用 创建单个线程的线程池，具体代码如下： 1234567891011121314ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 3; i++) &#123; singleThreadExecutor.execute(() -&gt; &#123; System.out.println(&quot;CurrentTime - &quot; + LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;);&#125;复制 以上程序执行结果如下： CurrentTime - 2019-06-27 21:43:34 CurrentTime - 2019-06-27 21:43:35 CurrentTime - 2019-06-27 21:43:36 ScheduledThreadPool 使用 创建一个可以执行周期性任务的线程池，具体代码如下： 1234567ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(2);scheduledThreadPool.schedule(() -&gt; &#123; System.out.println(&quot;ThreadPool：&quot; + LocalDateTime.now());&#125;, 1L, TimeUnit.SECONDS);System.out.println(&quot;CurrentTime：&quot; + LocalDateTime.now());复制 以上程序执行结果如下： CurrentTime：2019-06-27T21:54:21.881 ThreadPool：2019-06-27T21:54:22.845 根据执行结果可以看出，我们设置的 1 秒后执行的任务生效了。 SingleThreadScheduledExecutor 使用 创建一个可以执行周期性任务的单线程池，具体代码如下： 1234567ScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();singleThreadScheduledExecutor.schedule(() -&gt; &#123; System.out.println(&quot;ThreadPool：&quot; + LocalDateTime.now());&#125;, 1L, TimeUnit.SECONDS);System.out.println(&quot;CurrentTime：&quot; + LocalDateTime.now());复制 WorkStealingPool 使用 Java 8 新增的创建线程池的方式，可根据当前电脑 CPU 处理器数量生成相应个数的线程池，使用代码如下： 12345678910ExecutorService workStealingPool = Executors.newWorkStealingPool();for (int i = 0; i &lt; 5; i++) &#123; int finalNumber = i; workStealingPool.execute(() -&gt; &#123; System.out.println(&quot;I：&quot; + finalNumber); &#125;);&#125;Thread.sleep(5000);复制 以上程序执行结果如下： I：0 I：3 I：2 I：1 I：4 根据执行结果可以看出，newWorkStealingPool 是并行处理任务的，并不能保证执行顺序。 ThreadPoolExecutor VS Executors ThreadPoolExecutor 和 Executors 都是用来创建线程池的，其中 ThreadPoolExecutor 创建线程池的方式相对传统，而 Executors 提供了更多的线程池类型（6 种），但很不幸的消息是在实际开发中并不推荐使用 Executors 的方式来创建线程池。 无独有偶《阿里巴巴 Java 开发手册》中对于线程池的创建也是这样规定的，内容如下： 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 OOM 是 OutOfMemoryError 的缩写，指内存溢出的意思。 为什么不允许使用 Executors？ 我们先来看一个简单的例子： 123456789101112ExecutorService maxFixedThreadPool = Executors.newFixedThreadPool(10);for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; maxFixedThreadPool.execute(()-&gt;&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;);&#125;复制 之后设置 JVM（Java 虚拟机）的启动参数： -Xmx10m -Xms10m （设置 JVM 最大运行内存等于 10M）运行程序，会抛出 OOM 异常，信息如下： Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:416) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1371) at xxx.main(xxx.java:127) 为什么 Executors 会存在 OOM 的缺陷？ 通过以上代码，找到了 FixedThreadPool 的源码，代码如下： 1234567public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;复制 可以看到创建 FixedThreadPool 使用了 LinkedBlockingQueue 作为任务队列，继续查看 LinkedBlockingQueue 的源码就会发现问题的根源，源码如下： 12345public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125;复制 当使用 LinkedBlockingQueue 并没有给它指定长度的时候，默认长度为 Integer.MAX_VALUE，这样就会导致程序会给线程池队列添加超多个任务，因为任务量太大就有造成 OOM 的风险。 相关面试题 1.以下程序会输出什么结果？ 123456789101112public static void main(String[] args) &#123; ExecutorService workStealingPool = Executors.newWorkStealingPool(); for (int i = 0; i &lt; 5; i++) &#123; int finalNumber = i; workStealingPool.execute(() -&gt; &#123; System.out.print(finalNumber); &#125;); &#125;while (!workStealingPool.isTerminated()) &#123; &#125;&#125;复制 A：不输出任何结果 B：输出 0 到 4（包含0、4）的有序数字 C：输出 0 到 4（包含0、4）的无序数字 D：以上全对 答：C 题目解析：newWorkStealingPool 内部实现是 ForkJoinPool，它的工作方式是使用分治算法，递归地将任务分割成更小的子任务，然后把子任务分配给不同的线程执行并发执行。 2.Executors 能创建单线程的线程池吗？怎么创建？ 答：Executors 可以创建单线程线程池，创建分为两种方式： Executors.newSingleThreadExecutor()：创建一个单线程线程池。 Executors.newSingleThreadScheduledExecutor()：创建一个可以执行周期性任务的单线程池。 3.Executors 中哪个线程适合执行短时间内大量任务？ 答：newCachedThreadPool() 适合处理大量短时间工作任务。它会试图缓存线程并重用，如果没有缓存任务就会新创建任务，如果线程的限制时间超过六十秒，则会被移除线程池，因此它比较适合短时间内处理大量任务。 4.可以执行周期性任务的线程池都有哪些？ 答：可执行周期性任务的线程池有两个，分别是：newScheduledThreadPool() 和 newSingleThreadScheduledExecutor()，其中 newSingleThreadScheduledExecutor() 是 newScheduledThreadPool() 的单线程版本。 5.JDK 8 新增了什么线程池？有什么特点？ 答：JDK 8 新增的线程池是 newWorkStealingPool(n)，如果不指定并发数（也就是不指定 n），newWorkStealingPool() 会根据当前 CPU 处理器数量生成相应个数的线程池。它的特点是并行处理任务的，不能保证任务的执行顺序。 6.newFixedThreadPool 和 ThreadPoolExecutor 有什么关系？ 答：newFixedThreadPool 是 ThreadPoolExecutor 包装，newFixedThreadPool 底层也是通过 ThreadPoolExecutor 实现的。 newFixedThreadPool 的实现源码如下： 12345678public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125;复制 7.单线程的线程池存在的意义是什么？ 答：单线程线程池提供了队列功能，如果有多个任务会排队执行，可以保证任务执行的顺序性。单线程线程池也可以重复利用已有线程，减低系统创建和销毁线程的性能开销。 8.线程池为什么建议使用 ThreadPoolExecutor 创建，而非 Executors？ 答：使用 ThreadPoolExecutor 能让开发者更加明确线程池的运行规则，避免资源耗尽的风险。 Executors 返回线程池的缺点如下： FixedThreadPool 和 SingleThreadPool 允许请求队列长度为 Integer.MAX_VALUE，可能会堆积大量请求，可能会导致内存溢出； CachedThreadPool 和 ScheduledThreadPool 允许创建线程数量为 Integer.MAX_VALUE，创建大量线程，可能会导致内存溢出。 总结 Executors 可以创建 6 种不同类型的线程池，其中 newFixedThreadPool() 适合执行单位时间内固定的任务数，newCachedThreadPool() 适合短时间内处理大量任务，newSingleThreadExecutor() 和 newSingleThreadScheduledExecutor() 为单线程线程池，而 newSingleThreadScheduledExecutor() 可以执行周期性的任务，是 newScheduledThreadPool(n) 的单线程版本，而 newWorkStealingPool() 为 JDK 8 新增的并发线程池，可以根据当前电脑的 CPU 处理数量生成对比数量的线程池，但它的执行为并发执行不能保证任务的执行顺序。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"19.线程池之 ThreadPoolExecutor + 面试题","slug":"interview-java-19","date":"2020-10-08T06:08:43.000Z","updated":"2020-10-08T06:22:35.906Z","comments":true,"path":"2020/10/08/interview-java-19/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-19/","excerpt":"","text":"线程池之 ThreadPoolExecutor + 面试题 线程池介绍 线程池（Thread Pool）：把一个或多个线程通过统一的方式进行调度和重复使用的技术，避免了因为线程过多而带来使用上的开销。 为什么要使用线程池？ 可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。 避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。 支持更多功能，比如延迟任务线程池（newScheduledThreadPool）和缓存线程池（newCachedThreadPool）等。 线程池使用 创建线程池有两种方式：ThreadPoolExecutor 和 Executors，其中 Executors 又可以创建 6 种不同的线程池类型，会在下节讲，本节重点来看看 ThreadPoolExecutor 的使用。 ThreadPoolExecutor 的使用 线程池使用代码如下： 12345678ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 10, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue(100));threadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; // 执行线程池 System.out.println(&quot;Hello, Java.&quot;); &#125;&#125;); 以上程序执行结果如下： Hello, Java. ThreadPoolExecutor 参数说明 ThreadPoolExecutor 构造方法有以下四个，如下图所示： 其中最后一个构造方法有 7 个构造参数，包含了前三个方法的构造参数，这 7 个参数名称如下所示： 123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; //...&#125; 其代表的含义如下： ① corePoolSize 线程池中的核心线程数，默认情况下核心线程一直存活在线程池中，如果将 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设为 true，如果线程池一直闲置并超过了 keepAliveTime 所指定的时间，核心线程就会被终止。 ② maximumPoolSize 最大线程数，当线程不够时能够创建的最大线程数。 ③ keepAliveTime 线程池的闲置超时时间，默认情况下对非核心线程生效，如果闲置时间超过这个时间，非核心线程就会被回收。如果 ThreadPoolExecutor 的 allowCoreThreadTimeOut 设为 true 的时候，核心线程如果超过闲置时长也会被回收。 ④ unit 配合 keepAliveTime 使用，用来标识 keepAliveTime 的时间单位。 ⑤ workQueue 线程池中的任务队列，使用 execute() 或 submit() 方法提交的任务都会存储在此队列中。 ⑥ threadFactory 为线程池提供创建新线程的线程工厂。 ⑦ rejectedExecutionHandler 线程池任务队列超过最大值之后的拒绝策略，RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution 方法，可在此方法内添加任务超出最大值的事件处理。ThreadPoolExecutor 也提供了 4 种默认的拒绝策略： new ThreadPoolExecutor.DiscardPolicy()：丢弃掉该任务，不进行处理 new ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务 new ThreadPoolExecutor.AbortPolicy()：直接抛出 RejectedExecutionException 异常 new ThreadPoolExecutor.CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务 包含所有参数的 ThreadPoolExecutor 使用代码： 12345678910111213141516171819202122232425262728293031public class ThreadPoolExecutorTest &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(2), new MyThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); threadPool.allowCoreThreadTimeOut(true); for (int i = 0; i &lt; 10; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;&#125;class MyThreadFactory implements ThreadFactory &#123; private AtomicInteger count = new AtomicInteger(0); @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); String threadName = &quot;MyThread&quot; + count.addAndGet(1); t.setName(threadName); return t; &#125;&#125; 线程池执行方法 execute() VS submit() execute() 和 submit() 都是用来执行线程池的，区别在于 submit() 方法可以接收线程池执行的返回值。 下面分别来看两个方法的具体使用和区别： 123456789101112131415161718// 创建线程池ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 10, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue(100));// execute 使用threadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Hello, Java.&quot;); &#125;&#125;);// submit 使用Future&lt;String&gt; future = threadPoolExecutor.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;Hello, 老王.&quot;); return &quot;Success&quot;; &#125;&#125;);System.out.println(future.get()); 以上程序执行结果如下： Hello, Java. Hello, 老王. Success 线程池关闭 线程池关闭，可以使用 shutdown() 或 shutdownNow() 方法，它们的区别是： shutdown()：不会立即终止线程池，而是要等所有任务队列中的任务都执行完后才会终止。执行完 shutdown 方法之后，线程池就不会再接受新任务了。 shutdownNow()：执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，执行此方法会返回未执行的任务。 下面用代码来模拟 shutdown() 之后，给线程池添加任务，代码如下： 1234567891011121314threadPoolExecutor.execute(() -&gt; &#123; for (int i = 0; i &lt; 2; i++) &#123; System.out.println(&quot;I&#x27;m &quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;);threadPoolExecutor.shutdown();threadPoolExecutor.execute(() -&gt; &#123; System.out.println(&quot;I&#x27;m Java.&quot;);&#125;); 以上程序执行结果如下： I’m 0 Exception in thread “main” java.util.concurrent.RejectedExecutionException: Task com.interview.chapter5.Section2$$Lambda$2/1828972342@568db2f2 rejected from java.util.concurrent.ThreadPoolExecutor@378bf509[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0] I’m 1 可以看出，shutdown() 之后就不会再接受新的任务了，不过之前的任务会被执行完成。 相关面试题 1.ThreadPoolExecutor 有哪些常用的方法？ 答：常用方法如下所示： submit()/execute()：执行线程池 shutdown()/shutdownNow()：终止线程池 isShutdown()：判断线程是否终止 getActiveCount()：正在运行的线程数 getCorePoolSize()：获取核心线程数 getMaximumPoolSize()：获取最大线程数 getQueue()：获取线程池中的任务队列 allowCoreThreadTimeOut(boolean)：设置空闲时是否回收核心线程 2.以下程序执行的结果是什么？ 12345678910111213141516ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 10, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue());threadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 2; i++) &#123; System.out.println(&quot;I：&quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;);threadPoolExecutor.shutdownNow();System.out.println(&quot;Java&quot;); 答：程序执行的结果是： I：0 Java java.lang.InterruptedException: sleep interrupted（报错信息） I：1 题目解析：因为程序中使用了 shutdownNow() 会导致程序执行一次之后报错，抛出 sleep interrupted 异常，又因为本身有 try/catch，所以程序会继续执行打印 I：1 。 3.在 ThreadPool 中 submit() 和 execute() 有什么区别？ 答：submit() 和 execute() 都是用来执行线程池的，只不过使用 execute() 执行线程池不能有返回方法，而使用 submit() 可以使用 Future 接收线程池执行的返回值。 submit() 方法源码（JDK 8）如下： 123456public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task &#x3D;&#x3D; null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task); execute(ftask); return ftask;&#125; execute() 源码（JDK 8）如下： 12345public void execute(Runnable command) &#123; if (command &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F;..... 其他&#125; 4.说一下 ThreadPoolExecutor 都需要哪些参数？ 答：ThreadPoolExecutor 最多包含以下七个参数： corePoolSize：线程池中的核心线程数 maximumPoolSize：线程池中最大线程数 keepAliveTime：闲置超时时间 unit：keepAliveTime 超时时间的单位（时/分/秒等） workQueue：线程池中的任务队列 threadFactory：为线程池提供创建新线程的线程工厂 rejectedExecutionHandler：线程池任务队列超过最大值之后的拒绝策略 更多详细介绍，请见正文。 5.在线程池中 shutdownNow() 和 shutdown() 有什么区别？ 答：shutdownNow() 和 shutdown() 都是用来终止线程池的，它们的区别是，使用 shutdown() 程序不会报错，也不会立即终止线程，它会等待线程池中的缓存任务执行完之后再退出，执行了 shutdown() 之后就不能给线程池添加新任务了；shutdownNow() 会试图立马停止任务，如果线程池中还有缓存任务正在执行，则会抛出 java.lang.InterruptedException: sleep interrupted 异常。 6.说一说线程池的工作原理？ 答：当线程池中有任务需要执行时，线程池会判断如果线程数量没有超过核心数量就会新建线程池进行任务执行，如果线程池中的线程数量已经超过核心线程数，这时候任务就会被放入任务队列中排队等待执行；如果任务队列超过最大队列数，并且线程池没有达到最大线程数，就会新建线程来执行任务；如果超过了最大线程数，就会执行拒绝执行策略。 7.以下线程名称被打印了几次？ 1234567891011121314151617ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 10L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(2), new ThreadPoolExecutor.DiscardPolicy());threadPool.allowCoreThreadTimeOut(true);for (int i = 0; i &lt; 10; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; // 打印线程名称 System.out.println(Thread.currentThread().getName()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 答：线程名被打印了 3 次。 题目解析：线程池第 1 次执行任务时，会新创建任务并执行；第 2 次执行任务时，因为没有空闲线程所以会把任务放入队列；第 3 次同样把任务放入队列，因为队列最多可以放两条数据，所以第 4 次之后的执行都会被舍弃（没有定义拒绝策略），于是就打印了 3 次线程名称。 总结 ThreadPoolExecutor 是创建线程池最传统和最推荐使用的方式，创建时要设置线程池的核心线程数和最大线程数还有任务队列集合，如果任务量大于队列的最大长度，线程池会先判断当前线程数量是否已经到达最大线程数，如果没有达到最大线程数就新建线程来执行任务，如果已经达到最大线程数，就会执行拒绝策略（拒绝策略可自行定义）。线程池可通过 submit() 来调用执行，从而获得线程执行的结果，也可以通过 shutdown() 来终止线程池。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"18.为什么需要线程 + 面试题","slug":"interview-java-18","date":"2020-10-08T06:08:40.000Z","updated":"2020-10-08T06:22:20.451Z","comments":true,"path":"2020/10/08/interview-java-18/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-18/","excerpt":"","text":"为什么需要线程 + 面试题 线程介绍 线程（Thread）是程序运行的执行单元，依托于进程存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源、更加轻量化，因而也被称为轻量级的进程。 什么是进程 进程（Processes）是程序的一次动态执行，是系统进行资源分配和调度的基本单位，是操作系统运行的基础，通常每一个进程都拥有自己独立的内存空间和系统资源。简单来说，进程可以被当做是一个正在运行的程序。 为什么需要线程 程序的运行必须依靠进程，进程的实际执行单元就是线程。 为什么需要多线程 多线程可以提高程序的执行性能。例如，有个 90 平方的房子，一个人打扫需要花费 30 分钟，三个人打扫就只需要 10 分钟，这三个人就是程序中的“多线程”。 线程使用 线程的创建，分为以下三种方式： 继承 Thread 类，重写 run 方法 实现 Runnable 接口，实现 run 方法 实现 Callable 接口，实现 call 方法 下面分别来看看线程创建和使用的具体代码。 1）继承 Thread 类 请参考以下代码： 123456789101112class ThreadTest &#123; public static void main(String[] args) throws Exception &#123; MyThread thread = new MyThread(); thread.start(); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;Thread&quot;); &#125;&#125; 以上程序执行结果如下： Thread 2）实现 Runnable 接口 请参考以下代码： 123456789101112class ThreadTest &#123; public static void main(String[] args) &#123; MyRunnable runnable = new MyRunnable(); new Thread(runnable).start(); &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;Runnable&quot;); &#125;&#125; 以上程序执行结果如下： Runnable 3）实现 Callable 接口 请参考以下代码： 123456789101112131415161718class ThreadTest &#123; public static void main(String[] args) throws Exception &#123; MyCallable callable = new MyCallable(); // 定义返回结果 FutureTask&lt;String&gt; result = new FutureTask(callable); // 执行程序 new Thread(result).start(); // 输出返回结果 System.out.println(result.get()); &#125;&#125;class MyCallable implements Callable &#123; @Override public String call() &#123; System.out.println(&quot;Callable&quot;); return &quot;Success&quot;; &#125;&#125; 以上程序执行结果如下： Callable Success 可以看出，Callable 的调用是可以有返回值的，它弥补了之前调用线程没有返回值的情况，它是随着 JDK 1.5 一起发布的。 4）JDK 8 创建线程 JDK 8 之后可以使用 Lambda 表达式很方便地创建线程，请参考以下代码： 1new Thread(() -&gt; System.out.println(&quot;Lambda Of Thread.&quot;)).start(); 线程高级用法 线程等待 使用 wait() 方法实现线程等待，代码如下： 1234567891011121314System.out.println(LocalDateTime.now());Object lock = new Object();Thread thread = new Thread(() -&gt; &#123; synchronized (lock)&#123; try &#123; // 1 秒钟之后自动唤醒 lock.wait(1000); System.out.println(LocalDateTime.now()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);thread.start(); 以上程序执行结果如下： 2019-06-22T20:53:08.776 2019-06-22T20:53:09.788 注意：当使用 wait() 方法时，必须先持有当前对象的锁，否则会抛出异常 java.lang.IllegalMonitorStateException。 线程唤醒 使用 notify()/notifyAll() 方法唤醒线程。 notify() 方法随机唤醒对象的等待池中的一个线程； notifyAll() 唤醒对象的等待池中的所有线程。 使用如下： 1234Object lock = new Object();lock.wait();lock.notify();// lock.notifyAll(); 线程休眠 12// 休眠 1 秒Thread.sleep(1000); 等待线程执行完成 123456789101112Thread joinThread = new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;执行前&quot;); Thread.sleep(1000); System.out.println(&quot;执行后&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;);joinThread.start();joinThread.join();System.out.println(&quot;主程序&quot;); 以上程序执行结果： 执行前 执行后 主程序 yield 交出 CPU 执行权 1234567891011new Thread()&#123; @Override public void run() &#123; for (int i = 1; i &lt; 10; i++) &#123; if (i == 5) &#123; // 让同优先级的线程有执行的机会 this.yield(); &#125; &#125; &#125;&#125;.start(); 注意：yield 方法是让同优先级的线程有执行的机会，但不能保证自己会从正在运行的状态迅速转换到可运行的状态。 线程中断 使用 System.exit(0) 可以让整个程序退出；要中断单个线程，可配合 interrupt() 对线程进行“中断”。 使用代码如下： 1234567891011121314Thread interruptThread = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; System.out.println(&quot;i：&quot; + i); if (this.isInterrupted()) &#123; break; &#125; &#125; &#125;&#125;;interruptThread.start();Thread.sleep(10);interruptThread.interrupt(); 线程优先级 在 Java 语言中，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以使用 setPriority 方法设置（1-10）优先级，默认的优先级是 5，数字越大表示优先级越高，优先级越高的线程可能优先被执行的概率就越大。 设置优先级的代码如下： 123Thread thread = new Thread(() -&gt; System.out.println(&quot;Java&quot;));thread.setPriority(10);thread.start(); 死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 比如，当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 A B 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。 死锁示意图如下所示： 死锁代码： 12345678910111213141516171819202122232425262728293031323334Object obj1 = new Object();Object obj2 = new Object();// 线程1拥有对象1，想要等待获取对象2new Thread() &#123; @Override public void run() &#123; synchronized (obj1) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj2) &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125; &#125;&#125;.start();// 线程2拥有对象2，想要等待获取对象1new Thread() &#123; @Override public void run() &#123; synchronized (obj2) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj1) &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125; &#125;&#125;.start(); 相关面试题 1.线程和进程有什么区别和联系？ 答：从本质上来说，线程是进程的实际执行单元，一个程序至少有一个进程，一个进程至少有一个线程，它们的区别主要体现在以下几个方面： 进程间是独立的，不能共享内存空间和上下文，而线程可以； 进程是程序的一次执行，线程是进程中执行的一段程序片段； 线程占用的资源比进程少。 2.如何保证一个线程执行完再执行第二个线程？ 答：使用 join() 方法，等待上一个线程的执行完之后，再执行当前线程。 示例代码： 123456789101112Thread joinThread = new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;执行前&quot;); Thread.sleep(1000); System.out.println(&quot;执行后&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;);joinThread.start();joinThread.join();System.out.println(&quot;主程序&quot;); 3.线程有哪些常用的方法？ 答：线程的常用方法如下： currentThread()：返回当前正在执行的线程引用 getName()：返回此线程的名称 setPriority()/getPriority()：设置和返回此线程的优先级 isAlive()：检测此线程是否处于活动状态，活动状态指的是程序处于正在运行或准备运行的状态 sleep()：使线程休眠 join()：等待线程执行完成 yield()：让同优先级的线程有执行的机会，但不能保证自己会从正在运行的状态迅速转换到可运行的状态 interrupted()：是线程处于中断的状态，但不能真正中断线程 4.wait() 和 sleep() 有什么区别？ 答：wait() 和 sleep() 的区别主要体现在以下三个方面。 存在类的不同：sleep() 来自 Thread，wait() 来自 Object。 释放锁：sleep() 不释放锁；wait() 释放锁。 用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。 5.守护线程是什么？ 答：守护线程是一种比较低级别的线程，一般用于为其他类别线程提供服务，因此当其他线程都退出时，它也就没有存在的必要了。例如，JVM（Java 虚拟机）中的垃圾回收线程。 6.线程有哪些状态？ 答：在 JDK 8 中，线程的状态有以下六种。 NEW：尚未启动 RUNNABLE：正在执行中 BLOCKED：阻塞（被同步锁或者 IO 锁阻塞） WAITING：永久等待状态 TIMED_WAITING：等待指定的时间重新被唤醒的状态 TERMINATED：执行完成 题目分析：JDK 8 线程状态的源码如下图所示： 7.线程中的 start() 和 run() 有那些区别？ 答：start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 8.产生死锁需要具备哪些条件？ 答：产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个线程使用； 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放； 不剥夺条件：线程已获得的资源，在末使用完之前，不能强行剥夺； 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系； 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 9.如何预防死锁？ 答：预防死锁的方法如下： 尽量使用 tryLock(long timeout, TimeUnit unit) 的方法 (ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁； 尽量使用 Java. util. concurrent 并发类代替自己手写锁； 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁； 尽量减少同步的代码块。 10.thread.wait() 和 thread.wait(0) 有什么区别？代表什么含义？ 答：thread.wait() 和 thread.wait(0) 是相同的，使用 thread.wait() 内部其实是调用的 thread.wait(0)，源码如下： 123public final void wait() throws InterruptedException &#123; wait(0);&#125; wait() 表示进入等待状态，释放当前的锁让出 CPU 资源，并且只能等程序执行 notify()/notifyAll() 方法才会被重写唤醒。 11.如何让两个程序依次输出 11/22/33 等数字，请写出实现代码？ 答：使用思路是在每个线程输出信息之后，让当前线程等待一会再执行下一次操作，具体实现代码如下： 1234567891011121314151617181920new Thread(() -&gt; &#123; for (int i = 1; i &lt; 4; i++) &#123; System.out.println(&quot;线程一：&quot; + i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();new Thread(() -&gt; &#123; for (int i = 1; i &lt; 4; i++) &#123; System.out.println(&quot;线程二：&quot; + i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start(); 程序执行结果如下： 线程一：1 线程二：1 线程二：2 线程一：2 线程二：3 线程一：3 12.说一下线程的调度策略？ 答：线程调度器选择优先级最高的线程运行，但是如果发生以下情况，就会终止线程的运行： 线程体中调用了 yield() 方法，让出了对 CPU 的占用权； 线程体中调用了 sleep() 方法，使线程进入睡眠状态； 线程由于 I/O 操作而受阻塞； 另一个更高优先级的线程出现； 在支持时间片的系统中，该线程的时间片用完。 总结 程序的运行依靠的是进程，而进程的执行依靠的是多个线程，多线程之间可以共享一块内存和一组系统资源，而多进程间通常是相互独立的。线程的创建有三种方式：继承 Thread 重写 run 方法，实现 Runnable 或 Callable 接口，其中 Callable 可以允许线程的执行有返回值，JDK 8 中也可以使用 Lambda 来更加方便的使用线程，线程是有优先级的，优先级从 1-10 ，数字越大优先级越高，也越早被执行。如果两个线程各自拥有一把锁的同时，又同时等待获取对方的锁，就会造成死锁。可以降低锁的粒度或减少同步代码块的范围或使用 Java 提供的安全类，来防止死锁的产生。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"17.JDK 原生动态代理是怎么实现的 + 面试题","slug":"interview-java-17","date":"2020-10-08T06:08:37.000Z","updated":"2020-10-08T06:22:11.556Z","comments":true,"path":"2020/10/08/interview-java-17/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-17/","excerpt":"","text":"JDK 原生动态代理是怎么实现的 + 面试题 反射 反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect）的能力。简单来说就是通过反射，可以在运行期间获取、检测和调用对象的属性和方法。 反射的使用场景 在现实中反射的使用场景有很多，比如以下几个。 使用场景一：编程工具 IDEA 或 Eclipse 等，在写代码时会有代码（属性或方法名）提示，就是因为使用了反射。 使用场景二：很多知名的框架，为了让程序更优雅更简洁，也会使用到反射。 例如，Spring 可以通过配置来加载不同的类，调用不同的方法，代码如下所示： 12&lt;bean id=&quot;person&quot; class=&quot;com.spring.beans.Person&quot; init-method=&quot;initPerson&quot;&gt;&lt;/bean&gt; 例如，MyBatis 在 Mapper 使用外部类的 SQL 构建查询时，代码如下所示： 1234567891011@SelectProvider(type = PersonSql.class, method = &quot;getListSql&quot;)List&lt;Person&gt; getList();class PersonSql &#123; public String getListSql() &#123; String sql = new SQL() &#123;&#123; SELECT(&quot;*&quot;); FROM(&quot;person&quot;); &#125;&#125;.toString(); return sql; &#125;&#125; 使用场景三：数据库连接池，也会使用反射调用不同类型的数据库驱动，代码如下所示： 12345String url = &quot;jdbc:mysql://127.0.0.1:3306/mydb&quot;;String username = &quot;root&quot;;String password = &quot;root&quot;;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);Connection connection = DriverManager.getConnection(url, username, password); 当然反射还有其他很多类似的使用场景，这里就不一一列举，读者可以举一反三，想想在平常的开发中，还有哪些使用了反射功能的场景。 反射的基本使用 下来我们通过反射调用类中的某个方法，来学习反射的基本使用。 使用反射调用类中的方法，分为三种情况： 调用静态方法 调用公共方法 调用私有方法 假设有一个实体类 MyReflect 包含了以上三种方法，代码如下： 123456789101112131415package com.interview.chapter4;class MyReflect &#123; // 静态方法 public static void staticMd() &#123; System.out.println(&quot;Static Method&quot;); &#125; // 公共方法 public void publicMd() &#123; System.out.println(&quot;Public Method&quot;); &#125; // 私有方法 private void privateMd() &#123; System.out.println(&quot;Private Method&quot;); &#125;&#125; 下面分别来看，使用反射如何调用以上三种类型的方法。 ① 反射调用静态方法 123Class myClass = Class.forName(&quot;com.interview.chapter4.MyReflect&quot;);Method method = myClass.getMethod(&quot;staticMd&quot;);method.invoke(myClass); ② 反射调用公共方法 12345Class myClass = Class.forName(&quot;com.interview.chapter4.MyReflect&quot;);// 创建实例对象（相当于 new ）Object instance = myClass.newInstance();Method method2 = myClass.getMethod(&quot;publicMd&quot;);method2.invoke(instance); ③ 反射调用私有方法 123456Class myClass = Class.forName(&quot;com.interview.chapter4.MyReflect&quot;);// 创建实例对象（相当于 new ）Object object = myClass.newInstance();Method method3 = myClass.getDeclaredMethod(&quot;privateMd&quot;);method3.setAccessible(true);method3.invoke(object); 反射使用总结 反射获取调用类可以通过 Class.forName()，反射获取类实例要通过 newInstance()，相当于 new 一个新对象，反射获取方法要通过 getMethod()，获取到类方法之后使用 invoke() 对类方法进行调用。如果是类方法为私有方法的话，则需要通过 setAccessible(true) 来修改方法的访问限制，以上的这些操作就是反射的基本使用。 动态代理 动态代理可以理解为，本来应该自己做的事情，却交给别人代为处理，这个过程就叫做动态代理。 动态代理的使用场景 动态代理被广为人知的使用场景是 Spring 中的面向切面编程（AOP）。例如，依赖注入 @Autowired 和事务注解 @Transactional 等，都是利用动态代理实现的。 动态代理还可以封装一些 RPC 调用，也可以通过代理实现一个全局拦截器等。 动态代理和反射的关系 JDK 原生提供的动态代理就是通过反射实现的，但动态代理的实现方式还可以是 ASM（一个短小精悍的字节码操作框架）、cglib（基于 ASM）等，并不局限于反射。 下面我们分别来看：JDK 原生动态代理和 cglib 的实现。 1）JDK 原生动态代理 123456789101112131415161718192021222324252627282930313233343536373839interface Animal &#123; void eat();&#125;class Dog implements Animal &#123; @Override public void eat() &#123; System.out.println(&quot;The dog is eating&quot;); &#125;&#125;class Cat implements Animal &#123; @Override public void eat() &#123; System.out.println(&quot;The cat is eating&quot;); &#125;&#125;// JDK 代理类class AnimalProxy implements InvocationHandler &#123; private Object target; // 代理对象 public Object getInstance(Object target) &#123; this.target = target; // 取得代理对象 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;调用前&quot;); Object result = method.invoke(target, args); // 方法调用 System.out.println(&quot;调用后&quot;); return result; &#125;&#125;public static void main(String[] args) &#123; // JDK 动态代理调用 AnimalProxy proxy = new AnimalProxy(); Animal dogProxy = (Animal) proxy.getInstance(new Dog()); dogProxy.eat();&#125; 以上代码，我们实现了通过动态代理，在所有请求前、后都打印了一个简单的信息。 注意： JDK Proxy 只能代理实现接口的类（即使是 extends 继承类也是不可以代理的）。 2）cglib 动态代理 要是用 cglib 实现要添加对 cglib 的引用，如果是 maven 项目的话，直接添加以下代码： 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.12&lt;/version&gt;&lt;/dependency&gt; cglib 的具体实现，请参考以下代码： 123456789101112131415161718192021222324252627282930class Panda &#123; public void eat() &#123; System.out.println(&quot;The panda is eating&quot;); &#125;&#125;class CglibProxy implements MethodInterceptor &#123; private Object target; // 代理对象 public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); // 设置父类为实例类 enhancer.setSuperclass(this.target.getClass()); // 回调方法 enhancer.setCallback(this); // 创建代理对象 return enhancer.create(); &#125; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;调用前&quot;); Object result = methodProxy.invokeSuper(o, objects); // 执行方法调用 System.out.println(&quot;调用后&quot;); return result; &#125;&#125;public static void main(String[] args) &#123; // cglib 动态代理调用 CglibProxy proxy = new CglibProxy(); Panda panda = (Panda)proxy.getInstance(new Panda()); panda.eat();&#125; 以上程序执行的结果： 调用前 The panda is eating 调用后 由以上代码可以知道，cglib 的调用通过实现 MethodInterceptor 接口的 intercept 方法，调用 invokeSuper 进行动态代理的。它可以直接对普通类进行动态代理，并不需要像 JDK 代理那样，需要通过接口来完成，值得一提的是 Spring 的动态代理也是通过 cglib 实现的。 注意：cglib 底层是通过子类继承被代理对象的方式实现动态代理的，因此代理类不能是最终类（final），否则就会报错 java.lang.IllegalArgumentException: Cannot subclass final class xxx。 相关面试题 1.动态代理解决了什么问题？ 答：首先它是一个代理机制，如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成，通过代理可以让调用者与实现者之间解耦。比如进行 RPC 调用，通过代理，可以提供更加友善的界面；还可以通过代理，做一个全局的拦截器。 2.动态代理和反射的关系是什么？ 答：反射可以用来实现动态代理，但动态代理还有其他的实现方式，比如 ASM（一个短小精悍的字节码操作框架）、cglib 等。 3.以下描述错误的是？ A：cglib 的性能更高 B：Spring 中有使用 cglib 来实现动态代理 C：Spring 中有使用 JDK 原生的动态代理 D：JDK 原生动态代理性能更高 答：D 题目解析：Spring 动态代理的实现方式有两种：cglib 和 JDK 原生动态代理。 4.请补全以下代码？ 123456789101112131415class MyReflect &#123; // 私有方法 private void privateMd() &#123; System.out.println(&quot;Private Method&quot;); &#125;&#125;class ReflectTest &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123; Class myClass = Class.forName(&quot;MyReflect&quot;); Object object = myClass.newInstance(); // 补充此行代码 method.setAccessible(true); method.invoke(object); &#125;&#125; 答：Method method = myClass.getDeclaredMethod(“privateMd”); 题目解析：此题主要考的是私有方法的获取，私有方法的获取并不是通过 getMethod() 方式，而是通过 getDeclaredMethod() 获取的。 5.cglib 可以代理任何类这句话对吗？为什么？ 答：这句话不完全对，因为 cglib 只能代理可以有子类的普通类，对于像最终类（final），cglib 是不能实现动态代理的，因为 cglib 的底层是通过继承代理类的子类来实现动态代理的，所以不能被继承类无法使用 cglib。 6.JDK 原生动态代理和 cglib 有什么区别？ 答：JDK 原生动态代理和 cglib 区别如下： JDK 原生动态代理是基于接口实现的，不需要添加任何依赖，可以平滑的支持 JDK 版本的升级； cglib 不需要实现接口，可以直接代理普通类，需要添加依赖包，性能更高。 7.为什么 JDK 原生的动态代理必须要通过接口来完成？ 答：这是由于 JDK 原生设计的原因，来看动态代理的实现方法 newProxyInstance() 的源码： 12345678910111213/** * ...... * @param loader the class loader to define the proxy class * @param interfaces the list of interfaces for the proxy class to implement * ...... */ @CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123;// 省略其他代码 来看前两个参数的声明： loader：为类加载器，也就是 target.getClass().getClassLoader() interfaces：接口代理类的接口实现列表 看了上面的参数说明，我们就明白了，要使用 JDK 原生的动态只能通过实现接口来完成。 总结 通过本文可以知道 JDK 原生动态代理是使用反射实现的，但动态代理的实现方式不止有反射，还可以是 ASM（一个短小精悍的字节码操作框架）、cglib（基于 ASM）等。其中 JDK 原生的动态代理是通过接口实现的，而 cglib 是通过子类实现的，因此 cglib 不能代理最终类（final）。而反射不但可以反射调用静态方法，还可以反射调用普通方法和私有方法，其中调用私有方法时要设置 setAccessible 为 true。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"16.java.io 包下的类有哪些 + 面试题","slug":"interview-java-16","date":"2020-10-08T06:08:33.000Z","updated":"2020-10-08T06:22:01.568Z","comments":true,"path":"2020/10/08/interview-java-16/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-16/","excerpt":"","text":"java.io 包下的类有哪些 + 面试题 IO 介绍 IO 是 Input/Output 的缩写，它是基于流模型实现的，比如操作文件时使用输入流和输出流来写入和读取文件等。 IO 分类 传统的 IO，按照流类型我们可以分为： 字符流 字节流 其中，字符流包括 Reader、Writer；字节流包括 InputStream、OutputStream。 传统 IO 的类关系图，如下图所示： IO 使用 了解了 IO 之间的关系，下面我们正式进入实战环节，分别来看字符流（Reader、Writer）和字节流（InputStream、OutputStream）的使用。 ① Writer 使用 Writer 可用来写入文件，请参考以下代码： 1234// 给指定目录下的文件追加信息Writer writer = new FileWriter(&quot;d:\\\\io.txt&quot;,true);writer.append(&quot;老王&quot;);writer.close(); 这几行简单的代码就可以实现把信息 老王 追加到 d:\\\\io.txt 的文件下，参数二表示的是覆盖文字还是追加文字。 ② Reader 使用 Reader 可用来读取文件，请参考以下代码： 123456789Reader reader = new FileReader(&quot;d:\\\\io.txt&quot;);BufferedReader bufferedReader = new BufferedReader(reader);String str = null;// 逐行读取信息while (null != (str = bufferedReader.readLine())) &#123; System.out.println(str);&#125;bufferedReader.close();reader.close(); ③ InputStream 使用 InputStream 可用来读取文件，请参考以下代码： 1234567InputStream inputStream = new FileInputStream(new File(&quot;d:\\\\io.txt&quot;));byte[] bytes = new byte[inputStream.available()];// 读取到 byte 数组inputStream.read(bytes);// 内容转换为字符串String content = new String(bytes, &quot;UTF-8&quot;);inputStream.close(); ④ OutputStream 使用 OutputStream 可用来写入文件，请参考以下代码： 123OutputStream outputStream = new FileOutputStream(new File(&quot;d:\\\\io.txt&quot;),true);outputStream.write(&quot;老王&quot;.getBytes());outputStream.close(); NIO 介绍 上面讲的内容都是 java.io 包下的知识点，但随着 Java 的不断发展，在 Java 1.4 时新的 IO 包出现了 java.nio，NIO（Non-Blocking IO）的出现解决了传统 IO，也就是我们经常说的 BIO（Blocking IO）同步阻塞的问题，NIO 提供了 Channel、Selector 和 Buffer 等概念，可以实现多路复用和同步非阻塞 IO 操作，从而大大提升了 IO 操作的性能。 前面提到同步和阻塞的问题，那下面来看看同步和阻塞结合都有哪些含义。 组合方式 性能分析 同步阻塞 最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态 同步非阻塞 提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。 这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上 异步阻塞 这种方式在分布式数据库中经常用到。例如，在往一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其他机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O；异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况 异步非阻塞 这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。例如，Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高 了解了同步和阻塞的含义，下面来看 NIO 的具体使用，请参考以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int port = 6666;new Thread(new Runnable() &#123; @Override public void run() &#123; try (Selector selector = Selector.open(); ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();) &#123; serverSocketChannel.bind(new InetSocketAddress(InetAddress.getLocalHost(), port)); serverSocketChannel.configureBlocking(false); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) &#123; selector.select(); // 阻塞等待就绪的 Channel Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); while (iterator.hasNext()) &#123; SelectionKey key = iterator.next(); try (SocketChannel channel = ((ServerSocketChannel) key.channel()).accept()) &#123; channel.write(Charset.defaultCharset().encode(&quot;老王，你好~&quot;)); &#125; iterator.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; @Override public void run() &#123; // Socket 客户端 1（接收信息并打印） try (Socket cSocket = new Socket(InetAddress.getLocalHost(), port)) &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(cSocket.getInputStream())); bufferedReader.lines().forEach(s -&gt; System.out.println(&quot;客户端 1 打印：&quot; + s)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; @Override public void run() &#123; // Socket 客户端 2（接收信息并打印） try (Socket cSocket = new Socket(InetAddress.getLocalHost(), port)) &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(cSocket.getInputStream())); bufferedReader.lines().forEach(s -&gt; System.out.println(&quot;客户端 2 打印：&quot; + s)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start(); 以上代码创建了两个 Socket 客户端，用于收取和打印服务器端的消息。 其中，服务器端通过 SelectionKey（选择键）获取到 SocketChannel（通道），而通道都注册到 Selector（选择器）上，所有的客户端都可以获得对应的通道，而不是所有客户端都排队堵塞等待一个服务器连接，这样就实现多路复用的效果了。多路指的是多个通道（SocketChannel），而复用指的是一个服务器端连接重复被不同的客户端使用。 AIO 介绍 AIO（Asynchronous IO）是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 AIO 实现简单的 Socket 服务器，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int port = 8888;new Thread(new Runnable() &#123; @Override public void run() &#123; AsynchronousChannelGroup group = null; try &#123; group = AsynchronousChannelGroup.withThreadPool(Executors.newFixedThreadPool(4)); AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group).bind(new InetSocketAddress(InetAddress.getLocalHost(), port)); server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() &#123; @Override public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) &#123; server.accept(null, this); // 接收下一个请求 try &#123; Future&lt;Integer&gt; f = result.write(Charset.defaultCharset().encode(&quot;Hi, 老王&quot;)); f.get(); System.out.println(&quot;服务端发送时间：&quot; + DateFormat.getDateTimeInstance().format(new Date())); result.close(); &#125; catch (InterruptedException | ExecutionException | IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, AsynchronousServerSocketChannel attachment) &#123; &#125; &#125;); group.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS); &#125; catch (IOException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();// Socket 客户端AsynchronousSocketChannel client = AsynchronousSocketChannel.open();Future&lt;Void&gt; future = client.connect(new InetSocketAddress(InetAddress.getLocalHost(), port));future.get();ByteBuffer buffer = ByteBuffer.allocate(100);client.read(buffer, null, new CompletionHandler&lt;Integer, Void&gt;() &#123; @Override public void completed(Integer result, Void attachment) &#123; System.out.println(&quot;客户端打印：&quot; + new String(buffer.array())); &#125; @Override public void failed(Throwable exc, Void attachment) &#123; exc.printStackTrace(); try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);Thread.sleep(10 * 1000); 相关面试题 1.使用以下哪个方法来判断一个文件是否存在？ A：createFile B：exists C：read D：exist 答：B 2.以下说法错误的是？ A：同步操作不一定会阻塞 B：异步操作不一定会阻塞 C：阻塞一定是同步操作 D：同步或异步都可能会阻塞 答：C 题目解析：异步操作也可能会阻塞，比如分布式集群消息同步，采用的就是异步阻塞的方式。 3.BIO、NIO、AIO 的区别是什么？ 答：它们三者的区别如下。 BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。 NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。 AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，因此人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 简单来说 BIO 就是传统 IO 包，产生的最早；NIO 是对 BIO 的改进提供了多路复用的同步非阻塞 IO，而 AIO 是 NIO 的升级，提供了异步非阻塞 IO。 4.读取和写入文件最简洁的方式是什么？ 答：使用 Java 7 提供的 Files 读取和写入文件是最简洁，请参考以下代码： 1234// 读取文件byte[] bytes = Files.readAllBytes(Paths.get(&quot;d:\\\\io.txt&quot;));// 写入文件Files.write(Paths.get(&quot;d:\\\\io.txt&quot;), &quot;追加内容&quot;.getBytes(), StandardOpenOption.APPEND); 读取和写入都是一行代码搞定，可以说很简洁了。 5.Files 常用方法都有哪些？ 答：Files 是 Java 1.7 提供的，使得文件和文件夹的操作更加方便，它的常用方法有以下几个： Files. exists()：检测文件路径是否存在 Files. createFile()：创建文件 Files. createDirectory()：创建文件夹 Files. delete()：删除一个文件或目录 Files. copy()：复制文件 Files. move()：移动文件 Files. size()：查看文件个数 Files. read()：读取文件 Files. write()：写入文件 6.FileInputStream 可以实现什么功能？ 答：FileInputStream 可以实现文件的读取。 题目解析：因为 FileInputStream 和 FileOutputStream 很容易被记反，FileOutputStream 才是用来写入文件的，所以也经常被面试官问到。 7.不定项选择：为了提高读写性能，可以采用什么流？ A：InputStream B：DataInputStream C：BufferedReader D：BufferedInputStream E：OutputStream F：BufferedOutputStream 答：D、F 题目解析：BufferedInputStream 是一种带缓存区的输入流，在读取字节数据时可以从底层流中一次性读取多个字节到缓存区，而不必每次都调用系统底层；同理，BufferedOutputStream 也是一种带缓冲区的输出流，通过缓冲区输出流，应用程序先把字节写入缓冲区，缓存区满后再调用操作系统底层，从而提高系统性能，而不必每次都去调用系统底层方法。 8.FileInputStream 和 BufferedInputStream 的区别是什么？ 答：FileInputStream 在小文件读写时性能较好，而在大文件操作时使用 BufferedInputStream 更有优势。 9.以下这段代码运行在 Windwos 平台，执行的结果是？ 12Files.createFile(Paths.get(&quot;c:\\\\pf.txt&quot;), PosixFilePermissions.asFileAttribute( EnumSet.of(PosixFilePermission.OWNER_READ))); A：在指定的盘符产生了对应的文件，文件只读 B：在指定的盘符产生了对应的文件，文件只写 C：在指定的盘符产生了对应的文件，文件可读写 D：程序报错 答：D 题目解析：本题目考察的是 Files.createFile 参数传递的问题，PosixFilePermissions 不支持 Windows，因此在 Windows 执行会报错 java.lang.UnsupportedOperationException: ‘posix:permissions’ not supported as initial attribute。 总结 在 Java 1.4 之前只有 BIO（Blocking IO）可供使用，也就是 java.io 包下的那些类，它的缺点是同步阻塞式运行的。随后在 Java 1.4 时，提供了 NIO（Non-Blocking IO）属于 BIO 的升级，提供了同步非阻塞的 IO 操作方式，它的重要组件是 Selector（选择器）、Channel（通道）、Buffer（高效数据容器）实现了多路复用的高效 IO 操作。而 AIO（Asynchronous IO）也叫 NIO 2.0，属于 NIO 的补充和升级，提供了异步非阻塞的 IO 操作。 还有另一个重要的知识点，是 Java 7.0 时新增的 Files 类，极大地提升了文件操作的便利性，比如读、写文件 Files.write()、Files.readAllBytes() 等，都是非常简便和实用的方法。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"15.数据结构之队列的使用 + 面试题","slug":"interview-java-15","date":"2020-10-08T06:08:30.000Z","updated":"2020-10-08T06:21:52.731Z","comments":true,"path":"2020/10/08/interview-java-15/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-15/","excerpt":"","text":"数据结构之队列的使用 + 面试题 队列（Queue）：与栈相对的一种数据结构， 集合（Collection）的一个子类。队列允许在一端进行插入操作，而在另一端进行删除操作的线性表，栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，比如实现消息队列。 Queue 类关系图，如下图所示： 注：为了让读者更直观地理解，上图为精简版的 Queue 类关系图。本文如无特殊说明，内容都是基于 Java 1.8 版本。 队列（Queue） 1）Queue 分类 从上图可以看出 Queue 大体可分为以下三类。 双端队列：双端队列（Deque）是 Queue 的子类也是 Queue 的补充类，头部和尾部都支持元素插入和获取。 阻塞队列：阻塞队列指的是在元素操作时（添加或删除），如果没有成功，会阻塞等待执行。例如，当添加元素时，如果队列元素已满，队列会阻塞等待直到有空位时再插入。 非阻塞队列：非阻塞队列和阻塞队列相反，会直接返回操作的结果，而非阻塞等待。双端队列也属于非阻塞队列。 2）Queue 方法说明 Queue 方法如下图所示： 其中比较常用的方法有以下几个： add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常； offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false； remove(Object)：删除元素，成功返回 true，失败返回 false； poll()：获取并移除此队列的第一个元素，若队列为空，则返回 null； peek()：获取但不移除此队列的第一个元素，若队列为空，则返回 null； element()：获取但不移除此队列的第一个元素，若队列为空，则抛异常。 3）Queue 使用实例 1234567Queue&lt;String&gt; linkedList = new LinkedList&lt;&gt;();linkedList.add(&quot;Dog&quot;);linkedList.add(&quot;Camel&quot;);linkedList.add(&quot;Cat&quot;);while (!linkedList.isEmpty()) &#123; System.out.println(linkedList.poll());&#125; 程序执行结果： Dog Camel Cat 阻塞队列 1）BlockingQueue BlockingQueue 在 java.util.concurrent 包下，其他阻塞类都实现自 BlockingQueue 接口，BlockingQueue 提供了线程安全的队列访问方式，当向队列中插入数据时，如果队列已满，线程则会阻塞等待队列中元素被取出后再插入；当从队列中取数据时，如果队列为空，则线程会阻塞等待队列中有新元素再获取。 BlockingQueue 核心方法 插入方法： add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常； offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false ； put(E)：将元素插入到队列的尾部，如果该队列已满，则一直阻塞。 删除方法： remove(Object)：移除指定元素，成功返回 true，失败返回 false； poll()： 获取并移除队列的第一个元素，如果队列为空，则返回 null； take()：获取并移除队列第一个元素，如果没有元素则一直阻塞。 检查方法： peek()：获取但不移除队列的第一个元素，若队列为空，则返回 null。 2）LinkedBlockingQueue LinkedBlockingQueue 是一个由链表实现的有界阻塞队列，容量默认值为 Integer.MAX_VALUE，也可以自定义容量，建议指定容量大小，默认大小在添加速度大于删除速度情况下有造成内存溢出的风险，LinkedBlockingQueue 是先进先出的方式存储元素。 3）ArrayBlockingQueue ArrayBlockingQueue 是一个有边界的阻塞队列，它的内部实现是一个数组。它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。 ArrayBlockingQueue 也是先进先出的方式存储数据，ArrayBlockingQueue 内部的阻塞队列是通过重入锁 ReenterLock 和 Condition 条件队列实现的，因此 ArrayBlockingQueue 中的元素存在公平访问与非公平访问的区别，对于公平访问队列，被阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。而非公平队列，当队列可用时，阻塞的线程将进入争夺访问资源的竞争中，也就是说谁先抢到谁就执行，没有固定的先后顺序。 示例代码如下： 1234567891011121314151617// 默认非公平阻塞队列ArrayBlockingQueue queue = new ArrayBlockingQueue(6);// 公平阻塞队列ArrayBlockingQueue queue2 = new ArrayBlockingQueue(6,true);// ArrayBlockingQueue 源码展示public ArrayBlockingQueue(int capacity) &#123; this(capacity, false);&#125;public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 4）DelayQueue DelayQueue 是一个支持延时获取元素的无界阻塞队列，队列中的元素必须实现 Delayed 接口，在创建元素时可以指定延迟时间，只有到达了延迟的时间之后，才能获取到该元素。 实现了 Delayed 接口必须重写两个方法 ，getDelay(TimeUnit) 和 compareTo(Delayed)，如下代码所示： 123456789101112class DelayElement implements Delayed &#123; @Override // 获取剩余时间 public long getDelay(TimeUnit unit) &#123; // do something &#125; @Override // 队列里元素的排序依据 public int compareTo(Delayed o) &#123; // do something &#125; &#125; DelayQueue 使用的完整示例，请参考以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class DelayTest &#123; public static void main(String[] args) throws InterruptedException &#123; DelayQueue delayQueue = new DelayQueue(); delayQueue.put(new DelayElement(1000)); delayQueue.put(new DelayElement(3000)); delayQueue.put(new DelayElement(5000)); System.out.println(&quot;开始时间：&quot; + DateFormat.getDateTimeInstance().format(new Date())); while (!delayQueue.isEmpty())&#123; System.out.println(delayQueue.take()); &#125; System.out.println(&quot;结束时间：&quot; + DateFormat.getDateTimeInstance().format(new Date())); &#125; static class DelayElement implements Delayed &#123; // 延迟截止时间（单面：毫秒） long delayTime = System.currentTimeMillis(); public DelayElement(long delayTime) &#123; this.delayTime = (this.delayTime + delayTime); &#125; @Override // 获取剩余时间 public long getDelay(TimeUnit unit) &#123; return unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override // 队列里元素的排序依据 public int compareTo(Delayed o) &#123; if (this.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return 1; &#125; else if (this.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; @Override public String toString() &#123; return DateFormat.getDateTimeInstance().format(new Date(delayTime)); &#125; &#125;&#125; 程序执行结果： 开始时间：2019-6-13 20:40:38 2019-6-13 20:40:39 2019-6-13 20:40:41 2019-6-13 20:40:43 结束时间：2019-6-13 20:40:43 非阻塞队列 ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。 它的入队和出队操作均利用 CAS（Compare And Set）更新，这样允许多个线程并发执行，并且不会因为加锁而阻塞线程，使得并发性能更好。 ConcurrentLinkedQueue 使用示例： 123456ConcurrentLinkedQueue concurrentLinkedQueue = new ConcurrentLinkedQueue();concurrentLinkedQueue.add(&quot;Dog&quot;);concurrentLinkedQueue.add(&quot;Cat&quot;);while (!concurrentLinkedQueue.isEmpty()) &#123; System.out.println(concurrentLinkedQueue.poll());&#125; 执行结果： Dog Cat 可以看出不管是阻塞队列还是非阻塞队列，使用方法都是类似的，区别是底层的实现方式。 优先级队列 PriorityQueue 一个基于优先级堆的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。 PriorityQueue 代码使用示例： 1234567891011121314Queue&lt;Integer&gt; priorityQueue = new PriorityQueue(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; // 非自然排序，数字倒序 return o2 - o1; &#125;&#125;);priorityQueue.add(3);priorityQueue.add(1);priorityQueue.add(2);while (!priorityQueue.isEmpty()) &#123; Integer i = priorityQueue.poll(); System.out.println(i);&#125; 程序执行的结果是： 3 2 1 PriorityQueue 注意的点： PriorityQueue 是非线程安全的，在多线程情况下可使用 PriorityBlockingQueue 类替代； PriorityQueue 不允许插入 null 元素。 相关面试题 1.ArrayBlockingQueue 和 LinkedBlockingQueue 的区别是什么？ 答：ArrayBlockingQueue 和 LinkedBlockingQueue 都实现自阻塞队列 BlockingQueue，它们的区别主要体现在以下几个方面： ArrayBlockingQueue 使用时必须指定容量值，LinkedBlockingQueue 可以不用指定； ArrayBlockingQueue 的最大容量值是使用时指定的，并且指定之后就不允许修改；而 LinkedBlockingQueue 最大的容量为 Integer.MAX_VALUE； ArrayBlockingQueue 数据存储容器是采用数组存储的；而 LinkedBlockingQueue 采用的是 Node 节点存储的。 2.LinkedList 中 add() 和 offer() 有什么关系？ 答：add() 和 offer() 都是添加元素到队列尾部。offer 方法是基于 add 方法实现的，Offer 的源码如下： 123public boolean offer(E e) &#123; return add(e);&#125; 3.Queue 和 Deque 有什么区别？ 答：Queue 属于一般队列，Deque 属于双端队列。一般队列是先进先出，也就是只有先进的才能先出；而双端队列则是两端都能插入和删除元素。 4.LinkedList 属于一般队列还是双端队列？ 答：LinkedList 实现了 Deque 属于双端队列，因此拥有 addFirst(E)、addLast(E)、getFirst()、getLast() 等方法。 5.以下说法错误的是？ A：DelayQueue 内部是基于 PriorityQueue 实现的 B：PriorityBlockingQueue 不是先进先出的数据存储方式 C：LinkedBlockingQueue 默认容量是无限大的 D：ArrayBlockingQueue 内部的存储单元是数组，初始化时必须指定队列容量 答：C 题目解析：LinkedBlockingQueue 默认容量是 Integer.MAX_VALUE，并不是无限大的。 6.关于 ArrayBlockingQueue 说法不正确的是？ A：ArrayBlockingQueue 是线程安全的 B：ArrayBlockingQueue 元素允许为 null C：ArrayBlockingQueue 主要应用场景是“生产者-消费者”模型 D：ArrayBlockingQueue 必须显示地设置容量 答：B 题目解析：ArrayBlockingQueue 不允许元素为 null，如果添加一个 null 元素，会抛 NullPointerException 异常。 7.以下程序执行的结果是什么？ 123PriorityQueue priorityQueue = new PriorityQueue();priorityQueue.add(null);System.out.println(priorityQueue.size()); 答：程序执行报错，PriorityQueue 不能插入 null。 8.Java 中常见的阻塞队列有哪些？ 答：Java 中常见的阻塞队列如下： ArrayBlockingQueue，由数组结构组成的有界阻塞队列； PriorityBlockingQueue，支持优先级排序的无界阻塞队列； SynchronousQueue，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素； LinkedBlockingQueue，由链表结构组成的阻塞队列； DelayQueue，支持延时获取元素的无界阻塞队列。 9.有界队列和无界队列有哪些区别？ 答：有界队列和无界队列的区别如下。 有界队列：有固定大小的队列叫做有界队列，比如：new ArrayBlockingQueue(6)，6 就是队列的大小。 无界队列：指的是没有设置固定大小的队列，这些队列的特点是可以直接入列，直到溢出。它们并不是真的无界，它们最大值通常为 Integer.MAX_VALUE，只是平常很少能用到这么大的容量（超过 Integer.MAX_VALUE），因此从使用者的体验上，就相当于 “无界”。 10.如何手动实现一个延迟消息队列？ 答：说到延迟消息队列，我们应该可以第一时间想到要使用 DelayQueue 延迟队列来解决这个问题。实现思路，消息队列分为生产者和消费者，生产者用于增加消息，消费者用于获取并消费消息，我们只需要生产者把消息放入到 DelayQueue 队列并设置延迟时间，消费者循环使用 take() 阻塞获取消息即可。完整的实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class CustomDelayQueue &#123; // 消息编号 static AtomicInteger MESSAGENO = new AtomicInteger(1); public static void main(String[] args) throws InterruptedException &#123; DelayQueue&lt;DelayedElement&gt; delayQueue = new DelayQueue&lt;&gt;(); // 生产者1 producer(delayQueue, &quot;生产者1&quot;); // 生产者2 producer(delayQueue, &quot;生产者2&quot;); // 消费者 consumer(delayQueue); &#125; //生产者 private static void producer(DelayQueue&lt;DelayedElement&gt; delayQueue, String name) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; // 产生 1~5 秒的随机数 long time = 1000L * (new Random().nextInt(5) + 1); try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 组合消息体 String message = String.format(&quot;%s，消息编号：%s 发送时间：%s 延迟：%s 秒&quot;, name, MESSAGENO.getAndIncrement(), DateFormat.getDateTimeInstance().format(new Date()), time / 1000); // 生产消息 delayQueue.put(new DelayedElement(message, time)); &#125; &#125; &#125;).start(); &#125; //消费者 private static void consumer(DelayQueue&lt;DelayedElement&gt; delayQueue) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; DelayedElement element = null; try &#123; // 消费消息 element = delayQueue.take(); System.out.println(element); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; // 延迟队列对象 static class DelayedElement implements Delayed &#123; // 过期时间（单位：毫秒） long time = System.currentTimeMillis(); // 消息体 String message; // 参数：delayTime 延迟时间（单位毫秒） public DelayedElement(String message, long delayTime) &#123; this.time += delayTime; this.message = message; &#125; @Override // 获取过期时间 public long getDelay(TimeUnit unit) &#123; return unit.convert(time - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override // 队列元素排序 public int compareTo(Delayed o) &#123; if (this.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) return 1; else if (this.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) return -1; else return 0; &#125; @Override public String toString() &#123; // 打印消息 return message + &quot; |执行时间：&quot; + DateFormat.getDateTimeInstance().format(new Date()); &#125; &#125;&#125; 以上程序支持多生产者，执行的结果如下： 生产者1，消息编号：1 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39 生产者2，消息编号：2 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39 生产者1，消息编号：3 发送时间：2019-6-12 20:38:41 延迟：4 秒 |执行时间：2019-6-12 20:38:45 生产者1，消息编号：5 发送时间：2019-6-12 20:38:43 延迟：2 秒 |执行时间：2019-6-12 20:38:45 …… 总结 队列（Queue）按照是否阻塞可分为：阻塞队列 BlockingQueue 和 非阻塞队列。其中，双端队列 Deque 也属于非阻塞队列，双端队列除了拥有队列的先进先出的方法之外，还拥有自己独有的方法，如 addFirst()、addLast()、getFirst()、getLast() 等，支持首未插入和删除元素。队列中比较常用的两个队列还有 PriorityQueue（优先级队列）和 DelayQueue（延迟队列），可使用延迟队列来实现延迟消息队列，这也是面试中比较常考的问题之一。需要面试朋友对延迟队列一定要做到心中有数，动手写一个消息队列也是非常有必要的。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"14.为什么要使用泛型和迭代器 + 面试题","slug":"interview-java-14","date":"2020-10-08T06:08:27.000Z","updated":"2020-10-08T06:21:42.917Z","comments":true,"path":"2020/10/08/interview-java-14/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-14/","excerpt":"","text":"为什么要使用泛型和迭代器 + 面试题 泛型 1）为什么要用泛型？ 在泛型没有诞生之前，我们经常会遇到这样的问题，如以下代码所示： 1234567ArrayList arrayList &#x3D; new ArrayList();arrayList.add(&quot;Java&quot;);arrayList.add(24);for (int i &#x3D; 0; i &lt; arrayList.size(); i++) &#123; String str &#x3D; (String) arrayList.get(i); System.out.println(str);&#125; 看起来好像没有什么大问题，也能正常编译，但真正运行起来就会报错： Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at xxx(xxx.java:12) 类型转换出错，当我们给 ArrayList 放入不同类型的数据，却使用一种类型进行接收的时候，就会出现很多类似的错误，可能更多的时候，是因为开发人员的不小心导致的。那有没有好的办法可以杜绝此类问题的发生呢？这个时候 Java 语言提供了一个很好的解决方案——“泛型”。 2）泛型介绍 泛型：泛型本质上是类型参数化，解决了不确定对象的类型问题。 泛型的使用，请参考以下代码： 12ArrayList&lt;String&gt; arrayList &#x3D; new ArrayList();arrayList.add(&quot;Java&quot;); 这个时候如果给 arrayList 添加非 String 类型的元素，编译器就会报错，提醒开发人员插入相同类型的元素。 报错信息如下图所示： 这样就可以避免开头示例中，类型不一致导致程序运行过程中报错的问题了。 3）泛型的优点 泛型的优点主要体现在以下三个方面。 安全：不用担心程序运行过程中出现类型转换的错误。 避免了类型转换：如果是非泛型，获取到的元素是 Object 类型的，需要强制类型转换。 可读性高：编码阶段就明确的知道集合中元素的类型。 迭代器（Iterator） 1）为什么要用迭代器？ 我们回想一下，在迭代器（Iterator）没有出现之前，如果要遍历数组和集合，需要使用方法。 数组遍历，代码如下： 1234String[] arr &#x3D; new String[]&#123;&quot;Java&quot;, &quot;Java虚拟机&quot;, &quot;Java中文社群&quot;&#125;;for (int i &#x3D; 0; i &lt; arr.length; i++) &#123; String item &#x3D; arr[i];&#125; 集合遍历，代码如下： 12345678List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;() &#123;&#123; add(&quot;Java&quot;); add(&quot;Java虚拟机&quot;); add(&quot;Java中文社群&quot;);&#125;&#125;;for (int i &#x3D; 0; i &lt; list.size(); i++) &#123; String item &#x3D; list.get(i);&#125; 而迭代器的产生，就是为不同类型的容器遍历，提供标准统一的方法。 迭代器遍历，代码如下： 12345Iterator iterator &#x3D; list.iterator();while (iterator.hasNext()) &#123; Object object &#x3D; iterator.next(); &#x2F;&#x2F; do something&#125; 总结：使用了迭代器就可以不用关注容器的内部细节，用同样的方式遍历不同类型的容器。 2）迭代器介绍 迭代器是用来遍历容器内所有元素对象的，也是一种常见的设计模式。 迭代器包含以下四个方法。 hasNext():boolean —— 容器内是否还有可以访问的元素。 next():E —— 返回下一个元素。 remove():void —— 删除当前元素。 forEachRemaining(Consumer):void —— JDK 8 中添加的，提供一个 lambda 表达式遍历容器元素。 迭代器使用如下： 1234567891011121314List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;() &#123;&#123; add(&quot;Java&quot;); add(&quot;Java虚拟机&quot;); add(&quot;Java中文社群&quot;);&#125;&#125;;Iterator iterator &#x3D; list.iterator();&#x2F;&#x2F; 遍历while (iterator.hasNext())&#123; String str &#x3D; (String) iterator.next(); if (str.equals(&quot;Java中文社群&quot;))&#123; iterator.remove(); &#125;&#125;System.out.println(list); 程序执行结果： 1[Java, Java虚拟机] forEachRemaining 使用如下： 1234567List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;() &#123;&#123; add(&quot;Java&quot;); add(&quot;Java虚拟机&quot;); add(&quot;Java中文社群&quot;);&#125;&#125;;&#x2F;&#x2F; forEachRemaining 使用list.iterator().forEachRemaining(item -&gt; System.out.println(item)); 相关面试题 1.为什么迭代器的 next() 返回的是 Object 类型？ 答：因为迭代器不需要关注容器的内部细节，所以 next() 返回 Object 类型就可以接收任何类型的对象。 2.HashMap 的遍历方式都有几种？ 答：HashMap 的遍历分为以下四种方式。 方式一：entrySet 遍历 方式二：iterator 遍历 方式三：遍历所有的 key 和 value 方式四：通过 key 值遍历 以上方式的代码实现如下： 1234567891011121314151617181920212223242526Map&lt;String, String&gt; hashMap &#x3D; new HashMap();hashMap.put(&quot;name&quot;, &quot;老王&quot;);hashMap.put(&quot;sex&quot;, &quot;你猜&quot;);&#x2F;&#x2F; 方式一：entrySet 遍历for (Map.Entry item : hashMap.entrySet()) &#123; System.out.println(item.getKey() + &quot;:&quot; + item.getValue());&#125;&#x2F;&#x2F; 方式二：iterator 遍历Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator &#x3D; hashMap.entrySet().iterator();while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry &#x3D; iterator.next(); System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());&#125;&#x2F;&#x2F; 方式三：遍历所有的 key 和 valuefor (Object k : hashMap.keySet()) &#123; &#x2F;&#x2F; 循环所有的 key System.out.println(k);&#125;for (Object v : hashMap.values()) &#123; &#x2F;&#x2F; 循环所有的值 System.out.println(v);&#125;&#x2F;&#x2F; 方式四：通过 key 值遍历for (Object k : hashMap.keySet()) &#123; System.out.println(k + &quot;:&quot; + hashMap.get(k));&#125; 3.以下关于泛型说法错误的是？ A：泛型可以修饰类 B：泛型可以修饰方法 C：泛型不可以修饰接口 D：以上说法全错 答：选 C，泛型可以修饰类、方法、接口、变量。 例如： 12public interface Iterable&lt;T&gt; &#123;&#125; 4.以下程序执行的结果是什么？ 123List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();System.out.println(list.getClass() == list2.getClass()); 答：程序的执行结果是 true。 题目解析：Java 中泛型在编译时会进行类型擦除，因此 List list 和 List list2 类型擦除后的结果都是 java.util.ArrayLis ，进而 list.getClass() == list2.getClass() 的结果也一定是 true。 5. List 和 List 有什么区别？ 答：List 可以容纳任意类型，只不过 List 被赋值之后，就不允许添加和修改操作了；而 List 和 List 不同的是它在赋值之后，可以进行添加和修改操作，如下图所示： 6.可以把 List 赋值给 List 吗？ 答：不可以，编译器会报错，如下图所示： 7. List 和 List 的区别是什么？ 答： List 和 List 都能存储任意类型的数据，但 List 和 List 的唯一区别就是，List 不会触发编译器的类型安全检查，比如把 List 赋值给 List 是没有任何问题的，但赋值给 List 就不行，如下图所示： 8.以下程序执行的结果是？ 123456789101112131415List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;Java&quot;);list.add(&quot;Java虚拟机&quot;);list.add(&quot;Java中文社群&quot;);Iterator iterator &#x3D; list.iterator();while (iterator.hasNext()) &#123; String str &#x3D; (String) iterator.next(); if (str.equals(&quot;Java中文社群&quot;)) &#123; iterator.remove(); &#125;&#125;while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;System.out.println(&quot;Over&quot;); 答：程序打印结果是 Over。 题目解析：因为第一个 while 循环之后，iterator.hasNext() 返回值就为 false 了，所以不会进入第二个循环，之后打印最后的 Over。 9.泛型的工作原理是什么？为什么要有类型擦除？ 答：泛型是通过类型擦除来实现的，类型擦除指的是编译器在编译时，会擦除了所有类型相关的信息，比如 List 在编译后就会变成 List 类型，这样做的目的就是确保能和 Java 5 之前的版本（二进制类库）进行兼容。 总结 通过本文知道了泛型的优点：安全性、避免类型转换、提高了代码的可读性。泛型的本质是类型参数化，但编译之后会执行类型擦除，这样就可以和 Java 5 之前的二进制类库进行兼容。本文也介绍了迭代器（Iterator）的使用，使用迭代器的好处是不用关注容器的内部细节，用同样的方式遍历不同类型的容器。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"13.集合详解之 Map + 面试题","slug":"interview-java-13","date":"2020-10-08T06:08:24.000Z","updated":"2020-10-08T06:21:31.516Z","comments":true,"path":"2020/10/08/interview-java-13/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-13/","excerpt":"","text":"集合详解之 Map + 面试题 集合有两个大接口：Collection 和 Map，本文重点来讲解集合中另一个常用的集合类型 Map。 以下是 Map 的继承关系图： Map 简介 Map 常用的实现类如下： Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用。 HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代。 TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定 Comparator 来自定义排序。 LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。 Map 常用方法 常用方法包括：put、remove、get、size 等，所有方法如下图： 使用示例，请参考以下代码： 1234567891011121314151617Map hashMap &#x3D; new HashMap();&#x2F;&#x2F; 增加元素hashMap.put(&quot;name&quot;, &quot;老王&quot;);hashMap.put(&quot;age&quot;, &quot;30&quot;);hashMap.put(&quot;sex&quot;, &quot;你猜&quot;);&#x2F;&#x2F; 删除元素hashMap.remove(&quot;age&quot;);&#x2F;&#x2F; 查找单个元素System.out.println(hashMap.get(&quot;age&quot;));&#x2F;&#x2F; 循环所有的 keyfor (Object k : hashMap.keySet()) &#123; System.out.println(k);&#125;&#x2F;&#x2F; 循环所有的值for (Object v : hashMap.values()) &#123; System.out.println(v);&#125; 以上为 HashMap 的使用示例，其他类的使用也是类似。 HashMap 数据结构 HashMap 底层的数据是数组被成为哈希桶，每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。 HashMap 数据结构，如下图： HashMap 重要方法 1）添加方法：put(Object key, Object value) 执行流程如下： 对 key 进行 hash 操作，计算存储 index； 判断是否有哈希碰撞，如果没碰撞直接放到哈希桶里，如果有碰撞则以链表的形式存储； 判断已有元素的类型，决定是追加树还是追加链表，当链表大于等于 8 时，把链表转换成红黑树； 如果节点已经存在就替换旧值； 判断是否超过阀值，如果超过就要扩容。 源码及说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public V put(K key, V value) &#123; // 对 key 进行 hash() return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123; int h; // 对 key 进行 hash() 的具体实现 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算 index，并对 null 做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 节点存在 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 该链为树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 写入 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 超过load factor*current capacity，resize if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; put() 执行流程图如下： 2）获取方法：get(Object key) 执行流程如下： 首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点； 如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对。 源码及说明： 123456789101112131415161718192021222324252627282930313233343536public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/*** 该方法是 Map.get 方法的具体实现* 接收两个参数* @param hash key 的 hash 值，根据 hash 值在节点数组中寻址，该 hash 值是通过 hash(key) 得到的* @param key key 对象，当存在 hash 碰撞时，要逐个比对是否相等* @return 查找到则返回键值对节点对象，否则返回 null*/final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 声明节点数组对象、链表的第一个节点对象、循环遍历时的当前节点对象、数组长度、节点的键对象 // 节点数组赋值、数组长度赋值、通过位运算得到求模结果确定链表的首节点 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // 首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 返回首节点 // 如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对 if ((e = first.next) != null) &#123; // 如果存在下一个节点 e，那么先看看这个首节点是否是个树节点 if (first instanceof TreeNode) // 如果是首节点是树节点，那么遍历树来查找 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 如果首节点不是树节点，就说明还是个普通的链表，那么逐个遍历比对即可 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 比对时还是先看 hash 值是否相同、再看地址或 equals return e; // 如果当前节点e的键对象和key相同，那么返回 e &#125; while ((e = e.next) != null); // 看看是否还有下一个节点，如果有，继续下一轮比对，否则跳出循环 &#125; &#125; return null; // 在比对完了应该比对的树节点 或者全部的链表节点 都没能匹配到 key，那么就返回 null 相关面试题 1.Map 常见实现类有哪些？ 答：Map 的常见实现类如下列表： Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用； HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代； TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定的 Comparator 来自定义排序； LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。 2.使用 HashMap 可能会遇到什么问题？如何避免？ 答：HashMap 在并发场景中可能出现死循环的问题，这是因为 HashMap 在扩容的时候会对链表进行一次倒序处理，假设两个线程同时执行扩容操作，第一个线程正在执行 B→A 的时候，第二个线程又执行了 A→B ，这个时候就会出现 B→A→B 的问题，造成死循环。 解决的方法：升级 JDK 版本，在 JDK 8 之后扩容不会再进行倒序，因此死循环的问题得到了极大的改善，但这不是终极的方案，因为 HashMap 本来就不是用在多线程版本下的，如果是多线程可使用 ConcurrentHashMap 替代 HashMap。 3.以下说法正确的是？ A：Hashtable 和 HashMap 都是非线程安全的 B：ConcurrentHashMap 允许 null 作为 key C：HashMap 允许 null 作为 key D：Hashtable 允许 null 作为 key 答：C 题目解析：Hashtable 是线程安全的，ConcurrentHashMap 和 Hashtable 是不允许 null 作为键和值的。 4.TreeMap 怎么实现根据 value 值倒序？ 答：使用 Collections.sort(list, new Comparator&gt;() 自定义比较器实现，先把 TreeMap 转换为 ArrayList，在使用 Collections.sort() 根据 value 进行倒序，完整的实现代码如下。 1234567891011121314151617TreeMap&lt;String, String&gt; treeMap &#x3D; new TreeMap();treeMap.put(&quot;dog&quot;, &quot;dog&quot;);treeMap.put(&quot;camel&quot;, &quot;camel&quot;);treeMap.put(&quot;cat&quot;, &quot;cat&quot;);treeMap.put(&quot;ant&quot;, &quot;ant&quot;);&#x2F;&#x2F; map.entrySet() 转成 ListList&lt;Map.Entry&lt;String, String&gt;&gt; list &#x3D; new ArrayList&lt;&gt;(treeMap.entrySet());&#x2F;&#x2F; 通过比较器实现比较排序Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() &#123; public int compare(Map.Entry&lt;String, String&gt; m1, Map.Entry&lt;String, String&gt; m2) &#123; return m2.getValue().compareTo(m1.getValue()); &#125;&#125;);&#x2F;&#x2F; 打印结果for (Map.Entry&lt;String, String&gt; item : list) &#123; System.out.println(item.getKey() + &quot;:&quot; + item.getValue());&#125; 程序执行结果： 1234dog:dogcat:catcamel:camelant:ant 5.以下哪个 Set 实现了自动排序？ A：LinedHashSet B：HashSet C：TreeSet D：AbstractSet 答：C 6.以下程序运行的结果是什么？ 123Hashtable hashtable &#x3D; new Hashtable();hashtable.put(&quot;table&quot;, null);System.out.println(hashtable.get(&quot;table&quot;)); 答：程序执行报错：java.lang.NullPointerException。Hashtable 不允许 null 键和值。 7.HashMap 有哪些重要的参数？用途分别是什么？ 答：HashMap 有两个重要的参数：容量（Capacity）和负载因子（LoadFactor）。 容量（Capacity）：是指 HashMap 中桶的数量，默认的初始值为 16。 负载因子（LoadFactor）：也被称为装载因子，LoadFactor 是用来判定 HashMap 是否扩容的依据，默认值为 0.75f，装载因子的计算公式 = HashMap 存放的 KV 总和（size）/ Capacity。 8.HashMap 和 Hashtable 有什么区别？ 答：HashMap 和 Hashtable 区别如下： Hashtable 使用了 synchronized 关键字来保障线程安全，而 HashMap 是非线程安全的； HashMap 允许 K/V 都为 null，而 Hashtable K/V 都不允许 null； HashMap 继承自 AbstractMap 类；而 Hashtable 继承自 Dictionary 类。 9.什么是哈希冲突？ 答：当输入两个不同值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。 10.有哪些方法可以解决哈希冲突？ 答：哈希冲突的常用解决方案有以下 4 种。 开放定址法：当关键字的哈希地址 p=H（key）出现冲突时，以 p 为基础，产生另一个哈希地址 p1，如果 p1 仍然冲突，再以 p 为基础，产生另一个哈希地址 p2，循环此过程直到找出一个不冲突的哈希地址，将相应元素存入其中。 再哈希法：这种方法是同时构造多个不同的哈希函数，当哈希地址 Hi=RH1（key）发生冲突时，再计算 Hi=RH2（key），循环此过程直到找到一个不冲突的哈希地址，这种方法唯一的缺点就是增加了计算时间。 链地址法：这种方法的基本思想是将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。 建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。 11.HashMap 使用哪种方法来解决哈希冲突（哈希碰撞）？ 答：HashMap 使用链表和红黑树来解决哈希冲突，详见本文 put() 方法的执行过程。 12.HashMap 的扩容为什么是 2^n ？ 答：这样做的目的是为了让散列更加均匀，从而减少哈希碰撞，以提供代码的执行效率。 13.有哈希冲突的情况下 HashMap 如何取值？ 答：如果有哈希冲突，HashMap 会循环链表中的每项 key 进行 equals 对比，返回对应的元素。相关源码如下： 12345do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 比对时还是先看 hash 值是否相同、再看地址或 equals return e; // 如果当前节点 e 的键对象和 key 相同，那么返回 e&#125; while ((e = e.next) != null); // 看看是否还有下一个节点，如果有，继续下一轮比对，否则跳出循环 14.以下程序会输出什么结果？ 12345678910111213141516171819202122232425262728class Person &#123; private Integer age; public boolean equals(Object o) &#123; if (o &#x3D;&#x3D; null || !(o instanceof Person)) &#123; return false; &#125; else &#123; return this.getAge().equals(((Person) o).getAge()); &#125; &#125; public int hashCode() &#123; return age.hashCode(); &#125; public Person(int age) &#123; this.age &#x3D; age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125; public Integer getAge() &#123; return age; &#125; public static void main(String[] args) &#123; HashMap&lt;Person, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;(); Person person &#x3D; new Person(18); hashMap.put(person, 1); System.out.println(hashMap.get(new Person(18))); &#125;&#125; 答：1 题目解析：因为 Person 重写了 equals 和 hashCode 方法，所有 person 对象和 new Person(18) 的键值相同，所以结果就是 1。 15.为什么重写 equals() 时一定要重写 hashCode()？ 答：因为 Java 规定，如果两个对象 equals 比较相等（结果为 true），那么调用 hashCode 也必须相等。如果重写了 equals() 但没有重写 hashCode()，就会与规定相违背，比如以下代码（故意注释掉 hashCode 方法）： 12345678910111213141516171819202122232425262728class Person &#123; private Integer age; public boolean equals(Object o) &#123; if (o &#x3D;&#x3D; null || !(o instanceof Person)) &#123; return false; &#125; else &#123; return this.getAge().equals(((Person) o).getAge()); &#125; &#125;&#x2F;&#x2F; public int hashCode() &#123;&#x2F;&#x2F; return age.hashCode();&#x2F;&#x2F; &#125; public Person(int age) &#123; this.age &#x3D; age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125; public Integer getAge() &#123; return age; &#125; public static void main(String[] args) &#123; Person p1 &#x3D; new Person(18); Person p2 &#x3D; new Person(18); System.out.println(p1.equals(p2)); System.out.println(p1.hashCode() + &quot; : &quot; + p2.hashCode()); &#125;&#125; 执行的结果： 12true21685669 : 2133927002 如果重写 hashCode() 之后，执行的结果是： 12true18 : 18 这样就符合了 Java 的规定，因此重写 equals() 时一定要重写 hashCode()。 16.HashMap 在 JDK 7 多线程中使用会导致什么问题？ 答：HashMap 在 JDK 7 中会导致死循环的问题。因为在 JDK 7 中，多线程进行 HashMap 扩容时会导致链表的循环引用，这个时候使用 get() 获取元素时就会导致死循环，造成 CPU 100% 的情况。 17.HashMap 在 JDK 7 和 JDK 8 中有哪些不同？ 答：HashMap 在 JDK 7 和 JDK 8 的主要区别如下。 存储结构：JDK 7 使用的是数组 + 链表；JDK 8 使用的是数组 + 链表 + 红黑树。 存放数据的规则：JDK 7 无冲突时，存放数组；冲突时，存放链表；JDK 8 在没有冲突的情况下直接存放数组，有冲突时，当链表长度小于 8 时，存放在单链表结构中，当链表长度大于 8 时，树化并存放至红黑树的数据结构中。 插入数据方式：JDK 7 使用的是头插法（先将原位置的数据移到后 1 位，再插入数据到该位置）；JDK 8 使用的是尾插法（直接插入到链表尾部/红黑树）。 总结 通过本文可以了解到： Map 的常用实现类 Hashtable 是 Java 早期的线程安全的哈希表实现； HashMap 是最常用的哈希表实现，但它是非线程安全的，可使用 ConcurrentHashMap 替代； TreeMap 是基于红黑树的一种提供顺序访问的哈希表实现； LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。 HashMap 在 JDK 7 可能在扩容时会导致链表的循环引用而造成 CPU 100%，HashMap 在 JDK 8 时数据结构变更为：数组 + 链表 + 红黑树的存储方式，在没有冲突的情况下直接存放数组，有冲突，当链表长度小于 8 时，存放在单链表结构中，当链表长度大于 8 时，树化并存放至红黑树的数据结构中。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"12.集合详解之 Collection + 面试题","slug":"interview-java-12","date":"2020-10-08T06:08:21.000Z","updated":"2020-10-08T06:21:18.289Z","comments":true,"path":"2020/10/08/interview-java-12/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-12/","excerpt":"","text":"集合详解之 Collection + 面试题 先来看看集合的继承关系图，如下图所示： 其中： 外框为虚线的表示接口，边框为实线的表示类； 箭头为虚线的表示实现了接口，箭头为实线的表示继承了类。 为了方便理解，我隐藏了一些与本文内容无关的信息，隐藏的这些内容会在后面的章节中进行详细地介绍。 从图中可以看出，集合的根节点是 Collection，而 Collection 下又提供了两大常用集合，分别是： List：使用最多的有序集合，提供方便的新增、修改、删除的操作； Set：集合不允许有重复的元素，在许多需要保证元素唯一性的场景中使用。 下面我们分别对集合类进行详细地介绍。 集合使用 1）Vector Vector 是 Java 早期提供的线程安全的有序集合，如果不需要线程安全，不建议使用此集合，毕竟同步是有线程开销的。 使用示例代码： 12345Vector vector &#x3D; new Vector();vector.add(&quot;dog&quot;);vector.add(&quot;cat&quot;);vector.remove(&quot;cat&quot;);System.out.println(vector); 程序执行结果：[dog] 2）ArrayList ArrayList 是最常见的非线程安全的有序集合，因为内部是数组存储的，所以随机访问效率很高，但非尾部的插入和删除性能较低，如果在中间插入元素，之后的所有元素都要后移。ArrayList 的使用与 Vector 类似。 3）LinkedList LinkedList 是使用双向链表数据结构实现的，因此增加和删除效率比较高，而随机访问效率较差。 LinkedList 除了包含以上两个类的操作方法之外，还新增了几个操作方法，如 offer() 、peek() 等，具体详情，请参考以下代码： 12345678910LinkedList linkedList &#x3D; new LinkedList();&#x2F;&#x2F; 添加元素linkedList.offer(&quot;bird&quot;);linkedList.push(&quot;cat&quot;);linkedList.push(&quot;dog&quot;);&#x2F;&#x2F; 获取第一个元素System.out.println(linkedList.peek());&#x2F;&#x2F; 获取第一个元素，并删除此元素System.out.println(linkedList.poll());System.out.println(linkedList); 程序的执行结果： 123dogdog[cat, bird] 4）HashSet HashSet 是一个没有重复元素的集合。虽然它是 Set 集合的子类，实际却为 HashMap 的实例，相关源码如下： 123public HashSet() &#123; map &#x3D; new HashMap&lt;&gt;();&#125; 因此 HashSet 是无序集合，没有办法保证元素的顺序性。 HashSet 默认容量为 16，每次扩充 0.75 倍，相关源码如下： 1234public HashSet(Collection&lt;? extends E&gt; c) &#123; map &#x3D; new HashMap&lt;&gt;(Math.max((int) (c.size()&#x2F;.75f) + 1, 16)); addAll(c);&#125; HashSet 的使用与 Vector 类似。 5）TreeSet TreeSet 集合实现了自动排序，也就是说 TreeSet 会把你插入数据进行自动排序。 示例代码如下： 123456TreeSet treeSet &#x3D; new TreeSet();treeSet.add(&quot;dog&quot;);treeSet.add(&quot;camel&quot;);treeSet.add(&quot;cat&quot;);treeSet.add(&quot;ant&quot;);System.out.println(treeSet); 程序执行结果：[ant, camel, cat, dog] 可以看出，TreeSet 的使用与 Vector 类似，只是实现了自动排序。 6）LinkedHashSet LinkedHashSet 是按照元素的 hashCode 值来决定元素的存储位置，但同时又使用链表来维护元素的次序，这样使得它看起来像是按照插入顺序保存的。 LinkedHashSet 的使用与 Vector 类似。 集合与数组 集合和数组的转换可使用 toArray() 和 Arrays.asList() 来实现，请参考以下代码示例： 1234567List&lt;String&gt; list = new ArrayList();list.add(&quot;cat&quot;);list.add(&quot;dog&quot;);// 集合转数组String[] arr = list.toArray(new String[list.size()]);// 数组转集合List&lt;String&gt; list2 = Arrays.asList(arr); 集合与数组的区别，可以参考「数组和排序算法的应用 + 面试题」的内容。 集合排序 在 Java 语言中排序提供了两种方式：Comparable 和 Comparator，它们的区别也是常见的面试题之一。下面我们彻底地来了解一下 Comparable 和 Comparator 的使用与区别。 1）Comparable Comparable 位于 java.lang 包下，是一个排序接口，也就是说如果一个类实现了 Comparable 接口，就意味着该类有了排序功能。 Comparable 接口只包含了一个函数，定义如下： 12345package java.lang;import java.util.*;public interface Comparable &#123; public int compareTo(T o);&#125; Comparable 使用示例，请参考以下代码： 1234567891011121314151617181920212223242526272829303132class ComparableTest &#123; public static void main(String[] args) &#123; Dog[] dogs = new Dog[]&#123; new Dog(&quot;老旺财&quot;, 10), new Dog(&quot;小旺财&quot;, 3), new Dog(&quot;二旺财&quot;, 5), &#125;; // Comparable 排序 Arrays.sort(dogs); for (Dog d : dogs) &#123; System.out.println(d.getName() + &quot;：&quot; + d.getAge()); &#125; &#125;&#125;class Dog implements Comparable&lt;Dog&gt; &#123; private String name; private int age; @Override public int compareTo(Dog o) &#123; return age - o.age; &#125; public Dog(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; 程序执行结果： 123小旺财：3二旺财：5老旺财：10 如果 Dog 类未实现 Comparable 执行代码会报程序异常的信息，错误信息为： Exception in thread “main” java.lang.ClassCastException: xxx cannot be cast to java.lang.Comparable compareTo() 返回值有三种： e1.compareTo(e2) &gt; 0 即 e1 &gt; e2； e1.compareTo(e2) = 0 即 e1 = e2； e1.compareTo(e2) &lt; 0 即 e1 &lt; e2。 2）Comparator Comparator 是一个外部比较器，位于 java.util 包下，之所以说 Comparator 是一个外部比较器，是因为它无需在比较类中实现 Comparator 接口，而是要新创建一个比较器类来进行比较和排序。 Comparator 接口包含的主要方法为 compare()，定义如下： 123public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; Comparator 使用示例，请参考以下代码： 12345678910111213141516171819202122232425262728293031323334class ComparatorTest &#123; public static void main(String[] args) &#123; Dog[] dogs = new Dog[]&#123; new Dog(&quot;老旺财&quot;, 10), new Dog(&quot;小旺财&quot;, 3), new Dog(&quot;二旺财&quot;, 5), &#125;; // Comparator 排序 Arrays.sort(dogs,new DogComparator()); for (Dog d : dogs) &#123; System.out.println(d.getName() + &quot;：&quot; + d.getAge()); &#125; &#125;&#125;class DogComparator implements Comparator&lt;Dog&gt; &#123; @Override public int compare(Dog o1, Dog o2) &#123; return o1.getAge() - o2.getAge(); &#125;&#125;class Dog &#123; private String name; private int age; public Dog(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; 程序执行结果： 123小旺财：3二旺财：5老旺财：10 相关面试题 1.List 和 Set 有什么区别？ 答：区别分为以下几个方面： List 允许有多个 null 值，Set 只允许有一个 null 值； List 允许有重复元素，Set 不允许有重复元素； List 可以保证每个元素的存储顺序，Set 无法保证元素的存储顺序。 2.哪种集合可以实现自动排序？ 答：TreeSet 集合实现了元素的自动排序，也就是说无需任何操作，即可实现元素的自动排序功能。 3.Vector 和 ArrayList 初始化大小和容量扩充有什么区别？ 答：Vector 和 ArrayList 的默认容量都为 10，源码如下。 Vector 默认容量源码： 123public Vector() &#123; this(10);&#125; ArrayList 默认容量源码： 1private static final int DEFAULT_CAPACITY &#x3D; 10; Vector 容量扩充默认增加 1 倍，源码如下： 1234567891011private void grow(int minCapacity) &#123; &#x2F;&#x2F; overflow-conscious code int oldCapacity &#x3D; elementData.length; int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity &#x3D; minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity &#x3D; hugeCapacity(minCapacity); elementData &#x3D; Arrays.copyOf(elementData, newCapacity);&#125; 其中 capacityIncrement 为初始化 Vector 指定的，默认情况为 0。 ArrayList 容量扩充默认增加大概 0.5 倍（oldCapacity + (oldCapacity &gt;&gt; 1)），源码如下（JDK 8）： 1234567891011private void grow(int minCapacity) &#123; &#x2F;&#x2F; overflow-conscious code int oldCapacity &#x3D; elementData.length; int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity &#x3D; minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity &#x3D; hugeCapacity(minCapacity); &#x2F;&#x2F; minCapacity is usually close to size, so this is a win: elementData &#x3D; Arrays.copyOf(elementData, newCapacity);&#125; 4.Vector、ArrayList、LinkedList 有什么区别？ 答：这三者都是 List 的子类，因此功能比较相似，比如增加和删除操作、查找元素等，但在性能、线程安全等方面表现却又不相同，差异如下： Vector 是 Java 早期提供的动态数组，它使用 synchronized 来保证线程安全，如果非线程安全需要不建议使用，毕竟线程同步是有性能开销的； ArrayList 是最常用的动态数组，本身并不是线程安全的，因此性能要好很多，与 Vector 类似，它也是动态调整容量的，只不过 Vector 扩容时会增加 1 倍，而 ArrayList 会增加 50%； LinkedList 是双向链表集合，因此它不需要像上面两种那样调整容量，它也是非线程安全的集合。 5.Vector、ArrayList、LinkedList 使用场景有什么区别？ 答：Vector 和 ArrayList 的内部结构是以数组形式存储的，因此非常适合随机访问，但非尾部的删除或新增性能较差，比如我们在中间插入一个元素，就需要把后续的所有元素都进行移动。 LinkedList 插入和删除元素效率比较高，但随机访问性能会比以上两个动态数组慢。 6.Collection 和 Collections 有什么区别？ 答：Collection 和 Collections 的区别如下： Collection 是集合类的上级接口，继承它的主要有 List 和 Set； Collections 是针对集合类的一个帮助类，它提供了一些列的静态方法实现，如 Collections.sort() 排序、Collections.reverse() 逆序等。 7.以下选项没有继承 Collection 接口的是？ A：List B：Set C：Map D：HashSet 答：C 8.LinkedHashSet 如何保证有序和唯一性？ 答：LinkedHashSet 底层数据结构由哈希表和链表组成，链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。 9.HashSet 是如何保证数据不可重复的？ 答：HashSet 的底层其实就是 HashMap，只不过 HashSet 实现了 Set 接口并且把数据作为 K 值，而 V 值一直使用一个相同的虚值来保存，我们可以看到源码： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;// 调用 HashMap 的 put 方法,PRESENT 是一个至始至终都相同的虚值&#125; 由于 HashMap 的 K 值本身就不允许重复，并且在 HashMap 中如果 K/V 相同时，会用新的 V 覆盖掉旧的 V，然后返回旧的 V，那么在 HashSet 中执行这一句话始终会返回一个 false，导致插入失败，这样就保证了数据的不可重复性。 10.执行以下程序会输出什么结果？为什么？ 123Integer num &#x3D; 10;Integer num2 &#x3D; 5;System.out.println(num.compareTo(num2)); 答：程序输出的结果是 1，因为 Integer 默认实现了 compareTo 方法，定义了自然排序规则，所以当 num 比 num2 大时会返回 1，Integer 相关源码如下： 123456public int compareTo(Integer anotherInteger) &#123; return compare(this.value, anotherInteger.value);&#125;public static int compare(int x, int y) &#123; return (x &lt; y) ? -1 : ((x &#x3D;&#x3D; y) ? 0 : 1);&#125; 11.如何用程序实现后进先出的栈结构？ 答：可以使用集合中的 Stack 实现，Stack 是标准的后进先出的栈结构，使用 Stack 中的 pop() 方法返回栈顶元素并删除该元素，示例代码如下。 12345678Stack stack &#x3D; new Stack();stack.push(&quot;a&quot;);stack.push(&quot;b&quot;);stack.push(&quot;c&quot;);for (int i &#x3D; 0; i &lt; 3; i++) &#123; &#x2F;&#x2F; 移除并返回栈顶元素 System.out.print(stack.pop() + &quot; &quot;);&#125; 程序执行结果：c b a 12.LinkedList 中的 peek() 和 poll() 有什么区别？ 答：peek() 方法返回第一个元素，但不删除当前元素，当元素不存在时返回 null；poll() 方法返回第一个元素并删除此元素，当元素不存在时返回 null。 13.Comparable 和 Comparator 有哪些区别？ 答：Comparable 和 Comparator 的主要区别如下： Comparable 位于 java.lang 包下，而 Comparator 位于 java.util 包下； Comparable 在排序类的内部实现，而 Comparator 在排序类的外部实现； Comparable 需要重写 CompareTo() 方法，而 Comparator 需要重写 Compare() 方法； Comparator 在类的外部实现，更加灵活和方便。 总结 本文介绍的集合都实现自 Collection，因此它们都有同样的操作方法，如 add()、addAll()、remove() 等，Collection 接口的方法列表如下图： 当然部分集合也在原有方法上扩充了自己特有的方法，如 LinkedList 的 offer()、push() 等方法。本文也提供了数组和集合互转方法，List.toArray() 把集合转换为数组，Arrays.asList(array) 把数组转换为集合。最后介绍了 Comparable 和 Comparator 的使用和区别，Comparable 和 Comparator 是 Java 语言排序提供的两种排序方式，Comparable 位于 java.lang 包下，如果一个类实现了 Comparable 接口，就意味着该类有了排序功能；而 Comparator 位于 java.util 包下，是一个外部比较器，它无需在比较类中实现 Comparator 接口，而是要新创建一个比较器类来进行比较和排序。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"11.克隆和序列化应用 + 面试题","slug":"interview-java-11","date":"2020-10-08T06:08:18.000Z","updated":"2020-10-08T06:21:04.677Z","comments":true,"path":"2020/10/08/interview-java-11/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-11/","excerpt":"","text":"克隆和序列化应用 + 面试题 克隆 在开始学习克隆之前，我们先来看看下面的代码，普通的对象复制，存在什么问题？ 123456789101112131415161718192021class CloneTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; // 等号赋值（ 基本类型） int number = 6; int number2 = number; // 修改 number2 的值 number2 = 9; System.out.println(&quot;number：&quot; + number); System.out.println(&quot;number2：&quot; + number2); // 等号赋值（对象） Dog dog = new Dog(); dog.name = &quot;旺财&quot;; dog.age = 5; Dog dog2 = dog; // 修改 dog2 的值 dog2.name = &quot;大黄&quot;; dog2.age = 3; System.out.println(dog.name + &quot;，&quot; + dog.age + &quot;岁&quot;); System.out.println(dog2.name + &quot;，&quot; + dog2.age + &quot;岁&quot;); &#125;&#125; 程序执行结果： 1234number：6number2：9大黄，3岁大黄，3岁 可以看出，如果使用等号复制时，对于值类型来说，彼此之间的修改操作是相对独立的，而对于引用类型来说，因为复制的是引用对象的内存地址，所以修改其中一个值，另一个值也会跟着变化，原理如下图所示： 因此为了防止这种问题的发生，就要使用对象克隆来解决引用类型复制的问题。 1）浅克隆 默认的 clone() 方法，为浅克隆，代码如下： 123456789101112131415161718192021class CloneTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Dog dog &#x3D; new Dog(); dog.name &#x3D; &quot;旺财&quot;; dog.age &#x3D; 5; &#x2F;&#x2F; 克隆 Dog dog3 &#x3D; (Dog) dog.clone(); dog3.name &#x3D; &quot;小白&quot;; dog3.age &#x3D; 2; System.out.println(dog.name + &quot;，&quot; + dog.age + &quot;岁&quot;); System.out.println(dog3.name + &quot;，&quot; + dog3.age + &quot;岁&quot;); &#125;&#125;class Dog implements Cloneable &#123; public String name; public int age; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 程序执行结果： 12旺财，5岁小白，2岁 可以看出使用克隆就可以解决引用类型复制的问题了，原理如下图所示： 以上这种复制方式叫做浅克隆。 浅克隆的实现条件：需要克隆的对象必须实现 Cloneable 接口，并重写 clone() 方法，即可实现对此对象的克隆。 然而使用浅克隆也会存在一个问题，请参考以下代码。 123456789101112131415161718192021222324252627class CloneTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; DogChild dogChild &#x3D; new DogChild(); dogChild.name &#x3D; &quot;二狗&quot;; Dog dog4 &#x3D; new Dog(); dog4.name &#x3D; &quot;大黄&quot;; dog4.dogChild &#x3D; dogChild; Dog dog5 &#x3D; (Dog) dog4.clone(); dog5.name &#x3D; &quot;旺财&quot;; dog5.dogChild.name &#x3D; &quot;狗二&quot;; System.out.println(&quot;dog name 4：&quot;+dog4.name); System.out.println(&quot;dog name 5：&quot;+dog5.name); System.out.println(&quot;dog child name 4：&quot;+dog4.dogChild.name); System.out.println(&quot;dog child name 5：&quot;+dog5.dogChild.name); &#125;&#125;class Dog implements Cloneable &#123; public String name; public DogChild dogChild; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;class DogChild &#123; public String name;&#125; 程序执行结果： 1234dog name 4：大黄dog name 5：旺财dog child name 4：狗二dog child name 5：狗二 也就是说浅克隆，只会复制对象的值类型，而不会复制对象的引用类型。原因如下图所示： 要处理引用类型不被复制的问题，就要使用到深克隆。 2）深克隆 定义：深克隆就是复制整个对象信息，包含值类型和引用类型。 深克隆的实现方式通常包含以下两种。 序列化实现深克隆：先将原对象序列化到内存的字节流中，再从字节流中反序列化出刚刚存储的对象，这个新对象和原对象就不存在任何地址上的共享，这样就实现了深克隆。 所有引用类型都实现克隆：要复制对象的所有引用类型都要实现克隆，所有对象都是复制的新对象，从而实现了深克隆。 深克隆实现方式一：序列化 实现思路：先将要拷贝对象写入到内存中的字节流中，然后再从这个字节流中读出刚刚存储的信息，作为一个新对象返回，那么这个新对象和原对象就不存在任何地址上的共享，自然实现了深拷贝。请参考以下代码： 1234567891011121314151617181920212223242526272829303132333435363738class CloneTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; BirdChild birdChild &#x3D; new BirdChild(); birdChild.name &#x3D; &quot;小小鸟&quot;; Bird bird &#x3D; new Bird(); bird.name &#x3D; &quot;小鸟&quot;; bird.birdChild &#x3D; birdChild; &#x2F;&#x2F; 使用序列化克隆对象 Bird bird2 &#x3D; CloneUtils.clone(bird); bird2.name &#x3D; &quot;黄雀&quot;; bird2.birdChild.name &#x3D; &quot;小黄雀&quot;; System.out.println(&quot;bird name:&quot; + bird.name); System.out.println(&quot;bird child name:&quot; + bird.birdChild.name); System.out.println(&quot;bird name 2:&quot; + bird2.name); System.out.println(&quot;bird child name 2:&quot; + bird2.birdChild.name); &#125;&#125;class CloneUtils &#123; public static &lt;T extends Serializable&gt; T clone(T obj) &#123; T cloneObj &#x3D; null; try &#123; &#x2F;&#x2F;写入字节流 ByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream(); ObjectOutputStream oos &#x3D; new ObjectOutputStream(bo); oos.writeObject(obj); oos.close(); &#x2F;&#x2F;分配内存,写入原始对象,生成新对象 ByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());&#x2F;&#x2F;获取上面的输出字节流 ObjectInputStream oi &#x3D; new ObjectInputStream(bi); &#x2F;&#x2F;返回生成的新对象 cloneObj &#x3D; (T) oi.readObject(); oi.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return cloneObj; &#125;&#125; 程序执行结果： 1234bird name:小鸟bird child name:小小鸟bird name 2:黄雀bird child name 2:小黄雀 深克隆实现方式二：所有引用类型都实现克隆 12345678910111213141516171819202122232425262728293031323334class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ParrotChild parrotChild &#x3D; new ParrotChild(); parrotChild.name &#x3D; &quot;小鹦鹉&quot;; Parrot parrot &#x3D; new Parrot(); parrot.name &#x3D; &quot;大鹦鹉&quot;; parrot.parrotChild &#x3D; parrotChild; &#x2F;&#x2F; 克隆 Parrot parrot2 &#x3D; (Parrot) parrot.clone(); parrot2.name &#x3D; &quot;老鹦鹉&quot;; parrot2.parrotChild.name &#x3D; &quot;少鹦鹉&quot;; System.out.println(&quot;parrot name:&quot; + parrot.name); System.out.println(&quot;parrot child name:&quot; + parrot.parrotChild.name); System.out.println(&quot;parrot name 2:&quot; + parrot2.name); System.out.println(&quot;parrot child name 2:&quot; + parrot2.parrotChild.name); &#125; &#125;class Parrot implements Cloneable &#123; public String name; public ParrotChild parrotChild; @Override protected Object clone() throws CloneNotSupportedException &#123; Parrot bird &#x3D; (Parrot) super.clone(); bird.parrotChild &#x3D; (ParrotChild) parrotChild.clone(); return bird; &#125;&#125;class ParrotChild implements Cloneable &#123; public String name; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 程序执行结果： 1234parrot name:大鹦鹉parrot child name:小鹦鹉parrot name 2:老鹦鹉parrot child name 2:少鹦鹉 序列化和反序列化 1）介绍 内存中的数据对象只有转换成二进制流才能进行数据持久化或者网络传输，将对象转换成二进制流的过程叫做序列化（Serialization）；相反，把二进制流恢复为数据对象的过程就称之为反序列化（Deserialization）。 2）序列化和反序列代码实现 先把对象序列化到磁盘，再从磁盘中反序列化出对象，请参考以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; &#x2F;&#x2F; 对象赋值 User user &#x3D; new User(); user.setName(&quot;老王&quot;); user.setAge(30); System.out.println(user); &#x2F;&#x2F; 创建输出流（序列化内容到磁盘） ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;)); &#x2F;&#x2F; 序列化对象 oos.writeObject(user); oos.flush(); oos.close(); &#x2F;&#x2F; 创建输入流（从磁盘反序列化） ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;test.out&quot;)); &#x2F;&#x2F; 反序列化 User user2 &#x3D; (User) ois.readObject(); ois.close(); System.out.println(user2); &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID &#x3D; 3831264392873197003L; private String name; private int age; @Override public String toString() &#123; return &quot;&#123;name:&quot; + name + &quot;,age:&quot; + age + &quot;&#125;&quot;; &#125; &#x2F;&#x2F; setter&#x2F;getter... public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125;&#125; 程序执行结果： 12&#123;name:老王,age:30&#125;&#123;name:老王,age:30&#125; 更多序列化和反序列化的实现方式以及代码示例，请看下文面试部分的内容。 开发工具设置：IDEA 开启自动生成 serialVersionUID 点击 Settings → Inspections → 搜索 Serialization issues → 勾选 Serializable class without ‘SerialVersionUID’ 保存设置，如下图所示： 设置完之后，光标放到类名上，点击提示，生成 serialVersionUID，如下图所示： 相关面试题 1.serialVersionUID 的作用是什么？ 答：如果显示定义了 serialVersionUID 值之后，可以使序列化和反序列化向后兼容。也就是说如果 serialVersionUID 的值相同，修改对象的字段（删除或增加），程序不会报错，之后给没有的字段赋值为 null，而如果没有指定 serialVersionUID 的值，如果修改对象的字段，程序就会报错。如下图所示： 2.可序列化接口（Serializalbe）的用途是什么？ 答：可序列化 Serializalbe 接口存在于 java.io 包中，构成了 Java 序列化机制的核心，它没有任何方法，它的用途是标记某对象为可序列化对象，指示编译器使用 Java 序列化机制序列化此对象。 3.常用的序列化方式都有哪些？ 答：常用的序列化有以下三种方式： 1）Java 原生序列化方式 请参考以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F; 序列化和反序列化class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; &#x2F;&#x2F; 对象赋值 User user &#x3D; new User(); user.setName(&quot;老王&quot;); user.setAge(30); System.out.println(user); &#x2F;&#x2F; 创建输出流（序列化内容到磁盘） ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;)); &#x2F;&#x2F; 序列化对象 oos.writeObject(user); oos.flush(); oos.close(); &#x2F;&#x2F; 创建输入流（从磁盘反序列化） ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;test.out&quot;)); &#x2F;&#x2F; 反序列化 User user2 &#x3D; (User) ois.readObject(); ois.close(); System.out.println(user2); &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID &#x3D; 5132320539584511249L; private String name; private int age; @Override public String toString() &#123; return &quot;&#123;name:&quot; + name + &quot;,age:&quot; + age + &quot;&#125;&quot;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125;&#125; 2）JSON 格式，可使用 fastjson 或 GSON JSON 是一种轻量级的数据格式，JSON 序列化的优点是可读性比较高，方便调试。我们本篇以 fastjson 的序列化为例，请参考以下代码： 1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F; 序列化和反序列化class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; &#x2F;&#x2F; 对象赋值 User user &#x3D; new User(); user.setName(&quot;老王&quot;); user.setAge(30); System.out.println(user); String jsonSerialize &#x3D; JSON.toJSONString(user); User user3 &#x3D; (User) JSON.parseObject(jsonSerialize, User.class); System.out.println(user3); &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID &#x3D; 5132320539584511249L; private String name; private int age; @Override public String toString() &#123; return &quot;&#123;name:&quot; + name + &quot;,age:&quot; + age + &quot;&#125;&quot;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125;&#125; 3）Hessian 方式序列化 Hessian 序列化的优点是可以跨编程语言，比 Java 原生的序列化和反序列化效率高。 请参考以下示例代码： 123456789101112131415161718192021222324252627282930313233343536// 序列化和反序列化class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; // 序列化 ByteArrayOutputStream bo = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(bo); hessianOutput.writeObject(user); byte[] hessianBytes = bo.toByteArray(); // 反序列化 ByteArrayInputStream bi = new ByteArrayInputStream(hessianBytes); HessianInput hessianInput = new HessianInput(bi); User user4 = (User) hessianInput.readObject(); System.out.println(user4); &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 5132320539584511249L; private String name; private int age; @Override public String toString() &#123; return &quot;&#123;name:&quot; + name + &quot;,age:&quot; + age + &quot;&#125;&quot;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 4.使用克隆有什么好处？ 答：好处包含以下几点。 使用方便：假如要复制一个对象，但这个对象中的部分属性已经被修改过了，如果不使用克隆的话，需要给属性手动赋值，相比克隆而已麻烦很多； 性能高：查看 clone 方法可以知道，它是 native 方法，native 方法是原生函数，使用操作系统底层的语言实现的，因此执行效率更高； 隔离性：克隆可以确保对象操作时相互隔离。 clone() 源代码，如下图： 5.浅克隆和深克隆有什么区别？ 答：区别主要在对引用类型的复制上，具体信息如下。 浅克隆：只会复制对象的值类型，而不会复制对象的引用类型； 深克隆：复制整个对象，包含值类型和引用类型。 6.如何实现浅克隆？ 答：克隆的对象实现 Cloneable 接口，并重写 clone() 方法就可以实现浅克隆了。 7.以下代码执行的结果是？ 12345678910111213141516171819202122232425import java.util.Arrays;class CloneTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; CloneObj cloneObj &#x3D; new CloneObj(); cloneObj.name &#x3D; &quot;老王&quot;; cloneObj.age &#x3D; 30; cloneObj.sistersAge &#x3D; new int[]&#123;18, 19&#125;; CloneObj cloneObj2 &#x3D; (CloneObj) cloneObj.clone(); cloneObj2.name &#x3D; &quot;磊哥&quot;; cloneObj2.age &#x3D; 33; cloneObj2.sistersAge[0] &#x3D; 20; System.out.println(cloneObj.name + &quot;|&quot; + cloneObj2.name); System.out.println(cloneObj.age + &quot;|&quot; + cloneObj2.age); System.out.println(Arrays.toString(cloneObj.sistersAge) + &quot;|&quot; + Arrays.toString(cloneObj2.sistersAge)); &#125;&#125;class CloneObj implements Cloneable &#123; public String name; public int age; public int[] sistersAge; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 答：执行结果如下。 123老王|磊哥30|33[20, 19]|[20, 19] 8.深克隆如何实现？有几种实现方式？ 答：一般实现方式有两种。 通过序列化实现深克隆（序列化实现方式：Java 原生序列化、JSON 序列化、Hessian 序列化）； 所有引用类型都实现克隆，从而实现深克隆。 9.为什么不能直接使用 Object 的 Clone 方法，还要重写 clone() 方法之后才能实现克隆？ 答：直接使用 Object 对象的 clone() 方法会抛出异常，因为 Java Api 规定使用克隆必须实现 Cloneable 接口，并重写 clone() 方法，不然就会抛出 ‘CloneNotSupportedException’ 的异常。 为什么 Java 克隆必须要实现 Cloneable 接口？ 首先 Java 对象需要支持克隆的功能，但不是所有 Java 对象都应该被克隆，这时候需要用户自行决定哪些类可以被克隆，所以就有了这样的设计，实现 Cloneable 接口（空接口）的对象，相当于标记了此对象具备了克隆的功能。 10.序列化可不可以实现深克隆？实现的原理是什么？ 答：先将原对象序列化到内存的字节流中，再从字节流中反序列化出刚刚存储的对象，这个新对象和原对象就不存在任何地址上的共享，这样就实现了深克隆。 11.序列化时某些成员不需要序列化，如何实现？ 答：可以把不需要序列化的成员设置为瞬态（trasient）和静态变量，这样就不会被序列化了，瞬态的使用如下： public transient int num; 12.是否可以自定义序列化过程，覆盖 Java 中的默认序列化过程？ 答：可以，在 Java 中默认序列化一个对象需要调用 ObjectOutputStream.writeObject(saveThisObject) 和 ObjectInputStream.readObject() 读取对象，你可以自定义这两个方法，从而实现自定义序列化的过程。需要注意的重要一点是，记得声明这些方法为私有方法，以避免被继承、重写或重载。 13.在 Java 中的序列化和反序列化过程中使用了哪些方法？ 答：在 Java 中序列化由 java.io.ObjectOutputStream 类完成，该类是一个筛选器流，它封装在较低级别的字节流中，以处理序列化机制。要通过序列化机制存储任何对象，我们需要调用 ObjectOutputStream.writeObject(savethisobject) 方法，如果要反序列化该对象，我们需要调用 ObjectInputStream.readObject() 方法，readObject() 方法会读取字节，并把这些字节转换为对象再返回。 总结 序列化常见的使用场景是远程服务调用（RPC）和网络对象传输等，可通过 implements Serializable 来实现对象序列化，在序列化对象中通过定义 serialVersionUID 来防止执行不兼容的类更改。调用 Object 类中的 clone() 方法默认是浅克隆，浅克隆只能复制值类型，不能复制引用类型，因此更多的时候我们需要深克隆，深克隆通常的实现方式有两种：序列化和所有引用类型都实现克隆。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"10.抽象类和接口的应用 + 面试题","slug":"interview-java-10","date":"2020-10-08T06:08:14.000Z","updated":"2020-10-08T06:20:48.799Z","comments":true,"path":"2020/10/08/interview-java-10/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-10/","excerpt":"","text":"抽象类和接口的应用 + 面试题 抽象类 定义 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。简单来说，使用关键字 abstract 修饰的类就叫做抽象类。 抽象类使用 示例代码，如下： 1234567891011121314151617181920212223abstract class AbstractAnimal &#123; public AbstractAnimal() &#123; System.out.println(&quot;Init AbstractAnimal.&quot;); &#125; static String name &#x3D; &quot;AbstractAnimal&quot;; public abstract void eat(); public void run() &#123; System.out.println(&quot;AbstractAnimal Run.&quot;); &#125;&#125;class Animal extends AbstractAnimal &#123; public static void main(String[] args) &#123; AbstractAnimal animal &#x3D; new Animal(); animal.run(); System.out.println(animal.name); animal.eat(); &#125; &#x2F;&#x2F; 必须重写抽象父类方法 @Override public void eat() &#123; System.out.println(&quot;Animal Eat.&quot;); &#125;&#125; 以上代码执行的结果： 1234Init AbstractAnimal.AbstractAnimal Run.AbstractAnimalAnimal Eat. 抽象方法 使用 abstract 关键字修饰的方法叫做抽象方法，抽象方法仅有声明没有方法体。如下代码： 1public abstract void m(); 抽象类的特性 抽象类不能被初始化 抽象类可以有构造方法 抽象类的子类如果为普通类，则必须重写抽象类中的所有抽象方法 抽象类中的方法可以是抽象方法或普通方法 一个类中如果包含了一个抽象方法，这个类必须是抽象类 子类中的抽象方法不能与父类中的抽象方法同名 抽象方法不能为 private、static、final 等关键字修饰 抽象类中可以包含普通成员变量，访问类型可以任意指定，也可以使用静态变量（static） 接口 定义 接口（interface）是抽象类的延伸，它允许一个类可以实现多个接口，弥补了抽象类不能多继承的缺陷，接口是对类的描述，使用 interface 关键字来声明。 接口使用 示例代码，如下： 12345678910111213interface IAnimal &#123; void run();&#125;class AnimalImpl implements IAnimal &#123; public static void main(String[] args) &#123; IAnimal animal &#x3D; new AnimalImpl(); animal.run(); &#125; @Override public void run() &#123; System.out.println(&quot;AnimalImpl Run.&quot;); &#125;&#125; Java 8 中接口的改动 1）接口中增加了 default 方法和 static 方法，可以有方法体 示例代码，如下： 123456789101112131415interface IAnimal &#123; static void printSex() &#123; System.out.println(&quot;Male Dog&quot;); &#125; default void printAge() &#123; System.out.println(&quot;18&quot;); &#125;&#125;class AnimalImpl implements IAnimal &#123; public static void main(String[] args) &#123; IAnimal.printSex(); IAnimal animal &#x3D; new AnimalImpl(); animal.printAge(); &#125;&#125; 注意：static 方法属于接口方法，可以直接使用；default 属于实例方法，必须先创建实例。 2）接口中的静态变量会被继承 示例代码，如下： 123456789101112interface IAnimal &#123; static String animalName &#x3D; &quot;Animal Name&quot;; static void printSex() &#123; System.out.println(&quot;Male Dog&quot;); &#125;&#125;class AnimalImpl implements IAnimal &#123; public static void main(String[] args) &#123; System.out.println(animalName); IAnimal.printSex(); &#125;&#125; 注意：静态变量会被继承，静态方法不会被继承。 3）新增函数式接口 函数式接口（Function Interface）是一个特殊的接口，使用 @FunctionInterface 注解声明，定义这种接口可以使用 Lambda 表达式直接调用。 示例代码，如下： 1234567891011121314151617@FunctionalInterfaceinterface IAnimal &#123; static String animalName &#x3D; &quot;Animal Name&quot;; static void printSex() &#123; System.out.println(&quot;Male Dog&quot;); &#125; default void printAge() &#123; System.out.println(&quot;18&quot;); &#125; void sayHi(String name);&#125;class FunctionInterfaceTest &#123; public static void main(String[] args) &#123; IAnimal animal &#x3D; name -&gt; System.out.println(name); animal.sayHi(&quot;WangWang&quot;); &#125;&#125; 注意：使用 @FunctionInterface 声明的函数式接口，抽象方法必须有且仅有一个，但可以包含其他非抽象方法。 相关面试题 1.抽象类中能不能包含方法体？ 答：抽象类中可以包含方法体。抽象类的构成也可以完全是包含方法体的普通方法，只不过这样并不是抽象类最优的使用方式。 题目解析：包含了方法体的抽象类示例代码如下： 1234567891011abstract class AbstractAnimal &#123; public void run() &#123; System.out.println(&quot;AbstractAnimal Run.&quot;); &#125;&#125;class Animal extends AbstractAnimal &#123; public static void main(String[] args) &#123; AbstractAnimal animal &#x3D; new Animal(); animal.run(); &#125;&#125; 以上代码执行的结果是： AbstractAnimal Run. 2.抽象类能不能被实例化？为什么？ 答：抽象类不能被实例化，因为抽象类和接口的设计就是用来规定子类行为特征的，就是让其他类来继承，是多态思想的一种设计体现，所以强制规定抽象类不能被实例化。 3.抽象方法可以被 private 修饰吗？为什么？ 答：抽象方法不能使用 private 修饰，因为抽象方法就是要子类继承重写的，如果设置 private 则子类不能重写此抽象方法，这与抽象方法的设计理念相违背，所以不能被 private 修饰。 4.添加以下哪个选项不会引起编译器报错？ 1234abstract class AbstractAnimal &#123; static String animalName = &quot;AbstractAnimal&quot;; // 添加代码处&#125; A：protected abstract void eat(); B： void eat(); C：abstract void eat(){}; D：animalName += “Cat”; 答：A 题目解析：选项 B 普通方法必须有方法体；选项 C 抽象方法不能有方法体；选项 D 变量赋值操作必须在方法内。 5.以下关于抽象类和抽象方法说法正确的是？ A：抽象类中的方法必须全部为抽象方法 B： 抽象类中必须包含一个抽象方法 C：抽象类中不能包含普通方法 D：抽象类中的方法可以全部为普通方法（包含方法体） 答：D 题目解析：抽象类中可以没有方法或者全部为普通方法，都是允许的，如下代码所示： 1234567891011abstract class AbstractAnimal &#123; public void run() &#123; System.out.println(&quot;AbstractAnimal Run.&quot;); &#125;&#125;class Animal extends AbstractAnimal &#123; public static void main(String[] args) &#123; AbstractAnimal animal = new Animal(); animal.run(); &#125;&#125; 程序执行的结果为：AbstractAnimal Run. 6.接口和普通类有什么关系？ 答：在 Java 语言设计中，接口不是类，而是对类的一组需求描述，这些类必须要遵循接口描述的统一格式进行定义。 7.接口能不能有方法体？ 答：JDK 8 之前接口不能有方法体，JDK 8 之后新增了 static 方法和 default 方法，可以包含方法体。 8.执行以下代码会输出什么结果？ 123456789interface IAnimal &#123; static String animalName &#x3D; &quot;Animal Name&quot;;&#125;class AnimalImpl implements IAnimal &#123; static String animalName &#x3D; new String(&quot;Animal Name&quot;); public static void main(String[] args) &#123; System.out.println(IAnimal.animalName &#x3D;&#x3D; animalName); &#125;&#125; 答：执行的结果为 false。 题目解析：子类使用 new String… 重新创建了变量 animalName，又因为使用 == 进行内存地址比较，所以结果就是 false。 9.抽象类和接口有什么区别？ 答：抽象类和接口的区别，主要分为以下几个部分。 默认方法 抽象类可以有默认方法的实现 JDK 8 之前接口不能有默认方法的实现，JDK 8 之后接口可以有默认方法的实现 继承方式 子类使用 extends 关键字来继承抽象类 子类使用 implements 关键字类实现接口 构造器 抽象类可以有构造器 接口不能有构造器 方法访问修饰符 抽象方法可以用 public / protected / default 等修饰符 接口默认是 public 访问修饰符，并且不能使用其他修饰符 多继承 一个子类只能继承一个抽象类 一个子类可以实现多个接口 10.以下抽象方法描述正确的是？ A：抽象方法可以是静态（static）的 B：抽象方法可同时是本地方法（native） C：抽象方法可以被 synchronized 修饰 D：以上都不是 答：D 题目解析：抽象方法需要被子类重写，而静态方法是无法被重写的，因此抽象方法不能被静态（static）修饰；本地方法是由本地代码实现的方法，而抽象方法没有实现，所以抽象方法不能同时是本地方法；synchronized 和方法的实现细节有关，而抽象方法不涉及实现细节，因此抽象方法不能被 synchronized 修饰。 总结 抽象类和接口都是面向对象编程中多态的具体实现，在 Java 编程思想中占据着重要的地位，同时也是初级面试岗位必问的问题之一，但由于接口在 JDK 8 中的改动比较大，因而面试者在网上搜到的绝大数关于接口和抽象类区别的答案也是不准确的，这点需要面试者特别注意一下。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"9.各种内部类和枚举类的使用 + 面试题","slug":"interview-java-9","date":"2020-10-08T06:08:10.000Z","updated":"2020-10-08T06:28:28.914Z","comments":true,"path":"2020/10/08/interview-java-9/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-9/","excerpt":"","text":"各种内部类和枚举类的使用 + 面试题 内部类不仅经常出现在各种面试题中，还会在 Java 源码中频频出现，因此只有搞明白了 Java 内部类，才能搞定面试和看懂各种 Java 源码。 内部类 Java 内部类，分为以下四种： 成员内部类 静态成员内部类 局部内部类 匿名内部类 下面分别来看这些内部类的使用。 成员内部类 定义 在一个类中定义了另一个类，则将定义在类中的那个类称之为成员内部类。成员内部类也是最普通的内部类。 使用 成员内部类的使用示例如下： 12345678910class Outer &#123; public Outer() &#123; System.out.println(&quot;Outer Class.&quot;); &#125; class Inner &#123; public void sayHi() &#123; System.out.println(&quot;Hi, Inner.&quot;); &#125; &#125;&#125; 其中 Inner 类则为成员内部类。 而成员内部类的创建和使用，请参考以下完整的示例代码： 123456789101112131415161718class InnerTest &#123; public static void main(String[] args) &#123; Outer out &#x3D; new Outer(); &#x2F;&#x2F; 创建成员内部类 Outer.Inner inner &#x3D; out.new Inner(); inner.sayHi(); &#125;&#125;class Outer &#123; public Outer() &#123; System.out.println(&quot;Outer Class.&quot;); &#125; class Inner &#123; public void sayHi() &#123; System.out.println(&quot;Hi, Inner.&quot;); &#125; &#125;&#125; 成员内部类的创建 语法： Outer.Inner inner = new Outer().new Inner(); 内部类访问外部类 语法： Outer.this.xxx 代码示例： 1234567891011121314151617181920class Outer &#123; private String name &#x3D; &quot;OuterClass&quot;; public void sayHi() &#123; System.out.println(&quot;Hi, Outer.&quot;); &#125; class Inner &#123; public void sayHi() &#123; &#x2F;&#x2F; 内部类访问外部类 Outer.this.sayHi(); System.out.println(Outer.this.name); System.out.println(&quot;Hi, Inner.&quot;); &#125; &#125;&#125;class InnerTest &#123; public static void main(String[] args) &#123; Outer.Inner inner &#x3D; new Outer().new Inner(); inner.sayHi(); &#125;&#125; 外部类访问内部类 语法： new Inner().xxx 代码示例： 1234567891011121314151617class Outer &#123; public void sayHi() &#123; System.out.println(new Inner().name); System.out.println(&quot;Hi, Outer.&quot;); &#125; private class Inner &#123; String name &#x3D; &quot;InnerClass&quot;; public void sayHi() &#123; System.out.println(&quot;Hi, Inner.&quot;); &#125; &#125;&#125;class InnerTest &#123; public static void main(String[] args) &#123; new Outer().sayHi(); &#125;&#125; 小结 成员内部类可直接访问外部类（使用：外部类.this.xxx）； 外部成员类要访问内部类，必须先建立成员内部类对象； 成员内部类可使用任意作用域修饰（public、protected、默认、private）； 成员内部类可访问外部类任何作用域修饰的属性和方法； 外部类建立成员内部类对象之后，可以访问任何作用域修饰的内部类属性和方法。 静态成员内部类 定义 在一个类中定义了另一个 static 类，则将定义在类中的那个 static 类称之为静态成员内部类。 静态成员内部类也就是给内部成员类加上 static 修饰符。 使用 静态成员内部类的使用示例如下： 12345678910111213141516class OuterClass &#123; public OuterClass() &#123; System.out.println(&quot;OuterClass Init.&quot;); &#125; protected static class InnerClass &#123; public void sayHi() &#123; System.out.println(&quot;Hi, InnerClass.&quot;); &#125; &#125;&#125;class InnerClassTest &#123; public static void main(String[] args) &#123; OuterClass.InnerClass innerClass &#x3D; new OuterClass.InnerClass(); innerClass.sayHi(); &#125;&#125; 与内部成员类的创建方式 new Outer().new Inner() 不同，静态成员内部类可使用 new OuterClass.InnerClass() 的方式进行创建。 注意：不能从静态成员内部类中访问非静态外部类对象。 局部内部类 定义 一个类定义在另一个类的局部（方法或者任意作用域），这个类就称之为局部内部类。 使用 局部内部类的使用示例如下： 12345678910111213141516class OutClass &#123; public void sayHi() &#123; class InnerClass &#123; InnerClass(String name) &#123; System.out.println(&quot;InnerClass:&quot; + name); &#125; &#125; System.out.println(new InnerClass(&quot;Three&quot;)); System.out.println(&quot;Hi, OutClass&quot;); &#125;&#125;class OutTest &#123; public static void main(String[] args) &#123; new OutClass().sayHi(); &#125;&#125; 局部内部类特点 局部内部类不能使用任何访问修饰符； 局部类如果在方法中，可以直接使用方法中的变量，不需要通过 OutClass.this.xxx 的方式获得。 匿名内部类 定义 没有名字的内部类就叫做匿名内部类。 使用 匿名内部类的使用示例如下： 1234567891011121314interface AnonymityOuter &#123; void hi();&#125;class AnonymityTest &#123; public static void main(String[] args) &#123; AnonymityOuter anonymityOuter &#x3D; new AnonymityOuter() &#123; @Override public void hi() &#123; System.out.println(&quot;Hi, AnonymityOuter.&quot;); &#125; &#125;; anonymityOuter.hi(); &#125;&#125; 其中，new AnonymityOuter() 之后的 {…} 大括号包含的部分就为匿名内部类。 匿名内部类特点 匿名内部类必须继承一个父类或者实现一个接口 匿名内部类不能定义任何静态成员和方法 匿名内部类中的方法不能是抽象的 枚举类 枚举类是 JDK 1.5 引入的新特性，使用关键字“enum”声明。枚举功能虽小，却非常实用，大大方便了程序的开发者。 枚举类的使用 请参考以下代码： 123456789101112131415161718192021222324252627enum ColorEnum &#123; RED, BLUE, YELLOW, GREEN&#125;class EnumTest &#123; public static void main(String[] args) &#123; ColorEnum color &#x3D; ColorEnum.GREEN; switch (color) &#123; case RED: System.out.println(&quot;Red&quot;); break; case BLUE: System.out.println(&quot;Blue&quot;); break; case YELLOW: System.out.println(&quot;Yellow&quot;); break; case GREEN: System.out.println(&quot;Green&quot;); break; default: break; &#125; &#125;&#125; 枚举类命名规范 《阿里巴巴 Java 开发手册》对枚举类的命名规范建议，如下图： 扩展枚举类 我们可以自定义一些枚举类方法，扩展枚举类的使用，请参考以下代码： 123456789101112131415161718192021222324252627282930enum ColorsEnum &#123; RED(&quot;红色&quot;, 1), BLUE(&quot;蓝色&quot;, 2), YELLOW(&quot;黄色&quot;, 3), GREEN(&quot;绿色&quot;, 4); ColorsEnum(String name, int index) &#123; this.name &#x3D; name; this.index &#x3D; index; &#125; private String name; private int index; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index &#x3D; index; &#125;&#125;class EnumTest &#123; public static void main(String[] args) &#123; System.out.println(ColorsEnum.RED.getName()); System.out.println(ColorsEnum.RED.getIndex()); &#125;&#125; 执行以上代码返回的结果： 12红色1 相关面试题 1.Java 中的内部类有哪些？ 答：内部类包含以下 4 种： 静态内部类：static class StaticInnerClass{}； 成员内部类：private class InstanceInnerClass{}； 局部内部类：定义在方法或者表达式内部； 匿名内部类：(new Thread(){}).start()。 2.以下关于匿名内部类说法错误的是？ A：匿名内部类必须继承一个父类或者实现一个接口 B：匿名内部类中的方法不能是抽象的 C：匿名内部类可以实现接口的部分抽象方法 D：匿名内部类不能定义任何静态成员和方法 答：C 题目解析：匿名内部类规定必须实现接口的所有抽象方法，否则程序会报错，如下图所示。 3.以下枚举类比较“==”和“equals”结果一致吗？为什么？ 123456789101112class EnumTest &#123; public static void main(String[] args) &#123; ColorEnum redColor = ColorEnum.RED; ColorEnum redColor2 = ColorEnum.RED; System.out.println(redColor == redColor2); System.out.println(redColor.equals(redColor2)); &#125;&#125;enum ColorEnum &#123; RED, BLUE&#125; 答：结果一致，都是 true。 题目分析：因为枚举类重写了 equals 方法，equals 方法里直接使用的 == 比较的，而枚举类不能通过 new 进行创建，使用 ColorEnum.RED 得到的对象，其实使用的是对象的引用地址，所以 == 比较的结果一定是 true。equals 被重写的源码如下图： 4.使用静态内部类的好处有哪些？ 答：使用静态内部类的好处如下： 作用域不会扩散到包外； 可以通过“外部类.内部类”的方式直接访问； 内部类可以访问外部类中的所有静态属性和方法。 5.以下代码执行的结果是？ 123456789101112131415class OuterClass &#123; String name &#x3D; &quot;OuterClass&quot;; protected static class InnerClass &#123; String name &#x3D; &quot;InnerClass&quot;; public void sayHi() &#123; System.out.println(OuterClass.this.name); &#125; &#125;&#125;class InnerClassTest &#123; public static void main(String[] args) &#123; OuterClass.InnerClass innerClass &#x3D; new OuterClass.InnerClass(); innerClass.sayHi(); &#125;&#125; 答：程序报错。 题目解析：在静态成员内部类中不能直接访问非静态外部类，因此程序会报错。 6.成员内部类和局部内部类有什么区别？ 答：内部成员类和局部内部类的区别如下。 内部成员类可以使用任意访问修饰符，局部内部类不能使用任何访问修饰符； 局部内部类是声明在外部类的方法或其他作用域范围内的，内部类是直接声明在外部类之中的，与方法和属性平级。 7.为什么要使用内部类？内部类的使用场景有哪些？ 答：使用内部类的好处有以下两个。 可以作为多继承的一种实现方式，最早内部类的实现就是平衡 Java 语言中没有多继承的一种方式； 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 内部类可以作为多继承的一种实现方式进行使用，因为每个内部类都能独立的继承一个类或接口，所以整个类就可以实现多继承。 8.以下代码执行的结果是？ 1234567891011121314151617class Outer &#123; public int num &#x3D; 1; class Inner &#123; public int num &#x3D; 2; public void show() &#123; int num &#x3D; 3; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); &#125; &#125;&#125;class InnerTest &#123; public static void main(String[] args) &#123; new Outer().new Inner().show(); &#125;&#125; 答：输出内容如下。 123321 9.枚举有哪些应用场景？ 答：枚举类的主要应用场景如下： ① 枚举类可作为高级的常量类 示例代码如下： 12345678910public enum Color &#123; RED(&quot;#FF0000&quot;, &quot;255,0,0&quot;), GREEN(&quot;#00FFFF&quot;, &quot;0,255,255&quot;), YELLOW(&quot;#FFFF00&quot;, &quot;255,255,0&quot;); String hex, rgb; Color(String hex, String rgb) &#123; this.hex = hex; this.rgb = rgb; &#125;&#125; ② 枚举类可方便的用于 switch 判断 示例代码如下： 1234567891011121314switch(color)&#123;case RED: System.out.println(&quot;红灯停&quot;); break;case GREEN: System.out.println(&quot;绿灯行&quot;); break;case YELLOW: System.out.println(&quot;看情况&quot;); break;default: System.out.println(&quot;灯坏了&quot;);&#125; 10.枚举类在 JVM 中是如何实现的？ 答：枚举类在 JVM（Java 虚拟机） 中其实是通过普通的 static final 形式实现的。 题目解析：我们使用 javap 命令来分析枚举类最终编译的结果，查看编译后的结果，就找到了枚举类在 JVM 中的具体实现了。 首先定义一个枚举类，代码如下： 123456enum DBEnum &#123; ORACLE, DB2, MYSQL, SQLSERVER&#125; 再使用命令 javac DBEnum.java 编译 .class 文件，然后再使用命令 javap DBEnum.class，我们看到最终执行的结果如下： 12345678910Compiled from &quot;EnumTest.java&quot;final class DBEnum extends java.lang.Enum&lt;DBEnum&gt; &#123;public static final DBEnum ORACLE;public static final DBEnum DB2;public static final DBEnum MYSQL;public static final DBEnum SQLSERVER;public static DBEnum[] values();public static DBEnum valueOf(java.lang.String);static &#123;&#125;;&#125; 由此可以断定，枚举类在 JVM 中的实现也是通过普通的 static final 实现的。 11.枚举类可以被继承吗？ 答：不能被继承，因为枚举类编译后的实际代码是 final class 的形式，类被 final 修饰了自然不能被继承。 12.枚举类是否是线程安全的？ 答：枚举类是线程安全的，因为枚举类被编译后是 final class 的形式存在的，所以枚举类是线程安全的。 13.枚举是否可以被序列化？ 答：枚举是可以被序列化的，Oracle 官方对此给出了说明，内容如下： Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not transmitted. To serialize an enum constant, ObjectOutputStream writes the string returned by the constant’s name method. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized; any class-specific writeObject and writeReplace methods defined by enum types are ignored during serialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixed serialVersionUID of 0L 原文地址：https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html 大致的意思是说：枚举的序列化和其他普通类的序列化不同，枚举序列化的时候，只是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf 方法根据名字查找枚举对象。 总结 通过本文我们系统地学习了 Java 的各种内部类：静态内部类、成员内部类、局部内部类、匿名内部类，知道了它们特点和区别，并学习了枚举类了使用，知道了枚举类在编译之后，其实还是普通的最终类（final class）。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"8.类与 Object 的应用 + 面试题","slug":"interview-java-8","date":"2020-10-08T06:08:03.000Z","updated":"2020-10-08T06:28:21.387Z","comments":true,"path":"2020/10/08/interview-java-8/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-8/","excerpt":"","text":"类与 Object 的应用 + 面试题 类介绍 Java 程序是由若干个类组成的，类也是面向对象编程思想的具体实现。 以下为类的基本使用： 12345678910111213141516171819202122232425public class Cat &#123; &#x2F;&#x2F; 私有属性 private String name; private int age; &#x2F;&#x2F; 构造方法 public Cat() &#123; &#125; &#x2F;&#x2F; 普通方法 public void eat() &#123; System.out.println(&quot;吃吃吃&quot;); &#125; &#x2F;&#x2F; 对外包装属性 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125;&#125; 类引用 当我们需要使用不同包下的类时，就需要使用 import 导入包或类，这个时候才能正常使用。例如，我们要使用 java.util 下的 ArrayList 就必须使用 import java.util.ArrayList，请参考以下代码： 1234567&#x2F;&#x2F; 导入 ArrayList 类import java.util.ArrayList;class importTest &#123; public static void main(String[] args) &#123; ArrayList list &#x3D; new ArrayList(); &#125;&#125; 类引用的高级用法 import 还可以导入静态方法和静态域的功能，比如以下代码： 1234567// 导入 static 静态域的功能import static java.lang.System.*;class staticTest &#123; public static void main(String[] args) &#123; out.println(&quot;hi&quot;); &#125;&#125; 以上代码也可以顺利的执行，这也是 import 好玩的一个地方。 访问修饰符 在 Java 中访问修饰符有以下四种： public protected 默认 private 具体介绍如下表： 访问级别 访问控制修饰符 同类 同包 子类 不同的包 公开 public ✓ ✓ ✓ ✓ 受保护 protected ✓ ✓ ✓ × 默认 没有访问修饰符 ✓ ✓ × × 私有 private ✓ × × × （1）在开发中要尽可能地加上访问修饰符（提高程序的可读性）； （2）无特殊要求的情况下，类内部的变量应该设置为私有的（防止外部篡改）。 构造方法 构造方法也叫构造器或构造函数，它的作用是对类进行初始化，比如以下代码： 1234567891011121314151617181920212223242526class Cat &#123; &#x2F;&#x2F; 构造方法 public Cat(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public static void main(String[] args) &#123; Cat cat &#x3D; new Cat(&quot;喵星人&quot;,2); System.out.println(cat.getName()); System.out.println(cat.getAge()); &#125; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125;&#125; 以上代码执行结果如下： 12喵星人2 构造方法五大原则： 构造方法必须与类同名； 构造方法的参数可以没有或者有多个； 构造方法不能有返回值； 每个类可以有一个或多个构造方法； 构造方法总是伴随着 new 操作一起使用。 继承 用法：使用 extends 关键字来实现类的继承，示例代码如下： 12345678910111213class Animal &#123; public void eat() &#123; System.out.println(&quot;Animal&quot;); &#125;&#125;class Cat extends Animal &#123;&#125;public class eTest implements Cloneable &#123; public static void main(String[] args) &#123; Animal cat &#x3D; new Cat(); cat.eat(); &#125;&#125; 以上程序执行结果：Animal 继承使用技巧： 将公共的变量或者方法提取到超类中； 除非所有的方法都有继承的意义，否则不要使用继承； 在方法覆盖时不要改变原有方法的预期行为。 Object Object 类是 Java 中的一个特殊类，它是所有类的父类，Java 中的类都直接或间接的继承自 Object 类。 Object 类的常用方法如下： equals()：对比两个对象是否相同 getClass()：返回一个对象的运行时类 hashCode()：返回该对象的哈希码值 toString()：返回该对象的字符串描述 wait()：使当前的线程等待 notify()：唤醒在此对象监视器上等待的单个线程 notifyAll()：唤醒在此对象监视器上等待的所有线程 clone()：克隆一个新对象 关于更多 Object 的内容，如克隆（深克隆、浅克隆）、线程等待和唤醒，会在后面的章节中详细介绍。 相关面试题 1. 类的组成部分有哪些？ 答：在 Java 语言中，类主要是由方法和变量两部分组成。 2. 类与对象有哪些区别？ 答：类是一个抽象的概念，是对某一事物的描述；而对象是类的实例，是实实在在存在的个体。比如，“人”就是一个类（一个概念），而老王（王磊）就是实实在在的一个“对象”。 3. Java 中可以多继承吗？ 答：Java 中只能单继承，但可以实现多接口。 4. Java 中为什么不能实现多继承？ 答：从技术的实现角度来说，是为了降低编程的复杂性。假设 A 类中有一个 m() 方法，B 类中也有一个 m() 方法，如果 C 类同时继承 A 类和 B 类，那调用 C 类的 m() 方法时就会产生歧义，这无疑增加了程序开发的复杂性，为了避免这种问题的产生，Java 语言规定不能多继承类，但可以实现多接口。 5. 覆盖和重载有哪些区别？ 答：覆盖和重载的区别如下： 覆盖（Override）是指子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private，否则只是在子类中重新定义了一个方法； 重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。 6. 以下不属于重载特性的是？ A：方法的参数类型不同 B：方法的返回值不同 C：方法的参数个数不同 D：方法的参数顺序不同 答：B 7. 为什么方法不能根据返回类型来区分重载？ 答：因为在方法调用时，如果不指定类型信息，编译器就不知道你要调用哪个方法了。比如，以下代码： 1234float max(int x,int y);int max(int x,int y);// 方法调用max(1,2); 因为 max(1,2) 没有指定返回值，编译器就不知道要调用哪个方法了。 8. 构造方法有哪些特征？ 答：构造方法的特征如下： 构造方法必须与类名相同； 构造方法没有返回类型（void 也不能有）； 构造方法不能被继承、覆盖、直接调用； 类定义时提供了默认的无参构造方法； 构造方法可以私有，外部无法使用私有构造方法创建对象。 9. 构造函数能不能被覆盖？能不能被重载？ 答：构造函数可以重载，但不能覆盖。 10. 以下说法正确的是？ A：类中的构造方法不能忽略 B：构造方法可以作为普通方法被调用 C：构造方法在对象被 new 时被调用 D：一个类只能有一个构造方法 答：C 11. 以下程序执行的结果是？ 123456789101112131415161718192021222324252627class ExecTest &#123; public static void main(String[] args) &#123; Son son = new Son(); &#125;&#125;class Parent&#123; &#123; System.out.print(&quot;1&quot;); &#125; static&#123; System.out.print(&quot;2&quot;); &#125; public Parent()&#123; System.out.print(&quot;3&quot;); &#125;&#125;class Son extends Parent&#123; &#123; System.out.print(&quot;4&quot;); &#125; static&#123; System.out.print(&quot;5&quot;); &#125; public Son()&#123; System.out.print(&quot;6&quot;); &#125;&#125; 答：打印的结果是：251346 加载顺序如下： 执行父类的静态成员； 执行子类的静态成员； 父类的实例成员和实例初始化； 执行父类构造方法； 子类的实例成员和实例初始化； 子类构造方法。 12. 以下程序执行的结果是？ 1234567891011121314151617181920class A &#123; public int x &#x3D; 0; public static int y &#x3D; 0; public void m() &#123; System.out.print(&quot;A&quot;); &#125;&#125;class B extends A &#123; public int x &#x3D; 1; public static int y &#x3D; 2; public void m() &#123; System.out.print(&quot;B&quot;); &#125; public static void main(String[] args) &#123; A myClass &#x3D; new B(); System.out.print(myClass.x); System.out.print(myClass.y); myClass.m(); &#125;&#125; 答：打印的结果是：00B 题目解析：在 Java 语言中，变量不能被重写。 13. 以下程序执行的结果是？ 1234567891011121314151617181920212223242526272829class A &#123; public void m(A a) &#123; System.out.println(&quot;AA&quot;); &#125; public void m(D d) &#123; System.out.println(&quot;AD&quot;); &#125;&#125;class B extends A &#123; @Override public void m(A a) &#123; System.out.println(&quot;BA&quot;); &#125; public void m(B b) &#123; System.out.println(&quot;BD&quot;); &#125; public static void main(String[] args) &#123; A a = new B(); B b = new B(); C c = new C(); D d = new D(); a.m(a); a.m(b); a.m(c); a.m(d); &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125; 答：打印结果如下。 1234BABABAAD 题目解析： 第一个 BA：因为 A 的 m() 方法，被子类 B 重写了，所以输出是：BA； 第二个 BA：因为 B 是 A 的子类，当调用父类 m() 方法时，发现 m() 方法被 B 类重写了，所以会调用 B 中的 m() 方法，输出就是：BA； 第三个 BA：因为 C 是 B 的子类，会直接调用 B 的 m() 方法，所以输出就是：BA； 第四个 AD：因为 D 是 A 的子类，所以会调用 A 的 m() 方法，所以输出就是：AD。 14. Java 中的 this 和 super 有哪些区别？ 答：this 和 super 都是 Java 中的关键字，起指代作用，在构造方法中必须出现在第一行，它们的区别如下。 基础概念：this 是访问本类实例属性或方法；super 是子类访问父类中的属性或方法。 查找范围：this 先查本类，没有的话再查父类；super 直接访问父类。 使用：this 单独使用时，表示当前对象；super 在子类覆盖父类方法时，访问父类同名方法。 15. 在静态方法中可以使用 this 或 super 吗？为什么？ 答：在静态方法中不能使用 this 或 super，因为 this 和 super 指代的都是需要被创建出来的对象，而静态方法在类加载的时候就已经创建了，所以没办法在静态方法中使用 this 或 super。 16. 静态方法的使用需要注意哪些问题？ 答：静态方法的使用需要注意以下两个问题： 静态方法中不能使用实例成员变量和实例方法； 静态方法中不能使用 this 和 super。 17. final 修饰符的作用有哪些？ 答：final 修饰符作用如下： 被 final 修饰的类不能被继承； 被 final 修饰的方法不能被重写； 被 final 修饰的变量不能被修改。 18. 覆盖 equals() 方法的时候需要遵守哪些规则？ 答：Oracle 官方的文档对于 equals() 重写制定的规则如下。 自反性：对于任意非空的引用值 x，x.equals(x) 返回值为真。 对称性：对于任意非空的引用值 x 和 y，x.equals(y) 必须和 y.equals(x) 返回相同的结果。 传递性：对于任意的非空引用值 x、y 和 z，如果 x.equals(y) 返回值为真，y.equals(z) 返回值也为真，那么 x.equals(z) 也必须返回值为真。 一致性：对于任意非空的引用值 x 和 y，无论调用 x.equals(y) 多少次，都要返回相同的结果。在比较的过程中，对象中的数据不能被修改。 对于任意的非空引用值 x，x.equals(null) 必须返回假。 此题目不要求记忆，能知道大概即可，属于加分项题目。 19. 在 Object 中 notify() 和 notifyAll() 方法有什么区别？ 答：notify() 方法随机唤醒一个等待的线程，而 notifyAll() 方法将唤醒所有在等待的线程。 20. 如何使用 clone() 方法？ 答：如果是同一个类中使用的话，只需要实现 Cloneable 接口，定义或者处理 CloneNotSupportedException 异常即可，请参考以下代码： 12345678910class CloneTest implements Cloneable &#123; int num; public static void main(String[] args) throws CloneNotSupportedException &#123; CloneTest ct &#x3D; new CloneTest(); ct.num &#x3D; 666; System.out.println(ct.num); CloneTest ct2 &#x3D; (CloneTest) ct.clone(); System.out.println(ct2.num); &#125;&#125; 如果非内部类调用 clone() 的话，需要重写 clone() 方法，请参考以下代码： 1234567891011121314151617181920212223class CloneTest implements Cloneable &#123; int num; public static void main(String[] args) throws CloneNotSupportedException &#123; CloneTest ct &#x3D; new CloneTest(); ct.num &#x3D; 666; System.out.println(ct.num); CloneTest ct2 &#x3D; (CloneTest) ct.clone(); System.out.println(ct2.num); &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;public class CloneTest2 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; CloneTest ct &#x3D; new CloneTest(); ct.num &#x3D; 666; System.out.println(ct.num); CloneTest ct2 &#x3D; (CloneTest) ct.clone(); System.out.println(ct2.num); &#125;&#125; 总结 本文我们学习了类的基础用法，类引用：import 和 import static，访问修饰符的作用，构造函数和继承的特点以及使用技巧等，通过这些内容让我们对整个 Java 程序的组成，有了更加清晰直观的印象。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"7.数组和排序算法的应用 + 面试题","slug":"interview-java-7","date":"2020-10-08T06:08:00.000Z","updated":"2020-10-08T06:28:14.393Z","comments":true,"path":"2020/10/08/interview-java-7/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-7/","excerpt":"","text":"数组和排序算法的应用 + 面试题 数组的定义与使用 数组是 Java 编程中最重要的数据结构之一，也是最基本的数据结构，Java 中的常用集合 ArrayList、HashMap 等内部的实现都使用到了数组结构。数组是只能用来存储一种类型的集合，可以通过下标访问数值中的所有元素。 数组的声明方式有以下两种，如整数型数组，请参考下面代码： 方式一：int[] arr; 方式二：int arr[]; 大部分情况下，我们会使用第一种方式 int[] arr; 来声明数组。 数组初始化 数组可使用 new int[n] 进行初始化，每个元素初始化为 0，声明了 n 个元素。也可以直接赋值，例如 new int[]{ 1,2,3…… }，具体用法可参照下面代码： 123456&#x2F;&#x2F; 初始化方式一int[] arr &#x3D; new int[5];&#x2F;&#x2F; 初始化方式二int[] arr2 &#x3D; new int[]&#123;1, 2, 3, 4, 5&#125;;&#x2F;&#x2F; 初始化方式二的延伸版，可省略 new int[] 直接赋值int[] arr3 &#x3D; &#123;1, 2, 3, 4, 5&#125;; 注意：在 Java 中，数组初始化如果声明了数组长度，则不能直接赋值。例如，int[] arr = new int[5]{1, 2, 3, 4, 5}; 给这段初始化数组长度并赋值时，编译器会报错，编译不通过。 数组遍历 数组遍历的常见方式有三种：传统的 for 循环、for each 遍历、还有 JDK 8 中新增的 Lambda 表达式。具体的实现请参考以下实例。 方式一：传统 for 循环 12345Integer[] arr &#x3D; &#123;2, 3, 6, 7, 9&#125;;&#x2F;&#x2F; 方式一：传统 forfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 方式二：for each 12345Integer[] arr &#x3D; &#123;2, 3, 6, 7, 9&#125;;&#x2F;&#x2F; 方式二：for eachfor (int i : arr) &#123; System.out.println(i);&#125; 方式三：JDK 8 中的 Lambda 表达式 123Integer[] arr &#x3D; &#123;2, 3, 6, 7, 9&#125;;&#x2F;&#x2F; 方式三：jdk 8 LambdaArrays.asList(arr).forEach(x -&gt; System.out.println(x)); 其中 for each 的方式，写法更简洁，也更不容易出错，不必为数组的越界而担心（大于元素的最大下标值）。 注意：数组的访问是从 0 开始，而不是 1 开始，也就是第一个元素的获取是 arr[0]，而非 arr[1]。 数组拷贝 数组拷贝使用的是 Arrays.copyof() 方法，具体实现请参考下面代码： 123int[] arr &#x3D; &#123;3, 4, 9&#125;;int[] arr2 &#x3D; Arrays.copyOf(arr, arr.length);System.out.println(Arrays.toString(arr2)); 程序执行结果：[3, 4, 9] 注意：Arrays.copyOf(array,newLength) 第二个参数 newLength 表示声明此数组的长度，可以比拷贝的数组的长度长，多出来的元素会初始化为 0 值。 数组填充与合并 数组填充 即为每个元素统一赋值，使用 Arrays.fill() 进行数组填充，具体实现请参考下面代码： 123int[] arr &#x3D; new int[10];Arrays.fill(arr, 6);System.out.println(Arrays.toString(arr)); 程序执行结果：[6, 6, 6, 6, 6, 6, 6, 6, 6, 6] 注意：使用 Arrays.fill() 会覆盖原有的值，即使数组之前有赋值操作，也会被覆盖。 数组合并 使用 org.apache.commons.lang3.ArrayUtils.addAll() 方法，具体实现请参考下面代码： 12345int[] arr &#x3D; &#123;2, 8, 13, 11, 6, 7&#125;;int[] arr2 &#x3D; &#123;66, 88&#125;;&#x2F;&#x2F; 合并数组int[] arr3 &#x3D; org.apache.commons.lang3.ArrayUtils.addAll(arr, arr2);System.out.println(Arrays.toString(arr3)); 程序执行结果：[2, 8, 13, 11, 6, 7, 66, 88] 排序与算法 数组排序 使用 Arrays.sort() 方法，具体实现请参考下面代码： 123int[] arr &#x3D; &#123;2, 8, 13, 11, 6, 7&#125;;Arrays.sort(arr);System.out.println(Arrays.toString(arr)); 程序执行结果：[2, 6, 7, 8, 11, 13] 数组逆序 使用 org.apache.commons.lang3.ArrayUtils.reverse(arr) 方法，具体实现请参考下面代码： 1234567int[] arr = &#123;2, 8, 13, 11, 6, 7&#125;;int[] arr = &#123;2, 8, 13, 11, 6, 7&#125;;// 数组正序（排序）Arrays.sort(arr);// 数组逆序org.apache.commons.lang3.ArrayUtils.reverse(arr);System.out.println(Arrays.toString(arr)); 程序执行结果：[13, 11, 8, 7, 6, 2] 注意：org.apache.commons.lang3.ArrayUtils.reverse() 是数组逆序，并不是数组倒序，也就是说 ArrayUtils.reverse() 只会把数组原顺序颠倒输出，并不会自然排序后再倒序输出。 冒泡排序 依次比较相邻的两个数，把较大的值放后面，执行整个循环之后，数组就从小到大进行排列了。具体实现请参考下面代码： 1234567891011121314int[] arr &#x3D; &#123;2, 8, 13, 11, 6, 7&#125;;System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));for (int i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; 因为冒泡是把每轮循环中较大的数飘到后面，所以是 arr.length-i-1 for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F; 元素交换 int temp &#x3D; arr[j + 1]; arr[j + 1] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125;&#125;System.out.println(&quot;排序后：&quot; + Arrays.toString(arr)); 程序执行结果： 12排序前：[2, 8, 13, 11, 6, 7]排序后：[2, 6, 7, 8, 11, 13] 选择排序 每次从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。具体实现请参考下面代码： 12345678910111213141516int[] arr = &#123;2, 8, 13, 11, 6, 7&#125;;System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));for (int i = 0; i &lt; arr.length; i++) &#123; int lowerIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; // 找出最小的一个索引 if (arr[j] &lt; arr[lowerIndex]) &#123; lowerIndex = j; &#125; &#125; // 交换 int temp = arr[i]; arr[i] = arr[lowerIndex]; arr[lowerIndex] = temp;&#125;System.out.println(&quot;排序后：&quot; + Arrays.toString(arr)); 程序执行结果： 12排序前：[2, 8, 13, 11, 6, 7]排序后：[2, 6, 7, 8, 11, 13] 关于更多的排序算法，后面会有专门的章节进行介绍。 元素查找 查找数组是否包含某个值，使用 Arrays.binarySearch() 方法查询。 Arrays.binarySearch() 是利用二分法查询某个值，如果查到包含某值会返回该值的下标，如果没有查到则返回负值。 1234int[] arr &#x3D; &#123;1, 3, 4, 5&#125;;&#x2F;&#x2F; Arrays.binarySearch() 使用二分法查询某值int index &#x3D; Arrays.binarySearch(arr, 5);System.out.println(index); 注意：使用 Arrays.binarySearch 之前一定要先调用 Arrays.sort() 对数组进行排序，否则返回的结果有误。 多维数组 我们之前使用的数组可以称之为一维数组，而多维数组可以理解为数组的数组，可以用二维数组来举例，二维数组也是一种特殊的多维数组。 比如我们声明一个二维数组：int[][] arr = new int[2][4]; 这就相当于我们创建了一个两行四列的表，它的使用、赋值与取值，请查看下面代码示例： 1234567891011121314// 声明二维数组int[][] arr = new int[2][4];//循环二维数组for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[0].length; j++) &#123; // 二维数组赋值 arr[i][j] = j; &#125;&#125;// 二维数组取值System.out.println(arr[0][1]);// 打印二维数组System.out.println(Arrays.toString(arr[0]));System.out.println(Arrays.toString(arr[1])); 以上程序执行的结果是： 1231[0, 1, 2, 3][0, 1, 2, 3] 数组类型转换 字符串转数组 使用 split 分隔字符串就形成了数组，请参考以下代码： 123String str &#x3D; &quot;laowang,stone,wanglei&quot;;String[] arr &#x3D; str.split(&quot;,&quot;); &#x2F;&#x2F; 字符串转数组System.out.println(arr[0]); 数组转字符串 使用 Arrays.toString() 方法，请参考以下代码： 123String[] arr &#x3D; &#123;&quot;laowang&quot;, &quot;stone&quot;, &quot;wanglei&quot;&#125;;String str &#x3D; Arrays.toString(arr);System.out.println(str); 若要查看更多数组转字符串的方式，请查看本文面试部分的介绍。 数组转集合 使用 Arrays.asList() 方法，请参考以下代码： 123String[] strArr &#x3D; &#123;&quot;cat&quot;, &quot;dog&quot;&#125;;List list &#x3D; Arrays.asList(strArr);System.out.println(list); 集合转数组 使用 List.toArrray() 方法，请参考以下代码： 123456List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();list.add(&quot;cat&quot;);list.add(&quot;dog&quot;);&#x2F;&#x2F; 集合转换为数组String[] arr &#x3D; list.toArray(new String[list.size()]);System.out.println(Arrays.toString(arr)); 相关面试题 1. 数组和集合有什么区别？ 答：数组和集合的区别如下： 集合可以存储任意类型的对象数据，数组只能存储同一种数据类型的数据； 集合的长度是会发生变化的，数组的长度是固定的； 集合相比数组功能更强大，数组相比集合效率更高。 2. 以下代码访问数组元素打印的结果是多少？ 12int[] arr &#x3D; new int[5] &#123;1, 2, 3, 4, 5&#125;;System.out.println(arr[4]); 答：程序编译报错，在 Java 中初始化数组时，如果直接给数组赋值，不能声明数组长度；如果声明了数组长度，则不能赋值给数组，否则编译器报错。 正确的写法如下： 12int[] arr &#x3D; new int[]&#123;1, 2, 3, 4, 5&#125;;System.out.println(arr[4]); 输出的结果为：5，访问元素从 0 开始。 3. 执行以下代码会输出什么结果？ 123456789101112public static void main(String[] args) &#123; int[] arr &#x3D; &#123;2, 3, 4, 8&#125;; change(arr); System.out.println(arr[2]);&#125;private static void change(int[] arr) &#123; for (int i &#x3D; 0; i &lt; arr.length; i++) &#123; if (i % 2 &#x3D;&#x3D; 0) &#123; arr[i] *&#x3D; i; &#125; &#125;&#125; 答：输出的结果是 8。 题目解析：在 Java 中数组本质是引用类型，因此在调用方法中修改数组，就是对原数组本身的修改。 4. 以下程序打印的结果是多少？ 1234int[] intArr &#x3D; new int[3];String[] StrArr &#x3D; new String[3];System.out.println(intArr[1]);System.out.println(StrArr[1]); 答：以上程序打印的结果是：0 和 null。 题目解析：new int[3] 相当于声明了数组的长度为 3，每个元素初始化为 0，而 new String[3] 相当于声明了数组的长度为 3，每个元素初始化为 null。 5. 数组转换字符串有哪些方式？ 答：数组转换字符串，有以下几种方式。 方式一：遍历拼接，完整代码如下： 12345678String[] arr = &#123;&quot;laowang&quot;, &quot;stone&quot;, &quot;wanglei&quot;&#125;;StringBuffer sb = new StringBuffer();for (int i = 0; i &lt; arr.length; i++) &#123; sb.append(arr[i]); if (i != arr.length - 1) sb.append(&quot;,&quot;);&#125;System.out.println(sb.toString()); 方式二：Arrays.toString() 转换，完整代码如下： 123String[] arr = &#123;&quot;laowang&quot;, &quot;stone&quot;, &quot;wanglei&quot;&#125;;String str2 = Arrays.toString(arr);System.out.println(str2); 方式三：StringUtils.join() 转换，完整代码如下： 123String[] arr = &#123;&quot;laowang&quot;, &quot;stone&quot;, &quot;wanglei&quot;&#125;;String str3 = StringUtils.join(Arrays.asList(arr), &quot;,&quot;); // 使用英文逗号分隔System.out.println(str3); 6. 数组遍历有哪几种方式？ 答：常见的数组遍历有以下三种方式。 传统 for 循环，如 for (int i = 0; i &lt; arr.length; i++) { //…… } for each 循环，如 for (int i : arr) { //…… } jdk 8 Lambda 方式，如 Integer[] arr = &#123;2, 3, 6, 7, 9&#125;; Arrays._asList_(arr).forEach(x -&gt; System._out_.println(x)); 7. 以下数组比较的结果分别是什么？ 12345String[] strArr &#x3D; &#123;&quot;dog&quot;, &quot;cat&quot;, &quot;pig&quot;, &quot;bird&quot;&#125;;String[] strArr2 &#x3D; &#123;&quot;dog&quot;, &quot;cat&quot;, &quot;pig&quot;, &quot;bird&quot;&#125;;System.out.println(Arrays.equals(strArr, strArr2));System.out.println(strArr.equals(strArr2));System.out.println(strArr &#x3D;&#x3D; strArr2); 答：上面代码执行的结果，分别为：true、false、false。 题目解析：strArr == strArr2 为引用比较，因此结果一定是 false，而数组本身的比较也就是 strArr.equals(strArr2) 为 false 的原因是因为数组没有重写 equals 方法，因此也是引用比较。数组 equals 源码实现如下： 123public boolean equals(Object obj) &#123; return (this &#x3D;&#x3D; obj);&#125; 而 Arrays.equals 的结果之所以是 true 是因为 Arrays.equals 重写了 equals 方法。源代码实现如下： 12345678910111213141516public static boolean equals(Object[] a, Object[] a2) &#123; if (a&#x3D;&#x3D;a2) return true; if (a&#x3D;&#x3D;null || a2&#x3D;&#x3D;null) return false; int length &#x3D; a.length; if (a2.length !&#x3D; length) return false; for (int i&#x3D;0; i&lt;length; i++) &#123; Object o1 &#x3D; a[i]; Object o2 &#x3D; a2[i]; if (!(o1&#x3D;&#x3D;null ? o2&#x3D;&#x3D;null : o1.equals(o2))) return false; &#125; return true; &#125; 8. 以下程序使用 Arrays.binarySearch 返回的结果是 true 还是 false？ 123String[] arr &#x3D; &#123;&quot;dog&quot;, &quot;cat&quot;, &quot;pig&quot;, &quot;bird&quot;&#125;;int result &#x3D; Arrays.binarySearch(arr, &quot;bird&quot;);System.out.println(result &#x3D;&#x3D; -1); 答：返回的结果是：true。 题目解析：使用 Arrays.binarySearch 之前一定要先调用 Arrays.sort() 对数组进行排序，否则返回的结果有误，本数组返回的结果是 ﹣1，是因为没有使用排序的结果，正确的使用请查看以下代码： 1234String[] arr &#x3D; &#123;&quot;dog&quot;, &quot;cat&quot;, &quot;pig&quot;, &quot;bird&quot;&#125;;Arrays.sort(arr);int result &#x3D; Arrays.binarySearch(arr, &quot;bird&quot;);System.out.println(result &#x3D;&#x3D; -1); 9. Arrays 对象有哪些常用的方法？ 答：Arrays 常用方法如下： Arrays.copyOf() 数组拷贝 Arrays.asList() 数组转为 List 集合 Arrays.fill() 数组赋值 Arrays.sort() 数组排序 Arrays.toString() 数组转字符串 Arrays.binarySearch() 二分法查询元素 Arrays.equals() 比较两个数组的值 10. 查询字符串数组中是否包含某个值有几种方法？ 答：常见查询数组中是否包含某个值有以下两种方式： 方式一：Arrays.asList(array).contains(“key”); 方式二：Arrays.binarySearch(array, “key”); 具体的实现代码如下： 12345678String[] arr &#x3D; &#123;&quot;doc&quot;, &quot;pig&quot;, &quot;cat&quot;&#125;;&#x2F;&#x2F; 方式一：Arrays.asList(array).containsboolean bool &#x3D; Arrays.asList(arr).contains(&quot;cat&quot;);System.out.println(bool);&#x2F;&#x2F; 方式二：Arrays.binarySearchArrays.sort(arr);boolean bool2 &#x3D; Arrays.binarySearch(arr, &quot;cat&quot;) &gt; -1;System.out.println(bool2); 11. 如何修改数组的第三个到第五个元素的值为 6？ 答：本题考察的知识点显然不是使用 for 循环修改那么简单，而是考察对 Arrays.fill() 方法的掌握，以下提供了两种实现方式可供参考。 方式一：for 循环方式 123456int[] arrInt = new int[10];for (int i = 0; i &lt; arrInt.length; i++) &#123; if (i &gt;= 2 &amp;&amp; i &lt; 5) &#123; arrInt[i] = 6; &#125;&#125; 方式二：Arrays.fill() 方式 12int[] arrInt = new int[10];Arrays.fill(arrInt, 2, 5, 6); 总结 在 Java 中数组本质是引用类型，数组只能用来存储固定大小的同类型元素。在 Java 中很多集合的内部都是依赖数组实现的，如 ArrayList 和 HashMap 等。数组的冒泡排序和选择排序也是面试常考的内容，很多公司会要求面试者手写冒泡排序。本文也介绍了数组、字符串和集合之间的相互转换，只有掌握好这些技能才能开发出更好的 Java 程序。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"6.玩转时间操作 + 面试题","slug":"interview-java-6","date":"2020-10-08T06:07:56.000Z","updated":"2020-10-08T06:28:07.859Z","comments":true,"path":"2020/10/08/interview-java-6/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-6/","excerpt":"","text":"玩转时间操作 + 面试题 在 JDK 8 之前，Java 语言为我们提供了两个类用于操作时间，它们分别是：java.util.Date 和 java.util.Calendar，但在 JDK 8 的时候为了解决旧时间操作类的一些缺陷，提供了几个新的类，用于操作时间和日期，它们分别是：LocalTime、LocalDateTime、Instant，都位于 java.time 包下。 时间的操作在我们日常的开发中经常见到，比如，业务数据都要记录创建时间和修改时间，并要把这些时间格式化之后显示到前端页面，再比如我们需要计算业务数据的时间间隔等，都离不开对时间的操作，那如何正确而优雅地使用时间？这就是我们接下来要讨论的话题。 时间基础知识科普 格林威治时间 格林威治（又译格林尼治）是英国伦敦南郊原格林威治天文台的所在地，它是世界计算时间和地球经度的起点，国际经度会议 1884 年在美国华盛顿召开，会上通过协议，以经过格林威治天文台的经线为零度经线（即本初子午线），作为地球经度的起点，并以格林威治为“世界时区”的起点。 格林威治时间和北京时间的关系 格林威治时间被定义为世界时间，就是 0 时区，北京是东八区。也就是说格林威治时间的 1 日 0 点，对应到北京的时间就是 1 日 8 点。 时间戳 时间戳是指格林威治时间 1970-01-01 00:00:00（北京时间 1970-01-01 08:00:00）起至现在的总秒数。 JDK 8 之前的时间操作 1 获取时间 12345Date date = new Date();System.out.println(date);Calendar calendar = Calendar.getInstance();Date time = calendar.getTime();System.out.println(time); 2 获取时间戳 123456long ts = new Date().getTime();System.out.println(ts);long ts2 = System.currentTimeMillis();System.out.println(ts2);long ts3 = Calendar.getInstance().getTimeInMillis();System.out.println(ts3); 3 格式化时间 12SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sf.format(new Date())); // output:2019-08-16 21:46:22 SimpleDateFormat 构造参数的含义，请参考以下表格信息： 字符 含义 示例 y 年 yyyy-1996 M 月 MM-07 d 月中的天数 dd-02 D 年中的天数 121 E 星期几 星期四 H 小时数（0-23） HH-23 h 小时数（1-12） hh-11 m 分钟数 mm-02 s 秒数 ss-03 Z 时区 +0800 使用示例： 获取星期几：new SimpleDateFormat(“E”).format(new Date()) 获取当前时区：new SimpleDateFormat(“Z”).format(new Date*()) 注意事项：在多线程下 SimpleDateFormat 是非线程安全的，因此在使用 SimpleDateFormat 时要注意这个问题。在多线程下，如果使用不当，可能会造成结果不对或内存泄漏等问题。 4 时间转换 123456789SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);// String 转 DateString str = &quot;2019-10-10 10:10:10&quot;;System.out.println(sf.parse(str));//时间戳的字符串 转 DateString tsString = &quot;1556788591462&quot;;// import java.sqlTimestamp ts = new Timestamp(Long.parseLong(tsString)); // 时间戳的字符串转 DateSystem.out.println(sf.format(ts)); 注意事项：当使用 SimpleDateFormat.parse() 方法进行时间转换的时候，SimpleDateFormat 的构造函数必须和待转换字符串格式一致。 5 获得昨天此刻时间 123Calendar calendar = Calendar.getInstance();calendar.add(Calendar.DATE, -1);System.out.println(calendar.getTime()); JDK 8 时间操作 JDK 8 对时间操作新增了三个类：LocalDateTime、LocalDate、LocalTime。 LocalDate 只包含日期，不包含时间，不可变类，且线程安全。 LocalTime 只包含时间，不包含日期，不可变类，且线程安全。 LocalDateTime 既包含了时间又包含了日期，不可变类，且线程安全。 线程安全性 值得一提的是 JDK 8 中新增的这三个时间相关的类，都是线程安全的，这极大地降低了多线程下代码开发的风险。 1 获取时间 123456789// 获取日期LocalDate localDate = LocalDate.now();System.out.println(localDate); // output:2019-08-16// 获取时间LocalTime localTime = LocalTime.now();System.out.println(localTime); // output:21:09:13.708// 获取日期和时间LocalDateTime localDateTime = LocalDateTime.now();System.out.println(localDateTime); // output:2019-08-16T21:09:13.708 2 获取时间戳 1234long milli = Instant.now().toEpochMilli(); // 获取当前时间戳（精确到毫秒）long second = Instant.now().getEpochSecond(); // 获取当前时间戳（精确到秒）System.out.println(milli); // output:1565932435792System.out.println(second); // output:1565932435 3 时间格式化 1234567// 时间格式化①DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);String timeFormat = dateTimeFormatter.format(LocalDateTime.now());System.out.println(timeFormat); // output:2019-08-16 21:15:43// 时间格式化②String timeFormat2 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));System.out.println(timeFormat2); // output:2019-08-16 21:17:48 4 时间转换 123String timeStr = &quot;2019-10-10 06:06:06&quot;;LocalDateTime dateTime = LocalDateTime.parse(timeStr,DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));System.out.println(dateTime); 5 获得昨天此刻时间 123LocalDateTime today = LocalDateTime.now();LocalDateTime yesterday = today.plusDays(-1);System.out.println(yesterday); 相关面试题 1. 获取当前时间有几种方式？ 答：获取当前时间常见的方式有以下三种： new Date() Calendar.getInstance().getTime() LocalDateTime.now() 2. 如何获取昨天此刻的时间？ 答：以下为获取昨天此刻时间的两种方式： 1234567// 获取昨天此刻的时间（JDK 8 以前）Calendar c = Calendar.getInstance();c.add(Calendar.DATE,-1);System.out.println(c.getTime());// 获取昨天此刻的时间（JDK 8）LocalDateTime todayTime = LocalDateTime.now();System.out.println(todayTime.plusDays(-1)); 3. 如何获取本月的最后一天？ 答：以下为获取本月最后一天的两种方式： 1234567// 获取本月的最后一天（JDK 8 以前）Calendar ca = Calendar.getInstance();ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));System.out.println(ca.getTime());// 获取本月的最后一天（JDK 8）LocalDate today = LocalDate.now();System.out.println(today.with(TemporalAdjusters.lastDayOfMonth())); 4. 获取当前时间的时间戳有几种方式？ 答：以下为获取当前时间戳的几种方式： System.currentTimeMillis() new Date().getTime() Calendar.getInstance().getTime().getTime() Instant.now().toEpochMilli() LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).toEpochMilli() 其中，第四种和第五种方式是 JDK 8 才新加的。 5. 如何优雅地计算两个时间的相隔时间？ 答：JDK 8 中可以使用 Duration 类来优雅地计算两个时间的相隔时间，代码如下： 1234LocalDateTime dt1 = LocalDateTime.now();LocalDateTime dt2 = dt1.plusSeconds(60);Duration duration = Duration.between(dt1, dt2);System.out.println(duration.getSeconds()); // output:60 6. 如何优雅地计算两个日期的相隔日期？ 答：JDK 8 中可以使用 Period 类来优雅地计算两个日期的相隔日期，代码如下： 1234LocalDate d1 = LocalDate.now();LocalDate d2 = d1.plusDays(2);Period period = Period.between(d1, d2);System.out.println(period.getDays()); //output:2 7. SimpleDateFormat 是线程安全的吗？为什么？ 答：SimpleDateFormat 是非线程安全的。因为查看 SimpleDateFormat 的源码可以得知，所有的格式化和解析，都需要通过一个中间对象进行转换，这个中间对象就是 Calendar，这样的话就造成非线程安全。试想一下当我们有多个线程操作同一个 Calendar 的时候后来的线程会覆盖先来线程的数据，那最后其实返回的是后来线程的数据，因此 SimpleDateFormat 就成为了非线程的了。 8. 怎么保证 SimpleDateFormat 的线程安全？ 答：保证 SimpleDateFormat 线程安全的方式如下： 使用 Synchronized，在需要时间格式化的操作使用 Synchronized 关键字进行包装，保证线程堵塞格式化； 手动加锁，把需要格式化时间的代码，写到加锁部分，相对 Synchronized 来说，编码效率更低，性能略好，代码风险较大（风险在于不要忘记在操作的最后，手动释放锁）； 使用 JDK 8 的 DateTimeFormatter 替代 SimpleDateFormat。 9. JDK 8 中新增的时间类都有哪些优点？ 答：JDK 8 中的优点具体有以下几个优点，如下： 线程安全性 使用的便利性（如获取当前时间戳的便利性、增减日期的便利性等） 编写代码更简单优雅，如当前时间的格式化：LocalDateTime.now().format(DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”)); 10. 如何比较两个时间（Date）的大小？ 答：时间比较有以下三种方式： 获取两个时间的时间戳，得到两个 long 类型的变量，两个变量相减，通过结果的正负值来判断大小； 通过 Date 自带的 before()、after()、equals() 等方法比较，代码示例 date1.before(date2)； 通过 compareTo() 方法比较，代码示例：date1.compareTo(date2)，返回值 -1 表示前一个时间比后一个时间小，0 表示两个时间相等，1 表示前一个时间大于后一个时间。 总结 JDK 8 之前使用 java.util.Date 和 java.util.Calendar 来操作时间，它们有两个很明显的缺点，第一，非线程安全；第二，API 调用不方便。JDK 8 新增了几个时间操作类 java.time 包下的 LocalDateTime、LocalDate、LocalTime、Duration（计算相隔时间）、Period（计算相隔日期）和 DateTimeFormatter，提供了多线程下的线程安全和易用性，让我们可以更好的操作时间。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"5.深入了解 Java 中的异常处理 + 面试题","slug":"interview-java-5","date":"2020-10-08T06:07:52.000Z","updated":"2020-10-08T06:27:58.341Z","comments":true,"path":"2020/10/08/interview-java-5/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-5/","excerpt":"","text":"深入了解 Java 中的异常处理 + 面试题 在程序开发中，异常处理也是我们经常使用到的模块，只是平常很少去深究异常模块的一些知识点。比如，try-catch 处理要遵循的原则是什么，finally 为什么总是能执行，try-catch 为什么比较消耗程序的执行性能等问题，我们本讲内容都会给出相应的答案，当然还有面试中经常被问到的异常模块的一些面试题，也是我们本篇要讲解的重点内容。 异常处理基础介绍 先来看看异常处理的语法格式： try{ … } catch(Exception e){ … } finally{ … } 其中， try：是用来监测可能会出现异常的代码段。 catch：是用来捕获 try 代码块中某些代码引发的异常，如果 try 里面没有异常发生，那么 catch 也一定不会执行。在 Java 语言中，try 后面可以有多个 catch 代码块，用来捕获不同类型的异常，需要注意的是前面的 catch 捕获异常类型一定不能包含后面的异常类型，这样的话，编译器会报错。 finally：不论 try-catch 如何执行，finally 一定是最后执行的代码块，所有通常用来处理一些资源的释放，比如关闭数据库连接、关闭打开的系统资源等。 异常处理的基本使用，具体可以参考下面的代码段： 1234567try &#123; int i &#x3D; 10 &#x2F; 0;&#125; catch (ArithmeticException e) &#123; System.out.println(e);&#125; finally &#123; System.out.println(&quot;finally&quot;);&#125; 多 catch 的使用，具体可以参考下面的代码段： 123456789try &#123; int i &#x3D; Integer.parseInt(null);&#125; catch (ArithmeticException ae) &#123; System.out.println(&quot;ArithmeticException&quot;);&#125; catch (NullPointerException ne) &#123; System.out.println(&quot;NullPointerException&quot;);&#125; catch (Exception e) &#123; System.out.println(&quot;Exception&quot;);&#125; 需要注意的是 Java 虚拟机会从上往下匹配错误类型，因此前面的 catch 异常类型不能包含后面的异常类型。比如上面的代码如果把 Exception 放在最前面编译器就会报错，具体可以参考下面的图片。 异常处理的发展 随着 Java 语言的发展，JDK 7 的时候引入了一些更加便利的特性，用来更方便的处理异常信息，如 try-with-resources 和 multiple catch，具体可以参考下面的代码段： 123456try (FileReader fileReader &#x3D; new FileReader(&quot;&quot;); FileWriter fileWriter &#x3D; new FileWriter(&quot;&quot;)) &#123; &#x2F;&#x2F; try-with-resources System.out.println(&quot;try&quot;);&#125; catch (IOException | NullPointerException e) &#123; &#x2F;&#x2F; multiple catch System.out.println(e);&#125; 异常处理的基本原则 先来看下面这段代码，有没有发现一些问题？ 12345try &#123; &#x2F;&#x2F; ... int i &#x3D; Integer.parseInt(null);&#125; catch (Exception e) &#123;&#125; 以上的这段代码，看似“正常”，却违背了异常处理的两个基本原则： 第一，尽量不要捕获通用异常，也就是像 Exception 这样的异常，而是应该捕获特定异常，这样更有助于你发现问题； 第二，不要忽略异常，像上面的这段代码只是加了 catch，但没有进行如何的错误处理，信息就已经输出了，这样在程序出现问题的时候，根本找不到问题出现的原因，因此要切记不要直接忽略异常。 异常处理对程序性能的影响 异常处理固然好用，但一定不要滥用，比如下面的代码片段： 123456789&#x2F;&#x2F; 使用 com.alibaba.fastjsonJSONArray array &#x3D; new JSONArray();String jsonStr &#x3D; &quot;&#123;&#39;name&#39;:&#39;laowang&#39;&#125;&quot;;try &#123; array &#x3D; JSONArray.parseArray(jsonStr);&#125; catch (Exception e) &#123; array.add(JSONObject.parse(jsonStr));&#125;System.out.println(array.size()); 这段代码是借助了 try-catch 去处理程序的业务逻辑，通常是不可取的，原因包括下列两个方面。 try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，因此建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。 Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。 以上使用 try-catch 处理业务的代码，可以修改为下列代码： 123456789101112&#x2F;&#x2F; 使用 com.alibaba.fastjsonJSONArray array &#x3D; new JSONArray();String jsonStr &#x3D; &quot;&#123;&#39;name&#39;:&#39;laowang&#39;&#125;&quot;;if (null !&#x3D; jsonStr &amp;&amp; !jsonStr.equals(&quot;&quot;)) &#123; String firstChar &#x3D; jsonStr.substring(0, 1); if (firstChar.equals(&quot;&#123;&quot;)) &#123; array.add(JSONObject.parse(jsonStr)); &#125; else if (firstChar.equals(&quot;[&quot;)) &#123; array &#x3D; JSONArray.parseArray(jsonStr); &#125;&#125;System.out.println(array.size()); 相关面试题 1. try 可以单独使用吗？ 答：try 不能单独使用，否则就失去了 try 的意义和价值。 2. 以下 try-catch 可以正常运行吗？ 12345try &#123; int i &#x3D; 10 &#x2F; 0;&#125; catch &#123; System.out.println(&quot;last&quot;);&#125; 答：不能正常运行，catch 后必须包含异常信息，如 catch (Exception e)。 3. 以下 try-finally 可以正常运行吗？ 12345try &#123; int i &#x3D; 10 &#x2F; 0;&#125; finally &#123; System.out.println(&quot;last&quot;);&#125; 答：可以正常运行。 4. 以下代码 catch 里也发生了异常，程序会怎么执行？ 12345678910try &#123; int i = 10 / 0; System.out.println(&quot;try&quot;);&#125; catch (Exception e) &#123; int j = 2 / 0; System.out.println(&quot;catch&quot;);&#125; finally &#123; System.out.println(&quot;finally&quot;);&#125;System.out.println(&quot;main&quot;); 答：程序会打印出 finally 之后抛出异常并终止运行。 5. 以下代码 finally 里也发生了异常，程序会怎么运行？ 123456789try &#123; System.out.println(&quot;try&quot;);&#125; catch (Exception e) &#123; System.out.println(&quot;catch&quot;);&#125; finally &#123; int k &#x3D; 3 &#x2F; 0; System.out.println(&quot;finally&quot;);&#125;System.out.println(&quot;main&quot;); 答：程序在输出 try 之后抛出异常并终止运行，不会再执行 finally 异常之后的代码。 6. 常见的运行时异常都有哪些？ 答：常见的运行时异常如下： java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象； java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误，通常是程序 试图通过字符串来加载某个类时引发的异常； java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符； java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生； java.lang.ClassCastException 数据类型转换异常； java.lang.NoClassDefFoundException 未找到类定义错误； java.lang.NoSuchMethodException 方法不存在异常； java.lang.IllegalArgumentException 方法传递参数错误。 7. Exception 和 Error 有什么区别？ 答：Exception 和 Error 都属于 Throwable 的子类，在 Java 中只有 Throwable 及其之类才能被捕获或抛出，它们的区别如下： Exception（异常）是程序正常运行中，可以预期的意外情况，并且可以使用 try/catch 进行捕获处理的。Exception 又分为运行时异常（Runtime Exception）和受检查的异常（Checked Exception），运行时异常编译能通过，但如果运行过程中出现这类未处理的异常，程序会终止运行；而受检查的异常，要么用 try/catch 捕获，要么用 throws 字句声明抛出，否则编译不会通过。 Error（错误）是指突发的非正常情况，通常是不可以恢复的，比如 Java 虚拟机内存溢出，诸如此类的问题叫做 Error。 8. throw 和 throws 的区别是什么？ 答：它们的区别如下： throw 语句用在方法体内，表示抛出异常由方法体内的语句处理，执行 throw 一定是抛出了某种异常； throws 语句用在方法声明的后面，该方法的调用者要对异常进行处理，throws 代表可能会出现某种异常，并不一定会发生这种异常。 9. Integer.parseInt(null) 和 Double.parseDouble(null) 抛出的异常一样吗？为什么？ 答：Integer.parseInt(null) 和 Double.parseDouble(null) 抛出的异常类型不一样，如下所示： Integer.parseInt(null) 抛出的异常是 NumberFormatException； Double.parseDouble(null) 抛出的异常是 NullPointerException。 至于为什么会产生不同的异常，其实没有特殊的原因，主要是由于这两个功能是不同人开发的，因而就产生了两种不同的异常信息。 10. NoClassDefFoundError 和 ClassNoFoundException 有什么区别？ NoClassDefFoundError 是 Error（错误）类型，而 ClassNoFoundExcept 是 Exception（异常）类型； ClassNoFoundExcept 是 Java 使用 Class.forName 方法动态加载类，没有加载到，就会抛出 ClassNoFoundExcept 异常； NoClassDefFoundError 是 Java 虚拟机或者 ClassLoader 尝试加载类的时候却找不到类订阅导致的，也就是说要查找的类在编译的时候是存在的，运行的时候却找不到，这个时候就会出现 NoClassDefFoundError 的错误。 11. 使用 try-catch 为什么比较耗费性能？ 答：这个问题要从 JVM（Java 虚拟机）层面找答案了。首先 Java 虚拟机在构造异常实例的时候需要生成该异常的栈轨迹，这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息，这就是使用异常捕获耗时的主要原因了。 12. 常见的 OOM 原因有哪些？ 答：常见的 OOM 原因有以下几个： 数据库资源没有关闭； 加载特别大的图片； 递归次数过多，并一直操作未释放的变量。 13. 以下程序的返回结果是？ 12345678public static int getNumber() &#123; try &#123; int number = 0 / 1; return 2; &#125; finally &#123; return 3; &#125;&#125; A：0 B：2 C：3 D：1 答：3 题目解析：程序最后一定会执行 finally 里的代码，会把之前的结果覆盖为 3。 14. finally、finalize 的区别是什么？ 答：finally、finalize 的区别如下： finally 是异常处理语句的一部分，表示总是执行； finalize 是 Object 类的一个方法，子类可以覆盖该方法以实现资源清理工作，垃圾回收之前会调用此方法。 15. 为什么 finally 总能被执行？ 答：finally 总会被执行，都是编译器的作用，因为编译器在编译 Java 代码时，会复制 finally 代码块的内容，然后分别放在 try-catch 代码块所有的正常执行路径及异常执行路径的出口中，这样 finally 才会不管发生什么情况都会执行。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"4.Java 中的运算符和流程控制 + 面试题","slug":"interview-java-4","date":"2020-10-08T06:07:48.000Z","updated":"2020-10-08T06:27:50.770Z","comments":true,"path":"2020/10/08/interview-java-4/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-4/","excerpt":"","text":"Java 中的运算符和流程控制 + 面试题 算术运算符 Java 中的算术运算符，包括以下几种： 算术运算符 名称 举例 + 加法 1+2=3 - 减法 2-1=1 * 乘法 2*3=6 / 除法 24/8=3 % 求余 24%7=3 ++ 自增1 int i=1;i++ – 自减1 int i=1;i– 我们本讲要重点讲的是 “” 和 “–”，其他的算术运算符相对比较简单直观，本讲就不花精力去讲解了，之所以要把 “” 和 “–” 单独拿出来讲，是因为在使用他们的时候有很多坑需要开发者注意，最重要的是 “++” 和 “–” 也是面试中高频出现的面试题。 先来看 “++” 的基本使用： 1234int i &#x3D; 1;int i2 &#x3D; ++i; &#x2F;&#x2F; ++i 相当于 i &#x3D; 1+i;System.out.println(i); &#x2F;&#x2F; 2System.out.println(i2); &#x2F;&#x2F; 2 ++i 和 i++ 的区别 ++i 先自加再赋值 i++ 先赋值再自加 比如： 123456int i &#x3D; 0;int i2 &#x3D; i++;int j &#x3D; 0;int j2 &#x3D; ++j;System.out.println(&quot;i2&#x3D;&quot; + i2);System.out.println(&quot;j2&#x3D;&quot; + j2); 输出的结果： 12i2&#x3D;0j2&#x3D;1 代码解析：i++ 是先给 i2 赋值再自身 +1 ，所以 i2 等于0，而 ++j 是先自加等于 1 之后，再赋值给 j2，所以 j2 等于 1。 注意事项 ++/-- 是非线程安全的，也就是说 ++/-- 操作在多线程下可能会引发混乱，例如下面代码： 12345678910111213141516new Thread() &#123; @Override public void run() &#123; for (int i &#x3D; 0; i &lt; 100000; i++) &#123; System.out.println(&quot;thread:&quot; + this.getName() + &quot;,count&#x3D;&quot; + (++count)); &#125; &#125;&#125;.start();new Thread() &#123; @Override public void run() &#123; for (int i &#x3D; 0; i &lt; 100000; i++) &#123; System.out.println(&quot;thread:&quot; + this.getName() + &quot;,count&#x3D;&quot; + (++count)); &#125; &#125;&#125;.start(); 执行的结果，如下图： 如上图所示，每台机器的执行可能略有差距，但大多数情况下并不能给我们想要的真实值 200000。 原理分析 “++” 操作在多线程下引发混乱的原因：因为 ++ 操作对于底层操作系统来说，并不是一条 CPU 操作指令，而是三条 CPU 操作指令——取值、累加、存储，因此无法保证原子性，就会出现上面代码执行后的误差。 如何避免 ++/-- 操作在多线程下的“误差”？ 方法一：++/-- 操作放在同步块 synchronized 中。 方法二：自己申明锁，把 ++/-- 操作放入其中。 方法三：使用 AtomicInteger 类型替代 int 类型。 最后，因为 – 的语法和 ++ 完全一致，所以 – 的操作，请参照上面的 ++ 语法。 条件运算符（三元运算符） 条件运算符（?:）也叫“三元运算符”。 语法： 布尔表达式 ? 表达式1 ：表达式2 运算过程：如果布尔表达式的值为 true，则返回 表达式 1 的值，否则返回 表达式 2 的值。 例如： 12String s &#x3D; 3 &gt; 1 ? &quot;三大于一&quot; : &quot;三小于一&quot;;System.out.println(s); 执行结果：三大于一。 流程控制 在 Java 语言中使用条件语句和循环结构来实现流程控制。 1 条件语句 条件语句的语法格式： if(……) …… 其中的条件判断必须使用括号括起来不能省略。 基础用法使用： 12345678int i &#x3D; 1;if (i &gt; 1) &#123; System.out.println(&quot;i大于一&quot;);&#125; else if (i &#x3D;&#x3D; 1) &#123; System.out.println(&quot;i等于一&quot;);&#125; else &#123; System.out.println(&quot;其他&quot;);&#125; 2 循环 while 当条件成立的时候执行下一条语句。 while 语法格式： while(……) …… 基本语法使用： 1234int i &#x3D; 0; while (i &lt; 3) &#123; System.out.println(++i);&#125; while 是先判断再决定是否执行，有可能一次也不执行，如果希望至少执行一次，可以使用 do/while。 do/while 语法格式： do{……}while(……); 基本语法使用： 1234int i &#x3D; 0;do &#123; System.out.println(++i);&#125; while (i &lt; 3); 3 确定循环 for 循环是程序中最长使用的循环之一，它是利用每次迭代之后更新计数器来控制循环的次数。 for 语法格式： for(int i=0;i&lt;n;i++){ …… } 基础语法使用： 123for (int i &#x3D; 0; i &lt; 10; i++) &#123; System.out.println(&quot;i&#x3D;&quot; + i);&#125; for 循环中可使用关键字 continue，跳过后续操作，继续下一次迭代。 例如： 1234for (int i &#x3D; 1; i &lt; 4; i++) &#123; if (i &#x3D;&#x3D; 2) continue; System.out.println(&quot;i&#x3D;&quot; + i);&#125; 执行结果： 12i&#x3D;1i&#x3D;3 如结果所示，第二次循环就会跳过，执行下一次循环。 for 注意事项 在循环中检查两个浮点数是否相等要格外小心，例如下面代码： 12345public static void main(String[] args) &#123; for (float i &#x3D; 0; i !&#x3D; 1; i +&#x3D; 0.1) &#123; System.out.println(i); &#125;&#125; 循环永远不会停下来，由于舍入误差，因为 0.1 无法精确的用二级制表示，所以上面代码到 0.9000001 之后，会直接跳到 1.0000001，不会等于 1，所以循环就永远不会停下来。 4 多重选择 switch 的特点是可以判断多个条件，if 的特点是执行少量判断，它们两个刚好形成互补的关系。 switch 语法格式： switch(……){ case 1: …… break; …… default: …… break; } switch 基础使用： 123456789101112131415int i &#x3D; 3;switch (i) &#123; case 1: System.out.println(&quot;等于1&quot;); break; case 2: System.out.println(&quot;等于2&quot;); break; case 3: System.out.println(&quot;等于3&quot;); break; default: System.out.println(&quot;等于其他&quot;); break;&#125; 可用于 case 的类型有： byte、char、short、int 枚举 字符串（Java SE 7 新加入） switch 注意事项 switch 使用时，每个选项最末尾一定不要忘记加 break 关键字，否则会执行多个条件。 案例： 1234567891011int i &#x3D; 1;switch (i) &#123; case 1: System.out.println(&quot;等于1&quot;); case 2: System.out.println(&quot;等于2&quot;); case 3: System.out.println(&quot;等于3&quot;); default: System.out.println(&quot;等于其他&quot;);&#125; 程序执行的结果： 1234等于1等于2等于3等于其他 所以使用 switch 时，每个选项的末尾一定得加 break 关键字。 相关面试题 1. Java 中 i++ 和 ++i 有什么区别？ 答：i 先赋值再运算；i 先运算再赋值。 示例代码： 123456int i &#x3D; 0;int i2 &#x3D; i++;int j &#x3D; 0;int j2 &#x3D; ++j;System.out.println(&quot;i2&#x3D;&quot; + i2);System.out.println(&quot;j2&#x3D;&quot; + j2); 输出结果：i2=0，j2=1 2. 以下代码 i 的值是多少？ 123int i &#x3D; 0;i &#x3D; i++;System.out.println(i); 答：i=0 题目解析：因为 Java 虚拟机在执行 i++ 时，把这个值有赋值给了 i，而 i++ 是先赋值再相加，所以这个时候 i 接收到的结果自然是 0 了。 3. 以下代码 i2 和 i3 的值分别为多少？ 123int i &#x3D; 0;int i2 &#x3D; i++;int i3 &#x3D; ++i; 答：i2=0，i3=2 4. 以下代码能不能正常执行？ 1if (true) System.out.println(&quot;laowang&quot;); 答：可以正常执行，其中判断条件的括号不能省略，大括号是可以省略的（作者并不建议为了省代码的而牺牲代码的可读性）。 5. 以下 switch 执行的结果是什么？ 12345678910111213int num &#x3D; 1;switch (num) &#123; case 0: System.out.print(&quot;0&quot;); case 1: System.out.print(&quot;1&quot;); case 2: System.out.print(&quot;2&quot;); case 3: System.out.print(&quot;3&quot;); default: System.out.print(&quot;default&quot;);&#125; 答：123default 6. switch 能否用于 byte 类型的判断上？能否用于 long 类型的判断上？ 答：switch 支持 byte 类型的判断，不支持 long 类型的判断。 题目解析：switch 支持的全部类型（JDK 8）：char、byte、short、int、Charachter、Byte、Short、Integer、String、enum。 7. while 必须配合 break 一起使用的说法正确吗？ 答：错误，while 可以单独使用。 例如： 1234int i &#x3D; 0;while (i &lt; 3) &#123; System.out.println(++i);&#125; 8. 以下代码可以正常运行吗？为什么？ 1234567int i &#x3D; 0;while (i &lt; 3) &#123; if (i &#x3D;&#x3D; 2) &#123; return; &#125; System.out.println(++i);&#125; 答：可以正常运行，这里的 return 和 break 的效果是一致的，while 可以配合 return 或 break 一起使用。 9. 以下的程序执行结果什么？ 1234int i &#x3D; 0;do &#123; System.out.println(++i);&#125; while (i &lt; 3) 答：编译器报错，do/while 之后必须使用分号 ; 结尾。 10. 以下程序输出的结果是？ 1234567891011String s = new String(&quot;laowang&quot;);String s2 = new String(&quot;laowang&quot;);System.out.println(s == s2);switch (s) &#123; case &quot;laowang&quot;: System.out.println(&quot;laowang&quot;); break; default: System.out.println(&quot;default&quot;); break;&#125; A：true,default B：false,default C：false,laowang D：true,laowang 答：C 11. 以下代码循环执行了几次？ 123for (float i &#x3D; 0; i !&#x3D; 10; i +&#x3D; 0.1) &#123; System.out.println(&quot;hi&quot;);&#125; 答：无数次，循环永远不会停下来。由于舍入误差，因为 0.1 无法精确的用二级制表示，所以上面代码到 0.9000001 之后，会直接跳到 1.0000001，不会等于 1，所以循环就永远不会停下来。 12. 以下代码输出的结果是？ 12int num = -4;System.out.println(num % 2 == 1 || num % 2 == -1); A：1 B：-1 C：true D：false 答：D 题目解析：-4 % 2 = 0 既不等于 1 也不等于 -1，所以结果为 false。 13. 以下代码输出的结果是？ 123int num = 4;num = ((num &amp; 1) == 1);System.out.println(num); A：4 B：1 C：以上都不是 答：C 题目解析：== 运算返回的是 boolean 类型，不能使用 int 接收，所以程序会报错。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"3.深入理解字符串 + 面试题","slug":"interview-java-3","date":"2020-10-08T06:07:45.000Z","updated":"2020-10-08T06:24:25.403Z","comments":true,"path":"2020/10/08/interview-java-3/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-3/","excerpt":"","text":"深入理解字符串 + 面试题 字符串介绍 字符串是程序开发当中，使用最频繁的类型之一，有着与基础类型相同的地位，甚至在 JVM（Java 虚拟机）编译的时候会对字符串做特殊的处理，比如拼加操作可能会被 JVM 直接合成为一个最终的字符串，从而到达高效运行的目的。 1 String 特性 String 是标准的不可变类（immutable），对它的任何改动，其实就是创建了一个新对象，再把引用指向该对象； String 对象赋值之后就会在常量池中缓存，如果下次创建会判定常量池是否已经有缓存对象，如果有的话直接返回该引用给创建者。 2 字符串创建 字符串创建的两种方式： String str = “laowang”; String str = new String(“laowang”); 3 注意事项 查看下面代码： 12345String s1 = &quot;laowang&quot;;String s2 = s1;String s3 = new String(s1);System.out.println(s1 == s2);System.out.println(s1 == s3); 输出结果：true、false。 为什么会这样？原因是 s3 使用 new String 时一定会在堆中重新创建一个内存区域，而 s2 则会直接使用了 s1 的引用，所以得到的结果也完全不同。 字符串的使用 1 字符串拼加 字符串拼加的几种方式： String str = “lao” + “wang”; String str = “lao”; str += “wang”; String str = “lao”; String str2 = str + “wang”; 2 JVM 对字符串的优化 根据前面的知识我们知道，对于 String 的任何操作其实是创建了一个新对象，然后再把引用地址返回该对象，但 JVM 也会对 String 进行特殊处理，以此来提供程序的运行效率，比如以下代码： 1String str = &quot;hi,&quot; + &quot;lao&quot; + &quot;wang&quot;; 经过 JVM 优化后的代码是这样的： 1String str = &quot;hi,laowang&quot;; 验证代码如下： 123String str = &quot;hi,&quot; + &quot;lao&quot; + &quot;wang&quot;;String str2 = &quot;hi,laowang&quot;;System.out.println(str == str2); 执行的结果：true。 这就说明 JVM 在某些情况下会特殊处理 String 类型。 3 字符串截取 字符串的截取使用 substring() 方法，使用如下： 12345String str = &quot;abcdef&quot;;// 结果：cdef（从下标为2的开始截取到最后，包含开始下标）System.out.println(str.substring(2));// 结果：cd（从下标为2的开始截取到下标为4的，包含开始下标不包含结束下标）System.out.println(str.substring(2,4)); 4 字符串格式化 字符串格式化可以让代码更简洁更直观，比如，“我叫老王，今年 30 岁，喜欢读书”在这条信息中：姓名、年龄、兴趣都是要动态改变的，如果使用“+”号拼接的话很容易出错，这个时候字符串格式化方法 String.format() 就派上用场了，代码如下： 1String str = String.format(&quot;我叫%s，今年%d岁，喜欢%s&quot;, &quot;老王&quot;, 30, &quot;读书&quot;); 转换符说明列表： 转换符 说明 %s 字符串类型 %d 整数类型（十进制） %c 字符类型 %b 布尔类型 %x 整数类型（十六进制） %o 整数类型（八进制） %f 浮点类型 %a 浮点类型（十六进制） %e 指数类型 %% 百分比类型 %n 换行符 5 字符对比 根据前面的知识我们知道，使用 String 和 new String 声明的对象是不同的，那有没有简单的方法，可以忽略它们的创建方式（有没有 new）而只对比它们的值是否相同呢？答案是肯定的，使用 equals() 方法可以实现，代码如下： 12345678String s1 = &quot;hi,&quot; + &quot;lao&quot; + &quot;wang&quot;;String s2 = &quot;hi,&quot;;s2 += &quot;lao&quot;;s2 += &quot;wang&quot;;String s3 = &quot;hi,laowang&quot;;System.out.println(s1.equals(s2)); // trueSystem.out.println(s1.equals(s3)); // trueSystem.out.println(s2.equals(s3)); // true 以上使用 equals 对比的结果都为 true。 如果要忽略字符串的大小写对比值可以使用 equalsIgnoreCase()，代码示例： 1234String s1 = &quot;Hi,laowang&quot;;String s2 = &quot;hi,laowang&quot;;System.out.println(s1.equals(s2)); // falseSystem.out.println(s1.equalsIgnoreCase(s2)); // true s1.equals(s2) 执行的结果为：false，s1.equalsIgnoreCase(s2) 执行的结果为：true。 6 String、StringBuffer、StringBuilder 字符串相关类型主要有这三种：String、StringBuffer、StringBuilder，其中 StringBuffer、StringBuilder 都是可以变的字符串类型，StringBuffer 在字符串拼接时使用 synchronized 来保障线程安全，因此在多线程字符串拼接中推荐使用 StringBuffer。 StringBuffer 使用： 1234567StringBuffer sf = new StringBuffer(&quot;lao&quot;);// 添加字符串到尾部sf.append(&quot;wang&quot;); // 执行结果：laowang// 插入字符串到到当前字符串下标的位置sf.insert(0,&quot;hi,&quot;); // 执行结果：hi,laowang// 修改字符中某个下标的值sf.setCharAt(0,&#x27;H&#x27;); // 执行结果：Hi,laowang StringBuilder 的使用方法和 StringBuffer 一样，它们都继承于 AbstractStringBuilder。 相关面试题 1. String 属于基础数据类型吗？ 答：String 不是基础数据类型，它是从堆上分配来的。基础数据类型有 8 个，分别为：boolean、byte、short、int、long、float、double、char。 2. 以下可以正确获取字符串长度的是？ A：str.length B：str.size C：str.length() D：str.size() 答：C 题目解析：字符串没有 length 属性，只有 length() 方法。 3. “==” 和 equals 的区别是什么？ 答：&quot;==&quot; 对基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 ① “==” 解读 对于基本类型和引用类型 == 的作用效果是不同的，如下所示： 基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同。 代码示例： 1234567String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true 代码说明：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String() 方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。 ② equals 解读 equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。 首先来看默认情况下 equals 比较一个有相同值的对象，代码如下： 123456789101112131415class Cat &#123; public Cat(String name) &#123; this.name = name; &#125; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？！ 这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 原来 equals 本质上就是 ==。 那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下： 123String s1 = new String(&quot;老王&quot;);String s2 = new String(&quot;老王&quot;);System.out.println(s1.equals(s2)); // true 同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 总结来说，&quot;==&quot; 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 4. 以下代码输出的结果是？ 123String str = &quot;laowang&quot;;str.substring(0,1);System.out.println(str); A：l B：a C：la D：laowang 答：D 题目解析：因为 String 的 substring() 方法不会修改原字符串内容，所以结果还是 laowang。 5. 以下字符串对比的结果是什么？ 12345678String s1 = &quot;hi,&quot; + &quot;lao&quot; + &quot;wang&quot;;String s2 = &quot;hi,&quot;;s2 += &quot;lao&quot;;s2 += &quot;wang&quot;;String s3 = &quot;hi,laowang&quot;;System.out.println(s1 == s2);System.out.println(s1 == s3);System.out.println(s2 == s3); 答：false true false 题目解析：String s1 = “hi,” + “lao” + “wang” 代码会被 JVM 优化为：String s1 = “hi,laowang”，这样就和 s3 完全相同，s1 创建的时候会把字符&quot;hi,laowang&quot;放入常量池，s3 创建的时候，常量池中已经存在对应的缓存，会直接把引用返回给 s3，所以 s1==s3 就为 true，而 s2 使用了 += 其引用地址就和其他两个不同。 6. 以下 String 传值修改后执行的结果是什么？ 12345678public static void main(String[] args) &#123; String str = new String(&quot;laowang&quot;); change(str); System.out.println(str);&#125;public static void change(String str) &#123; str = &quot;xiaowang&quot;;&#125; 答：laowang 7. 以下 StringBuffer 传值修改后的执行结果是什么？ 12345678public static void main(String[] args) &#123; StringBuffer sf = new StringBuffer(&quot;hi,&quot;); changeSf(sf); System.out.println(sf);&#125;public static void changeSf(StringBuffer sf)&#123; sf.append(&quot;laowang&quot;);&#125; 答：hi,laowang 题目解析：String 为不可变类型，在方法内对 String 修改的时候，相当修改传递过来的是一个 String 副本，所以 String 本身的值是不会被修改的，而 StringBuffer 为可变类型，参数传递过来的是对象的引用，对其修改它本身就会发生改变。 8. 以下使用 substring 执行的结果什么？ 12String str = &quot;abcdef&quot;;System.out.println(str.substring(3, 3)); 答：&quot;&quot;(空)。 9. 判定字符串是否为空，有几种方式？ 答：常用的方式有以下两种。 str.equals(&quot;&quot;) str.length()==0 10. String、StringBuffer、StringBuilder 的区别？ 答：以下是 String、StringBuffer、StringBuilder 的区别： 可变性：String 为字符串常量是不可变对象，StringBuffer 与 StringBuilder 为字符串变量是可变对象； 性能：String 每次修改相当于生成一个新对象，因此性能最低；StringBuffer 使用 synchronized 来保证线程安全，性能优于 String，但不如 StringBuilder； 线程安全：StringBuilder 为非线程安全类，StringBuffer 为线程安全类。 11. String 对象的 intern() 有什么作用？ 答：intern() 方法用于查找常量池中是否存在该字符值，如果常量池中不存在则先在常量池中创建，如果已经存在则直接返回。 示例代码： 123String s = &quot;laowang&quot;;String s2 = s.intern();System.out.println(s == s2); // 返回 true 12. String s=new String(“laowang”) 创建了几个对象？ 答：创建了一个或两个对象，如果常量池中已经有了字符串 “laowang”，就只会创建一个引用对象 s 指向常量池中的对象 ”laowang“；如果常量池中没有字符串 ”laowang“，则先会在常量池中创建一个对象 ”laowang“，再创建一个引用对象 s 指向常量池中的对象，所以答案是创建一个或者两个对象。 13. 什么是字符串常量池？ 字符串常量池是存储在 Java 堆内存中的字符串池，是为防止每次新建字符串带的时间和空间消耗的一种解决方案。在创建字符串时 JVM 会首先检查字符串常量池，如果字符串已经存在池中，就返回池中的实例引用，如果字符串不在池中，就会实例化一个字符串放到池中并把当前引用指向该字符串。 14. String 不可变性都有哪些好处？ 答：不可变的好处如下。 只有当字符串是不可变的，字符串常量池才能实现，字符串池的实现可以在运行时节约很多堆空间，因为不同的字符串变量都指向池中的同一个字符串； 可以避免一些安全漏洞，比如在 Socket 编程中，主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞； 多线程安全，因为字符串是不可变的，所以同一个字符串实例可以被多个线程共享，保证了多线程的安全性； 适合做缓存的 key，因为字符串是不可变的，所以在它创建的时候哈希值就被缓存了，不需要重新计算速度更快，所以字符串很适合作缓存的中的 key。 15. String 是否可以被继承？为什么？ 答：String 不能被继承。因为 String 被声明为 final（最终类），所以不能被继承，源码如下（JDK 8）。 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; //......&#125;","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"2.你不知道的基本数据类型和包装类 + 面试题","slug":"interview-java-2","date":"2020-10-08T06:07:41.000Z","updated":"2020-10-08T06:22:45.368Z","comments":true,"path":"2020/10/08/interview-java-2/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-2/","excerpt":"","text":"你不知道的基本数据类型和包装类 + 面试题 基本数据类型 Java 基本数据按类型可以分为四大类：布尔型、整数型、浮点型、字符型，这四大类包含 8 种基本数据类型。 布尔型：boolean 整数型：byte、short、int、long 浮点型：float、double 字符型：char 8 种基本类型取值如下： 数据类型 代表含义 默认值 取值 包装类 boolean 布尔型 false 0(false) 到 1(true) Boolean byte 字节型 (byte)0 ﹣128 到 127 Byte char 字符型 ‘\\u0000’(空) ‘\\u0000’ 到 ‘\\uFFFF’ Character short 短整数型 (short)0 -215215 到 215215-1 Short int 整数型 0 ﹣231231 到 231231-1 Integer long 长整数型 0L ﹣263263 到 263263-1 Long float 单浮点型 0.0f 1.4e-45 到 3.4e+38 Float double 双浮点型 0.0d 4.9e-324 到 1.798e+308 Double 除 char 的包装类 Character 和 int 的包装类 Integer 之外，其他基本数据类型的包装类只需要首字母大写即可。包装类的作用和特点，本文下半部分详细讲解。 我们可以在代码中，查看某种类型的取值范围，代码如下： 123456public static void main(String[] args) &#123; &#x2F;&#x2F; Byte 取值：-128 ~ 127 System.out.println(String.format(&quot;Byte 取值：%d ~ %d&quot;, Byte.MIN_VALUE, Byte.MAX_VALUE)); &#x2F;&#x2F; Int 取值：-2147483648 ~ 2147483647 System.out.println(String.format(&quot;Int 取值：%d ~ %d&quot;, Integer.MIN_VALUE, Integer.MAX_VALUE));&#125; 包装类型 我们知道 8 种基本数据类型都有其对应的包装类，因为 Java 的设计思想是万物既对象，有很多时候我们需要以对象的形式操作某项功能，比如说获取哈希值（hashCode）或获取类（getClass）等。 那包装类特性有哪些？ 1. 功能丰富 包装类本质上是一个对象，对象就包含有属性和方法，比如 hashCode、getClass 、max、min 等。 2. 可定义泛型类型参数 包装类可以定义泛型，而基本类型不行。 比如使用 Integer 定义泛型，代码： 1List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(); 如果使用 int 定义就会报错，代码： 1List list &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 编译器代码报错 3. 序列化 因为包装类都实现了 Serializable 接口，所以包装类天然支持序列化和反序列化。比如 Integer 的类图如下： 4. 类型转换 包装类提供了类型转换的方法，可以很方便的实现类型之间的转换，比如 Integer 类型转换代码： 1234String age &#x3D; &quot;18&quot;;int ageInt &#x3D; Integer.parseInt(age) + 2;&#x2F;&#x2F; 输出结果：20System.out.println(ageInt); 5. 高频区间的数据缓存 此特性为包装类很重要的用途之一，用于高频区间的数据缓存，以 Integer 为例来说，在数值区间为 -128~127 时，会直接复用已有对象，在这区间之外的数字才会在堆上产生。 我们使用 == 对 Integer 进行验证，代码如下： 1234567891011public static void main(String[] args) &#123; &#x2F;&#x2F; Integer 高频区缓存范围 -128~127 Integer num1 &#x3D; 127; Integer num2 &#x3D; 127; &#x2F;&#x2F; Integer 取值 127 &#x3D;&#x3D; 结果为 true（值127 num1&#x3D;&#x3D;num2 &#x3D;&gt; true） System.out.println(&quot;值127 num1&#x3D;&#x3D;num2 &#x3D;&gt; &quot; + (num1 &#x3D;&#x3D; num2)); Integer num3 &#x3D; 128; Integer num4 &#x3D; 128; &#x2F;&#x2F; Integer 取值 128 &#x3D;&#x3D; 结果为 false（值128 num3&#x3D;&#x3D;num4 &#x3D;&gt; false） System.out.println(&quot;值128 num3&#x3D;&#x3D;num4 &#x3D;&gt; &quot; + (num3 &#x3D;&#x3D; num4)); &#125; 从上面的代码很明显可以看出，Integer 为 127 时复用了已有对象，当值为 128 时，重新在堆上生成了新对象。 为什么会产生高频区域数据缓存？我们查看源码就能发现“线索”，源码版本 JDK8，源码如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 由此可见，高频区域的数值会直接使用已有对象，非高频区域的数值会重新 new 一个新的对象。 各包装类高频区域的取值范围： Boolean：使用静态 final 定义，就会返回静态值 Byte：缓存区 -128~127 Short：缓存区 -128~127 Character：缓存区 0~127 Long：缓存区 -128~127 Integer：缓存区 -128~127 包装类的注意事项 int 的默认值是 0，而 Integer 的默认值是 null。 推荐所有包装类对象之间的值比较使用 equals() 方法，因为包装类的非高频区数据会在堆上产生，而高频区又会复用已有对象，这样会导致同样的代码，因为取值的不同，而产生两种截然不同的结果。代码示例： 12345678910111213public static void main(String[] args) &#123; &#x2F;&#x2F; Integer 高频区缓存范围 -128~127 Integer num1 &#x3D; 127; Integer num2 &#x3D; 127; &#x2F;&#x2F; Integer 取值 127 &#x3D;&#x3D; 结果为 true（值127 num1&#x3D;&#x3D;num2 &#x3D;&gt; true） System.out.println(&quot;值127 num1&#x3D;&#x3D;num2 &#x3D;&gt; &quot; + (num1 &#x3D;&#x3D; num2)); Integer num3 &#x3D; 128; Integer num4 &#x3D; 128; &#x2F;&#x2F; Integer 取值 128 &#x3D;&#x3D; 结果为 false（值128 num3&#x3D;&#x3D;num4 &#x3D;&gt; false） System.out.println(&quot;值128 num3&#x3D;&#x3D;num4 &#x3D;&gt; &quot; + (num3 &#x3D;&#x3D; num4)); &#x2F;&#x2F; Integer 取值 128 equals 结果为 true（值128 num3.equals(num4) &#x3D;&gt; true） System.out.println(&quot;值128 num3.equals(num4) &#x3D;&gt; &quot; + num3.equals(num4));&#125; Float 和 Double 不会有缓存，其他包装类都有缓存。 Integer 是唯一一个可以修改缓存范围的包装类，在 VM optons 加入参数： -XX:AutoBoxCacheMax=666 即修改缓存最大值为 666 。 示例代码如下： 1234567891011public static void main(String[] args) &#123; Integer num1 &#x3D; -128; Integer num2 &#x3D; -128; System.out.println(&quot;值为-128 &#x3D;&gt; &quot; + (num1 &#x3D;&#x3D; num2)); Integer num3 &#x3D; 666; Integer num4 &#x3D; 666; System.out.println(&quot;值为666 &#x3D;&gt; &quot; + (num3 &#x3D;&#x3D; num4)); Integer num5 &#x3D; 667; Integer num6 &#x3D; 667; System.out.println(&quot;值为667 &#x3D;&gt; &quot; + (num5 &#x3D;&#x3D; num6));&#125; 执行结果如下： 123值为-128 &#x3D;&gt; true值为666 &#x3D;&gt; true值为667 &#x3D;&gt; false 由此可见将 Integer 最大缓存修改为 666 之后，667 不会被缓存，而 -128~666 之间的数都被缓存了。 相关面试题 1. 以下 Integer 代码输出的结果是？ 12345Integer age = 10;Integer age2 = 10;Integer age3 = 133;Integer age4 = 133;System.out.println((age == age2) + &quot;,&quot; + (age3 == age4)); 答：true,false 2. 以下 Double 代码输出的结果是？ 12345Double num &#x3D; 10d;Double num2 &#x3D; 10d;Double num3 &#x3D; 133d;Double num4 &#x3D; 133d;System.out.println((num &#x3D;&#x3D; num2) + &quot;,&quot; + (num3 &#x3D;&#x3D; num4)); 答：false,false 3. 以下程序输出结果是？ 1234int i = 100;Integer j = new Integer(100);System.out.println(i == j);System.out.println(j.equals(i)); A：true,true B：true,false C：false,true D：false,false 答：A 题目分析：有人认为这和 Integer 高速缓存有关系，但你发现把值改为 10000 结果也是 true,true，这是因为 Integer 和 int 比较时，会自动拆箱为 int 相当于两个 int 比较，值一定是 true,true。 4. 以下程序执行的结果是？ 12final int iMax = Integer.MAX_VALUE;System.out.println(iMax + 1); A：2147483648 B：-2147483648 C：程序报错 D：以上都不是 答：B 题目解析：这是因为整数在内存中使用的是补码的形式表示，最高位是符号位 0 表示正数，1 表示负数，当执行 +1 时，最高位就变成了 1，结果就成了 -2147483648。 5. 以下程序执行的结果是？ 123456Set&lt;Short&gt; set = new HashSet&lt;&gt;();for (short i = 0; i &lt; 5; i++) &#123; set.add(i); set.remove(i - 1);&#125;System.out.println(set.size()); A：1 B：0 C：5 D：以上都不是 答：5 题目解析：Short 类型 -1 之后转换成了 Int 类型，remove() 的时候在集合中找不到 Int 类型的数据，所以就没有删除任何元素，执行的结果就是 5。 6. short s=2;s=s+1; 会报错吗？short s=2;s+=1; 会报错吗？ 答：s=s+1 会报错，s+=1 不会报错，因为 s=s+1 会导致 short 类型升级为 int 类型，所以会报错，而 s+=1 还是原来的 short 类型，所以不会报错。 7. float f=3.4; 会报错吗？为什么？ 答：会报错，因为值 3.4 是 double 类型，float 类型级别小于 double 类型，所以会报错。如下图所示： 8. 为什么需要包装类？ 答：需要包装类的原因有两个。 ① Java 的设计思想是万物既对象，包装类体现了面向对象的设计理念； ② 包装类包含了很多属性和方法，比基本数据类型功能多，比如提供的获取哈希值（hashCode）或获取类（getClass）的方法等。 9. 基本类 int 和包装类 Integer，在 -128~127 之间都会复用已有的缓存对象，这种说法正确吗？ 答：不正确，只有包装类高频区域数据才有缓存。 10. 包装类 Double 和 Integer 一样都有高频区域数据缓存，这种说法正确吗？ 答：不正确，基本数据类型的包装类只有 Double 和 Float 没有高频区域的缓存。 11. 包装类的值比较要使用什么方法？ 答：包装类因为有高频区域数据缓存，所以推荐使用 equals() 方法进行值比较。 12. 包装类有哪些功能？ 答：包装类提供的功能有以下几个。 功能丰富：包装类包含了有 hashCode、getClass 、max、min 等方法； 可定义泛型类型参数：例如 List list = new ArrayList&lt;&gt;(); ; 序列化：包装类实现了 Serializable 接口，所以包装类天然支持序列化和反序列化； 类型转换：包装类提供了方便的类型转换方法，比如 Integer 的 parseInt() 方法； 高频区域数据缓存：高频区域可使用已有的缓存对象。 详见正文“包装类型”部分内容。 13. 泛型可以为基本类型吗？为什么？ 答：泛型不能使用基本数据类型。泛型在 JVM（Java虚拟机）编译的时候会类型檫除，比如代码 List list 在 JVM 编译的时候会转换为 List list ，因为泛型是在 JDK 5 时提供的，而 JVM 的类型檫除是为了兼容以前代码的一个折中方案，类型檫除之后就变成了 Object，而 Object 不能存储基本数据类型，但可以使用基本数据类型对应的包装类，所以像 List list 这样的代码是不被允许的，编译器阶段会检查报错，而 List list 是被允许的。 14. 选择包装类还是基本类的原则有哪些？ 答：我们知道正确的使用包装类，可以提供程序的执行效率，可以使用已有的缓存，一般情况下选择基本数据类型还是包装类原则有以下几个。 ① 所有 POJO 类属性必须使用包装类； ② RPC 方法返回值和参数必须使用包装类； ③ 所有局部变量推荐使用基本数据类型。 15. 基本数据类型在 JVM 中一定存储在栈中吗？为什么？ 答：基本数据类型不一定存储在栈中，因为基本类型的存储位置取决于声明的作用域，来看具体的解释。 当基本数据类型为局部变量的时候，比如在方法中声明的变量，则存放在方法栈中的，当方法结束系统会释放方法栈，在该方法中的变量也会随着栈的销毁而结束，这也是局部变量只能在方法中使用的原因； 当基本数据类型为全局变量的时候，比如类中的声明的变量，则存储在堆上，因为全局变量不会随着某个方法的执行结束而销毁。 16. 以下程序执行的结果是？ 1234567Integer i1 = new Integer(10);Integer i2 = new Integer(10);Integer i3 = Integer.valueOf(10);Integer i4 = Integer.valueOf(10);System.out.println(i1 == i2);System.out.println(i2 == i3);System.out.println(i3 == i4); A：false,false,false B：false,false,true C：false,true,true D：true,false,false 答：B 题目解析：new Integer(10) 每次都会创建一个新对象，Integer.valueOf(10) 则会使用缓存池中的对象。 17. 3*0.1==0.3 返回值是多少？ 答：返回值为：false。 题目解析：因为有些浮点数不能完全精确的表示出来，如下代码： System.out.println(3 * 0.1); 返回的结果是：0.30000000000000004。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"1.Java 程序是如何执行的","slug":"interview-java-1","date":"2020-10-08T06:07:38.000Z","updated":"2021-02-23T14:23:16.758Z","comments":true,"path":"2020/10/08/interview-java-1/","link":"","permalink":"https://idea360.cn/2020/10/08/interview-java-1/","excerpt":"","text":"Java 程序是如何执行的 了解任何一门语言的精髓都是先俯览其全貌，从宏观的视角把握全局，然后再深入每个知识点逐个击破，这样就可以深入而快速的掌握一项技能。同样学习 Java 也是如此，本节就让我们先从整体来看一下 Java 中的精髓。 Java 介绍 Java 诞生于 1991 年，Java 的前身叫做 Oak（橡树），但在注册商标的时候，发现这个名字已经被人注册了，后来团队的人就在咖啡馆讨论这件事该怎么办，有人灵机一动说叫 Java 如何，因为当时他们正在喝着一款叫做 Java 的咖啡。就这样，这个后来家喻户晓的名字，竟以这种“随意”的方式诞生了，并一直沿用至今。 Java 发展历程： 1990，Sun 成立了“Green Team”项目小组 1991，Java 语言前身 Oak（橡树）诞生 1995，Oak 语言更名为 Java 1996，Java 1.0 发布 1997，Java 1.1 发布 1998，Java 1.2 发布 2000，Java 1.3 发布 2000，Java 1.4 发布 2004，Java 5 发布 2006，Java 6 发布 2011，Java 7 发布 2014，Java 8 发布 2017，Java 9（非长期支持版）发布 2018.03，Java 10（非长期支持版） 发布 2018.09，Java 11（长期支持版）发布 2019.03, Java 12（非长期支持版） 发布 注：长期支持版指的是官方发布版本后的一段时间内，通常以“年”为计数单位，会对此版本进行持续维护和升级。 版本发布时间 Java 10 之后，官方表示每半年推出一个大版本，长期支持版本（LTS）每三年发布一次。 Java 和 JDK 的关系 JDK（Java Development Kit）Java 开发工具包，它包括：编译器、Java 运行环境（JRE，Java Runtime Environment）、JVM（Java 虚拟机）监控和诊断工具等，而 Java 则表示一种开发语言。 Java 程序是怎么执行的？ 我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？ 其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下： 先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器 -&gt; 最终生成字节码，其中任何一个节点执行失败就会造成编译失败； 把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM； Java 虚拟机使用类加载器（Class Loader）装载 class 文件； 类加载完成之后，会进行字节码校验，字节码校验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。 Java 程序执行流程图如下： Java 虚拟机是如何判定热点代码的？ Java 虚拟机判定热点代码的方式有两种： 基于采样的热点判定 主要是虚拟机会周期性的检查各个线程的栈顶，若某个或某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种判定方式的优点是实现简单；缺点是很难精确一个方法的热度，容易受到线程阻塞或外界因素的影响。 基于计数器的热点判定 主要就是虚拟机给每一个方法甚至代码块建立了一个计数器，统计方法的执行次数，超过一定的阀值则标记为此方法为热点方法。 Hotspot 虚拟机使用的基于计数器的热点探测方法。它使用了两类计数器：方法调用计数器和回边计数器，当到达一定的阀值是就会触发 JIT 编译。 方法调用计数器：在 client 模式下的阀值是 1500 次，Server 是 10000 次，可以通过虚拟机参数： -XX:CompileThreshold=N 对其进行设置。但是JVM还存在热度衰减，时间段内调用方法的次数较少，计数器就减小。 回边计数器：主要统计的是方法中循环体代码执行的次数。 由上面的知识我们可以看出，要想做到对 Java 了如指掌，必须要好好学习 Java 虚拟机，那除了 Java 虚拟机外，还有哪些知识是面试必考，也是 Java 工程师必须掌握的知识呢？ 1. Java 基础中的核心内容 字符串和字符串常量池的深入理解、Array 的操作和排序算法、深克隆和浅克隆、各种 IO 操作、反射和动态代理（JDK 自身动态代理和 CGLIB）等。 2. 集合 集合和 String 是编程中最常用的数据类型，关于集合的知识也是面试备考的内容，它包含：链表（LinkedList）、TreeSet、栈（Stack）、队列（双端、阻塞、非阻塞队列、延迟队列）、HashMap、TreeMap 等，它们的使用和底层存储数据结构都是热门的面试内容。 3. 多线程 多线程使用和线程安全的知识也是必考的面试题目，它包括：死锁、6 种线程池的使用与差异、ThreadLocal、synchronized、Lock、JUC（java.util.concurrent包）、CAS（Compare and Swap）、ABA 问题等。 4. 热门框架 Spring、Spring MVC、MyBatis、SpringBoot 5. 分布式编程 消息队列（RabbitMQ、Kafka）、Dubbo、Zookeeper、SpringCloud 等。 6. 数据库 MySQL 常用引擎的掌握、MySQL 前缀索引、回表查询、数据存储结构、最左匹配原则、MySQL 的问题分析和排除方案、MySQL 读写分离的实现原理以及 MySQL 的常见优化方案等。 Redis 的使用场景、缓存雪崩和缓存穿透的解决方案、Redis 过期淘汰策略和主从复制的实现方案等。 7. Java 虚拟机 虚拟机的组成、垃圾回收算法、各种垃圾回收器的区别、Java 虚拟机分析工具的掌握、垃圾回收器的常用调优参数等。 8. 其他 常用算法的掌握、设计模式的理解、网络知识和常见 Linux 命令的掌握等。 值得庆幸的是以上所有内容都包含在本专栏中，接下来就让我们一起学习，一起构建 Java 的认知体系吧! 相关面试题 1. Java 语言都有哪些特点？ 答：Java 语言包含以下特点。 面向对象，程序容易理解、开发简单、方便； 跨平台，可运行在不同服务器类型上，比如：Linux、Windows、Mac 等； 执行性能好，运行效率高； 提供大量的 API 扩展，语言强大； 有多线程支持，增加了响应和实时交互的能力； 安全性好，自带验证机制，确保程序的可靠性和安全性。 2. Java 跨平台实现的原理是什么？ 答：要了解 Java 跨平台实现原理之前，必须先要了解 Java 的执行过程，Java 的执行过程如下： Java 执行流程：Java 源代码（.java）-&gt; 编译 -&gt; Java 字节码（.class） -&gt;通过 JVM（Java 虚拟机）运行 Java 程序。每种类型的服务器都会运行一个 JVM，Java 程序只需要生成 JVM 可以执行的代码即可，JVM 底层屏蔽了不同服务器类型之间的差异，从而可以在不同类型的服务器上运行一套 Java 程序。 3. JDK、JRE、JVM 有哪些区别？ 答：了解了 JDK、JRE、JVM 的定义也就明白了它们之间的区别，如下所述。 JDK：Java Development Kit（Java 开发工具包）的简称，提供了 Java 的开发环境和运行环境； JRE：Java Runtime Environment（Java 运行环境）的简称，为 Java 的运行提供了所需环境； JVM：Java Virtual Machine（Java虚拟机）的简称，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的，简单来说就是所有的 Java 程序都是运行在 JVM（Java 虚拟机）上的。 总体来说，JDK 提供了一整套的 Java 运行和开发环境，通常使用对象为 Java 的开发者，当然 JDK 也包含了 JRE；而 JRE 为 Java 运行的最小运行单元，一般安装在 Java 服务器上，所以 JDK 和 JRE 可以从用途上进行理解和区分。JVM 不同于 JDK 和 JRE，JVM 是 Java 程序运行的载体，Java 程序只有通过 JVM 才能正常的运行。 4. Java 中如何获取明天此刻的时间？ 答：JDK 8 之前使用 Calendar.add() 方法获取，代码如下： 123Calendar calendar = Calendar.getInstance();calendar.add(Calendar.DATE, 1);System.out.println(calendar.getTime()); JDK 8 有两种获取明天时间的方法。 方法一，使用 LocalDateTime.plusDays() 方法获取，代码如下： 123LocalDateTime today = LocalDateTime.now();LocalDateTime tomorrow = today.plusDays(1);System.out.println(tomorrow); 方法二，使用 LocalDateTime.minusDays() 方法获取，代码如下： 123LocalDateTime today = LocalDateTime.now();LocalDateTime tomorrow = today.minusDays(-1);System.out.println(tomorrow); minusDays() 方法为当前时间减去 n 天，传负值就相当于当前时间加 n 天。 5. Java 中如何跳出多重嵌套循环？ 答：Java 中跳出多重嵌套循环的两种方式。 方法一：定义一个标号，使用 break 加标号的方式 方法二：使用全局变量终止循环 方法一，示例代码： 123456789myfor:for (int i = 0; i &lt; 100; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; System.out.println(&quot;J:&quot; + j); if (j == 10) &#123; // 跳出多重循环 break myfor; &#125; &#125;&#125; 方法二，示例代码： 1234567891011boolean flag = true;for (int i = 0; i &lt; 100 &amp;&amp; flag; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; System.out.println(&quot;J:&quot; + j); if (j == 10) &#123; // 跳出多重循环 flag = false; break; &#125; &#125;&#125; 6. char 变量能不能存贮一个中文汉字？为什么？ 答：char 变量可以存贮一个汉字，因为 Java 中使用的默认编码是 Unicode ，一个 char 类型占 2 个字节（16 bit），所以放一个中文是没问题的。 7. Java 中会存在内存泄漏吗？请简单描述一下。 答：一个不再被程序使用的对象或变量一直被占据在内存中就造成了内存泄漏。 Java 中的内存泄漏的常见情景如下： 长生命周期对象持有短生命的引用，比如，缓存系统，我们加载了一个对象放在缓存中，然后一直不使用这个缓存，由于缓存的对象一直被缓存引用得不到释放，就造成了内存泄漏； 各种连接未调用关闭方法，比如，数据库 Connection 连接，未显性地关闭，就会造成内存泄漏； 内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露； 改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。","categories":[{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"设计模式——装饰者模式","slug":"design-patterns-decorator","date":"2020-10-06T07:20:18.000Z","updated":"2021-02-23T14:14:34.658Z","comments":true,"path":"2020/10/06/design-patterns-decorator/","link":"","permalink":"https://idea360.cn/2020/10/06/design-patterns-decorator/","excerpt":"","text":"概述 先简单描述下装饰者模式发挥作用的地方，当我们设计好了一个类，我们需要给这个类添加一些辅助的功能，并且不希望改变这个类的代码，这时候就是装饰者模式大展雄威的时候了。 这里还体现了一个原则：类应该对扩展开放，对修改关闭。 实现 下面以游戏为背景介绍装饰者模式。玩过游戏的兄弟应该都知道，游戏里面每个角色有武器、鞋子、护腕、戒指、还有各种红宝石、蓝宝石、黄宝石等等。 下面需求开始：设计游戏的装备系统，基本要求，要可以计算出每种装备在镶嵌了各种宝石后的攻击力和描述： 具体需求： 1、武器（攻击力20） 、戒指（攻击力5）、护腕（攻击力5）、鞋子（攻击力5） 2、蓝宝石（攻击力5/颗）、黄宝石（攻击力10/颗）、红宝石（攻击力15/颗） 3、每个装备可以随意镶嵌3颗 代码 装备超类 123456789101112131415161718192021222324252627package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 装备的接口 */public interface IEquip &#123; /** * 计算攻击力 * * @return */ public int caculateAttack(); /** * 装备的描述 * * @return */ public String description();&#125; 武器 12345678910111213141516171819202122232425package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 武器 * 攻击力20 */public class ArmEquip implements IEquip &#123; @Override public int caculateAttack() &#123; return 20; &#125; @Override public String description() &#123; return &quot;屠龙刀&quot;; &#125;&#125; 戒指 1234567891011121314151617181920212223242526package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 戒指 * 攻击力5 */public class RingEquip implements IEquip &#123; @Override public int caculateAttack() &#123; return 5; &#125; @Override public String description() &#123; return &quot;圣战戒指&quot;; &#125;&#125; 护腕 12345678910111213141516171819202122232425package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 护腕 * 攻击力5 */public class WristEquip implements IEquip &#123; @Override public int caculateAttack() &#123; return 5; &#125; @Override public String description() &#123; return &quot;圣战护腕&quot;; &#125;&#125; 鞋子 1234567891011121314151617181920212223242526package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 鞋子 * 攻击力5 */public class ShoeEquip implements IEquip &#123; @Override public int caculateAttack() &#123; return 5; &#125; @Override public String description() &#123; return &quot;圣战靴子&quot;; &#125;&#125; 装饰品超类 123456789101112package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 装饰品的接口 */public interface IEquipDecorator extends IEquip &#123;&#125; 蓝宝石 1234567891011121314151617181920212223242526272829303132333435package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 蓝宝石装饰品 * 每颗攻击力+5 */public class BlueGemDecorator implements IEquipDecorator &#123; /** * 每个装饰品维护一个装备 */ private IEquip equip; public BlueGemDecorator(IEquip equip) &#123; this.equip = equip; &#125; @Override public int caculateAttack() &#123; return 5 + equip.caculateAttack(); &#125; @Override public String description() &#123; return equip.description() + &quot;+ 蓝宝石&quot;; &#125;&#125; 黄宝石 1234567891011121314151617181920212223242526272829303132333435package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 黄宝石装饰品 * 每颗攻击力+10 */public class YellowGemDecorator implements IEquipDecorator &#123; /** * 每个装饰品维护一个装备 */ private IEquip equip; public YellowGemDecorator(IEquip equip) &#123; this.equip = equip; &#125; @Override public int caculateAttack() &#123; return 10 + equip.caculateAttack(); &#125; @Override public String description() &#123; return equip.description() + &quot;+ 黄宝石&quot;; &#125;&#125; 红宝石 1234567891011121314151617181920212223242526272829303132333435package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 * * 红宝石装饰品 * 每颗攻击力+15 */public class RedGemDecorator implements IEquipDecorator &#123; /** * 每个装饰品维护一个装备 */ private IEquip equip; public RedGemDecorator(IEquip equip) &#123; this.equip = equip; &#125; @Override public int caculateAttack() &#123; return 15 + equip.caculateAttack(); &#125; @Override public String description() &#123; return equip.description() + &quot;+ 红宝石&quot;; &#125;&#125; 演示 1234567891011121314151617181920212223242526272829303132333435363738package com.example.decorator;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 */public class DecoratorDemo &#123; /** * 一个镶嵌2颗红宝石，1颗蓝宝石的靴子 * 攻击力 : 40 * 描述 :圣战靴子+ 蓝宝石+ 红宝石+ 红宝石 * ------- * 一个镶嵌1颗红宝石，1颗蓝宝石,1颗黄宝石的武器 * 攻击力 : 50 * 描述 :屠龙刀+ 黄宝石+ 蓝宝石+ 红宝石 * ------- * * @param args */ public static void main(String[] args) &#123; // 一个镶嵌2颗红宝石，1颗蓝宝石的靴子 System.out.println(&quot; 一个镶嵌2颗红宝石，1颗蓝宝石的靴子&quot;); IEquip equip = new RedGemDecorator(new RedGemDecorator(new BlueGemDecorator(new ShoeEquip()))); System.out.println(&quot;攻击力 : &quot; + equip.caculateAttack()); System.out.println(&quot;描述 :&quot; + equip.description()); System.out.println(&quot;-------&quot;); // 一个镶嵌1颗红宝石，1颗蓝宝石的武器 System.out.println(&quot; 一个镶嵌1颗红宝石，1颗蓝宝石,1颗黄宝石的武器&quot;); equip = new RedGemDecorator(new BlueGemDecorator(new YellowGemDecorator(new ArmEquip()))); System.out.println(&quot;攻击力 : &quot; + equip.caculateAttack()); System.out.println(&quot;描述 :&quot; + equip.description()); System.out.println(&quot;-------&quot;); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://github.com/youlookwhat/DesignPattern","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"装饰者模式","slug":"装饰者模式","permalink":"https://idea360.cn/tags/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式——工厂模式","slug":"design-patterns-factory","date":"2020-10-06T06:47:40.000Z","updated":"2021-02-23T14:14:43.990Z","comments":true,"path":"2020/10/06/design-patterns-factory/","link":"","permalink":"https://idea360.cn/2020/10/06/design-patterns-factory/","excerpt":"","text":"概述 用模板方法来构建生成实例的工厂， 这就是工厂方法模式 类图 Product 12345678910package com.example.factory.framework;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 */public abstract class Product &#123; public abstract void use();&#125; Factory 只要是工厂方法模式, 在生成实例时就一定会使用到模板方法模式 1234567891011121314151617181920package com.example.factory.framework;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 */public abstract class Factory &#123; public final Product create(String owner) &#123; Product p = createProduct(owner); registerProduct(p); return p; &#125; protected abstract void registerProduct(Product p); protected abstract Product createProduct(String owner);&#125; IDCard 12345678910111213141516171819202122232425262728package com.example.factory.idcard;import com.example.factory.framework.Product;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 */public class IDCard extends Product &#123; private String owner; public IDCard(String owner) &#123; System.out.println(&quot;制作&quot; + owner + &quot;的ID卡。&quot;); this.owner = owner; &#125; @Override public void use() &#123; System.out.println(&quot;使用&quot; + owner + &quot;的ID卡。&quot;); &#125; public String getOwner() &#123; return owner; &#125;&#125; IDCardFactory 1234567891011121314151617181920212223242526272829303132package com.example.factory.idcard;import com.example.factory.framework.Factory;import com.example.factory.framework.Product;import java.util.ArrayList;import java.util.List;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 */public class IDCardFactory extends Factory &#123; private List owners = new ArrayList(); @Override protected void registerProduct(Product p) &#123; owners.add(((IDCard)p).getOwner()); &#125; @Override protected Product createProduct(String owner) &#123; return new IDCard(owner); &#125; public List getOwners() &#123; return owners; &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031323334package com.example.factory;import com.example.factory.framework.Product;import com.example.factory.idcard.IDCardFactory;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-06 */public class FactoryDemo &#123; /** * 制作张三的ID卡。 * 制作李四的ID卡。 * 制作王五的ID卡。 * 使用张三的ID卡。 * 使用李四的ID卡。 * 使用王五的ID卡。 * * @param args */ public static void main(String[] args) &#123; IDCardFactory factory = new IDCardFactory(); Product card1 = factory.create(&quot;张三&quot;); Product card2 = factory.create(&quot;李四&quot;); Product card3 = factory.create(&quot;王五&quot;); card1.use(); card2.use(); card3.use(); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://idea360.cn/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式——适配器模式","slug":"design-patterns-adapter","date":"2020-10-04T06:51:58.000Z","updated":"2021-02-23T14:14:16.710Z","comments":true,"path":"2020/10/04/design-patterns-adapter/","link":"","permalink":"https://idea360.cn/2020/10/04/design-patterns-adapter/","excerpt":"","text":"概述 Adapter 模式也被称为 Wrapper 模式 Adapter 模式有以下2种 类适配器模式(使用继承的适配器) 对象适配器模式(使用委托的适配器) 一般大家举例都喜欢用 220v 家用电压 和 12v 电器电压适配举例, 这里不做太多的场景引入, 只做代码演示 使用场景 已有功能的复用 版本升级及兼容性 功能完全不同的类 使用继承的适配器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 * * 家用电压220v */public class HomeVoltage &#123; public void provider220V() &#123; System.out.println(&quot;家用电压220v&quot;); &#125;&#125;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public interface PhoneVoltage &#123; public void need5V();&#125;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public class Adapter extends HomeVoltage implements PhoneVoltage &#123; @Override public void need5V() &#123; provider220V(); System.out.println(&quot;电压适配&quot;); System.out.println(&quot;输出5v电压&quot;); &#125;&#125;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public class AdapterDemo &#123; /** * 家用电压220v * 电压适配 * 输出5v电压 * * @param args */ public static void main(String[] args) &#123; Adapter adapter = new Adapter(); adapter.need5V(); &#125;&#125; 使用委托的适配器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 * * 家用电压220v */public class HomeVoltage &#123; public void provider220V() &#123; System.out.println(&quot;家用电压220v&quot;); &#125;&#125;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public interface PhoneVoltage &#123; public void need5V();&#125;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public class Wrapper implements PhoneVoltage &#123; private HomeVoltage homeVoltage; public Wrapper(HomeVoltage homeVoltage) &#123; this.homeVoltage = homeVoltage; &#125; @Override public void need5V() &#123; homeVoltage.provider220V(); System.out.println(&quot;电压适配&quot;); System.out.println(&quot;输出5v电压&quot;); &#125;&#125;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public class WrapperDemo &#123; /** * 家用电压220v * 电压适配 * 输出5v电压 * * @param args */ public static void main(String[] args) &#123; Wrapper wrapper = new Wrapper(new HomeVoltage()); wrapper.need5V(); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://idea360.cn/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式——迭代器模式","slug":"design-patterns-iterator","date":"2020-10-04T06:25:23.000Z","updated":"2021-02-23T14:15:01.878Z","comments":true,"path":"2020/10/04/design-patterns-iterator/","link":"","permalink":"https://idea360.cn/2020/10/04/design-patterns-iterator/","excerpt":"","text":"概述 首先简述2个概念 UML 中的 类图 (Class Diagram) 用于表示类、接口、实例等之间的静态关系 只要在一个类中持有另外一个类的实例, 无论是一个还是多个, 它们之间就是聚合关系 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 下边通过模拟List来说明Java中的迭代器, 详细实现请阅读jdk源码。 实现 我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 List 接口, 实现了 Container 接口的实体类将负责实现 Iterator 接口, 类图如下 Iterator接口 1234567891011/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next();&#125; List接口 1234567891011121314/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public interface List&lt;E&gt; &#123; /** * 生成遍历集合的迭代器 * @return */ Iterator&lt;E&gt; iterator();&#125; ArrayList实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 * * 阉割版, 仅用于演示设计模式 */public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123; transient Object[] elementData; private int size; public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; &#125; public boolean add(E e) &#123; elementData[size++] = e; return true; &#125; @Override public Iterator iterator() &#123; return new Itr(); &#125; /** * 迭代器实现 */ private class Itr implements Iterator&lt;E&gt; &#123; Itr() &#123;&#125; /** * 下个返回元素游标 */ int cursor; @Override public boolean hasNext() &#123; return cursor &lt; size; &#125; @Override public E next() &#123; if (this.hasNext()) &#123; return (E) elementData[cursor++]; &#125; return null; &#125; &#125;&#125; 演示 1234567891011121314151617181920/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-10-04 */public class IteratorDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(16); list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); list.add(&quot;王五&quot;); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 执行程序, 输出结果 123张三李四王五 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"https://idea360.cn/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java基础知识","slug":"java-api-scene","date":"2020-09-19T23:29:57.000Z","updated":"2021-02-23T14:23:32.110Z","comments":true,"path":"2020/09/20/java-api-scene/","link":"","permalink":"https://idea360.cn/2020/09/20/java-api-scene/","excerpt":"","text":"概述 本篇主要是对java基础的使用场景的总结 常见使用场景 静态内部类和非静态内部类的使用场景 静态内部类可以有静态成员（方法和属性），而非静态内部类则不能有静态成员（成员或属性） 静态内部类只能够访问外部类的静态成员和静态方法，而非静态内部类则可以访问外部类的所有成员（方法和属性） 静态代码块和代码块的使用场景 静态代码块，在虚拟机加载类的时候就会加载执行，而且只执行一次; 非静态代码块，在创建对象的时候(即new一个对象的时候)执行，每次创建对象都会执行一次 LinkHashmap使用场景 如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列 如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好 接口里定义的成员变量为什么是 public static final 接口提供的统一的抽象, 所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性 项目中日志如何使用 假设我们有些日志是debug级别, 那么应该如下 123if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Initializing filter &#x27;&quot; + filterConfig.getFilterName() + &quot;&#x27;&quot;);&#125; 用户自定义系统属性 123456789101112@Slf4jpublic class TestController &#123; public static void main(String[] args) &#123; System.setProperty(&quot;blog.host&quot;, &quot;http://idea360.cn&quot;); String property = System.getProperty(&quot;blog.host&quot;); if (log.isInfoEnabled()) &#123; log.info(property); &#125; &#125;&#125; 获取系统环境变量 12Map&lt;String, String&gt; getenv = System.getenv(); 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"基础","slug":"基础","permalink":"https://idea360.cn/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"搭建SpringMVC项目","slug":"idea-springmvc-maven","date":"2020-09-15T17:14:54.000Z","updated":"2021-02-23T14:22:59.495Z","comments":true,"path":"2020/09/16/idea-springmvc-maven/","link":"","permalink":"https://idea360.cn/2020/09/16/idea-springmvc-maven/","excerpt":"","text":"搭建SpringMVC 使用idea快速创建webapp项目 在pom.xml中添加依赖 1234567891011121314&lt;!-- spring-mvc 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 非必填, 为演示过滤器, 如在idea中启动报错 将默认provided改为compile--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 创建 java 和 resources 目录 创建controller 12345678@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public Object hello() &#123; return &quot;hello world&quot;; &#125;&#125; 编辑WEB-INF目录下的web.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app version=&quot;3.0&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 第一步: 配置 Spring MVC Dispatcher Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- init-param是Servlet范围内的参数，只能在Sercvlet的init()的方法中取得--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 第二步: 设置 URL mapping for Spring MVC Dispatcher--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 非必填: context-param是应用范围内的参数, 存放在ServletContext中, 通过ServletContext对象获取参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 非必填: 监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 非必填: 过滤器--&gt; &lt;filter&gt; &lt;description&gt;演示过滤器的注入&lt;/description&gt; &lt;filter-name&gt;TestFilter&lt;/filter-name&gt; &lt;filter-class&gt;cn.idea360.mvc.filter.TestFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;TestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 创建 springContext.xml 根据 web.xml 中的配置，我们在 resources 目录下创建 springContext.xml , 当然也可以根据 &lt;param-value&gt;/WEB-INF/springContext.xml&lt;/param-value&gt; 在WEB-INF下创建 123456789101112131415161718192021222324&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 修改名称 修改名称去适配 base-package --&gt; &lt;context:component-scan base-package=&quot;cn.idea360.mvc&quot;/&gt; &lt;mvc:annotation-driven/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- bean在这里注入--&gt;&lt;/beans&gt; 配置 tomcat 并启动, 如果没有 tomcat 可以在插件中添加 测试api请求 1curl http:&#x2F;&#x2F;localhost:8080&#x2F;hello 过滤器示例 123456789101112131415public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 有参构造bean注入 定义bean1 123456789101112public class UserService &#123; private String name; public UserService(String name) &#123; this.name = name; &#125; public void show() &#123; System.out.println(&quot;name=&quot; + name); &#125;&#125; 定义bean2 12345678910111213141516171819202122232425262728293031323334public class KafkaClient &#123; private String servers; private String topic; /** * @param configs Map类型构造参数 */ public KafkaClient(Map&lt;String, Object&gt; configs) &#123; this.servers = String.valueOf(configs.get(&quot;bootstrap.servers&quot;)); &#125; /** * @param properties Properties类型构造参数 */ public KafkaClient(Properties properties) &#123; this.servers = properties.getProperty(&quot;bootstrap.servers&quot;); &#125; /** * @param kafkaConfig 对象参数 */ public KafkaClient(KafkaConfig kafkaConfig) &#123; this.servers = kafkaConfig.getServers(); &#125; public void setTopic(String topic) &#123; this.topic = topic; &#125; public void show() &#123; System.out.println(&quot;servers=&quot; + servers + &quot;; topic=&quot; + topic); &#125;&#125; 对象参数 123456789101112public class KafkaConfig &#123; private String servers; public String getServers() &#123; return servers; &#125; public void setServers(String servers) &#123; this.servers = servers; &#125;&#125; 在springContext.xml中注入bean 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- bean在这里注入--&gt;&lt;!-- 根据参数名注入, 有参构造方法 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;cn.idea360.mvc.service.UserService&quot;&gt; &lt;!-- 有参构造方式1--&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;admin&quot;/&gt;&lt;/bean&gt;&lt;!-- Map构造参数--&gt;&lt;bean id=&quot;kafkaProducerProperties1&quot; class=&quot;java.util.HashMap&quot;&gt; &lt;constructor-arg&gt; &lt;map&gt; &lt;entry key=&quot;bootstrap.servers&quot; value=&quot;localhost:9092&quot;/&gt; &lt;/map&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- Properties构造参数--&gt;&lt;bean id=&quot;kafkaProducerProperties2&quot; class=&quot;java.util.HashMap&quot;&gt; &lt;constructor-arg&gt; &lt;props&gt; &lt;prop key=&quot;bootstrap.servers&quot;&gt;127.0.0.1:9092&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 对象构造参数--&gt;&lt;bean id=&quot;kafkaConfig&quot; class=&quot;cn.idea360.mvc.service.KafkaConfig&quot;&gt; &lt;property name=&quot;servers&quot; value=&quot;127.0.0.1&quot;/&gt;&lt;/bean&gt;&lt;!-- 有参注入--&gt;&lt;bean id=&quot;kafkaClient&quot; class=&quot;cn.idea360.mvc.service.KafkaClient&quot;&gt; &lt;!-- 有参构造方式2--&gt; &lt;constructor-arg ref=&quot;kafkaConfig&quot;/&gt; &lt;!--设置对应 topic--&gt; &lt;property name=&quot;topic&quot; value=&quot;topic-test&quot;/&gt;&lt;/bean&gt; 测试 123456789101112131415public class BeanTest &#123; public static void main(String[] args) &#123; // 当类上标注 @Component 等注解时可以基于使用 new AnnotationConfigApplicationContext(&quot;cn.idea360.mvc&quot;) 上下文获取bean ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;springContext.xml&quot;); // 有参构造1 name=admin UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.show(); // 有参构造2 servers=127.0.0.1:9092; topic=topic-test KafkaClient kafkaClient = context.getBean(KafkaClient.class); kafkaClient.show(); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://medium.com/@yuntianhe/create-a-web-project-with-maven-spring-mvc-b859503f74d7 https://mkyong.com/maven/how-to-create-a-web-application-project-with-maven/ https://github.com/yinjihuan/monkey-api-encrypt/tree/master/monkey-api-encrypt-springmvc-example https://gitbook.cn/books/5d6b2b9d84721b61db4432b5/index.html https://medium.com/panchalprogrammingacademy/create-a-spring-mvc-project-with-maven-and-intellij-idea-community-edition-1d31b3efe078","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://idea360.cn/tags/springmvc/"}]},{"title":"SpringBoot参数验证","slug":"spring-boot-starter-validation","date":"2020-09-08T14:42:11.000Z","updated":"2021-02-23T14:41:56.397Z","comments":true,"path":"2020/09/08/spring-boot-starter-validation/","link":"","permalink":"https://idea360.cn/2020/09/08/spring-boot-starter-validation/","excerpt":"","text":"maven 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 说明 注解 功能 @AssertFalse 可以为null,如果不为null的话必须为false @AssertTrue 可以为null,如果不为null的话必须为true @DecimalMax 设置不能超过最大值 @DecimalMin 设置不能超过最小值 @Digits 设置必须是数字且数字整数的位数和小数的位数必须在指定范围内 @Future 日期必须在当前日期的未来 @Past 日期必须在当前日期的过去 @Max 最大不得超过此最大值 @Min 最大不得小于此最小值 @NotNull 不能为null，可以是空 @Null 必须为null @Pattern 必须满足指定的正则表达式 @Size 集合、数组、map等的size()值必须在指定范围内 @Email 必须是email格式 @Length 长度必须在指定范围内 @NotBlank 字符串不能为null,字符串trim()后也不能等于“” @NotEmpty 不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“” @Range 值必须在指定范围内 @URL 必须是一个URL 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"validation","slug":"validation","permalink":"https://idea360.cn/tags/validation/"}]},{"title":"SpringBoot配置swagger3","slug":"swagger3","date":"2020-09-08T14:37:53.000Z","updated":"2021-02-23T14:49:01.822Z","comments":true,"path":"2020/09/08/swagger3/","link":"","permalink":"https://idea360.cn/2020/09/08/swagger3/","excerpt":"","text":"maven 12345&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; Swagger3 12345678910111213141516171819202122232425262728293031@EnableOpenApi@Configurationpublic class Swagger3Config &#123; /** * 是否开启swagger配置，生产环境需关闭 * http://localhost:7003/ai6/swagger-ui/index.html# * http://localhost:7003/ai6/doc.html# */ @Value(&quot;$&#123;swagger.enabled&#125;&quot;) private boolean enable; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) .enable(enable) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;流程服务&quot;) .description(&quot;流程服务接口&quot;) .version(&quot;0.0.1&quot;) .build(); &#125;&#125; 其他注解和swagger2一样 knife4j 由于swagger3不支持导出，这里引入knife4j 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt; 然后在swagger配置文件添加注解 1234@EnableKnife4j@Configurationpublic class Swagger3Config &#123;&#125; 生产环境 生产环境需要关闭swagger~ 123456789101112131415161718192021222324252627282930313233@Slf4j@SpringBootApplication@PropertySource(&#123;&quot;file:$&#123;IDC_HOME&#125;/conf/conf.properties&quot;&#125;)public class TestApplication &#123; private static final String line = &quot;\\n----------------------------------------------------------&quot;; public static void main(String[] args) throws UnknownHostException&#123; ConfigurableApplicationContext context = SpringApplication.run(TestApplication.class, args); String swaggerEnabled = context.getEnvironment().getProperty(&quot;swagger.enabled&quot;); afterRun(context, Boolean.parseBoolean(swaggerEnabled)); &#125; private static void afterRun(ConfigurableApplicationContext applicationContext, boolean swaggerEnabled) throws UnknownHostException &#123; if (swaggerEnabled) &#123; AbstractServletWebServerFactory webServerFactory = applicationContext.getBean(AbstractServletWebServerFactory.class); int port = webServerFactory.getPort(); String contextPath = webServerFactory.getContextPath(); log.info(&quot;\\n访问swaggger接口调试 URLs:&quot; + line + &quot;\\n&quot; + &quot;Local: \\t\\thttp://&#123;&#125;:&#123;&#125;&#123;&#125;/swagger-ui/index.html&quot; + line , InetAddress.getLocalHost().getHostAddress(), port, contextPath); log.info(&quot;\\n访问knife4j接口调试 URLs:&quot; + line + &quot;\\n&quot; + &quot;Local: \\t\\thttp://&#123;&#125;:&#123;&#125;&#123;&#125;/doc.html&quot; + line , InetAddress.getLocalHost().getHostAddress(), port, contextPath); &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"swagger3","slug":"swagger3","permalink":"https://idea360.cn/tags/swagger3/"}]},{"title":"HttpClient基本使用","slug":"httpclient","date":"2020-09-08T03:35:19.000Z","updated":"2021-04-24T08:51:06.465Z","comments":true,"path":"2020/09/08/httpclient/","link":"","permalink":"https://idea360.cn/2020/09/08/httpclient/","excerpt":"","text":"maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.12&lt;/version&gt;&lt;/dependency&gt; 返回结果 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.demo.utils;/** * @author CUI SHIYING */public class HttpResult &#123; /** * 响应的状态码 */ private int code; /** * 响应的响应体 */ private String body; public HttpResult(int code) &#123; this.code = code; &#125; public HttpResult(int code, String body) &#123; this.code = code; this.body = body; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125;&#125; 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package com.example.demo.utils;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.http.Header;import org.apache.http.HttpHeaders;import org.apache.http.HttpStatus;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.*;import org.apache.http.client.utils.URIBuilder;import org.apache.http.entity.ContentType;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.message.BasicHeader;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Objects;/** * @author CUI SHIYING */public class HttpClientUtil &#123; private static final Logger log = LoggerFactory.getLogger(HttpClientUtil.class); private static final CloseableHttpClient HTTP_CLIENT; private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); /** * 请求超时时间设置(10秒) */ private static final int TIMEOUT = 10 * 1000; static &#123; RequestConfig clientConfig = RequestConfig.custom() .setConnectTimeout(TIMEOUT) .setSocketTimeout(TIMEOUT) .setConnectionRequestTimeout(TIMEOUT) .build(); List&lt;Header&gt; headers = new ArrayList&lt;&gt;(); headers.add(new BasicHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;)); HTTP_CLIENT = HttpClientBuilder.create() .setDefaultRequestConfig(clientConfig) .setDefaultHeaders(headers) .build(); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; if (null != HTTP_CLIENT) &#123; try &#123; HTTP_CLIENT.close(); log.info(&quot;close http client success.&quot;); &#125; catch (IOException e) &#123; log.error(&quot;close http client error.&quot;, e); &#125; &#125; &#125;)); &#125; public static HttpResult doGet(String url, Map&lt;String, Object&gt; map) throws Exception &#123; URIBuilder uriBuilder = new URIBuilder(url); if (map != null)&#123; for (Map.Entry&lt;String, Object&gt; entry : map.entrySet())&#123; uriBuilder.setParameter(entry.getKey(), entry.getValue().toString()); &#125; &#125; HttpGet httpGet = new HttpGet(uriBuilder.build()); return execute(httpGet); &#125; public static HttpResult doGet(String url) throws Exception &#123; return doGet(url, null); &#125; public static HttpResult doPost(String url, Map&lt;String, Object&gt; reqMap, Map&lt;String, String&gt; headersMap) throws Exception &#123; HttpPost httpPost = new HttpPost(url); for (Map.Entry&lt;String, String&gt; entry : headersMap.entrySet()) &#123; httpPost.addHeader(entry.getKey(), entry.getValue()); &#125; if (reqMap != null) &#123;// List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;();// for (String key : reqMap.keySet()) &#123;// paramList.add(new BasicNameValuePair(key, reqMap.get(key).toString()));// &#125;// UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(paramList, StandardCharsets.UTF_8.name()); StringEntity formEntity = new StringEntity(OBJECT_MAPPER.writeValueAsString(reqMap), StandardCharsets.UTF_8.name()); httpPost.setEntity(formEntity); &#125; return execute(httpPost); &#125; public static HttpResult doPostJson(String url, String json) throws IOException &#123; HttpPost httpPost = new HttpPost(url); StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON); httpPost.setEntity(entity); return execute(httpPost); &#125; public static HttpResult doPost(String url) throws Exception &#123; return doPost(url, null, null); &#125; public static HttpResult doPut(String url, Map&lt;String, Object&gt; map) throws Exception &#123; HttpPut httpPut = new HttpPut(url); if (map != null) &#123; List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;(); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; params.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString())); &#125; UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params, StandardCharsets.UTF_8.name()); httpPut.setEntity(formEntity); &#125; return execute(httpPut); &#125; public static HttpResult doDelete(String url, Map&lt;String, Object&gt; map) throws Exception &#123; URIBuilder uriBuilder = new URIBuilder(url); if (map != null) &#123; for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; uriBuilder.setParameter(entry.getKey(), entry.getValue().toString()); &#125; &#125; HttpDelete httpDelete = new HttpDelete(uriBuilder.build()); return execute(httpDelete); &#125; private static HttpResult execute(HttpRequestBase httpRequest) throws IOException &#123; CloseableHttpResponse response = null; try &#123; response = HTTP_CLIENT.execute(httpRequest); if (Objects.nonNull(response) &amp;&amp; Objects.nonNull(response.getStatusLine())) &#123; String content = &quot;&quot;; if (Objects.nonNull(response.getEntity())) &#123; content = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8.name()); &#125; return new HttpResult(response.getStatusLine().getStatusCode(), content); &#125; return new HttpResult(HttpStatus.SC_INTERNAL_SERVER_ERROR); &#125; finally &#123; release(response); &#125; &#125; public static void release(CloseableHttpResponse httpResponse) throws IOException &#123; // 释放资源 if (httpResponse != null) &#123; httpResponse.close(); &#125; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.example.demo.controller;import com.example.demo.utils.HttpClientUtil;import com.example.demo.utils.HttpResult;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * @author cuishiying * @date 2021-01-22 */@RestController@RequestMappingpublic class HttpTest &#123; private static final Logger log = LoggerFactory.getLogger(HttpTest.class); // 请求总数 public static int clientTotal = 3000; // 同时并发执行的线程数 public static int threadTotal = 200; // 初始计数 public static int count = 0; /** * http://localhost:8081/http */ @GetMapping(&quot;/http&quot;) public Object testHttp() throws Exception&#123; long start = System.currentTimeMillis(); // 线程池 ExecutorService executorService = Executors.newCachedThreadPool(); // 控制并发 final Semaphore semaphore = new Semaphore(threadTotal); // 闭锁(让主线程等待子线程5000个任务执行完毕) final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; // 此处能够同时获取200个令牌, 然后等待令牌释放 semaphore.acquire(); request(); // 令牌释放后其他任务才能继续执行, 直到5000任务执行完毕 semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; // 计数器-1 countDownLatch.countDown(); &#125;); &#125; // 阻塞主线程, 等待子线程执行完毕(countDownLatch计数器变为0) countDownLatch.await(); executorService.shutdown(); log.info(&quot;count:&#123;&#125;&quot;, count); return System.currentTimeMillis()-start; &#125; private void request() &#123; try &#123; HttpResult httpResult = HttpClientUtil.doGet(&quot;http://localhost:8081/hello&quot;); System.out.println(httpResult.getBody()); count++; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"httpClient","slug":"httpClient","permalink":"https://idea360.cn/tags/httpClient/"}]},{"title":"Git提交commit规范","slug":"git-commit","date":"2020-09-06T15:35:22.000Z","updated":"2021-08-25T08:59:56.121Z","comments":true,"path":"2020/09/06/git-commit/","link":"","permalink":"https://idea360.cn/2020/09/06/git-commit/","excerpt":"","text":"日志规范 123456&lt;type&gt;[optional scope]: &lt;description&gt;[optional body][optional footer(s)] 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 其中，Header 是必需的，Body 和 Footer 可以省略。 Header Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 type type用于说明 commit 的类别，只允许使用下面7个标识。 1234567feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 master主分支打Tag 创建标签 git tag -a tag1 -m “我是tag1描述” 推送标签 git push origin tag1 删除本地标签 git tag -d tag1 删除远程标签 git push origin :refs/tags/tag1 合并commit提交记录 如果我们想合并远程仓库提交记录, 则 首先查看当前的日志记录, 假设下边的是我们的提交记录, 我们要将这5条合并为1条记录。 git log 1234567891011121314151617181920212223242526272829commit 475bd3f60cb8fd3b92370744014e45eb11ee7e61 (HEAD -&gt; ai6, origin&#x2F;ai6)Author: cuishiying &lt;idea360@foxmail.com&gt;Date: Wed Feb 3 13:56:45 2021 +0800 feat: 模板和模块添加颜色commit a2bc0f34ff0a0d9cc1139b2929a18c081dd357f6Author: cuishiying &lt;idea360@foxmail.com&gt;Date: Thu Jan 28 18:44:00 2021 +0800 refactor: 基本数据类型改包装数据类型commit 5bba947340d452e98669f7b6648e3118314c3384Author: cuishiying &lt;idea360@foxmail.com&gt;Date: Thu Jan 28 18:43:23 2021 +0800 refactor: 基本数据类型改包装数据类型commit 4bbd4ae9203697dba5da40ff27d43b313491b15aAuthor: cuishiying &lt;idea360@foxmail.com&gt;Date: Thu Jan 28 18:02:00 2021 +0800 refactor: 基本数据类型改包装数据类型commit 4b19e6f5dfafdf9bba4469eb0304984fafdb1516Author: cuishiying &lt;idea360@foxmail.com&gt;Date: Thu Jan 28 17:58:18 2021 +0800 refactor: 基本数据类型改包装数据类型 git rebase -i HEAD~5 1234567pick 4b19e6f refactor: 基本数据类型改包装数据类型pick 4bbd4ae refactor: 基本数据类型改包装数据类型pick 5bba947 refactor: 基本数据类型改包装数据类型pick a2bc0f3 refactor: 基本数据类型改包装数据类型pick 475bd3f feat: 模板和模块添加颜色# Rebase 2f248c1..475bd3f onto a2bc0f3 (5 commands) 修改第2~6行的第一个单词 pick 为 squash or s, 然后保存退出 pick 的意识是要执行这个 commit squash 的意识是这个 commit 会被合并到前一个 commit 修改结果为 1234567pick 4b19e6f refactor: 基本数据类型改包装数据类型squash 4bbd4ae refactor: 基本数据类型改包装数据类型squash 5bba947 refactor: 基本数据类型改包装数据类型squash a2bc0f3 refactor: 基本数据类型改包装数据类型squash 475bd3f feat: 模板和模块添加颜色# Rebase 2f248c1..475bd3f onto a2bc0f3 (5 commands) 接着会弹出合并后新的提交记录，修改为我们想提交的commit 1234# This is a combination of 5 commits.# This is the 1st commit message:refactor: 1. 基本数据类型保卫包装数据类型；2. 模板和模块添加颜色属性 同步到远程仓库 git push -f 暂存本地修改 1git stash -help merge和rebase rebase使用场景: 首先我们从dev分支拉取了记录。假设我们在dev-aaa分支修改了记录, 其他人修改了dev-bbb并合并到了dev分支, 那么dev和dev-aaa这两个分支各自&quot;前进&quot;了。 此时如果merge操作则会在合并代码后有1条merge记录。 如果rebase则会将dev-aaa的提交追加到dev-bbb的提交之后。(dev-aaa的代码进行了commit, 尚未push) 12341. git rebase dev2. 解决冲突并 git add .3. git rebase --continue 完成本地仓库的rebase合并4. git push推送到远端仓库 查看分支树 1git log --oneline --graph --decorate --all 删除分支 12345&#x2F;&#x2F; delete branch locallygit branch -d localBranchName&#x2F;&#x2F; delete branch remotelygit push origin --delete remoteBranchName 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://git-scm.com/book/zh/v2","categories":[{"name":"git","slug":"git","permalink":"https://idea360.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://idea360.cn/tags/git/"}]},{"title":"Js基本调试案例","slug":"js","date":"2020-09-06T14:03:44.000Z","updated":"2021-02-23T14:34:57.692Z","comments":true,"path":"2020/09/06/js/","link":"","permalink":"https://idea360.cn/2020/09/06/js/","excerpt":"","text":"前言 虽然现在前后端分离已经很普遍了，开发中还是免不了自己调试js，下边是ajax的简单调试 Http请求 后端接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-09-06 */@RestController@RequestMapping(&quot;/ajax&quot;)public class AjaxController &#123; /** * 支持请求 * Query Params * http://localhost:7777/ajax/get?name=admin * @param name * @return */ @GetMapping(&quot;/get&quot;) public R get(@RequestParam String name) &#123; return R.ok(name); &#125; /** * 支持请求 * 1. Query Params * http://localhost:7777/ajax/post?name=admin * * 2. form-data 文件上传时(contentType:multipart/form-data) * http://localhost:7777/ajax/post * name=admin * * 3. x-www-form-urlencoded * http://localhost:7777/ajax/post * name=admin * * @param name * @return */ @PostMapping(&quot;/post&quot;) public R post(@RequestParam String name) &#123; return R.ok(name); &#125; /** * 支持请求 * row * http://localhost:7777/ajax/body * body=&#123; * &quot;name&quot;:&quot;admin&quot; * &#125; * * @param userDetail * @return */ @PostMapping(&quot;/body&quot;) public R post(@RequestBody UserDetail userDetail) &#123; return R.ok(userDetail); &#125;&#125; 跨域配置 12345678910111213141516171819202122/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-09-06 */@Configurationpublic class CorsConfig &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1允许任何域名使用 corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2允许任何头 corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3允许任何方法（post、get等） return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4 return new CorsFilter(source); &#125;&#125; Ajax提交测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Ajax提交&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/qs/6.9.4/qs.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot; id=&quot;frm&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入账号&quot; class=&quot;name&quot;/&gt; &lt;button type=&quot;button&quot; id=&quot;ok&quot; style=&quot;height: 45px; width: 100px; margin: 50px&quot;&gt;登录&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; $(&#x27;#ok&#x27;).click(function () &#123; post4() &#125;) /** * get Query Params * url展示参数 */ function get1() &#123; var name = $(&quot;.name&quot;).val() console.log(&#x27;name=&#x27;, name) $.ajax(&#123; url: &#x27;http://localhost:7777/ajax/get?name=&#x27; + name, success: function(response) &#123; // &#123;&quot;code&quot;:0,&quot;data&quot;:&quot;admin&quot;,&quot;msg&quot;:&quot;执行成功&quot;&#125; console.log(response) &#125;, error: function(xhr) &#123; console.error(xhr) &#125; &#125;) &#125; /** * get Query Params * url展示参数 */ function get2() &#123; var name = $(&quot;.name&quot;).val() console.log(&#x27;name=&#x27;, name) $.ajax(&#123; url: &quot;http://localhost:7777/ajax/get&quot;, type: &quot;get&quot;, data: &#123; name: name &#125;, success: function(response) &#123; // &#123;&quot;code&quot;:0,&quot;data&quot;:&quot;admin&quot;,&quot;msg&quot;:&quot;执行成功&quot;&#125; console.log(response) &#125;, error: function(xhr) &#123; console.error(xhr) &#125; &#125;); &#125; /** * post Query Params * url展示参数 */ function post1() &#123; var name = $(&quot;.name&quot;).val() console.log(&#x27;name=&#x27;, name) $.ajax(&#123; url: &#x27;http://localhost:7777/ajax/post?name=&#x27; + name, type: &#x27;POST&#x27;, success: function(response) &#123; // &#123;&quot;code&quot;:0,&quot;data&quot;:&quot;admin&quot;,&quot;msg&quot;:&quot;执行成功&quot;&#125; console.log(response) &#125;, error: function(xhr) &#123; console.error(xhr) &#125; &#125;) &#125; /** * 提交表单 * Content-Type: application/x-www-form-urlencoded; charset=UTF-8 * url不展示参数 */ function post2() &#123; var name = $(&quot;.name&quot;).val() console.log(&#x27;name=&#x27;, name) $.ajax(&#123; url: &#x27;http://localhost:7777/ajax/post&#x27;, type: &#x27;POST&#x27;, data: &#123; name: name &#125;, success: function(response) &#123; // &#123;&quot;code&quot;:0,&quot;data&quot;:&quot;admin&quot;,&quot;msg&quot;:&quot;执行成功&quot;&#125; console.log(response) &#125;, error: function(xhr) &#123; console.error(xhr) &#125; &#125;) &#125; /** * 提交表单， name必须与接收字段一致 * Content-Type: application/x-www-form-urlencoded; charset=UTF-8 * url不展示参数 */ function post3() &#123; var frm = $(&#x27;#frm&#x27;); $.ajax(&#123; url: &#x27;http://localhost:7777/ajax/post&#x27;, type: &#x27;POST&#x27;, data: frm.serialize(), success: function(response) &#123; // &#123;&quot;code&quot;:0,&quot;data&quot;:&quot;admin&quot;,&quot;msg&quot;:&quot;执行成功&quot;&#125; console.log(response) &#125;, error: function(xhr) &#123; console.error(xhr) &#125; &#125;) &#125; /** * 提交表单， 拼接参数 * Content-Type: application/x-www-form-urlencoded; charset=UTF-8 * url不展示参数 */ function post4() &#123; var name = $(&quot;.name&quot;).val() var data = &#123; name: name, sex:1 &#125; console.log(&#x27;data:&#x27;, Qs.stringify(data)) // data: name=admin&amp;sex=1 $.ajax(&#123; url: &#x27;http://localhost:7777/ajax/post&#x27;, type: &#x27;POST&#x27;, data: Qs.stringify(data), success: function(response) &#123; // &#123;&quot;code&quot;:0,&quot;data&quot;:&quot;admin&quot;,&quot;msg&quot;:&quot;执行成功&quot;&#125; console.log(response) &#125;, error: function(xhr) &#123; console.error(xhr) &#125; &#125;) &#125; /** * 提交body-json * Content-Type: application/json; charset=UTF-8 */ function postbody() &#123; var name = $(&quot;.name&quot;).val() console.log(&#x27;name=&#x27;, name) var data = &#123; name: name &#125; $.ajax(&#123; url: &#x27;http://localhost:7777/ajax/body&#x27;, type: &#x27;POST&#x27;, dataType: &#x27;json&#x27;, contentType: &quot;application/json; charset=utf-8&quot;, data: JSON.stringify(data), success: function(response) &#123; // &#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;name&quot;:&quot;a&quot;&#125;,&quot;msg&quot;:&quot;执行成功&quot;&#125; console.log(response) &#125;, error: function(xhr) &#123; console.error(xhr) &#125; &#125;) &#125;&lt;/script&gt;&lt;/html&gt; Postman请求方式说明 form-data 等价于http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息； 由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。 x-www-form-urlencoded 等价于application/x-www-from-urlencoded,会将表单内的数据转换为键值对，比如,name=java&amp;age = 23 row 可以上传任意格式的文本，可以上传text、json、xml、html等 binary 相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。 multipart/form-data与x-www-form-urlencoded区别 multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息； x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。 自然排序 123456789101112131415161718192021&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/qs/6.9.4/qs.min.js&quot;&gt;&lt;/script&gt;function sort() &#123; // 未排序 var unordered = &#123; userId: &#x27;admin&#x27;, password: &#x27;123&#x27;, sessionId: &#x27;abc&#x27;, ts: (new Date()).getTime(), appKey: &quot;qweasd&quot; &#125; console.log(&#x27;排序前:&#x27;, Qs.stringify(unordered)) // 排序前: userId=admin&amp;password=123&amp;sessionId=abc&amp;ts=1599474324556&amp;appKey=qweasd // 根据key排序 const ordered = &#123;&#125;; Object.keys(unordered).sort().forEach(function(key) &#123; ordered[key] = unordered[key]; &#125;); console.log(&#x27;排序后:&#x27;, Qs.stringify(ordered)) // 排序后: appKey=qweasd&amp;password=123&amp;sessionId=abc&amp;ts=1599474324556&amp;userId=admin&#125; MD5 123&lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt;let sign = md5(Qs.stringify(ordered)); 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"ajax","slug":"ajax","permalink":"https://idea360.cn/categories/ajax/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://idea360.cn/tags/ajax/"},{"name":"js","slug":"js","permalink":"https://idea360.cn/tags/js/"}]},{"title":"idea快捷键","slug":"idea-keyboard-shortcut","date":"2020-09-01T15:40:21.000Z","updated":"2021-02-23T14:22:51.438Z","comments":true,"path":"2020/09/01/idea-keyboard-shortcut/","link":"","permalink":"https://idea360.cn/2020/09/01/idea-keyboard-shortcut/","excerpt":"","text":"前言 唯手熟尔~ 快捷键 Editing（编辑） 快捷键 描述 Control + O 覆盖方法（重写父类方法） Control + I 实现方法（实现接口中的方法） Command + Option + T 包围代码(try/catch) Command + J 动态模板插入(方法注释…) Conmmand + / 单行注释 Command + Shift + / 块注释 Command + Option + L 格式化代码 Ctrl + Option + O 优化导入的类，可以对当前文件和整个包目录使用 Control + Shift + J 智能的将代码拼接成一行 Command + Enter 智能的拆分拼接的行 Shift + Enter 开始新的一行 command + Shift + u 大小写切换 Shift + Option + 上下 上下移动代码 Command + 加号 / Command + 减号 展开 / 折叠代码块 Command + Shift加号 / Command + Shift + 减号 展开 / 折叠代码块 Command + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 Search/Replace（查询/替换） 快捷键 描述 Double Shift 查询任何东西 Command + F 文件内查找 Command + R 文件内替换 Command + Shift + F 全局查找（根据路径） Command + Shift + R 全局替换（根据路径) Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法 Navigation（导航） 快捷键 描述 Command + Option + &lt;- 后退 Command + Option + -&gt; 前进 Command + O 查找类文件 Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ Command + Option + O 全局搜索方法名、字段名 command + L 定位到行 Command + E 最近浏览文件 Command + Shift + E 最近修改文件列表 Option + F1 -&gt; “project view” 定位当前class类所在jar包的位置 Command + B 进入光标所在的方法/变量的接口或是定义处 Conmmand + Option + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Option + Space, Command + Y 快速打开光标所在方法、类的定义 Command + U 前往当前光标所在的方法的父类的方法 / 接口定义 Command + F12 弹出当前文件结构层 Ctrl + H 查看类或接口的继承结构 Ctrl + Option + H 查看方法的调用链 F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置 F4 / Command + 方向键下 编辑/查看代码源 Command + Option + U 查看uml类图 Refactoring（重构） 快捷键 描述 F5 复制文件到指定目录 F6 移动文件到指定目录 Shift + F6 重命名文件 Command + Option + N 构建方法 Command + Option + M 将选中的代码提取为方法 Command + Option + V 提取变量 Command + Option + F 提取字段 Command + Option + C 提取常量 Command + Option + P 提取参数 General（通用） 快捷键 描述 Command + Shift + F12 Editor最大化 F1 查看注释 Option + F12 打开终端 Terminal 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"快捷键","slug":"快捷键","permalink":"https://idea360.cn/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"idea","slug":"idea","permalink":"https://idea360.cn/tags/idea/"}]},{"title":"秒杀方案","slug":"java-seckill","date":"2020-09-01T15:37:45.000Z","updated":"2021-02-23T14:27:11.195Z","comments":true,"path":"2020/09/01/java-seckill/","link":"","permalink":"https://idea360.cn/2020/09/01/java-seckill/","excerpt":"","text":"秒杀方案 （1）尽量将请求拦截在系统上游（越上游越好）； （2）读多写少的常用多使用缓存（缓存抗读压力）； 第一层，客户端怎么优化（浏览器层，APP层） 问大家一个问题，大家都玩过微信的摇一摇抢红包对吧，每次摇一摇，就会往后端发送请求么？回顾我们下单抢票的场景，点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，对么？继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载，一个用户点5次，80%的请求是这么多出来的，怎么整？ （a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求； （b）JS层面，限制用户在x秒之内只能提交一次请求； APP层面，可以做类似的事情，虽然你疯狂的在摇微信，其实x秒才向后端发起一次请求。这就是所谓的“将请求尽量拦截在系统上游”，越上游越好，浏览器层，APP层就给拦住，这样就能挡住80%+的请求，这种办法只能拦住普通用户（但99%的用户是普通用户）对于群内的高端程序员是拦不住的。firebug一抓包，http长啥样都知道，js是万万拦不住程序员写for循环，调用http接口的，这部分请求怎么处理？ 第二层，站点层面的请求拦截 怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。 5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。 页面缓存不一定要保证所有站点返回一致的页面，直接放在每个站点的内存也是可以的。优点是简单，坏处是http请求落到不同的站点，返回的车票数据可能不一样，这是站点层的请求拦截与缓存优化。 好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。 第三层 服务层来拦截（反正就是不要让请求落到数据库上去） 服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！ 对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务） 1w部手机，只透1w个下单请求去db 3k张火车票，只透3k个下单请求去db 如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。 对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。 当然，还有业务规则上的一些优化。回想12306所做的，分时分段售票，原来统一10点卖票，现在8点，8点半，9点，…每隔半个小时放出一批：将流量摊匀。 其次，数据粒度的优化：你去购票，对于余票查询这个业务，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票？流量大的时候，做一个粗粒度的“有票”“无票”缓存即可。 第三，一些业务逻辑的异步：例如下单业务与 支付业务的分离。这些优化都是结合 业务 来的，我之前分享过一个观点“一切脱离业务的架构设计都是耍流氓”架构的优化也要针对业务。 第四层 最后是数据库层 浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。 全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。 方案一 Redis预减库存+RabbitMQ异步下单。 具体流程: 系统初始化，加载库存到redis 收到请求，预减库存 判断库存，若剩余，则入队列，否则秒杀失败 出队下单 分析： 一、通过将库存加载到redis中，使得每次判断、减少库存直接从内存中读取，无需访问数据库 二、收到请求预见库存，然后判断 注意这一顺序非常重要，保证了线程安全 分析：因为redis封装的decr()等函数是线程安全的，无需外加同步，所以你通过decr()减少库存后获取到的库存永远都是你刚刚减少后得到的库存，本身就是个原子操作，不会存在线程安全问题，然后根据这个库存来入队，不符合条件的秒杀请求直接返回失败，极大地减少了服务器的压力，而且整个后台逻辑中，需要保证原子性的也仅仅是decr()这一个操作，并且由于redis经过了乐观锁优化，所以整个系统的并发性相对于自己首先同步代码而言，并发性得到了极大的提高。 三、完成了上述的操作，再去实现接下来的逻辑就很简单了，唯一需要注意的是，从队列中出来的请求执行秒杀过程是一个事务，需完整执行，否则回滚。 同时，订单的详情页面做一个静态化优化，前端轮询秒杀结果，得到结果后进行渲染即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#x2F;** * GET POST * 1、GET幂等,服务端获取数据，无论调用多少次结果都一样 * 2、POST，向服务端提交数据，不是幂等 * &lt;p&gt; * 将同步下单改为异步下单 * * @param model * @param user * @param goodsId * @return *&#x2F;@RequestMapping(value &#x3D; &quot;&#x2F;do_seckill&quot;, method &#x3D; RequestMethod.POST)@ResponseBodypublic Result&lt;Integer&gt; list(Model model, User user, @RequestParam(&quot;goodsId&quot;) long goodsId) &#123; if (!rateLimiter.tryAcquire(1000, TimeUnit.MILLISECONDS)) &#123; return Result.error(CodeMsg.ACCESS_LIMIT_REACHED); &#125; if (user &#x3D;&#x3D; null) &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; model.addAttribute(&quot;user&quot;, user); &#x2F;&#x2F;内存标记，减少redis访问 boolean over &#x3D; localOverMap.get(goodsId); if (over) &#123; return Result.error(CodeMsg.SECKILL_OVER); &#125; &#x2F;&#x2F;预减库存 long stock &#x3D; redisService.decr(GoodsKey.getGoodsStock, &quot;&quot; + goodsId);&#x2F;&#x2F;10 if (stock &lt; 0) &#123; afterPropertiesSet(); long stock2 &#x3D; redisService.decr(GoodsKey.getGoodsStock, &quot;&quot; + goodsId);&#x2F;&#x2F;10 if(stock2 &lt; 0)&#123; localOverMap.put(goodsId, true); return Result.error(CodeMsg.SECKILL_OVER); &#125; &#125; &#x2F;&#x2F;判断重复秒杀 SeckillOrder order &#x3D; orderService.getOrderByUserIdGoodsId(user.getId(), goodsId); if (order !&#x3D; null) &#123; return Result.error(CodeMsg.REPEATE_SECKILL); &#125; &#x2F;&#x2F;入队 SeckillMessage message &#x3D; new SeckillMessage(); message.setUser(user); message.setGoodsId(goodsId); sender.sendSeckillMessage(message); return Result.success(0);&#x2F;&#x2F;排队中&#125; &#x2F;** * 系统初始化,将商品信息加载到redis和本地内存 *&#x2F;@Overridepublic void afterPropertiesSet() &#123; List&lt;GoodsVo&gt; goodsVoList &#x3D; goodsService.listGoodsVo(); if (goodsVoList &#x3D;&#x3D; null) &#123; return; &#125; for (GoodsVo goods : goodsVoList) &#123; redisService.set(GoodsKey.getGoodsStock, &quot;&quot; + goods.getId(), goods.getStockCount()); &#x2F;&#x2F;初始化商品都是没有处理过的 localOverMap.put(goods.getId(), false); &#125;&#125; 方案二 思路 对每个秒杀请求入队操作 当库存为N时，队列的长度超过N时，可以考虑拒绝后续请求，直接响应客户端秒杀结束 为了减轻库存处理的压力，验证并发量，这里通过信号量来控制线程安全。 编码 通过Semaphore来控制并发量 通过CAS来控制更新库存，保证线程安全 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&#x2F;*** * 模拟秒杀 *&#x2F;public class Knock &#123; &#x2F;** * CAS操作的类 *&#x2F; private static final Unsafe unsafe; &#x2F;** * total的偏移量 *&#x2F; private static final long totalOffset; &#x2F;** * 单实例 *&#x2F; private static volatile Knock knock; &#x2F;** * 总数量 *&#x2F; private volatile int total; &#x2F;** * 信号量 *&#x2F; private Semaphore semaphore; &#x2F;** * 初始化UnSafe * 只能通过反射实例化 * 在catch出只能抛出Error，unsafe只能初始化一次 *&#x2F; static &#123; try &#123; Field field &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); unsafe &#x3D; (Unsafe) field.get(null); totalOffset &#x3D; unsafe.objectFieldOffset(Knock.class.getDeclaredField(&quot;total&quot;)); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Error(e); &#125; &#125; &#x2F;** * 初始化公平的信号量 * * @param total 总数 * @param threadsPerTime 线程所需要的信号,控制并发量 *&#x2F; private Knock(int total, int threadsPerTime) &#123; this.total &#x3D; total; semaphore &#x3D; new Semaphore(threadsPerTime, true); &#125; &#x2F;** * 单例 lazy * * @param total * @param threadsPerTime * @return *&#x2F; public static Knock getInstance(int total, int threadsPerTime) &#123; &#x2F;&#x2F;one check if (null !&#x3D; knock) &#123; return knock; &#125; &#x2F;&#x2F;double check synchronized (Knock.class) &#123; if (null &#x3D;&#x3D; knock) &#123; &#x2F;&#x2F;knock需要加上volatile关键字，1.禁止重排序 2.线程间可见 knock &#x3D; new Knock(total, threadsPerTime); &#125; &#125; return knock; &#125; public int getTotal() &#123; return total; &#125; &#x2F;** * CAS 减法 * 死循环退出的条件 * 1. 总数大于0的情况下，去做一次CAS操作，操作成功，则返回，失败则循环 * 2. 如果total&#x3D;&#x3D;0的情况下，直接返回false，终止抢购 * @return *&#x2F; public boolean casTotal(int except) &#123; for (; ; ) &#123; if (total &gt; 0) &#123; int update &#x3D; total - 1; if (unsafe.compareAndSwapInt(this, totalOffset, except, update)) &#123; return true; &#125; &#125; else &#123; return false; &#125; &#125; &#125; &#x2F;** * 抢购 * * @param need *&#x2F; public void doKnock(int need) &#123; &#x2F;&#x2F;当队列的长度时商品总量的两倍就返回，抢购失败 &#x2F;&#x2F;当total&#x3D;&#x3D;0的时候，抢购失败 if (semaphore.getQueueLength() &gt; (total &lt;&lt; 1) || total &#x3D;&#x3D; 0) &#123; System.out.println(Thread.currentThread().getId() + &quot;：已售罄！&quot;); return; &#125; &#x2F;&#x2F;抢购 try &#123; &#x2F;&#x2F;获取资源 semaphore.acquire(need); &#x2F;&#x2F;这里要check total的值，不符合就直接返回 if (total &#x3D;&#x3D; 0) &#123; System.out.println(Thread.currentThread().getId() + &quot;已售罄！&quot;); return; &#125; &#x2F;&#x2F;这里必须通过局部变量接收，因为信号量模式，同一时间有多个线程在同时执行，是线程不安全的 int expect &#x3D; total; &#x2F;&#x2F;CAS修改当前库存 if (casTotal(expect)) &#123; &#x2F;&#x2F;current是当前线程消费过后的库存 int current &#x3D; expect - 1; System.out.println(Thread.currentThread().getId() + &quot;当前剩余:&quot; + current); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#x2F;&#x2F;释放资源 semaphore.release(need); &#125; &#125;&#125; 测试，通过CPU核心数，去控制并发的线程，提高QPS 123456789101112131415161718192021222324252627282930313233343536public class KTest &#123; static class T extends Thread &#123; private Knock knock; private int need; public T(Knock knock, int need) &#123; this.knock &#x3D; knock; this.need &#x3D; need; &#125; @Override public void run() &#123; knock.doKnock(need); &#125; &#125; public static void main(String[] args) &#123; &#x2F;&#x2F;获取可用CPU核心数 int availableProcessors &#x3D; Runtime.getRuntime().availableProcessors(); long s &#x3D; System.currentTimeMillis(); Knock knock &#x3D; Knock.getInstance(1100, availableProcessors*2); for (int i &#x3D; 0; i &lt; 2000; i++) &#123; T t &#x3D; new T(knock, 1); try &#123; t.start(); t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; long e &#x3D; System.currentTimeMillis(); System.out.println(knock.getTotal() + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+(e-s)); &#125;&#125; https://juejin.im/post/5dbeb66f51882524a33b9135 https://mp.weixin.qq.com/s/RLeujAj5rwZGNYMD0uLbrg","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"秒杀","slug":"秒杀","permalink":"https://idea360.cn/tags/%E7%A7%92%E6%9D%80/"}]},{"title":"Java限流算法","slug":"java-rate-limit","date":"2020-09-01T15:34:55.000Z","updated":"2021-02-23T14:26:47.505Z","comments":true,"path":"2020/09/01/java-rate-limit/","link":"","permalink":"https://idea360.cn/2020/09/01/java-rate-limit/","excerpt":"","text":"限流算法 一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如 nginx 的 limit_conn 模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如 Guava 的 RateLimiter、nginx 的 limit_req 模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制 MQ 的消费速率。另外还可以根据网络连接数、网络流量、CPU 或内存负载等来限流 1. 计数器算法 自定义实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class CountRateLimiter &#123; &#x2F;**计算器*&#x2F; private AtomicLong counter &#x3D; new AtomicLong(0); &#x2F;**初始时间*&#x2F; private static long timestamp &#x3D; System.currentTimeMillis(); &#x2F;**时间窗口内最大请求个数*&#x2F; private long limit; public CountRateLimiter(long limit) &#123; this.limit &#x3D; limit; &#125; public boolean tryAcquire() &#123; long now &#x3D; System.currentTimeMillis(); &#x2F;&#x2F;1s之内的请求 if (now - timestamp &lt; 1000) &#123; if (counter.get() &lt; limit) &#123; counter.incrementAndGet(); System.out.println(&quot;pass_request&quot;); return true; &#125; else &#123; System.out.println(&quot;refuse_request&quot;); return false; &#125; &#125; else &#123; counter &#x3D; new AtomicLong(0); timestamp &#x3D; now; System.out.println(&quot;time_end,refuse_request&quot;); return false; &#125; &#125; public static void main(String[] args) &#123; CountRateLimiter rateLimiter &#x3D; new CountRateLimiter(10); ExecutorService executor &#x3D; Executors.newCachedThreadPool(); for(int i&#x3D;0;i&lt;1000;i++) &#123; executor.submit(() -&gt; &#123; double random &#x3D; (new Random()).nextDouble(); long a &#x3D; (long)(random * 1000); try &#123; &#x2F;&#x2F;睡眠一下 Thread.sleep(a); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; rateLimiter.tryAcquire(); &#125;); &#125; executor.shutdown(); &#125;&#125; 这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题，我们看下图： 基于Google的Guava来实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class GuavaCountRateLimiter &#123; &#x2F;**缓存*&#x2F; private LoadingCache&lt;Long, AtomicLong&gt; counter &#x3D; CacheBuilder.newBuilder() .expireAfterWrite(2, TimeUnit.SECONDS) .build(new CacheLoader&lt;Long, AtomicLong&gt;() &#123; @Override public AtomicLong load(Long seconds) throws Exception &#123; return new AtomicLong(0); &#125; &#125;); &#x2F;**限制每秒10*&#x2F; private long limit &#x3D; 10; &#x2F;** * 使用Guava的Cache来存储计数器，过期时间设置为2秒（保证1秒内的计数器是有的），然后我们获取当前时间戳然后取秒数来作为KEY进行计数统计和限流 *&#x2F; public boolean tryAcquire() throws ExecutionException &#123; &#x2F;&#x2F;得到当前秒 long currentSeconds &#x3D; System.currentTimeMillis() &#x2F; 1000; if (counter.get(currentSeconds).incrementAndGet() &gt; limit) &#123; System.out.println(&quot;refuse_request:count&#x3D;&quot;+ counter.get(currentSeconds)); return true; &#125; else &#123; System.out.println(&quot;pass_request:count&#x3D;&quot; + counter.get(currentSeconds)); return false; &#125; &#125; public static void main(String[] args) &#123; GuavaCountRateLimiter guavaCountRateLimiter &#x3D; new GuavaCountRateLimiter(); ExecutorService executor &#x3D; Executors.newCachedThreadPool(); for(int i&#x3D;0;i&lt;1000;i++) &#123; executor.submit(() -&gt; &#123; double random &#x3D; (new Random()).nextDouble(); long a &#x3D; (long)(random * 1000); try &#123; &#x2F;&#x2F;睡眠一下 Thread.sleep(a); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; guavaCountRateLimiter.tryAcquire(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; executor.shutdown(); &#125;&#125; 2. 漏桶算法 基于Guava实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class LeakRateLimit &#123; &#x2F;&#x2F;定义桶的大小 private final ConcurrentLinkedQueue&lt;Integer&gt; container &#x3D; new ConcurrentLinkedQueue&lt;&gt;(); private final static int BUCKET_LIMIT &#x3D; 1000; &#x2F;&#x2F;消费者 不论多少个线程，每秒最大的处理能力是1秒中执行10次 private final RateLimiter consumerRate &#x3D; RateLimiter.create(10d); &#x2F;&#x2F;往桶里面放数据时，确认没有超过桶的最大的容量 private Monitor offerMonitor &#x3D; new Monitor(); &#x2F;&#x2F;从桶里消费数据时，桶里必须存在数据 private Monitor consumerMonitor &#x3D; new Monitor(); &#x2F;** * 往桶里面写数据 * @param data *&#x2F; public void submit(Integer data) &#123; if (offerMonitor.enterIf(offerMonitor.newGuard(() -&gt; container.size() &lt; BUCKET_LIMIT))) &#123; try &#123; container.offer(data); System.out.println(currentThread() + &quot; submit..&quot; + data + &quot; container size is :[&quot; + container.size() + &quot;]&quot;); &#125; finally &#123; offerMonitor.leave(); &#125; &#125; else &#123; &#x2F;&#x2F;这里时候采用降级策略了。消费速度跟不上产生速度时，而且桶满了，抛出异常 &#x2F;&#x2F;或者存入MQ DB等后续处理 System.out.println(&quot;The bucket is ful..Pls latter can try...&quot;); throw new IllegalStateException(currentThread().getName() + &quot;The bucket is ful..Pls latter can try...&quot;); &#125; &#125; &#x2F;** * 从桶里面消费数据 * @param consumer *&#x2F; public void takeThenConsumer(Consumer&lt;Integer&gt; consumer) &#123; if (consumerMonitor.enterIf(consumerMonitor.newGuard(() -&gt; !container.isEmpty()))) &#123; try &#123; &#x2F;&#x2F;不打印时 写 consumerRate.acquire(); System.out.println(currentThread() + &quot; waiting&quot; + consumerRate.acquire()); Integer data &#x3D; container.poll(); &#x2F;&#x2F;container.peek() 只是去取出来不会删掉 consumer.accept(data); &#125; finally &#123; consumerMonitor.leave(); &#125; &#125; else &#123; &#x2F;&#x2F;当木桶的消费完后，可以消费那些降级存入MQ或者DB里面的数据 System.out.println(&quot;will consumer Data from MQ...&quot;); try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; final LeakRateLimit bucket &#x3D; new LeakRateLimit(); final AtomicInteger DATA_CREATOR &#x3D; new AtomicInteger(0); &#x2F;&#x2F;生产线程 10个线程 每秒提交 50个数据 1&#x2F;0.2s*10&#x3D;50个 IntStream.range(0, 10).forEach(i -&gt; &#123; new Thread(() -&gt; &#123; for (; ; ) &#123; int data &#x3D; DATA_CREATOR.incrementAndGet(); try &#123; bucket.submit(data); TimeUnit.MILLISECONDS.sleep(200); &#125; catch (Exception e) &#123; &#x2F;&#x2F;对submit时，如果桶满了可能会抛出异常 if (e instanceof IllegalStateException) &#123; System.out.println(e.getMessage()); &#x2F;&#x2F;当满了后，生产线程就休眠1分钟 try &#123; TimeUnit.SECONDS.sleep(60); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; &#125; &#125;).start(); &#125;); &#x2F;&#x2F;消费线程 采用RateLimiter每秒处理10个 综合的比率是5:1 IntStream.range(0, 10).forEach(i -&gt; &#123; new Thread( () -&gt; &#123; for (; ; ) &#123; bucket.takeThenConsumer(x -&gt; &#123; System.out.println(currentThread() + &quot;C..&quot; + x); &#125;); &#125; &#125; ).start(); &#125;); &#125;&#125; 3. 令牌桶算法 手动实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class TokenLimiter &#123; &#x2F;**默认桶大小个数 即最大瞬间流量是64M*&#x2F; private static final int DEFAULT_BUCKET_SIZE &#x3D; 1024 * 1024 * 64; &#x2F;**一个桶的单位是1字节*&#x2F; private int everyTokenSize &#x3D; 1; &#x2F;**令牌最大数目*&#x2F; private int bucketSize; &#x2F;**平均流量*&#x2F; private int avgFlowRate; &#x2F;**队列来缓存桶数量*&#x2F; private ArrayBlockingQueue&lt;Byte&gt; tokenQueue &#x3D; new ArrayBlockingQueue&lt;Byte&gt;( DEFAULT_BUCKET_SIZE); private ScheduledExecutorService scheduledExecutorService &#x3D; Executors .newSingleThreadScheduledExecutor(); private volatile boolean isStart &#x3D; false; private ReentrantLock lock &#x3D; new ReentrantLock(true); private static final byte A_CHAR &#x3D; &#39;a&#39;; public TokenLimiter() &#123; &#125; public TokenLimiter(int bucketSize, int avgFlowRate) &#123; this.bucketSize &#x3D; bucketSize; this.avgFlowRate &#x3D; avgFlowRate; &#125; public TokenLimiter(int everyTokenSize, int bucketSize, int avgFlowRate) &#123; this.everyTokenSize &#x3D; everyTokenSize; this.bucketSize &#x3D; bucketSize; this.avgFlowRate &#x3D; avgFlowRate; &#125; public void addTokens(Integer tokenNum) &#123; &#x2F;&#x2F; 若是桶已经满了，就不再家如新的令牌 for (int i &#x3D; 0; i &lt; tokenNum; i++) &#123; tokenQueue.offer(Byte.valueOf(A_CHAR)); &#125; &#125; public TokenLimiter build() &#123; start(); return this; &#125; &#x2F;** * 获取足够的令牌个数 * * @return *&#x2F; public boolean getTokens(byte[] dataSize) &#123; &#x2F;&#x2F;传输内容大小对应的桶个数 int needTokenNum &#x3D; dataSize.length &#x2F; everyTokenSize + 1; final ReentrantLock lock &#x3D; this.lock; lock.lock(); try &#123; &#x2F;&#x2F;是否存在足够的桶数量 boolean result &#x3D; needTokenNum &lt;&#x3D; tokenQueue.size(); if (!result) &#123; return false; &#125; int tokenCount &#x3D; 0; for (int i &#x3D; 0; i &lt; needTokenNum; i++) &#123; Byte poll &#x3D; tokenQueue.poll(); if (poll !&#x3D; null) &#123; tokenCount++; &#125; &#125; return tokenCount &#x3D;&#x3D; needTokenNum; &#125; finally &#123; lock.unlock(); &#125; &#125; public void start() &#123; &#x2F;&#x2F; 初始化桶队列大小 if (bucketSize &gt; 0) &#123; tokenQueue &#x3D; new ArrayBlockingQueue&lt;Byte&gt;(bucketSize); &#125; &#x2F;&#x2F; 初始化令牌生产者 TokenProducer tokenProducer &#x3D; new TokenProducer(avgFlowRate, this); &#x2F;&#x2F;定时1s生产令牌 scheduledExecutorService.scheduleAtFixedRate(tokenProducer, 0, 1, TimeUnit.SECONDS); isStart &#x3D; true; &#125; public void stop() &#123; isStart &#x3D; false; scheduledExecutorService.shutdown(); &#125; public boolean isStarted() &#123; return isStart; &#125; class TokenProducer implements Runnable &#123; private int avgFlowRate; private TokenLimiter tokenLimiter; public TokenProducer(int avgFlowRate, TokenLimiter tokenLimiter) &#123; this.avgFlowRate &#x3D; avgFlowRate; this.tokenLimiter &#x3D; tokenLimiter; &#125; @Override public void run() &#123; tokenLimiter.addTokens(avgFlowRate); &#125; &#125; public static TokenLimiter newBuilder() &#123; return new TokenLimiter(); &#125; public TokenLimiter everyTokenSize(int everyTokenSize) &#123; this.everyTokenSize &#x3D; everyTokenSize; return this; &#125; public TokenLimiter bucketSize(int bucketSize) &#123; this.bucketSize &#x3D; bucketSize; return this; &#125; public TokenLimiter avgFlowRate(int avgFlowRate) &#123; this.avgFlowRate &#x3D; avgFlowRate; return this; &#125; private String stringCopy(String data, int copyNum) &#123; StringBuilder sbuilder &#x3D; new StringBuilder(data.length() * copyNum); for (int i &#x3D; 0; i &lt; copyNum; i++) &#123; sbuilder.append(data); &#125; return sbuilder.toString(); &#125; public static void main(String[] args) throws IOException, InterruptedException &#123; TokenLimiter tokenLimiter &#x3D; TokenLimiter.newBuilder().avgFlowRate(512) .bucketSize(1024).build(); BufferedWriter bufferedWriter &#x3D; new BufferedWriter( new OutputStreamWriter(new FileOutputStream(&quot;D:&#x2F;ds_test&quot;))); String data &#x3D; &quot;xxxx&quot;;&#x2F;&#x2F; 四个字节 ExecutorService executor &#x3D; Executors.newCachedThreadPool(); &#x2F;&#x2F;初始化 IntStream.range(0, 1000).forEach(i -&gt; &#123; executor.submit(() -&gt; &#123; &#x2F;&#x2F;每个线程需要一个令牌 boolean token &#x3D; tokenLimiter.getTokens(&quot;x&quot;.getBytes()); if (token) &#123; System.out.println(&quot;token pass&quot;); &#125; else &#123; System.out.println(&quot;token refuse&quot;); &#125; &#125;); &#125;); &#125;&#125; 基于Guava实现 1234567891011121314151617181920212223242526272829public class RateLimiterTest &#123;public static void main(String[] args) &#123; &#x2F;&#x2F;每秒生产两个令牌 final RateLimiter rateLimiter &#x3D; RateLimiter.create(20.0); ExecutorService executorService &#x3D; Executors.newCachedThreadPool(); IntStream.range(0, 10).forEach(i -&gt; &#123; executorService.submit(() -&gt; &#123; &#x2F;&#x2F;随机休眠 Random random &#x3D; new Random(); int r &#x3D; random.nextInt(1000); try &#123; TimeUnit.MICROSECONDS.sleep(r); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;每个线程需要一个令牌 boolean token &#x3D; rateLimiter.tryAcquire(); if (token) &#123; System.out.println(&quot;token pass&quot;); &#125; else &#123; System.out.println(&quot;token refuse&quot;); &#125; &#125;); &#125;);&#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://idea360.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"限流","slug":"限流","permalink":"https://idea360.cn/tags/%E9%99%90%E6%B5%81/"}]},{"title":"Redis+token机制实现幂等性操作","slug":"redis-token-idempotent","date":"2020-09-01T15:30:27.000Z","updated":"2021-02-23T14:39:34.865Z","comments":true,"path":"2020/09/01/redis-token-idempotent/","link":"","permalink":"https://idea360.cn/2020/09/01/redis-token-idempotent/","excerpt":"","text":"前言 使用redis+token实现幂等性操作，防止表单的重复提交和一些其他重复请求操作。有些接口需要保证操作的唯一性，比如：订单接口（重复点击下单，只会生成一个订单号）；支付接口（重复支付也只会扣一次款）；表单接口等等… 一、实现幂等性操作的方法 唯一索引 – 防止新增脏数据 token机制 – 防止页面重复提交 悲观锁 – 获取数据的时候加锁(锁表或锁行) 乐观锁 – 基于版本号version实现, 在更新数据那一刻校验数据 分布式锁 – redis(jedis、redisson)或zookeeper实现 状态机 – 状态变更, 更新数据时判断状态 本文使用token机制来实现幂等性操作 二、token机制简单流程图与原理（以表单提交为例） 这里以表单提交为例，大致的分析下流程： 在跳转到表单页面时，创建一个Token，存入redis中，并且保存这个token到表单页面中。 现在进入了表单页面，在表单页面添加个隐藏域，放入token。 表单正常提交，token也随之提交。 拦截器开始拦截，获得表单提交的token并与redis中的token进行对比判断。 若判断通过，正常执行程序，并删除token。若判断不通过，说明这次提交的表单有问题，抛出异常，程序不再继续执行 【模拟情景：】用户提交了一个表单，但是网络比较慢，用户点了多次提交。此时第一个提交的内容token验证通过了，redis中token被销毁，剩下的请求虽然也携带了token，但是redis中已然没有了数据，剩下的请求验证全部不通过，请求被放弃… 三、项目实战 1、跳转页面 123456789 @GetMapping(&quot;/diary/newDiary&quot;) @ApiOperation(&quot;跳转到创建随笔页面&quot;)//这是一个简单的跳转页面controller,在跳转时生成一个token到前段页面去 public ModelAndView toInsert(Model model)&#123; String newDiaryToken = redisUtils.getToken(); model.addAttribute(&quot;newDiaryToken&quot;,newDiaryToken); return new ModelAndView(&quot;diary/insert&quot;); &#125; 2、token生成工具 123456789101112131415161718/** * @Description: 创建Token，怕麻烦的可以直接生成UUID作为toekn的key和value * @Date: 2020/1/8 0008 */ public String getToken()&#123; String token_value = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;); int index = new Random().nextInt(5); String token_key = token_value.substring(0,index); try &#123; redisTemplate.opsForValue().set(token_key,token_value); return token_key; &#125;catch (Exception e)&#123; e.printStackTrace(); return null; &#125; &#125; 3、表单页面加入隐藏项 1&lt;input type=&quot;hidden&quot; th:value=&quot;$&#123;newDiaryToken&#125;&quot; name = &quot;token&quot;&gt; 4、拦截器拦截url请求，验证token 12345678910111213141516171819202122232425262728package com.braisedpanda.my.blog.web.framework.filter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.*;/** * @program: my-blog * @description: token拦截器 * * @create: 2020-01-08 10:08 **/@Configurationpublic class TokenInterceptorConfig implements WebMvcConfigurer &#123; @Bean TokenInterceptor tokenInterceptor()&#123; return new TokenInterceptor(); &#125; public void addInterceptors(InterceptorRegistry registry) &#123; //拦截指定URL registry.addInterceptor(tokenInterceptor()) .addPathPatterns(&quot;/admin/diary/insert/**&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.braisedpanda.my.blog.web.framework.filter;import com.braisedpanda.my.blog.web.config.redis.RedisUtils;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.lang.Nullable;import org.springframework.util.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @program: my-blog * @description: * @create: 2020-01-08 10:13 **/@Configuration@Slf4jpublic class TokenInterceptor implements HandlerInterceptor &#123; @Autowired private RedisUtils redisUtils; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //验证token String token = request.getParameter(&quot;token&quot;); String value = (String)redisUtils.get(token); if(!StringUtils.isEmpty(value) &amp;&amp; value !=null &amp;&amp; value.length()&gt;0)&#123; redisUtils.del(token); log.info(&quot;处理请求成功.......&quot;); return true; &#125;else &#123; log.error(&quot;请勿重复提交表单.......&quot;); response.sendRedirect(&quot;/toError&quot;); return false; &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"redis","slug":"redis","permalink":"https://idea360.cn/tags/redis/"},{"name":"幂等","slug":"幂等","permalink":"https://idea360.cn/tags/%E5%B9%82%E7%AD%89/"}]},{"title":"SpringCloud-Gateway认证授权","slug":"spring-cloud-gateway-auth","date":"2020-09-01T15:26:05.000Z","updated":"2021-07-10T12:04:02.205Z","comments":true,"path":"2020/09/01/spring-cloud-gateway-auth/","link":"","permalink":"https://idea360.cn/2020/09/01/spring-cloud-gateway-auth/","excerpt":"","text":"基于spring cloud gateway的简易认证授权 用户的访问基本上都是需要携带 JWT Token 的，gateway-service 在接收到请求之后，会向鉴权服务发送鉴权请求，获得授权之后可以得到当前访问的用户详细信息；如果检测到请求未经授权，那么 gateway-service 直接会返回未授权错误，保护内部服务访问安全。 理论上鉴权也可以通过自定义 gateway filter 来实现，不过我们希望可以尽可能多使用 spring-security 提供的能力，毕竟自己封装需要实现的东西还是有点多的。 Spring Cloud Gateway 只支持搭配 webflux 使用，所以我们后续使用了 @EnableWebFluxSecurity 注解。 我们将 gateway 作为一个 resource server 进行配置，毕竟 spring-security 帮我们做了很多事情，所以需要我们自己配置的代码很少。 api-server 资源服务器是一个普通的springboot服务，在整个微服务环境中是透明的，可以直接访问 curl http://localhost:8080/hello Hello World. 123456789@RestControllerpublic class ApiController &#123; @GetMapping(&quot;/hello&quot;) public String getRequest() &#123; return &quot;Hello World.&quot;; &#125;&#125; auth-server pom.xml 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.nimbusds&lt;/groupId&gt; &lt;artifactId&gt;nimbus-jose-jwt&lt;/artifactId&gt; &lt;version&gt;8.2&lt;/version&gt;&lt;/dependency&gt; Application.yml(签名文件在resource目录下) 1234567server: port: 8081## actuatormanagement: endpoints: web.exposure.include: &quot;*&quot; 认证配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344@EnableAuthorizationServer@Configuration@AllArgsConstructorpublic class AuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter &#123; private final AuthenticationManager authenticationManagerBean; private final PasswordEncoder passwordEncoder; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;test-client&quot;) .secret(passwordEncoder.encode(&quot;test-secret&quot;)) .authorizedGrantTypes(&quot;refresh_token&quot;, &quot;password&quot;) .scopes(&quot;default-scope&quot;); &#125; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints .authenticationManager(authenticationManagerBean) .accessTokenConverter(accessTokenConverter()); &#125; @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123; security .allowFormAuthenticationForClients(); &#125; @Bean public AccessTokenConverter accessTokenConverter() &#123; JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter(); jwtAccessTokenConverter.setKeyPair(keyPair()); return jwtAccessTokenConverter; &#125; @Bean public KeyPair keyPair() &#123; KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource(&quot;demojwt.jks&quot;), &quot;keystorepass&quot;.toCharArray()); return keyStoreKeyFactory.getKeyPair(&quot;jwt&quot;, &quot;keypairpass&quot;.toCharArray()); &#125;&#125; 安全配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Configuration@EnableWebSecuritypublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .requestMatchers(EndpointRequest.toAnyEndpoint()).permitAll() .antMatchers(&quot;/.well-known/jwks.json&quot;).permitAll() .anyRequest().authenticated(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(s -&gt; new UserDetails() &#123; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return AuthorityUtils.createAuthorityList(&quot;USER&quot;); &#125; @Override public String getPassword() &#123; return passwordEncoder().encode(&quot;user-password&quot;); &#125; @Override public String getUsername() &#123; return &quot;user-username&quot;; &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125; &#125;); &#125; @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; controller 12345678910111213@RestController@AllArgsConstructorpublic class MvcController &#123; private final KeyPair keyPair; @GetMapping(&quot;/.well-known/jwks.json&quot;) public Map&lt;String, Object&gt; getKey() &#123; RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAKey key = new RSAKey.Builder(publicKey).build(); return new JWKSet(key).toJSONObject(); &#125;&#125; gateway-service Pom.xml 1234567891011121314151617181920212223242526272829&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;&lt;/dependency&gt; Application.yml 12345678910111213server: port: 8082## gatewayspring: cloud.gateway.routes: - id: api-service-route uri: http://localhost:8080 predicates: - Path=/api/** filters: - StripPrefix=1 security.oauth2.resourceserver.jwt.jwk-set-uri: &#x27;http://localhost:8081/.well-known/jwks.json&#x27; 因为我们的 authorization server 使用了 jwt token，jwt 很适合在纯 RESTful API 中作为无状态的认证凭证进行使用，搭配 spring security oauth2 的话，简单且好用。当然如果在某些场景下需要撤销某个 jwt token，也可以搭配 redis 进行管理。 我们在上面代码中声明了 gateway-service 作为一个简单的 resource server 并启用了 jwt，jwt token 通过公钥来验证有效性。因此我们需要指定 jwt 鉴权的公钥地址。 ResourceServerConfigurer 1234567891011121314@EnableWebFluxSecuritypublic class ResourceServerConfigurer &#123; @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) &#123; http.authorizeExchange() .pathMatchers(&quot;/actuator/**&quot;).permitAll() .anyExchange().authenticated(); http.oauth2ResourceServer().jwt(); return http.build(); &#125;&#125; 测试 依次运行 auth-service，gateway-service，api-service 获取 access token script1234567curl -X POST \\ http://localhost:8081/oauth/token \\ -d grant_type=password \\ -d client_id=test-client \\ -d client_secret=test-secret \\ -d username=user-username \\ -d password=user-password 不带 token 访问接口，返回 401 Unauthorized script1curl -X GET http://localhost:8082/api/hello -sI 带 token 访问接口 script123curl -X GET \\ http://localhost:8082/api/hello \\ -H &#x27;Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzI0ODY3ODksInVzZXJfbmFtZSI6InVzZXItdXNlcm5hbWUiLCJhdXRob3JpdGllcyI6WyJVU0VSIl0sImp0aSI6IjA3MDZmOWUyLWRlMWYtNDg4ZS1hNTJhLTUzMjdiMjU4ZTI4ZiIsImNsaWVudF9pZCI6InRlc3QtY2xpZW50Iiwic2NvcGUiOlsiZGVmYXVsdC1zY29wZSJdfQ.IqSmO7rH_lFpQ8__ZP1rwSDh5S6kw3EPaT3gs-byW_usN5iM0l0ohEV1OCb1jOUjcMoxnqUM-C3ZEND_tVdGlpscNVXT1avkVGw8Rc2Y49_Ee0OYgLwg97LOFdoHgCIEWKqronk5EdZJES1Zv95MbGSO1o6U_mo8My1-znxNgUwYpGt1sNUsaoCRzIKEQR--67IWe3EMmxo1D0IcPPi0fgKbVD2LR7mOQTqvQMHEF4LplS67mbfUWLFJg9Q4gyH0l3ndgGkCIcofPop9-GlwNCgp52RiGQlp8MCXydHbybr-_g-nXrstxSHQ-1iC0ihIMSueDhEuN7gLe5OELBW1oA&#x27; 经过上面这些配置之后，我们就已经实现了一个比较简单的微服务架构下的网关服务了。 参考 https://mp.weixin.qq.com/s/4v_wwX0SS7jvOwtO8uiDAw 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://idea360.cn/tags/SpringCloud/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"认证","slug":"认证","permalink":"https://idea360.cn/tags/%E8%AE%A4%E8%AF%81/"},{"name":"授权","slug":"授权","permalink":"https://idea360.cn/tags/%E6%8E%88%E6%9D%83/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"}]},{"title":"spring之ioc源码解析","slug":"spring-ioc","date":"2020-09-01T15:22:33.000Z","updated":"2021-02-23T14:44:53.119Z","comments":true,"path":"2020/09/01/spring-ioc/","link":"","permalink":"https://idea360.cn/2020/09/01/spring-ioc/","excerpt":"","text":"前言 起初动机完全是面试问到这个问题了，觉得需要了解下。 看别人对源码的解读，完全不知道如何去表达，直到看了手写IOC，再去看源码，觉得哦… Spring 容器高层视图 Spring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配 置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准 备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现。 IOC流程 初始化IOC容器。定义一个BeanFactory,对象实例的工厂，这个工厂提供一个统一的方法，getBean 扫描包路径，读取配置文件，或者扫描注解。将配置信息转换为IOC容器能够识别的数据结构(BeanDefinition)，并注册到工厂 调用BeanFactory.getBean() 会触发Bean的实例化。(反射) 手写IOC 注解类 123456789/** * Bean注解 */@Documented@Target(&#123; ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Component &#123; String value() default &quot;&quot;;&#125; 12345678/** * DI注解 */@Documented@Target(&#123; ElementType.FIELD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Autowired &#123;&#125; 普通组件 123456789101112131415public class User &#123; private String username; private String password; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; @Override public String toString() &#123; return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; &#125;&#125; 12345678@Componentpublic class UserService &#123; public User getUser() &#123; return new User(&quot;admin&quot;, &quot;123456&quot;); &#125;&#125; 1234567891011@Componentpublic class UserController &#123; @Autowired private UserService userService; public void say() &#123; User user = userService.getUser(); System.out.println(user); &#125;&#125; IOC和DI核心 1234567891011public class BeanDefinition &#123; //bean实例 private Object bean; //bean的Class对象 private Class&lt;?&gt; beanClass; //bean的全限定名 private String className; //是否懒加载 private boolean lazyInit;&#125; 12345public interface BeanFactory &#123; Object getBean(String name);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class ApplicationContext implements BeanFactory &#123; // 所有类的集合(全类名) private List&lt;String&gt; classNames = new ArrayList&lt;&gt;(); //存储对象名称和已经实例化的对象映射 private Map&lt;String, Object&gt; beanMap = new ConcurrentHashMap&lt;&gt;(); public ApplicationContext(String basePackage) &#123; doScan(basePackage); doIoc(); doDI(); &#125; @Override public Object getBean(String name) &#123; return doGetBean(name); &#125; private Object doGetBean(String beanName) &#123; return beanMap.get(beanName); &#125; private void doScan(String basePackage) &#123; URL resource = this.getClass().getClassLoader().getResource(basePackage.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;)); File basePackageFile=new File(resource.getFile()); File[] files = basePackageFile.listFiles(); for (File file: files) &#123; if (file.isDirectory()) &#123; doScan(basePackage + &quot;.&quot; + file.getName()); &#125; else if (file.isFile()) &#123; classNames.add(basePackage + &quot;.&quot; + file.getName().split(&quot;\\\\.&quot;)[0]); &#125; &#125; &#125; private void doIoc() &#123; if (classNames.size() &lt;= 0) &#123; return; &#125; for (String className: classNames) &#123; try &#123; Class&lt;?&gt; cls = Class.forName(className); if (cls.isAnnotationPresent(Component.class)) &#123; Component component = cls.getAnnotation(Component.class); Object instance = cls.newInstance(); if (StringUtils.isBlank(component.value())) &#123; beanMap.put(camelCaseName(cls.getSimpleName()), instance); &#125; else &#123; beanMap.put(camelCaseName(cls.getSimpleName()), instance); beanMap.put(component.value(), instance); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void doDI() &#123; for (Map.Entry&lt;String, Object&gt; entry: beanMap.entrySet()) &#123; Field[] fields = entry.getValue().getClass().getDeclaredFields(); for (Field field:fields) &#123; if (field.isAnnotationPresent(Autowired.class)) &#123; Object obj = null; if (beanMap.containsKey(field.getName())) &#123; obj = beanMap.get(field.getName()); &#125; else &#123; obj = beanMap.get(camelCaseName(field.getType().getSimpleName())); &#125; if (null == obj) &#123; return; &#125; try &#123; // 暴力访问私有属性 field.setAccessible(true); field.set(entry.getValue(), obj); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; /** * 驼峰命名 * @param s * @return */ private static String camelCaseName(String s) &#123; char[] chars = s.toCharArray(); String firstChar = String.valueOf(chars[0]); chars[0] = firstChar.toLowerCase().charAt(0);// 转小写 return String.valueOf(chars); &#125;&#125; 123456789public class IocApplication &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ApplicationContext(&quot;com.idcmind.ioc&quot;); // test UserController componentB = (UserController) ctx.getBean(&quot;userController&quot;); componentB.say(); &#125;&#125; 实际过程中Bean是懒加载的，延时实例化。 当我们需要UserController的时候，会检索到需要先实例化UserService。 这就是依赖注入吧。当然，这样调用的时候需要全类名。 实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class ApplicationContext implements BeanFactroy &#123; //存储对象名称和已经实例化的对象映射 private Map&lt;String, Object&gt; beanMap = new ConcurrentHashMap&lt;&gt;(); //存储对象名称和对应对象信息的映射 private ConcurrentHashMap&lt;String,BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(); private List&lt;String&gt; packageNames = new ArrayList&lt;&gt;(); /** * 有参构造方法,参数类型为指定要扫描加载的包名 * @param basePackage com.idcmind.ioc */ public ApplicationContext(String basePackage) throws Exception &#123; scanBasePackage(basePackage); registerBeanDefinition(packageNames); &#125; /** * 注册bean定义 * @param packageNames * @throws Exception */ private void registerBeanDefinition(List&lt;String&gt; packageNames) throws Exception &#123; if (packageNames.size() &lt;= 0) &#123; return; &#125; for (String packageName : packageNames) &#123; Class&lt;?&gt; c = Class.forName(packageName); if (c.isAnnotationPresent(Component.class)) &#123; BeanDefinition beanDefinition = new BeanDefinition(); beanDefinition.setClassName(c.getName()); beanDefinition.setBeanClass(c); beanDefinition.setLazyInit(true); beanDefinition.setBean(c.newInstance()); beanDefinitionMap.put(c.getName(), beanDefinition); &#125; &#125; &#125; /** * 扫描包 * @param basePackage */ private void scanBasePackage(String basePackage) throws Exception&#123; URL resource = this.getClass().getClassLoader().getResource(basePackage.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;)); File basePackageFile=new File(resource.getFile()); File[] files = basePackageFile.listFiles(); for (File file: files) &#123; if (file.isDirectory()) &#123; scanBasePackage(basePackage + &quot;.&quot; + file.getName()); &#125; else if (file.isFile()) &#123; packageNames.add(basePackage + &quot;.&quot; + file.getName().split(&quot;\\\\.&quot;)[0]); &#125; &#125; &#125; /** * 获取bean * @param name * @return * @throws Exception */ public Object getBean(String name) throws Exception &#123; return doGetBean(name); &#125; /** * 获取bean * @param beanName * @return * @throws Exception */ private Object doGetBean(String beanName) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Objects.requireNonNull(beanName, &quot;beanName不能为空&quot;); Object instance = beanMap.get(beanName); //如果bean已存在，则直接返回 if(instance != null)&#123; return instance; &#125; BeanDefinition beanDefinition = beanDefinitionMap.get(beanName); String className = beanDefinition.getClassName(); Class&lt;?&gt; cls = Class.forName(className); instance = cls.newInstance(); setField(instance); beanMap.put(beanName, instance); return instance; &#125; /** * 设置参数 * @param instance */ private void setField(Object instance) &#123; Field[] fields = instance.getClass().getDeclaredFields(); for (Field field: fields) &#123; if (field.isAnnotationPresent(Autowired.class)) &#123; String filedName = field.getType().getName(); try &#123; Object fieldBean = getBean(filedName); field.setAccessible(true); field.set(instance, fieldBean); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"ioc","slug":"ioc","permalink":"https://idea360.cn/tags/ioc/"}]},{"title":"springboot集成cache","slug":"springboot-cache","date":"2020-09-01T15:20:01.000Z","updated":"2021-02-23T14:45:50.724Z","comments":true,"path":"2020/09/01/springboot-cache/","link":"","permalink":"https://idea360.cn/2020/09/01/springboot-cache/","excerpt":"","text":"Redis集群配置 pom.xml 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.cache&lt;/groupId&gt; &lt;artifactId&gt;cache-api&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 12345678910111213141516171819202122spring: redis: timeout: 6000 password: 123456 cluster: max-redirects: 3 # 获取失败 最大重定向次数 nodes: - 192.168.124.5:7001 - 192.168.124.5:7002 - 192.168.124.5:7003 - 192.168.124.5:7004 - 192.168.124.5:7005 - 192.168.124.5:7006 lettuce: pool: max-active: 1000 #连接池最大连接数（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） cache: jcache: config: classpath:ehcache.xml RedisConfig.class 123456789101112@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)public class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisCacheTemplate(LettuceConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; Ehcache配置 EhcacheConfig 1234@Configuration@EnableCachingpublic class EhcacheConfig &#123;&#125; ehcache.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;config xmlns:xsi=&#x27;http://www.w3.org/2001/XMLSchema-instance&#x27; xmlns=&#x27;http://www.ehcache.org/v3&#x27; xmlns:jsr107=&#x27;http://www.ehcache.org/v3/jsr107&#x27;&gt; &lt;service&gt; &lt;jsr107:defaults enable-statistics=&quot;true&quot;/&gt; &lt;/service&gt; &lt;!--完整配置一个缓存。areaOfCircleCache 为该缓存名称 对应@Cacheable的属性cacheNames--&gt; &lt;cache alias=&quot;defaultCache&quot;&gt; &lt;!-- 指定缓存 key 类型，对应@Cacheable的属性key --&gt; &lt;key-type&gt;java.lang.String&lt;/key-type&gt; &lt;!-- 配置value类型 --&gt; &lt;value-type&gt;java.lang.String&lt;/value-type&gt; &lt;!-- 缓存 ttl，单位为分钟minutes，现在设置的是2个小时。秒是seconds --&gt; &lt;expiry&gt; &lt;ttl unit=&quot;seconds&quot;&gt;20&lt;/ttl&gt; &lt;/expiry&gt; &lt;listeners&gt; &lt;listener&gt; &lt;class&gt;com.idcmind.ants.listener.CustomCacheEventLogger&lt;/class&gt; &lt;event-firing-mode&gt;ASYNCHRONOUS&lt;/event-firing-mode&gt; &lt;event-ordering-mode&gt;UNORDERED&lt;/event-ordering-mode&gt; &lt;events-to-fire-on&gt;CREATED&lt;/events-to-fire-on&gt; &lt;events-to-fire-on&gt;UPDATED&lt;/events-to-fire-on&gt; &lt;events-to-fire-on&gt;EXPIRED&lt;/events-to-fire-on&gt; &lt;events-to-fire-on&gt;REMOVED&lt;/events-to-fire-on&gt; &lt;events-to-fire-on&gt;EVICTED&lt;/events-to-fire-on&gt; &lt;/listener&gt; &lt;/listeners&gt; &lt;!--储存层配置--&gt; &lt;resources&gt; &lt;!-- 分配资源大小 --&gt; &lt;heap unit=&quot;entries&quot;&gt;2000&lt;/heap&gt; &lt;offheap unit=&quot;MB&quot;&gt;100&lt;/offheap&gt; &lt;/resources&gt; &lt;/cache&gt; &lt;!--这里可以配置N个 。。。。 不同的cache 根据业务情况配置--&gt; &lt;!--配置一个缓存模板--&gt; &lt;cache-template name=&quot;heap-cache&quot;&gt; &lt;expiry&gt; &lt;ttl unit=&quot;seconds&quot;&gt;20&lt;/ttl&gt; &lt;/expiry&gt; &lt;resources&gt; &lt;heap unit=&quot;entries&quot;&gt;2000&lt;/heap&gt; &lt;offheap unit=&quot;MB&quot;&gt;100&lt;/offheap&gt; &lt;/resources&gt; &lt;/cache-template&gt; &lt;!--使用缓存模板配置缓存--&gt; &lt;cache alias=&quot;local&quot; uses-template=&quot;heap-cache&quot; /&gt;&lt;/config&gt; CustomCacheEventLogger.java 12345678910public class CustomCacheEventLogger implements CacheEventListener&lt;Object, Object&gt; &#123; private static final Logger LOG = LoggerFactory.getLogger(CustomCacheEventLogger.class); @Override public void onEvent(CacheEvent cacheEvent) &#123; LOG.info(&quot;缓存监听事件 = &#123;&#125;, Key = &#123;&#125;, Old value = &#123;&#125;, New value = &#123;&#125;&quot;, cacheEvent.getType(), cacheEvent.getKey(), cacheEvent.getOldValue(), cacheEvent.getNewValue()); &#125;&#125; CacheService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Slf4j@Servicepublic class CacheService &#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; /** * 从ehcache中获取数据，如果缓存数据不存在，则从db中查询并填充ehcache * @param key * @return */ @Cacheable(value = &quot;local&quot;, key = &quot;#key&quot;) public String getDataFromLocalCache(String key) &#123; return null; &#125; /** * 添加缓存 * @param key * @param value * @return */ @CachePut(value = &quot;local&quot;, key = &quot;#key&quot;) public String saveData2LocalCache(String key, String value) &#123; log.info(&quot;缓存到[ehcache]&quot;, key, value); return value; &#125; /** * 移除缓存 * @param key */ @CacheEvict(value = &quot;local&quot;, key=&quot;#key&quot;) public void delete(String key) &#123; &#125; /** * 从redis获取数据 * @param key * @return */ public String getDataFromRedisCache(String key) &#123; String data = redisTemplate.opsForValue().get(key); return data; &#125; /** * 数据存储到redis * @param key * @param value */ public void saveData2RedisCache(String key, String value) &#123; log.info(&quot;缓存到[redis]&quot;, key, value); redisTemplate.opsForValue().set(key, value, 10, TimeUnit.SECONDS); &#125; /** * 从db获取数据，hystrix限流 * @param key * @return */ public String getDataFromDB(String key) &#123; return &quot;【data】= &quot; + key; &#125;&#125; DataService.java 123456789101112131415161718192021222324252627282930313233343536373839@Slf4j@Servicepublic class DataService &#123; @Autowired CacheService cacheService; public String getData(String key) &#123; String data = null; // 查找一级缓存 data = cacheService.getDataFromRedisCache(key); if (!StringUtils.isEmpty(data)) &#123; log.info(&quot;从[redis]里获取数据: &#123;&#125;&quot;, data); return data; &#125; // 查找二级缓存 data = cacheService.getDataFromLocalCache(key); if (!StringUtils.isEmpty(data)) &#123; log.info(&quot;从[ehcache]中获取数据: &#123;&#125;&quot;, data); // 更新一级缓存 cacheService.saveData2RedisCache(key, data); return data; &#125; // 查询数据库 data = cacheService.getDataFromDB(key); if (!StringUtils.isEmpty(data)) &#123; log.info(&quot;从[db]中获取数据: &#123;&#125;&quot;, data); // 更新一二级缓存 cacheService.saveData2LocalCache(key, data); cacheService.saveData2RedisCache(key, data); &#125; return data; &#125;&#125; 单元测试 1234567891011121314151617@Slf4j@SpringBootTestclass CacheServiceTest &#123; @Autowired private DataService dataService; @Test void getDataFromLocalCache() throws InterruptedException &#123; for (int i=0; i&lt;10; i++) &#123; String data = dataService.getData(&quot;k1&quot;); log.info(&quot;====================================&quot;); Thread.sleep(5000); &#125; &#125;&#125; 结果 123456789101112131415161718192021222324252627282020-01-18 18:40:08.025 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[db]中获取数据: 【data】&#x3D; k12020-01-18 18:40:08.026 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[ehcache]2020-01-18 18:40:08.033 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[redis]2020-01-18 18:40:08.040 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:13.046 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[redis]里获取数据: 【data】&#x3D; k12020-01-18 18:40:13.046 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:18.054 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[ehcache]中获取数据: 【data】&#x3D; k12020-01-18 18:40:18.054 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[redis]2020-01-18 18:40:18.061 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:23.070 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[redis]里获取数据: 【data】&#x3D; k12020-01-18 18:40:23.071 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:28.081 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[db]中获取数据: 【data】&#x3D; k12020-01-18 18:40:28.081 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[ehcache]2020-01-18 18:40:28.082 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[redis]2020-01-18 18:40:28.085 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:33.091 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[redis]里获取数据: 【data】&#x3D; k12020-01-18 18:40:33.092 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:38.097 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[redis]里获取数据: 【data】&#x3D; k12020-01-18 18:40:38.097 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:43.100 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[ehcache]中获取数据: 【data】&#x3D; k12020-01-18 18:40:43.101 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[redis]2020-01-18 18:40:43.104 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:48.107 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[redis]里获取数据: 【data】&#x3D; k12020-01-18 18:40:48.107 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2020-01-18 18:40:53.116 INFO 67416 --- [ main] com.idcmind.ants.service.DataService : 从[db]中获取数据: 【data】&#x3D; k12020-01-18 18:40:53.116 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[ehcache]2020-01-18 18:40:53.116 INFO 67416 --- [ main] com.idcmind.ants.service.CacheService : 缓存到[redis]2020-01-18 18:40:53.119 INFO 67416 --- [ main] c.idcmind.ants.service.CacheServiceTest : &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"cache","slug":"cache","permalink":"https://idea360.cn/tags/cache/"},{"name":"缓存","slug":"缓存","permalink":"https://idea360.cn/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"多线程socket","slug":"java-socket","date":"2020-09-01T15:18:20.000Z","updated":"2021-02-23T14:27:48.575Z","comments":true,"path":"2020/09/01/java-socket/","link":"","permalink":"https://idea360.cn/2020/09/01/java-socket/","excerpt":"","text":"多线程socket 1234567891011121314151617181920212223242526&#x2F;&#x2F;因为是多线程，所以不在服务端直接做业务处理，而是在线程类里处理public class NetServer &#123; public static void go()&#123; int PORT&#x3D;7775; try &#123; &#x2F;&#x2F;指定端口专门处理这件事 ServerSocket ss &#x3D; new ServerSocket(PORT); System.out.println(&quot;服务器已启动&quot;); &#x2F;&#x2F;死循环，目的是一直保持监听状态 while (true) &#123; &#x2F;&#x2F;开启监听 Socket s &#x3D; ss.accept(); &#x2F;&#x2F;将连接的客户端交给一个线程去处理 Thread t &#x3D; new Thread(new ClentThread(s)); &#x2F;&#x2F;开启线程 t.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; go(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class ClentThread implements Runnable &#123; private Socket socket &#x3D; null; public ClentThread(Socket s) &#123; this.socket &#x3D; s; &#125; @Override public void run() &#123; try &#123; &#x2F;&#x2F;接收客户端消息 BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream())); &#x2F;&#x2F;按行读取客户端的消息内容，并且拼接在一起 StringBuffer sb&#x3D;new StringBuffer(); String tmp&#x3D;&quot;&quot;; while((tmp&#x3D;in.readLine())!&#x3D;null)&#123; sb.append(tmp); &#125; System.out.println(&quot;客户端发送的是：&quot;+sb.toString()); &#x2F;&#x2F;转码 String rc&#x3D;new String(sb.toString().getBytes(),&quot;UTF-8&quot;); &#x2F;&#x2F;将消息返回给客户端 PrintWriter out &#x3D; new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true); out.print(rc); &#x2F;&#x2F;该关的都关掉 out.close(); in.close(); &#125; catch (Exception e) &#123; System.out.println(e.toString()); &#125; finally &#123; try &#123; socket.close(); &#125; catch (Exception e) &#123; System.out.println(e.toString()); &#125; &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"https://idea360.cn/tags/socket/"}]},{"title":"信号量semaphore","slug":"java-semaphore","date":"2020-09-01T15:17:11.000Z","updated":"2021-02-23T14:27:29.968Z","comments":true,"path":"2020/09/01/java-semaphore/","link":"","permalink":"https://idea360.cn/2020/09/01/java-semaphore/","excerpt":"","text":"Semaphore的使用方法 Semaphore翻译成字面意思为信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 Semaphore类位于java.util.concurrent包下，它提供了2个构造器： 1234567891011121314151617181920212223242526&#x2F;** * Creates a &#123;@code Semaphore&#125; with the given number of * permits and nonfair fairness setting. * * @param permits the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted. *&#x2F; public Semaphore(int permits) &#123; sync &#x3D; new NonfairSync(permits); &#125; &#x2F;** * Creates a &#123;@code Semaphore&#125; with the given number of * permits and the given fairness setting. * * @param permits the initial number of permits available. * This value may be negative, in which case releases * must occur before any acquires will be granted. * @param fair &#123;@code true&#125; if this semaphore will guarantee * first-in first-out granting of permits under contention, * else &#123;@code false&#125; *&#x2F; public Semaphore(int permits, boolean fair) &#123; sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits); &#125; 参数permits表示许可数目，即同时可以允许多少线程进行访问。 第二个构造函数多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可。 下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法： 123456789&#x2F;&#x2F;获取一个许可public void acquire() throws InterruptedException &#123; &#125;&#x2F;&#x2F;获取permits个许可 public void acquire(int permits) throws InterruptedException &#123; &#125; &#x2F;&#x2F;释放一个许可 public void release() &#123; &#125; &#x2F;&#x2F;释放permits个许可public void release(int permits) &#123; &#125; acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 release()用来释放许可。注意，在释放许可之前，必须先获获得许可。 这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法： 12345678&#x2F;&#x2F;尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire() &#123; &#125;; &#x2F;&#x2F;尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; &#x2F;&#x2F;尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(int permits) &#123; &#125;; &#x2F;&#x2F;尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;; 另外还可以通过availablePermits()方法得到可用的许可数目。 下面通过一个例子来看一下Semaphore的具体使用： 马上到端午节了，大家要去旅游，比如我们去圆明园游览，只有5个窗口可以售票，也就是说同一个时刻只能服务5个人。 1234567891011121314151617181920212223242526272829303132333435363738public class Test &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;游客的数量 int visitor &#x3D; 8; &#x2F;&#x2F;窗口的数量 Semaphore semaphore &#x3D; new Semaphore(5); for (int i &#x3D; 0; i &lt; visitor; i++) &#123; new Visitor(i, semaphore).start(); &#125; &#125; static class Visitor extends Thread &#123; private int num; private Semaphore semaphore; public Visitor(int num, Semaphore semaphore) &#123; this.num &#x3D; num; this.semaphore &#x3D; semaphore; &#125; @Override public void run() &#123; try &#123; &#x2F;&#x2F;占用窗口 semaphore.acquire(); System.out.println(&quot;游客&quot; + this.num + &quot;占用窗口进行买票...&quot;); Thread.sleep(2000); System.out.println(&quot;游客&quot; + this.num + &quot;释放出窗口&quot;); &#x2F;&#x2F;释放窗口 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 输出结果为 12345678910111213141516游客0占用窗口进行买票...游客1占用窗口进行买票...游客2占用窗口进行买票...游客3占用窗口进行买票...游客4占用窗口进行买票...游客0释放出窗口游客1释放出窗口游客2释放出窗口游客5占用窗口进行买票...游客7占用窗口进行买票...游客6占用窗口进行买票...游客3释放出窗口游客4释放出窗口游客5释放出窗口游客7释放出窗口游客6释放出窗口 从结果来看，最多只有5个游客在购票。而这么精确的控制，我们也只是调用了acquire和release方法。 从acquire方法进去，具体调用的还是AbstractQueuedSynchronizer这个类的逻辑 12345678910public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 而tryAcquireShared方法留给了子类去实现，Semaphore类里面的两个内部类FairSync和NonfairSync都继承自AbstractQueuedSynchronizer。 这两个内部类，从名字来看，一个实现了公平锁，另一个是非公平锁。 实现原理 Semaphore内部原理是通过AQS实现的。Semaphore中定义了Sync抽象类，而Sync又继承了AbstractQueuedSynchronizer，Semaphore中对许可的获取与释放，是使用CAS通过对AQS中state的操作实现的。 Semaphore对许可的分配有两种策略，公平策略和非公平策略，没有明确指明时，默认为非公平策略。 公平策略：根据方法调用顺序（即先进先出，FIFO）来选择线程、获得许可。 非公平策略：不对线程获取许可的顺序做任何保证。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"信号量","slug":"信号量","permalink":"https://idea360.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"semaphore","slug":"semaphore","permalink":"https://idea360.cn/tags/semaphore/"}]},{"title":"手写Hashmap","slug":"java-hashmap-custom","date":"2020-09-01T15:13:19.000Z","updated":"2021-02-23T14:23:59.750Z","comments":true,"path":"2020/09/01/java-hashmap-custom/","link":"","permalink":"https://idea360.cn/2020/09/01/java-hashmap-custom/","excerpt":"","text":"代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class CustomHashMap&lt;K, V&gt; &#123; private class Entry&lt;K, V&gt; &#123; int hash; K key; V value; Entry&lt;K, V&gt; next; Entry(int hash, K key, V value, Entry&lt;K, V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; &#125; private static final int DEFAULT_CAPACITY = 1 &lt;&lt; 4; private Entry&lt;K, V&gt;[] table; private int capacity; private int size; public CustomHashMap() &#123; this(DEFAULT_CAPACITY); &#125; public CustomHashMap(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException(); &#125; else &#123; table = new Entry[capacity]; size = 0; this.capacity = capacity; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0 ? true : false; &#125; private int hash(K key) &#123; int i = key.hashCode() &amp; (capacity - 1); double tmp = key.hashCode() * (Math.pow(5, 0.5) - 1) / 2; double digit = tmp - Math.floor(tmp); return (int) Math.floor(digit * capacity); &#125; public void put(K key, V value) &#123; if (key == null) &#123; throw new IllegalArgumentException(); &#125; int hash = hash(key); Entry&lt;K, V&gt; nEntry = new Entry&lt;K, V&gt;(hash, key, value, null); Entry&lt;K, V&gt; entry = table[hash]; while (entry != null) &#123; if (entry.key.equals(key)) &#123; entry.value = value; return; &#125; entry = entry.next; &#125; nEntry.next = table[hash]; table[hash] = nEntry; size++; &#125; public V get(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException(); &#125; int hash = hash(key); Entry&lt;K, V&gt; entry = table[hash]; while (entry != null) &#123; if (entry.key.equals(key)) &#123; return entry.value; &#125; entry = entry.next; &#125; return null; &#125; public static void main(String[] args) &#123; CustomHashMap&lt;String, String&gt; map = new CustomHashMap&lt;String, String&gt;(); map.put(&quot;1&quot;, &quot;11&quot;); map.put(&quot;1&quot;, &quot;22&quot;); map.put(&quot;3&quot;, &quot;33&quot;); System.out.println(map.get(&quot;1&quot;)); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"hashmap","slug":"hashmap","permalink":"https://idea360.cn/tags/hashmap/"}]},{"title":"Java动态代理","slug":"java-proxy","date":"2020-09-01T15:10:43.000Z","updated":"2021-02-23T14:26:14.029Z","comments":true,"path":"2020/09/01/java-proxy/","link":"","permalink":"https://idea360.cn/2020/09/01/java-proxy/","excerpt":"","text":"静态代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** 接口*/public interface IUserDao &#123; void save();&#125;/*** 接口实现* 目标对象*/public class UserDao implements IUserDao &#123; public void save() &#123; System.out.println(&quot;----已经保存数据!----&quot;); &#125;&#125;/*** 代理对象,静态代理*/public class UserDaoProxy implements IUserDao&#123; //接收保存目标对象 private IUserDao target; public UserDaoProxy(IUserDao target)&#123; this.target=target; &#125; public void save() &#123; System.out.println(&quot;开始事务...&quot;); target.save();//执行目标对象的方法 System.out.println(&quot;提交事务...&quot;); &#125;&#125;/*** 测试类*/public class App &#123; public static void main(String[] args) &#123; //目标对象 UserDao target = new UserDao(); //代理对象,把目标对象传给代理对象,建立代理关系 UserDaoProxy proxy = new UserDaoProxy(target); proxy.save();//执行的是代理的方法 &#125;&#125; jdk动态代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*** 创建动态代理对象* 动态代理不需要实现接口,但是需要指定接口类型*/public class ProxyFactory&#123; //维护一个目标对象 private Object target; public ProxyFactory(Object target)&#123; this.target=target; &#125; //给目标对象生成代理对象 public Object getProxyInstance()&#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;开始事务2&quot;); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务2&quot;); return returnValue; &#125; &#125; ); &#125;&#125;/*** 测试类*/public class App &#123; public static void main(String[] args) &#123; // 目标对象 IUserDao target = new UserDao(); // 【原始的类型 class cn.itcast.b_dynamic.UserDao】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // class $Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); &#125;&#125; cglib动态代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*** 目标对象,没有实现任何接口*/public class UserDao &#123; public void save() &#123; System.out.println(&quot;----已经保存数据!----&quot;); &#125;&#125;/*** Cglib子类代理工厂* 对UserDao在内存中动态构建一个子类对象*/public class ProxyFactory implements MethodInterceptor&#123; //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;开始事务...&quot;); //执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务...&quot;); return returnValue; &#125;&#125;/*** 测试类*/public class App &#123; @Test public void test()&#123; //目标对象 UserDao target = new UserDao(); //代理对象 UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.save(); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"动态代理","slug":"动态代理","permalink":"https://idea360.cn/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]},{"title":"Http参数验签(基于过滤器)","slug":"http-params-sign3","date":"2020-09-01T11:29:47.000Z","updated":"2021-02-23T14:20:55.165Z","comments":true,"path":"2020/09/01/http-params-sign3/","link":"","permalink":"https://idea360.cn/2020/09/01/http-params-sign3/","excerpt":"","text":"实现 过滤器 1234567891011121314151617181920212223242526272829303132333435/** * 参数验签过滤器 */@Slf4jpublic class SignFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info(&quot;SignFilter init.&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; log.info(&quot;SignFilter doFilter.&quot;); HttpServletRequest request = (HttpServletRequest) servletRequest; RequestWrapper requestWrapper = new RequestWrapper(request); // TODO 这里获取了所有前端传递的参数, 可能未必是Controller配置的参数 SortedMap&lt;String, String&gt; sortedMap = RequestUtils.getAllParams(requestWrapper); if (SignUtils.verifySign(sortedMap)) &#123; log.info(&quot;验签通过, path: [&#123;&#125;], params: [&#123;&#125;]&quot;, request.getServletPath(), sortedMap.toString()); filterChain.doFilter(requestWrapper, servletResponse); &#125; else &#123; log.error(&quot;验签失败, path: [&#123;&#125;], params: [&#123;&#125;]&quot;, request.getServletPath(), sortedMap.toString()); &#125; &#125; @Override public void destroy() &#123; log.info(&quot;SignFilter destroy.&quot;); &#125;&#125; Request重放 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class RequestWrapper extends HttpServletRequestWrapper &#123; private byte[] buffer; public RequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); InputStream is = request.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte buff[] = new byte[1024]; int read; while ((read = is.read(buff)) &gt; 0) &#123; baos.write(buff, 0, read); &#125; this.buffer = baos.toByteArray(); &#125; @Override public ServletInputStream getInputStream() &#123; final ByteArrayInputStream bais = new ByteArrayInputStream(buffer); return new ServletInputStream() &#123; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener readListener) &#123; &#125; @Override public int read() &#123; return bais.read(); &#125; &#125;; &#125; // 对外提供读取流的方法 @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125;&#125; 过滤器配置 123456789101112131415@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean filterRegistration() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new SignFilter()); registration.addUrlPatterns(&quot;/*&quot;); registration.setName(&quot;SignFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 提取请求参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 接口参数提取 */public class RequestUtils &#123; /** * 将URL请求参数转换成Map * @author show * @param request */ public static Map&lt;String, String&gt; getUrlParams(HttpServletRequest request) &#123; String param = &quot;&quot;; if (Objects.isNull(request.getQueryString())) &#123; return Collections.EMPTY_MAP; &#125; try &#123; param = URLDecoder.decode(request.getQueryString(), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(16); String[] params = param.split(&quot;&amp;&quot;); for (String s : params) &#123; int index = s.indexOf(&quot;=&quot;); result.put(s.substring(0, index), s.substring(index + 1)); &#125; return result; &#125; /** * 获取body中参数 * @param request * @return * @throws IOException */ public static Map&lt;String, String&gt; getBodyParams (HttpServletRequest request) throws IOException &#123; String body = request.getReader().lines().collect(Collectors.joining(System.lineSeparator())); //转化成json对象 Map&lt;String, String&gt; map = new Gson().fromJson(body, new TypeToken&lt;HashMap&lt;String, String&gt;&gt;() &#123;&#125;.getType()); return map; &#125; /** * 获取url参数和body参数 * @param request * @return * @throws IOException */ public static SortedMap&lt;String, String&gt; getAllParams(HttpServletRequest request) throws IOException &#123; SortedMap&lt;String, String&gt; sortedParams = new TreeMap&lt;&gt;(); // 获取url参数 Map&lt;String, String&gt; urlParams = getUrlParams(request); for (Map.Entry entry : urlParams.entrySet()) &#123; sortedParams.put((String) entry.getKey(), (String) entry.getValue()); &#125; // 获取body参数 if (!HttpMethod.GET.name().equals(request.getMethod())) &#123; Map&lt;String, String&gt; bodyParams = getBodyParams(request); if (null != bodyParams) &#123; for (Map.Entry entry : bodyParams.entrySet()) &#123; sortedParams.put((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; &#125; return sortedParams; &#125;&#125; 验签工具 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 验签工具类 */@Slf4jpublic class SignUtils &#123; // 该参数不传递, 作为加密盐计算摘要 public static final String appKey = &quot;wx3f2f5354f615c637&quot;; /** * 获取参数签名 * @param sortedMap * @return */ public static String getParamsSign(Map&lt;String, String&gt; sortedMap) &#123; //要先去掉 Url 里的 Sign sortedMap.remove(&quot;sign&quot;); sortedMap.put(&quot;appKey&quot;, appKey); String paramsJsonStr = GsonUtils.toJson(sortedMap); String md5 = DigestUtils.md5DigestAsHex(paramsJsonStr.getBytes()).toUpperCase(); log.info(&quot;加签参数: &#123;&#125;, MD5: &#123;&#125;&quot;, paramsJsonStr, md5); return md5; &#125; /** * 参数验签 * @param sortedMap 已排序参数 * @return 验证签名结果 */ public static boolean verifySign(Map&lt;String, String&gt; sortedMap) &#123; // 校验请求是否过期, 防止重放攻击 String inTimeStamp = sortedMap.getOrDefault(&quot;ts&quot;, &quot;0&quot;); LocalDateTime inTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(inTimeStamp)), ZoneOffset.ofHours(8)); Duration duration = Duration.between(inTime, LocalDateTime.now()); long seconds = duration.get(SECONDS); System.out.println(&quot;seconds: &quot; + seconds); if (seconds &gt; 60) &#123; System.out.println(&quot;请求超时&quot;); return Boolean.FALSE; &#125; String urlSign = Objects.nonNull(sortedMap.get(&quot;sign&quot;))?sortedMap.get(&quot;sign&quot;):null; log.info(&quot;传递签名: [&#123;&#125;]&quot;, urlSign); if (StringUtils.isBlank(urlSign)) &#123; return false; &#125; //把参数加密 String paramsSign = getParamsSign(sortedMap); log.info(&quot;计算签名: [&#123;&#125;]&quot;, paramsSign); return StringUtils.isNotBlank(paramsSign) &amp;&amp; urlSign.equals(paramsSign); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"验签","slug":"验签","permalink":"https://idea360.cn/tags/%E9%AA%8C%E7%AD%BE/"}]},{"title":"Spring数据脱敏","slug":"spring-data-masking","date":"2020-08-30T16:19:48.000Z","updated":"2021-02-23T14:44:15.386Z","comments":true,"path":"2020/08/31/spring-data-masking/","link":"","permalink":"https://idea360.cn/2020/08/31/spring-data-masking/","excerpt":"","text":"概述 所谓数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。在涉及客户安全数据或者一些商业性敏感数据的情况下，在不违反系统规则条件下，对真实数据进行改造并提供测试使用，如身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。 方案一 @JsonSerialize注解 123456789101112131415public class Test &#123; private String name; @JsonProperty(&quot;a&quot;) @JsonSerialize(converter = NameDesensitizeConverter.class) public String getName() &#123; return name; &#125;// @JsonProperty(&quot;b&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 转换类 12345678public class NameDesensitizeConverter extends StdConverter&lt;String, String&gt; &#123; @Override public String convert(String value) &#123; return &quot;***&quot;; &#125;&#125; controller 1234567891011@RestControllerpublic class TestController &#123; @GetMapping(&quot;/tm&quot;) public Object tm() &#123; Test test = new Test(); test.setName(&quot;张三&quot;); return test; &#125;&#125; 结果 12345// http://localhost:8080/tm&#123; &quot;a&quot;: &quot;***&quot;&#125; 方案二 Jackson序列化判断脱敏 脱敏类型枚举类 1234567891011121314151617181920212223242526272829303132333435public enum SensitiveType &#123; /** * 中文名 */ CHINESE_NAME, /** * 身份证号 */ ID_CARD, /** * 座机号 */ FIXED_PHONE, /** * 手机号 */ MOBILE_PHONE, /** * 地址 */ ADDRESS, /** * 电子邮件 */ EMAIL, /** * 银行卡 */ BANK_CARD, /** * 公司开户银行联号 */ CNAPS_CODE&#125; 脱敏注解类 1234567@Retention(RetentionPolicy.RUNTIME)@JacksonAnnotationsInside@JsonSerialize(using = SensitiveInfoSerialize.class)public @interface SensitiveInfo &#123; public SensitiveType value();&#125; entity实体 123456789101112131415161718192021import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Datapublic class UserDetail &#123; @ApiModelProperty(value = &quot;用户姓名&quot;) private String useName; @SensitiveInfo(SensitiveType.MOBILE_PHONE) @ApiModelProperty(value = &quot;用户手机号&quot;) private String mobile; @SensitiveInfo(SensitiveType.ID_CARD) @ApiModelProperty(value = &quot;用户身份证号&quot;) private String idCard;&#125; 脱敏序列化类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class SensitiveInfoSerialize extends JsonSerializer&lt;String&gt; implements ContextualSerializer &#123; private SensitiveType type; public SensitiveInfoSerialize() &#123; &#125; public SensitiveInfoSerialize(final SensitiveType type) &#123; this.type = type; &#125; @Override public void serialize(final String s, final JsonGenerator jsonGenerator, final SerializerProvider serializerProvider) throws IOException, JsonProcessingException &#123; switch (this.type) &#123; case CHINESE_NAME: &#123; jsonGenerator.writeString(SensitiveInfoUtils.chineseName(s)); break; &#125; case ID_CARD: &#123; jsonGenerator.writeString(SensitiveInfoUtils.idCardNum(s)); break; &#125; case FIXED_PHONE: &#123; jsonGenerator.writeString(SensitiveInfoUtils.fixedPhone(s)); break; &#125; case MOBILE_PHONE: &#123; jsonGenerator.writeString(SensitiveInfoUtils.mobilePhone(s)); break; &#125; case ADDRESS: &#123; jsonGenerator.writeString(SensitiveInfoUtils.address(s, 4)); break; &#125; case EMAIL: &#123; jsonGenerator.writeString(SensitiveInfoUtils.email(s)); break; &#125; case BANK_CARD: &#123; jsonGenerator.writeString(SensitiveInfoUtils.bankCard(s)); break; &#125; case CNAPS_CODE: &#123; jsonGenerator.writeString(SensitiveInfoUtils.cnapsCode(s)); break; &#125; &#125; &#125; @Override public JsonSerializer&lt;?&gt; createContextual(final SerializerProvider serializerProvider, final BeanProperty beanProperty) throws JsonMappingException &#123; if (beanProperty != null) &#123; // 为空直接跳过 if (Objects.equals(beanProperty.getType().getRawClass(), String.class)) &#123; // 非 String 类直接跳过 SensitiveInfo sensitiveInfo = beanProperty.getAnnotation(SensitiveInfo.class); if (sensitiveInfo == null) &#123; sensitiveInfo = beanProperty.getContextAnnotation(SensitiveInfo.class); &#125; if (sensitiveInfo != null) &#123; // 如果能得到注解，就将注解的 value 传入 SensitiveInfoSerialize return new SensitiveInfoSerialize(sensitiveInfo.value()); &#125; &#125; return serializerProvider.findValueSerializer(beanProperty.getType(), beanProperty); &#125; return serializerProvider.findNullValueSerializer(beanProperty); &#125;&#125; 脱敏处理工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.example.demojava.tm2;import org.apache.commons.lang3.StringUtils;public class SensitiveInfoUtils &#123; /** * [中文姓名] 只显示第一个汉字，其他隐藏为2个星号&lt;例子：李**&gt; */ public static String chineseName(final String fullName) &#123; if (StringUtils.isBlank(fullName)) &#123; return &quot;&quot;; &#125; final String name = StringUtils.left(fullName, 1); return StringUtils.rightPad(name, StringUtils.length(fullName), &quot;*&quot;); &#125; /** * [中文姓名] 只显示第一个汉字，其他隐藏为2个星号&lt;例子：李**&gt; */ public static String chineseName(final String familyName, final String givenName) &#123; if (StringUtils.isBlank(familyName) || StringUtils.isBlank(givenName)) &#123; return &quot;&quot;; &#125; return chineseName(familyName + givenName); &#125; /** * [身份证号] 显示最后四位，其他隐藏。共计18位或者15位。&lt;例子：*************5762&gt; */ public static String idCardNum(final String id) &#123; if (StringUtils.isBlank(id)) &#123; return &quot;&quot;; &#125; return StringUtils.left(id, 3).concat(StringUtils .removeStart(StringUtils.leftPad(StringUtils.right(id, 3), StringUtils.length(id), &quot;*&quot;), &quot;***&quot;)); &#125; /** * [固定电话] 后四位，其他隐藏&lt;例子：****1234&gt; */ public static String fixedPhone(final String num) &#123; if (StringUtils.isBlank(num)) &#123; return &quot;&quot;; &#125; return StringUtils.leftPad(StringUtils.right(num, 4), StringUtils.length(num), &quot;*&quot;); &#125; /** * [手机号码] 前三位，后四位，其他隐藏&lt;例子:138******1234&gt; */ public static String mobilePhone(final String num) &#123; if (StringUtils.isBlank(num)) &#123; return &quot;&quot;; &#125; return StringUtils.left(num, 2).concat(StringUtils .removeStart(StringUtils.leftPad(StringUtils.right(num, 2), StringUtils.length(num), &quot;*&quot;), &quot;***&quot;)); &#125; /** * [地址] 只显示到地区，不显示详细地址；我们要对个人信息增强保护&lt;例子：北京市海淀区****&gt; * * @param sensitiveSize 敏感信息长度 */ public static String address(final String address, final int sensitiveSize) &#123; if (StringUtils.isBlank(address)) &#123; return &quot;&quot;; &#125; final int length = StringUtils.length(address); return StringUtils.rightPad(StringUtils.left(address, length - sensitiveSize), length, &quot;*&quot;); &#125; /** * [电子邮箱] 邮箱前缀仅显示第一个字母，前缀其他隐藏，用星号代替，@及后面的地址显示&lt;例子:g**@163.com&gt; */ public static String email(final String email) &#123; if (StringUtils.isBlank(email)) &#123; return &quot;&quot;; &#125; final int index = StringUtils.indexOf(email, &quot;@&quot;); if (index &lt;= 1) &#123; return email; &#125; else &#123; return StringUtils.rightPad(StringUtils.left(email, 1), index, &quot;*&quot;) .concat(StringUtils.mid(email, index, StringUtils.length(email))); &#125; &#125; /** * [银行卡号] 前六位，后四位，其他用星号隐藏每位1个星号&lt;例子:6222600**********1234&gt; */ public static String bankCard(final String cardNum) &#123; if (StringUtils.isBlank(cardNum)) &#123; return &quot;&quot;; &#125; return StringUtils.left(cardNum, 6).concat(StringUtils.removeStart( StringUtils.leftPad(StringUtils.right(cardNum, 4), StringUtils.length(cardNum), &quot;*&quot;), &quot;******&quot;)); &#125; /** * [公司开户银行联号] 公司开户银行联行号,显示前两位，其他用星号隐藏，每位1个星号&lt;例子:12********&gt; */ public static String cnapsCode(final String code) &#123; if (StringUtils.isBlank(code)) &#123; return &quot;&quot;; &#125; return StringUtils.rightPad(StringUtils.left(code, 2), StringUtils.length(code), &quot;*&quot;); &#125;&#125; 测试 123456789101112131415@RestControllerpublic class TestController &#123; @GetMapping(&quot;/tm2&quot;) public Object tm() &#123; UserDetail u = new UserDetail(); u.setUseName(&quot;刘德华&quot;); u.setMobile(&quot;15135173514&quot;); u.setIdCard(&quot;110522199002027777&quot;); return u; &#125;&#125; 结果 1234567// http://localhost:8080/tm2&#123; &quot;useName&quot;: &quot;刘德华&quot;, &quot;mobile&quot;: &quot;15******14&quot;, &quot;idCard&quot;: &quot;110************777&quot;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"脱敏","slug":"脱敏","permalink":"https://idea360.cn/tags/%E8%84%B1%E6%95%8F/"}]},{"title":"MD5工具类","slug":"md5-utils","date":"2020-08-30T09:29:57.000Z","updated":"2021-02-23T14:38:27.337Z","comments":true,"path":"2020/08/30/md5-utils/","link":"","permalink":"https://idea360.cn/2020/08/30/md5-utils/","excerpt":"","text":"实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.idea360.demo.modules.sign;import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-08-30 */public class MD5Utils &#123; public static void main(String[] args) throws Exception&#123; String content = &quot;当我遇上你&quot;; // 方式1 System.out.println(org.springframework.util.DigestUtils.md5DigestAsHex(content.getBytes()).toUpperCase()); // B50E55687698915F9F70C7470DBA6E2F // 方式二 System.out.println(getMd5(content)); // 方式三 System.out.println(org.apache.commons.codec.digest.DigestUtils.md5Hex(content).toUpperCase()); &#125; public static String getMd5(String input) &#123; try &#123; // Static getInstance method is called with hashing MD5 MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); // digest() method is called to calculate message digest // of an input digest() return array of byte byte[] messageDigest = md.digest(input.getBytes()); // Convert byte array into signum representation BigInteger no = new BigInteger(1, messageDigest); // Convert message digest into hex value String hashtext = no.toString(16); while (hashtext.length() &lt; 32) &#123; hashtext = &quot;0&quot; + hashtext; &#125; return hashtext.toUpperCase(); &#125; // For specifying wrong message digest algorithms catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"md5","slug":"md5","permalink":"https://idea360.cn/tags/md5/"}]},{"title":"AES工具类","slug":"aes-utils","date":"2020-08-30T04:29:57.000Z","updated":"2021-02-23T14:11:08.803Z","comments":true,"path":"2020/08/30/aes-utils/","link":"","permalink":"https://idea360.cn/2020/08/30/aes-utils/","excerpt":"","text":"依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.13&lt;/version&gt;&lt;/dependency&gt; 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.idea360.idc;import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.Key;import java.security.SecureRandom;import java.util.UUID;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-08-30 */public class AESUtils &#123; // 加密算法有：AES，DES，DESede(DES3)和RSA 四种 private static final String KEY_ALGORITHM = &quot;AES&quot;; //参数分别代表 算法名称/加密模式/数据填充方式 private static final String DEFAULT_CIPHER_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;; /** * content: 加密内容 * slatKey: 加密的盐，16位字符串 * vectorKey: 加密的向量，16位字符串 */ public static String encrypt(String content, String slatKey, String vectorKey) throws Exception &#123; //实例化加密类，参数为加密方式，要写全 Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM); //两个参数，第一个为私钥字节数组， 第二个为加密方式 AES或者DES SecretKey secretKey = new SecretKeySpec(slatKey.getBytes(), KEY_ALGORITHM); // 偏移量 IvParameterSpec iv = new IvParameterSpec(vectorKey.getBytes()); //初始化，此方法可以采用三种方式，按加密算法要求来添加。 // （1）无第三个参数 // （2）第三个参数为SecureRandom random = new SecureRandom();中random对象，随机数。(AES不可采用这种方法) // （3）采用此代码中的IVParameterSpec cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv); //加密操作,返回加密后的字节数组，然后需要编码。主要编解码方式有Base64, HEX, UUE,7bit等等。此处看服务器需要什么编码方式 byte[] encrypted = cipher.doFinal(content.getBytes(StandardCharsets.UTF_8)); return new String(Base64.encodeBase64(encrypted)); &#125; /** * content: 解密内容(base64编码格式) * slatKey: 加密时使用的盐，16位字符串 * vectorKey: 加密时使用的向量，16位字符串 */ public static String decrypt(String base64Content, String slatKey, String vectorKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM); SecretKey secretKey = new SecretKeySpec(slatKey.getBytes(), KEY_ALGORITHM); IvParameterSpec iv = new IvParameterSpec(vectorKey.getBytes()); //与加密时不同MODE:Cipher.DECRYPT_MODE cipher.init(Cipher.DECRYPT_MODE, secretKey, iv); // 将字符串转化为base64编码的字节数组 // 将base64编码的字节数组转化为在加密之后的字节数组 byte[] content = Base64.decodeBase64(base64Content.getBytes()); byte[] encrypted = cipher.doFinal(content); return new String(encrypted, StandardCharsets.UTF_8); &#125; /** * 获取加密的密匙，传入的slatKey可以是任意长度的，作为SecureRandom的随机种子， * 而在KeyGenerator初始化时设置密匙的长度128bit(16位byte) */ private static Key getSlatKey(String slatKey) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;); SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); random.setSeed(slatKey.getBytes()); kgen.init(128, random); Key key = kgen.generateKey(); return key; &#125; public static String generateSalt() &#123; String pass = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).substring(0, 16); return pass; &#125; /** * 加密前：当我遇上你 * 加密后：Lv7B8Y4LnDX/zJp4RW8xXg== * 解密后：当我遇上你 * @param args * @throws Exception */ public static void main(String[] args) throws Exception&#123; String slatKey = generateSalt(); String vectorKey = generateSalt(); String content = &quot;当我遇上你&quot;; // 加密 System.out.println(&quot;加密前：&quot; + content); String encrypt = encrypt(content, slatKey, vectorKey); System.out.println(&quot;加密后：&quot; + encrypt); String decrypt = decrypt(encrypt, slatKey, vectorKey); System.out.println(&quot;解密后：&quot; + decrypt); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"AES","slug":"AES","permalink":"https://idea360.cn/tags/AES/"},{"name":"加密","slug":"加密","permalink":"https://idea360.cn/tags/%E5%8A%A0%E5%AF%86/"}]},{"title":"HttpServletRequest获取参数","slug":"request-utils","date":"2020-08-30T04:29:57.000Z","updated":"2021-02-23T14:39:58.238Z","comments":true,"path":"2020/08/30/request-utils/","link":"","permalink":"https://idea360.cn/2020/08/30/request-utils/","excerpt":"","text":"实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package cn.idea360.demo.modules.sign;import com.alibaba.fastjson.JSONObject;import org.springframework.http.HttpMethod;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.util.HashMap;import java.util.Map;import java.util.SortedMap;import java.util.TreeMap;import java.util.stream.Collectors;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-08-30 *//** * 接口参数提取 */public class RequestUtils &#123; /** * 将URL请求参数转换成Map * @author show * @param request */ public static Map&lt;String, String&gt; getUrlParams(HttpServletRequest request) &#123; String param = &quot;&quot;; if (Objects.isNull(request.getQueryString())) &#123; return Collections.EMPTY_MAP; &#125; try &#123; param = URLDecoder.decode(request.getQueryString(), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(16); String[] params = param.split(&quot;&amp;&quot;); for (String s : params) &#123; int index = s.indexOf(&quot;=&quot;); result.put(s.substring(0, index), s.substring(index + 1)); &#125; return result; &#125; public static Map&lt;String, String&gt; getFormParams(HttpServletRequest request) &#123; Map&lt;String, String&gt; paramMap = new HashMap&lt;String, String&gt;(); Map&lt;String, String[]&gt; requestMap = request.getParameterMap(); Iterator&lt;Map.Entry&lt;String, String[]&gt;&gt; it = requestMap.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String[]&gt; entry = it.next(); if(entry.getValue().length==1)&#123; paramMap.put(entry.getKey(), entry.getValue()[0]); &#125; else &#123; String[] values = entry.getValue(); String value = &quot;&quot;; for(int i=0; i&lt;values.length; i++)&#123; value = values[i] + &quot;,&quot;; &#125; value = value.substring(0, value.length()-1); paramMap.put(entry.getKey(), value); &#125; &#125; return paramMap; &#125; /** * 获取body中参数 * @param request * @return * @throws IOException */ public static Map&lt;String, String&gt; getBodyParams (HttpServletRequest request) throws IOException &#123; String body = request.getReader().lines().collect(Collectors.joining(System.lineSeparator())); //转化成json对象 Map&lt;String, String&gt; map = new Gson().fromJson(body, new TypeToken&lt;HashMap&lt;String, String&gt;&gt;() &#123;&#125;.getType()); return map; &#125; /** * 获取url参数和body参数 * @param request * @return * @throws IOException */ public static Map&lt;String, String&gt; getAllParams(HttpServletRequest request) throws IOException &#123; SortedMap&lt;String, String&gt; sortedParams = new TreeMap&lt;&gt;(); // 获取url参数 Map&lt;String, String&gt; urlParams = getUrlParams(request); for (Map.Entry entry : urlParams.entrySet()) &#123; sortedParams.put((String) entry.getKey(), (String) entry.getValue()); &#125; // 获取body参数 if (!HttpMethod.GET.name().equals(request.getMethod())) &#123; Map&lt;String, String&gt; bodyParams = getBodyParams(request); if (null != bodyParams) &#123; for (Map.Entry entry : bodyParams.entrySet()) &#123; sortedParams.put((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; &#125; // 获取表单参数 Map&lt;String, String&gt; formParams = getFormParams(request); for (Map.Entry entry : formParams.entrySet()) &#123; sortedParams.put((String) entry.getKey(), (String) entry.getValue()); &#125; return sortedParams; &#125; public static String obtainParameter(HttpServletRequest request, String parameter) &#123; String result = request.getParameter(parameter); return result == null ? &quot;&quot; : result; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.idea360.demo.modules.sign;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.util.Map;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-08-30 */@RestController@RequestMapping(&quot;/sign&quot;)public class SignController &#123; /** * http://localhost:7777/sign/getParamsMap?name=admin&amp;password=123&amp;sign=fP+QOzj05RVbVj54U9kA2T20eWQ= * @param request * @return &#123;password=123, name=admin, sign=fP QOzj05RVbVj54U9kA2T20eWQ=&#125; */ @GetMapping(&quot;/getParamsMap&quot;) public Object getParamsMap(HttpServletRequest request) throws IOException &#123; Map&lt;String, String&gt; urlParams = RequestUtils.getUrlParams(request); System.out.println(urlParams); return urlParams; &#125; /** * http://localhost:7777/sign/postBodyMap * @return &#123;password=123, name=admin, sign=fP+QOzj05RVbVj54U9kA2T20eWQ=&#125; */ @Sign @PostMapping(&quot;/postBodyMap&quot;) public Object postBodyMap(HttpServletRequest request) throws IOException &#123; Map&lt;String, String&gt; bodyParams = RequestUtils.getBodyParams(request); System.out.println(bodyParams); return bodyParams; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"http","slug":"http","permalink":"https://idea360.cn/tags/http/"}]},{"title":"RSA工具类","slug":"rsa-utils","date":"2020-08-30T04:29:47.000Z","updated":"2021-02-23T14:40:10.760Z","comments":true,"path":"2020/08/30/rsa-utils/","link":"","permalink":"https://idea360.cn/2020/08/30/rsa-utils/","excerpt":"","text":"实现 1234567891011121314151617181920212223242526272829303132/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-08-30 */public class RSAUtils &#123; /** * 根据slatKey获取公匙，传入的slatKey作为SecureRandom的随机种子 * 若使用new SecureRandom()创建公匙，则需要记录下私匙，解密时使用 */ private static byte[] getPublicKey(String slatKey) throws Exception &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); random.setSeed(slatKey.getBytes()); keyPairGenerator.initialize(1024, random);//or 2048 KeyPair keyPair = keyPairGenerator.generateKeyPair(); return keyPair.getPublic().getEncoded(); &#125; /** * 根据slatKey获取私匙，传入的slatKey作为SecureRandom的随机种子 */ private static byte[] getPrivateKey(String slatKey) throws Exception &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); random.setSeed(slatKey.getBytes()); keyPairGenerator.initialize(1024, random);// or 2048 KeyPair keyPair = keyPairGenerator.generateKeyPair(); return keyPair.getPrivate().getEncoded(); &#125;&#125;","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"加密","slug":"加密","permalink":"https://idea360.cn/tags/%E5%8A%A0%E5%AF%86/"},{"name":"rsa","slug":"rsa","permalink":"https://idea360.cn/tags/rsa/"}]},{"title":"HTTP401状态码返回","slug":"http-401","date":"2020-08-29T07:58:17.000Z","updated":"2021-02-23T14:20:21.538Z","comments":true,"path":"2020/08/29/http-401/","link":"","permalink":"https://idea360.cn/2020/08/29/http-401/","excerpt":"","text":"代码 12345678910111213HttpServletResponse response = (HttpServletResponse) servletResponse;response.setContentType(&quot;application/json;charset=UTF-8&quot;);response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);PrintWriter out = response.getWriter();Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();map.put(&quot;code&quot;,401);map.put(&quot;message&quot;,&quot;未登录&quot;);out.write(objectMapper.writeValueAsString(map));out.flush();out.close(); 返回结果 1234&#123; &quot;code&quot;: 401, &quot;message&quot;: &quot;未登录&quot;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"http","slug":"http","permalink":"https://idea360.cn/tags/http/"}]},{"title":"读取系统环境变量配置","slug":"config-sys-env","date":"2020-08-29T02:58:17.000Z","updated":"2021-02-23T14:11:58.003Z","comments":true,"path":"2020/08/29/config-sys-env/","link":"","permalink":"https://idea360.cn/2020/08/29/config-sys-env/","excerpt":"","text":"前言 公司的配置文件放在系统环境变量指定的位置，下边记录如何获取配置文件 实现1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.easyliao.jwt.conf.Conf;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;/** * 加载指定路径系统环境变量 */public class ConfigLoader &#123; private static ConfigLoader instance = null; private Properties globalConfigs = null; public static ConfigLoader getInstance() &#123; if (instance == null) &#123; instance = new ConfigLoader(); &#125; return instance; &#125; private ConfigLoader() &#123; this.init(); &#125; private void init() &#123; boolean hasConfig = this.checkHasConfig(System.getenv(Conf.SYS_ENV)); if (!hasConfig) &#123; throw new RuntimeException(&quot;没找到全局配置文件&quot;); &#125; &#125; private boolean checkHasConfig(String baseEnv) &#123; String defaultPath = baseEnv + File.separator + &quot;conf&quot; + File.separator; File file = new File(defaultPath); if (file.exists() &amp;&amp; file.isDirectory()) &#123; File conf = new File(defaultPath + Conf.DEFAULT_CONF_NAME); if (conf.exists() &amp;&amp; conf.isFile()) &#123; this.globalConfigs = new Properties(); try &#123; FileInputStream inputStream = new FileInputStream(conf); this.globalConfigs.load(inputStream); inputStream.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; else &#123; return false; &#125; &#125; public String getProperty(String key) &#123; return this.globalConfigs.getProperty(key, null); &#125;&#125; 12345678910111213public class Conf &#123; /** * 系统环境变量key */ public static final String SYS_ENV = &quot;IDEA360_HOME&quot;; /** * 默认配置文件名 */ public static final String DEFAULT_CONF_NAME = &quot;conf.properties&quot;;&#125; 实现2 12345678public class NlpKbProxyApplication &#123; public static void main(String[] args) &#123; SysConfig.configure(); SpringApplication.run(NlpKbProxyApplication.class, args); &#125;&#125; 将外部配置文件中的变量注入系统变量 1234567891011121314151617181920@Componentpublic class SysConfig &#123; private static final String EASYLIAO_HOME = &quot;EASYLIAO_HOME&quot;; private static final String FOLDER = &quot;conf&quot;; private static final String CONFIG_NAME = &quot;conf.properties&quot;; public static String NLP_SERVERS; public static void configure() &#123; Properties properties = new Properties(); try &#123; properties.load(new FileInputStream(new File(System.getenv(EASYLIAO_HOME) + File.separator + FOLDER + File.separator + CONFIG_NAME))); System.getProperties().putAll(properties); NLP_SERVERS = properties.getProperty(&quot;nlp.bootstrap.servers&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"环境变量","slug":"环境变量","permalink":"https://idea360.cn/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"JWT发放和验证TOKEN","slug":"jwt-token","date":"2020-08-29T02:58:17.000Z","updated":"2021-02-23T14:35:33.551Z","comments":true,"path":"2020/08/29/jwt-token/","link":"","permalink":"https://idea360.cn/2020/08/29/jwt-token/","excerpt":"","text":"前言 之前我们从研究官方文档去学习 jjwt 的使用, 本文做一个jwt的完整使用jar 实现 maven依赖 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 常量 12345678910111213141516171819202122public class Conf &#123; /** * 系统环境变量key */ public static final String SYS_ENV = &quot;IDEA360_HOME&quot;; /** * 默认配置文件名 */ public static final String DEFAULT_CONF_NAME = &quot;conf.properties&quot;; /** * 私钥约定配置文件key */ public static final String PRIVATEKEY_CONF = &quot;idea360.auth.jwt.privatekey&quot;; /** * 公钥约定配置文件key */ public static final String PUBLICKEY_CONF = &quot;idea360.auth.jwt.publicKey&quot;;&#125; 配置文件加载器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 加载指定路径系统环境变量 */public class ConfigLoader &#123; private static ConfigLoader instance = null; private Properties globalConfigs = null; public static ConfigLoader getInstance() &#123; if (instance == null) &#123; instance = new ConfigLoader(); &#125; return instance; &#125; private ConfigLoader() &#123; this.init(); &#125; private void init() &#123; boolean hasConfig = this.checkHasConfig(System.getenv(Conf.SYS_ENV)); if (!hasConfig) &#123; throw new RuntimeException(&quot;没找到全局配置文件&quot;); &#125; &#125; private boolean checkHasConfig(String baseEnv) &#123; String defaultPath = baseEnv + File.separator + &quot;conf&quot; + File.separator; File file = new File(defaultPath); if (file.exists() &amp;&amp; file.isDirectory()) &#123; File conf = new File(defaultPath + Conf.DEFAULT_CONF_NAME); if (conf.exists() &amp;&amp; conf.isFile()) &#123; this.globalConfigs = new Properties(); try &#123; FileInputStream inputStream = new FileInputStream(conf); this.globalConfigs.load(inputStream); inputStream.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; else &#123; return false; &#125; &#125; public String getProperty(String key) &#123; return this.globalConfigs.getProperty(key, null); &#125;&#125; 负载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class Payload implements Serializable &#123; /** * 公司id */ private Integer companyId; /** * 用户id */ private String userId; /** * appId */ private String appId; public Payload(Integer companyId, String userId, String appId) &#123; this.companyId = companyId; this.userId = userId; this.appId = appId; &#125; public Integer getCompanyId() &#123; return companyId; &#125; public void setCompanyId(Integer companyId) &#123; this.companyId = companyId; &#125; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getAppId() &#123; return appId; &#125; public void setAppId(String appId) &#123; this.appId = appId; &#125; @Override public String toString() &#123; return &quot;Payload&#123;&quot; + &quot;companyId=&quot; + companyId + &quot;, userId=&#x27;&quot; + userId + &#x27;\\&#x27;&#x27; + &quot;, appId=&#x27;&quot; + appId + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public static PayloadBuilder builder() &#123; return new PayloadBuilder(); &#125; public static class PayloadBuilder &#123; private Integer companyId; private String userId; private String appId; public PayloadBuilder() &#123; &#125; public PayloadBuilder setCompanyId(Integer companyId) &#123; this.companyId = companyId; return this; &#125; public PayloadBuilder setUserId(String userId) &#123; this.userId = userId; return this; &#125; public PayloadBuilder setAppId(String appId) &#123; this.appId = appId; return this; &#125; public Payload build() &#123; return new Payload(this.companyId, this.userId, this.appId); &#125; @Override public String toString() &#123; return &quot;PayloadBuilder&#123;&quot; + &quot;companyId=&quot; + companyId + &quot;, userId=&#x27;&quot; + userId + &#x27;\\&#x27;&#x27; + &quot;, appId=&#x27;&quot; + appId + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125;&#125; Token工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public class JwtGenerator &#123; private static Logger log = LoggerFactory.getLogger(JwtGenerator.class); // 默认2h token失效 private final Long DEFAULT_EXPIRE_TIME = 2L; // 私钥路径 private String privateKey; // 公钥路径 private String publicKey; public JwtGenerator() &#123; this.loadPrivateKey(); &#125; /** * 读取环境变量配置文件 */ private void loadPrivateKey() &#123; String privatekeyProperty = ConfigLoader.getInstance().getProperty(Conf.PRIVATEKEY_CONF); String publickeyProperty = ConfigLoader.getInstance().getProperty(Conf.PUBLICKEY_CONF);// if (Objects.isNull(privatekeyProperty)) &#123;// throw new NullPointerException(&quot;找不到私钥配置&quot; + Conf.PRIVATEKEY_CONF);// &#125;// if (Objects.isNull(publickeyProperty)) &#123;// throw new NullPointerException(&quot;找不到公钥配置&quot; + Conf.PUBLICKEY_CONF);// &#125; this.privateKey = privatekeyProperty; this.publicKey = publickeyProperty; &#125; /** * 生成token * @param payload * @return * @throws InvalidKeySpecException * @throws NoSuchAlgorithmException */ public String generateToken(Payload payload) throws InvalidKeySpecException, NoSuchAlgorithmException &#123; return this.generateToken(payload, DEFAULT_EXPIRE_TIME); &#125; /** * 生成token * @param payload token负载 * @param expire token有效期，单位: 分钟 * @return * @throws InvalidKeySpecException * @throws NoSuchAlgorithmException */ public String generateToken(Payload payload, Long expire) throws InvalidKeySpecException, NoSuchAlgorithmException &#123; if (Objects.isNull(payload.getCompanyId()) || Objects.isNull(payload.getUserId())) &#123; throw new NullPointerException(&quot;companyId和userId不能为空&quot;); &#125; if (Objects.isNull(privateKey) || &quot;&quot;.equals(privateKey)) &#123; throw new NullPointerException(&quot;请检查私钥配置是否正确: &quot; + Conf.PRIVATEKEY_CONF); &#125; String resourceKey = readResourceKey(privateKey); if (Objects.isNull(resourceKey)) &#123; throw new NullPointerException(&quot;请检查私钥文件是否正确&quot;); &#125; PrivateKey privateKey = getPrivateKey(resourceKey); expire = Objects.isNull(expire) || expire &lt;= 0L? DEFAULT_EXPIRE_TIME : expire; String token = Jwts.builder().setSubject(&quot;易聊科技&quot;) .setIssuer(&quot;易聊科技&quot;) .setIssuedAt(Date.from(Instant.now())) .setExpiration(Date.from(Instant.now().plus(expire, ChronoUnit.MINUTES))) .claim(&quot;companyId&quot;, payload.getCompanyId()) .claim(&quot;userId&quot;, payload.getUserId()) .claim(&quot;appId&quot;, payload.getAppId()) .signWith(SignatureAlgorithm.RS256, privateKey) .setId(UUID.randomUUID().toString()) .compact(); log.info(&quot;Generator Token: [&#123;&#125;]&quot;, token); return token; &#125; /** * token验证 * @param token * @return * @throws InvalidKeySpecException * @throws NoSuchAlgorithmException */ public Payload verifyToken(String token) throws InvalidKeySpecException, NoSuchAlgorithmException &#123; if (Objects.isNull(token) || &quot;&quot;.equals(token)) &#123; throw new NullPointerException(&quot;token不能为空&quot;); &#125; if (Objects.isNull(publicKey) || &quot;&quot;.equals(publicKey)) &#123; throw new NullPointerException(&quot;请检查公钥配置是否正确: &quot; + Conf.PUBLICKEY_CONF); &#125; String resourceKey = readResourceKey(publicKey); if (Objects.isNull(resourceKey)) &#123; throw new NullPointerException(&quot;请检查公钥文件是否正确&quot;); &#125; PublicKey publicKey = getPublicKey(resourceKey); try &#123; Jws&lt;Claims&gt; jws = Jwts.parser() .setSigningKey(publicKey) .parseClaimsJws(token); log.info(&quot;Header : [&#123;&#125;]&quot;, jws.getHeader()); log.info(&quot;Body : [&#123;&#125;]&quot;, jws.getBody()); log.info(&quot;Signature : [&#123;&#125;]&quot;, jws.getSignature()); Claims claims = jws.getBody(); String appId = claims.get(&quot;appId&quot;, String.class); String userId = claims.get(&quot;userId&quot;, String.class); Integer companyId = claims.get(&quot;companyId&quot;, Integer.class); return Payload.builder().setCompanyId(companyId).setUserId(userId).setAppId(appId).build(); &#125; catch (ExpiredJwtException | UnsupportedJwtException | MalformedJwtException | SignatureException | IllegalArgumentException e) &#123; log.error(&quot;token校验失败: &quot; + e); &#125; return null; &#125; /** * 生成私钥 * @param rsaPrivateKey * @return * @throws NoSuchAlgorithmException * @throws InvalidKeySpecException */ private PrivateKey getPrivateKey(String rsaPrivateKey) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; rsaPrivateKey = rsaPrivateKey.replace(&quot;-----BEGIN RSA PRIVATE KEY-----&quot;, &quot;&quot;); rsaPrivateKey = rsaPrivateKey.replace(&quot;-----END RSA PRIVATE KEY-----&quot;, &quot;&quot;); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(rsaPrivateKey)); KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;); return kf.generatePrivate(keySpec); &#125; /** * 生成公钥 * @param rsaPublicKey * @return * @throws NoSuchAlgorithmException * @throws InvalidKeySpecException */ private PublicKey getPublicKey(String rsaPublicKey) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; rsaPublicKey = rsaPublicKey.replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;); rsaPublicKey = rsaPublicKey.replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(rsaPublicKey)); KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;); return kf.generatePublic(keySpec); &#125; /** * 读取资源文件 * @param fileName * @return */ private String readResourceKey(String fileName) &#123; String key = null; try &#123; File file = new File(fileName); if (file.exists() &amp;&amp; file.isFile()) &#123; List&lt;String&gt; lines = FileUtils.readLines(file, Charset.defaultCharset()); lines = lines.subList(1, lines.size() - 1); key = String.join(&quot;&quot;, lines); &#125; &#125; catch (IOException e) &#123; log.error(&quot;读取私钥失败&quot;, e); &#125; return key; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"jwt","slug":"jwt","permalink":"https://idea360.cn/tags/jwt/"}]},{"title":"Cookie简单使用","slug":"cookie","date":"2020-08-27T08:58:17.000Z","updated":"2021-02-23T14:12:55.747Z","comments":true,"path":"2020/08/27/cookie/","link":"","permalink":"https://idea360.cn/2020/08/27/cookie/","excerpt":"","text":"概述 简单的不能再简单的使用 代码 12345678910111213141516171819202122public class CookieUtil &#123; public static String getCookie(HttpServletRequest request, String cookieName) &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(cookieName)) &#123; return cookie.getValue(); &#125; &#125; &#125; return null; &#125; public static void setCookie(HttpServletResponse response, String cookieName, String value,int maxAge) &#123; Cookie cookie = new Cookie(cookieName, value); cookie.setPath(&quot;/&quot;); cookie.setMaxAge(maxAge); response.addCookie(cookie); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"Cookie","slug":"Cookie","permalink":"https://idea360.cn/tags/Cookie/"}]},{"title":"JJWT","slug":"jjwt","date":"2020-08-26T10:24:25.000Z","updated":"2021-02-23T14:34:48.393Z","comments":true,"path":"2020/08/26/jjwt/","link":"","permalink":"https://idea360.cn/2020/08/26/jjwt/","excerpt":"","text":"概述 jjwt基本使用示例 读取公钥文件 123456789101112131415161718192021/** * 读取公钥 */@Testvoid pem() &#123; String resourceKey = readResourceKey(&quot;E:\\\\example\\\\spring-cloud-learning\\\\idc-sso\\\\public.pem&quot;); System.out.println(resourceKey);&#125;public String readResourceKey(String fileName) &#123; String key = null; try &#123; File file = new File(fileName); List&lt;String&gt; lines = FileUtils.readLines(file, Charset.defaultCharset()); lines = lines.subList(1, lines.size() - 1); key = lines.stream().collect(Collectors.joining()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return key;&#125; JKS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 参考：https://www.codeproject.com/Articles/1253786/Java-JWT-Token-Tutorial-using-JJWT-Library * * Create Java KeyStore： * * keytool -genkey -alias idea360 -keyalg RSA -keystore idea360.jks -keysize 2048 * 输入密钥库口令: * 再次输入新口令: * 您的名字与姓氏是什么? * [Unknown]: cui * 您的组织单位名称是什么? * [Unknown]: easyliao * 您的组织名称是什么? * [Unknown]: idea360 * 您所在的城市或区域名称是什么? * [Unknown]: bj * 您所在的省/市/自治区名称是什么? * [Unknown]: bj * 该单位的双字母国家/地区代码是什么? * [Unknown]: cn * CN=cui, OU=easyliao, O=idea360, L=bj, ST=bj, C=cn是否正确? * [否]: 是 * * Export the Public Key/Certificate: * * keytool -export -keystore idea360.jks -alias idea360 -file idea360.cer * * * @throws Exception */@Testvoid jks() throws Exception&#123; String jksPassword = &quot;abc123&quot;; KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); ks.load(new FileInputStream(&quot;E:\\\\example\\\\spring-cloud-learning\\\\idc-sso\\\\idea360.jks&quot;), jksPassword.toCharArray()); Key key = ks.getKey(&quot;idea360&quot;, jksPassword.toCharArray()); String encodedPublicKey = Base64.getEncoder().encodeToString(key.getEncoded()); System.out.println(&quot;jks:&quot;); System.out.println(encodedPublicKey);&#125;@Testvoid cer() throws Exception&#123; CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); Certificate cert = cf.generateCertificate(new FileInputStream(&quot;E:\\\\example\\\\spring-cloud-learning\\\\idc-sso\\\\idea360.cer&quot;)); PublicKey publicKey = cert.getPublicKey(); // 将公钥对象转为字符串 String encodedPublicKey = Base64.getEncoder().encodeToString(publicKey.getEncoded()); System.out.println(&quot;Public Key:&quot;); System.out.println(encodedPublicKey);&#125; PEM 生成私钥 PKCS1的文件头格式 -----BEGIN RSA PRIVATE KEY----- PKCS8的文件头格式 -----BEGIN PRIVATE KEY----- 生成RSA私钥, size 1024, 并输出到 private.pem 文件 12openssl genrsa -out rsa_private_key.pem 1024openssl pkcs8 -topk8 -inform PEM -outform PEM -in rsa_private_key.pem -out private.pem -nocrypt 私钥内容 12345678910111213141516-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAK1al6EzuB5AIbk3gXF4XQ9SJfqyRC/A935E7Kt48teEzwarorVO7oy4Hww6Meyu0mIgLgtTckCeE50u/S7G1ocCYwyUXoet2leEXMLgePsUnB75JjGGCgwl2e+GG1SaCmmrHBURd6tMzsJkdDTgE7yux8xQKk8TY+wCTaI+on1zAgMBAAECgYA11L7nOQdApYuTV3Ajy0uimVDf44GXDqYMGN0hdkJ6uGwNVzkEcklTe01w35VnOPZtsC58J+J/vFa85b2LTAWLjlDY/T3AulYDmT3ihPKIU401uRriMluIipyL7HNppxy2E85iRMfOiPnZgzF1EvCG36UudHfyEtPLRYz1Y4FnwQJBANY3wCaxffN+rv11o+lSU5Dca8dOjwZPI7vF5kILMkALwZffZkpRIPTAg22lT3PwVov93+PHTPHWAleBsas5ghMCQQDPKnB3gOkSNvPy5uw12GIGoQdB/IaezeDtivDjKTQLPoGgYgEembY/i+TO5QhDDAQ6w5uEpaVzO6Sw3phz04MhAkAGBi1WKTmkhlR/djZ00kbdVQWG5lOpVsJnfmo6QzxXhr0b+0FSJ7Pojh1kEPkKBqE4cJxCOJGWX3FTaqdHbGeXAkBhiMKQkOGqkLLDzpKxOyHTqyamm4Sp6ZYXYE3PNUvqa1BOOTX7uTTDsFJWUiBUqKipHgTvK6m8mf0MxJAUICXhAkEA1NOaPevOqoTLx+gdiIG2fNmaC/aT9tWr87jqigKkLNee2NEsDrWxaEAVJSQ0F5fpZtcqvvu75TyPm1Ca649LUw==-----END PRIVATE KEY----- 生成公钥 1openssl rsa -in rsa_private_key.pem -outform PEM -pubout -out public.pem 公钥内容 123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCtWpehM7geQCG5N4FxeF0PUiX6skQvwPd+ROyrePLXhM8Gq6K1Tu6MuB8MOjHsrtJiIC4LU3JAnhOdLv0uxtaHAmMMlF6HrdpXhFzC4Hj7FJwe+SYxhgoMJdnvhhtUmgppqxwVEXerTM7CZHQ04BO8rsfMUCpPE2PsAk2iPqJ9cwIDAQAB-----END PUBLIC KEY----- 示例一 maven依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; Java示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.idea360.idc;import io.jsonwebtoken.*;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.security.KeyPair;import java.security.PrivateKey;import java.security.PublicKey;import java.text.SimpleDateFormat;import java.util.Date;import java.util.UUID;import io.jsonwebtoken.security.Keys;@Slf4j@SpringBootTestclass IdcSsoApplicationTests &#123; /** * @author 当我遇上你 * @email idea360@foxmail.com * @公众号 当我遇上你 * * 参考 * https://github.com/jwtk/jjwt * https://www.viralpatel.net/java-create-validate-jwt-token/ * http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html * http://andaily.com/blog/?p=956 * * 日志 * 2020-08-26 18:32:30.863 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : token:[eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiLlvZPmiJHpgYfkuIrkvaAiLCJzdWIiOiJpZGVhMzYwIiwiYXVkIjoiYXBwIiwiaWF0IjoxNTk4NDM3OTUwLCJleHAiOjE1OTg0MzgwNzAsIm5iZiI6MTU5ODQzNzk1MCwidXNlcklkIjoiYWRtaW4iLCJjb21wYW55SWQiOjEsImp0aSI6ImFlZjJmOWY0LTVhMjYtNGI2ZS05YjRjLThjODE4MDMzYWVkNiJ9.Tpixe02lbHajDHoFvVMeSLneaQpDXgovu6K0CGzdLHZU5haS7k77WK6pKZ_LqAa3QOJ1ICFat3p5SDwtW22kmp0ATMLV33M96359ds6yD1nPPXs10Hurdzo83P1OmrMgzZXuskvc1w6EmfUw0vL6XSPdlGRQqgAhQerRUTJYlPvREoFH3G1AxZEhljpLkwfLX6VNpif3h4_4TKiEu9TMlP4Ol1Iou87nGqJA0YKIpvT2fAZDH4RjBqoi7BsRvmo6MYsmSkfpYy6cONVY_VhJ2HqLclEvWgZX_sNmTeGfgxNd0D_g7J3jduqTo0mkeO50_9gmmvF6w9yt_D10G1tFDw] * 2020-08-26 18:32:30.902 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : id:[aef2f9f4-5a26-4b6e-9b4c-8c818033aed6] * 2020-08-26 18:32:30.902 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : subject:[idea360] * 2020-08-26 18:32:30.902 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : userId:[admin] * 2020-08-26 18:32:30.902 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : companyId:[1] * 2020-08-26 18:32:30.902 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : 签发者:[当我遇上你] * 2020-08-26 18:32:30.902 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : 签发时间:[2020‐08‐26 18:32:30] * 2020-08-26 18:32:30.903 INFO 14272 --- [ main] cn.idea360.idc.IdcSsoApplicationTests : 过期时间:[2020‐08‐26 18:34:30] */ @Test void createJwt() &#123; // 非对称秘钥 KeyPair keyPair = Keys.keyPairFor(SignatureAlgorithm.RS256); //or RS384, RS512, PS256, PS384, PS512, ES256, ES384, ES512 PrivateKey privateKey = keyPair.getPrivate(); PublicKey publicKey = keyPair.getPublic(); String encodedPublicKey = Base64.getEncoder().encodeToString(publicKey.getEncoded()); String encodedPrivateKey = Base64.getEncoder().encodeToString(privateKey.getEncoded()); log.info(&quot;公钥:\\n &#123;&#125;&quot;, convertToPublicKey(encodedPublicKey)); log.info(&quot;私钥:\\n &#123;&#125;&quot;, convertToPrivateKey(encodedPrivateKey)); // 签名 String token = Jwts.builder() .setIssuer(&quot;当我遇上你&quot;) // jwt签发人 .setSubject(&quot;idea360&quot;) // 代表这个JWT的主体，即它的所有人，这个是一个json格式的字符串，可以存放什么userid，roldid之类的，作为什么用户的唯一标志。 .setAudience(&quot;app&quot;) // jwt的接受者 .setIssuedAt(new Date()) //jwt的签发时间 .signWith(privateKey) // 密钥 .setExpiration(new Date(System.currentTimeMillis() + 2 * 1000 * 60))// 设置过期时间 .setNotBefore(new Date()) //生效时间 .claim(&quot;userId&quot;, &quot;admin&quot;) // 自定义属性 .claim(&quot;companyId&quot;, 1) .setId(UUID.randomUUID().toString()) // 设置jti(JWT ID)：是JWT的唯一标识，根据业务需要，这个可以设置为一个不重复的值，主要用来作为一次性token,从而回避重放攻击。 .compact(); log.info(&quot;token:[&#123;&#125;]&quot;, token); // 验签 Jws&lt;Claims&gt; jws = null; try &#123; jws = Jwts.parserBuilder() .setSigningKey(publicKey) .build() .parseClaimsJws(token); // we can safely trust the JWT &#125;catch (JwtException ex) &#123; ex.printStackTrace(); // we *cannot* use the JWT as intended by its creator &#125; assert jws != null; Claims claims = jws.getBody(); log.info(&quot;id:[&#123;&#125;]&quot;, claims.getId()); log.info(&quot;subject:[&#123;&#125;]&quot;, claims.getSubject()); log.info(&quot;userId:[&#123;&#125;]&quot;, claims.get(&quot;userId&quot;)); log.info(&quot;companyId:[&#123;&#125;]&quot;, claims.get(&quot;companyId&quot;)); log.info(&quot;签发者:[&#123;&#125;]&quot;, claims.getIssuer()); SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy‐MM‐dd HH:mm:ss&quot;); log.info(&quot;签发时间:[&#123;&#125;]&quot;, sdf.format(claims.getIssuedAt())); log.info(&quot;过期时间:[&#123;&#125;]&quot;, sdf.format(claims.getExpiration())); &#125; // Add BEGIN and END comments private String convertToPublicKey(String key)&#123; StringBuilder result = new StringBuilder(); result.append(&quot;-----BEGIN PUBLIC KEY-----\\n&quot;); result.append(key); result.append(&quot;\\n-----END PUBLIC KEY-----&quot;); return result.toString(); &#125; // Add BEGIN and END comments private String convertToPrivateKey(String key)&#123; StringBuilder result = new StringBuilder(); result.append(&quot;-----BEGIN PRIVATE KEY-----\\n&quot;); result.append(key); result.append(&quot;\\n-----END PRIVATE KEY-----&quot;); return result.toString(); &#125;&#125; 示例二 maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; Java示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package cn.idea360.idc;import io.jsonwebtoken.*;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.security.*;import java.security.spec.InvalidKeySpecException;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.time.Instant;import java.time.temporal.ChronoUnit;import java.util.Base64;import java.util.Date;import java.util.UUID;@Slf4j@SpringBootTestclass IdcSsoApplicationTests &#123; /** * @author 当我遇上你 * @email idea360@foxmail.com * @公众号 当我遇上你 * Header : &#123;alg=RS256&#125; * Body : &#123;sub=adam, exp=1598447507, iss=info@wstutorial.com, groups=[user, admin]&#125; * Signature : FRRtPf6tTyr1FMYAA-vsmjSd58px1-staXWQlzwUOpeMxOn0o9vMAmcXkosvs7z-8oQ4ZlojdQkRwlm2QjGQGcU5l5dnlhYaaGhfAGUySvXL5YXcRwz5Amc9dGsA14G-JlD4b9zWo1euyKJN8g3nsZByx1a_w-iA_bLe81WCiMs * @throws NoSuchAlgorithmException */ @Test public void testJWTWithRsa() throws NoSuchAlgorithmException, InvalidKeySpecException &#123; KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); keyGenerator.initialize(1024); KeyPair kp = keyGenerator.genKeyPair(); PublicKey publicKey = kp.getPublic(); PrivateKey privateKey = kp.getPrivate(); // 将公钥对象转为字符串 String encodedPublicKey = Base64.getEncoder().encodeToString(publicKey.getEncoded()); System.out.println(&quot;Public Key:&quot;); System.out.println(convertToPublicKey(encodedPublicKey)); // 将私钥对象转为字符串 String encodedPrivateKey = Base64.getEncoder().encodeToString(privateKey.getEncoded()); System.out.println(&quot;Private Key:&quot;); System.out.println(convertToPrivateKey(encodedPrivateKey)); // 将字符串转为私钥对象 privateKey = getPrivateKey(encodedPrivateKey); // 获取token String token = generateJwtToken(privateKey); // 将字符串类型转为公钥对象 publicKey = getPublicKey(encodedPublicKey); // token解析 printStructure(token, publicKey); &#125; @SuppressWarnings(&quot;deprecation&quot;) public String generateJwtToken(PrivateKey privateKey) &#123; String token = Jwts.builder().setSubject(&quot;adam&quot;) .setIssuedAt(Date.from(Instant.now())) .setExpiration(Date.from(Instant.now().plus(5l, ChronoUnit.MINUTES))) .setIssuer(&quot;info@wstutorial.com&quot;) .claim(&quot;groups&quot;, new String[] &#123; &quot;user&quot;, &quot;admin&quot; &#125;) .signWith(SignatureAlgorithm.RS256, privateKey) // RS256 with privateKey .compact(); return token; &#125; //Print structure of JWT public void printStructure(String token, PublicKey publicKey) &#123; Jws parseClaimsJws = Jwts.parser() .setSigningKey(publicKey) .parseClaimsJws(token); System.out.println(&quot;Header : &quot; + parseClaimsJws.getHeader()); System.out.println(&quot;Body : &quot; + parseClaimsJws.getBody()); System.out.println(&quot;Signature : &quot; + parseClaimsJws.getSignature()); &#125; // Add BEGIN and END comments private String convertToPublicKey(String key)&#123; StringBuilder result = new StringBuilder(); result.append(&quot;-----BEGIN PUBLIC KEY-----\\n&quot;); result.append(key); result.append(&quot;\\n-----END PUBLIC KEY-----&quot;); return result.toString(); &#125; // Add BEGIN and END comments private String convertToPrivateKey(String key)&#123; StringBuilder result = new StringBuilder(); result.append(&quot;-----BEGIN PRIVATE KEY-----\\n&quot;); result.append(key); result.append(&quot;\\n-----END PRIVATE KEY-----&quot;); return result.toString(); &#125; // replace BEGIN and END comments private PrivateKey getPrivateKey(String rsaPrivateKey) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; rsaPrivateKey = rsaPrivateKey.replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;); rsaPrivateKey = rsaPrivateKey.replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(rsaPrivateKey)); KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;); PrivateKey privateKey = kf.generatePrivate(keySpec); return privateKey; &#125; // replace BEGIN and END comments private PublicKey getPublicKey(String rsaPublicKey) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; rsaPublicKey = rsaPublicKey.replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;); rsaPublicKey = rsaPublicKey.replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(rsaPublicKey)); KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;); PublicKey publicKey = kf.generatePublic(keySpec); return publicKey; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"jwt","slug":"jwt","permalink":"https://idea360.cn/tags/jwt/"}]},{"title":"SpringAOP失效问题","slug":"spring-aop-invalid","date":"2020-07-27T16:01:13.000Z","updated":"2021-02-23T14:41:26.806Z","comments":true,"path":"2020/07/28/spring-aop-invalid/","link":"","permalink":"https://idea360.cn/2020/07/28/spring-aop-invalid/","excerpt":"","text":"前言 有些时候我们会发现事务失效。其实事务也是基于AOP实现的，现在我们复现问题并解决。 AOP示例 原始的登录逻辑。逻辑很简单，当用户是admin时正常登录，如果非admin则非法登录。 123456789101112131415@Servicepublic class LoginService &#123; public void login(String userName) &#123; if (isAdmin(userName)) &#123; System.out.println(userName + &quot;正常登录&quot;); return; &#125; System.out.println(userName + &quot;非法登录&quot;); &#125; protected boolean isAdmin(String userName) &#123; return &quot;admin&quot;.equalsIgnoreCase(userName); &#125;&#125; 由于我们要在登录逻辑前后加入日志功能，所以我们需要编写一个环绕通知： 1234567891011121314@Aspect@Componentpublic class LoginAspect &#123; @Around(value = &quot;execution(* com.example.demojava.aop2.LoginService.login(..))&quot;) public Object loginAspect(ProceedingJoinPoint joinPoint) throws Throwable &#123; Object[] args = joinPoint.getArgs(); String userName = (String) args[0]; System.out.println(&quot;log:&quot; + userName + &quot;前置增强&quot;); Object proceed = joinPoint.proceed(); System.out.println(&quot;log:&quot; + userName + &quot;后置增强&quot;); return proceed; &#125;&#125; 接下来写个测试类看下效果 1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestclass LoginServiceTest &#123; @Autowired LoginService loginService; @Test void loginAdmin() &#123; loginService.login(&quot;admin&quot;); &#125; @Test void loginTest() &#123; loginService.login(&quot;test&quot;); &#125;&#125; 结果输出如下 123log:test前置增强test非法登录log:test后置增强 AOP失效情形 接下来假如我们又有了一个新需求，就是要对不合法用户做些特殊的处理，比如说统计下不合法用户调用登陆接口的次数。由于直接修改原有的登录逻辑有很多弊端，所以我们还是选择通过AOP来实现该功能。这可以通过编写一个返回增强来实现： 123456789@AfterReturning(value = &quot;execution(* com.example.demojava.aop2.LoginService.isAdmin(..))&quot;, returning = &quot;result&quot;)public void isAdminAspect(JoinPoint joinPoint, Object result) &#123; if (!(boolean)result) &#123; Object[] args = joinPoint.getArgs(); String userName = (String) args[0]; System.out.println(&quot;非法用户&quot; + userName + &quot;增强逻辑&quot;); &#125;&#125; 接下来我们还是用上一节的测试类来测试一下，我们直接看结果： 123log:test前置增强test非法登录log:test后置增强 AOP为何会失效 之所以会出现上述AOP失效的现象，归根到底是由于AOP的实现机制导致的。Spring AOP采用代理的方式实现AOP，我们编写的横切逻辑被添加到动态生成的代理对象中，只要我们调用的是代理对象，则可以保证调用的是被增强的代理方法。而在代理对象中，不管你的横切逻辑是怎样的，也不管你增加了多少层的横切逻辑，有一点可以确定的是，你终归会调用目标对象的同一方法来调用原始的业务逻辑。 如果目标对象中的原始方法依赖于其他对象，那么Spring会注入所依赖对象的代理对象，从而保证依赖的对象的横切逻辑能够被正常织入。而一旦目标对象调用的是自身的其他方法时，问题就来了，这种情况下，目标对象调用的并不是代理对象的方法，故被调用的方法无法织入横切逻辑。 如上图所示，method1和method2方法是同个类中的方法，当外部通过代理对象调用method1时，最终会调用目标对象的method1方法，而在目标对象的method1方法中调用method2方法时，最终调用的是目标对象的method2方法，而不是代理对象的method2方法，故而针对method2的AOP增强失效了。 如何避免AOP失效 方案一 要解决上述Spring AOP失效的问题，有两个方法，一个是将isAdmin方法跟login方法写在不同的类里，这样一来，当login方法调用isAdmin方法时，Spring会注入相应的代理对象，从而可以调用到isAdmin方法的代理逻辑。另一个方法是在调用isAdmin方法时先获取当前上下文的代理对象，再通过该代理对象调用被增强了的isAdmin方法，这样一来也能解决AOP失效的问题。实际上Spring AOP为我们提供了获取当前上下文代理对象的方法，使用起来非常方便，首先需要在AOP配置里暴露代理对象，在Spring Boot中可以通过注解@EnableAspectJAutoProxy(exposeProxy = true)进行配置： 123456789@EnableAspectJAutoProxy(exposeProxy = true)@SpringBootApplicationpublic class DemoJavaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoJavaApplication.class, args); &#125;&#125; 然后修改login方法，通过AopContext获取当前上下文代理对象，再通过该代理对象调用isAdmin方法： 1234567891011121314151617@Servicepublic class LoginService &#123; public void login(String userName) &#123; LoginService currentProxy = (LoginService) AopContext.currentProxy(); if (currentProxy.isAdmin(userName)) &#123; System.out.println(userName + &quot;正常登录&quot;); return; &#125; System.out.println(userName + &quot;非法登录&quot;); &#125; protected boolean isAdmin(String userName) &#123; return &quot;admin&quot;.equalsIgnoreCase(userName); &#125;&#125; 最后运行测试类看下效果 1234log:test前置增强非法用户test增强逻辑test非法登录log:test后置增强 这样就解决了上述AOP失效的问题。 方案二 springboot通过实现ApplicationContext获取代理对象 12345678910111213141516171819202122232425262728293031@Componentpublic class SpringContextUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringContextUtil.applicationContext = applicationContext; &#125; //获取applicationContext public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; //通过name获取 Bean. public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; //通过class获取Bean. public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; //通过name,以及Clazz返回指定的Bean public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125;&#125; 修改login方法 12345678910111213141516@Servicepublic class LoginService &#123; public void login(String userName) &#123; LoginService loginService = SpringContextUtil.getBean(this.getClass()); if (loginService.isAdmin(userName)) &#123; System.out.println(userName + &quot;正常登录&quot;); return; &#125; System.out.println(userName + &quot;非法登录&quot;); &#125; protected boolean isAdmin(String userName) &#123; return &quot;admin&quot;.equalsIgnoreCase(userName); &#125;&#125; 接下来我们再次测试以下 1234log:test前置增强非法用户test增强逻辑test非法登录log:test后置增强 可以看到问题已经解决了。 验证结果 以上我们猜想并解决了问题，下边来验证下对象的调用 1234567891011121314151617181920@Servicepublic class LoginService &#123; public void login(String userName) &#123; LoginService loginService = SpringContextUtil.getBean(this.getClass()); System.out.println(&quot;当前对象为&quot; + this.getClass().getName()); System.out.println(&quot;代理对象为&quot; + loginService.getClass().getName()); if (loginService.isAdmin(userName)) &#123; System.out.println(userName + &quot;正常登录&quot;); return; &#125; System.out.println(userName + &quot;非法登录&quot;); &#125; protected boolean isAdmin(String userName) &#123; return &quot;admin&quot;.equalsIgnoreCase(userName); &#125;&#125; 结果输出 123456log:test前置增强当前对象为com.example.demojava.aop2.LoginService代理对象为com.example.demojava.aop2.LoginService$$EnhancerBySpringCGLIB$$97517af5非法用户test增强逻辑test非法登录log:test后置增强 由日志可以看出失效调用时的this为target对象，而后边的调用为cglib生成的代理对象。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"aop","slug":"aop","permalink":"https://idea360.cn/tags/aop/"}]},{"title":"Java递归演示","slug":"java-recursion","date":"2020-07-24T08:11:19.000Z","updated":"2021-06-17T13:52:53.470Z","comments":true,"path":"2020/07/24/java-recursion/","link":"","permalink":"https://idea360.cn/2020/07/24/java-recursion/","excerpt":"","text":"父类包含子类型递归 子类 123456789101112@Datapublic class Rule &#123; private int ruleId; private String name; private int toId; public Rule(int ruleId, String name, int toId) &#123; this.ruleId = ruleId; this.name = name; this.toId = toId; &#125;&#125; 父类 1234567891011@Datapublic class Module &#123; private int id; private String name; private List&lt;Rule&gt; rules; public Module(int id, String name) &#123; this.id = id; this.name = name; &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; public static void main(String[] args) &#123; Module module1 = new Module(1, &quot;M1&quot;); Module module2 = new Module(2, &quot;M2&quot;); Module module3 = new Module(3, &quot;M3&quot;); Module module4 = new Module(4, &quot;M4&quot;); Module module5 = new Module(5, &quot;M5&quot;); Rule r1 = new Rule(11, &quot;R1&quot;, 2); Rule r2 = new Rule(12, &quot;R2&quot;, 3); Rule r3 = new Rule(13, &quot;R3&quot;, 4); Rule r4 = new Rule(14, &quot;R4&quot;, 5); module1.setRules(Arrays.asList(r1, r2)); module2.setRules(Arrays.asList(r3, r4)); List&lt;Module&gt; list = Arrays.asList(module1, module2, module3, module4, module5); List&lt;Integer&gt; ids = list.stream().map(module -&gt; module.getId()).collect(Collectors.toList()); Map&lt;Integer, Module&gt; moduleMap = list.stream().collect(Collectors.toMap(Module::getId, module -&gt; module)); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; integers = handleTree(module2, ids, moduleMap, result); System.out.println(integers); &#125; public static List&lt;Integer&gt; handleTree(Module target, List&lt;Integer&gt; moduleIdList, Map&lt;Integer, Module&gt; moduleMap, List&lt;Integer&gt; result) &#123; if (target != null) &#123; // 逻辑删除模块 System.out.println(&quot;删除模块&quot; + target.getId()); result.add(target.getId()); if (!CollectionUtils.isEmpty(target.getRules())) &#123; for (Rule rule:target.getRules()) &#123; // 逻辑删除连线 System.out.println(&quot;删除连线&quot; + rule.getRuleId()); if (rule.getToId() != 0 &amp;&amp; moduleIdList.contains(rule.getToId())) &#123; Module module = moduleMap.get(rule.getToId()); handleTree(module, moduleIdList, moduleMap, result); &#125; &#125; &#125; &#125; return result; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"递归","slug":"递归","permalink":"https://idea360.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"tree","slug":"tree","permalink":"https://idea360.cn/tags/tree/"},{"name":"树","slug":"树","permalink":"https://idea360.cn/tags/%E6%A0%91/"},{"name":"树结构","slug":"树结构","permalink":"https://idea360.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"}]},{"title":"springboot如何防止Long类型精度丢失","slug":"springboot-long-serializer","date":"2020-07-23T08:51:25.000Z","updated":"2021-02-23T14:46:46.112Z","comments":true,"path":"2020/07/23/springboot-long-serializer/","link":"","permalink":"https://idea360.cn/2020/07/23/springboot-long-serializer/","excerpt":"","text":"配置 12345678910111213141516@Configurationpublic class WebMvcAutoConfiguration &#123; @Bean @Primary public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) &#123; final JavaTimeModule module = new JavaTimeModule();// module.addSerializer(LocalDateTime.class, LocalDateTimeSerializer.INSTANCE);// module.addDeserializer(LocalDateTime.class, LocalDateTimeDeserializer.INSTANCE); module.addSerializer(Long.class, ToStringSerializer.instance); module.addSerializer(Long.TYPE, ToStringSerializer.instance); return builder.createXmlMapper(false).modulesToInstall(module).build(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"long","slug":"long","permalink":"https://idea360.cn/tags/long/"},{"name":"精度丢失","slug":"精度丢失","permalink":"https://idea360.cn/tags/%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/"}]},{"title":"雪花算法实战","slug":"id","date":"2020-07-23T08:39:25.000Z","updated":"2021-02-23T14:22:42.808Z","comments":true,"path":"2020/07/23/id/","link":"","permalink":"https://idea360.cn/2020/07/23/id/","excerpt":"","text":"算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public class SnowflakeDistributeId &#123; private long startTime = 1572537600000L; private final long clusterIdBits = 6L; private final long maxClusterId = 63L; private final long machineIdBits = 6L; private final long maxMachineId = 63L; private final long sameServiceBits = 1L; private final long maxServiceId = 1L; private final long sequenceBits = 9L; private final long sameServiceLeftShift = 9L; private final long machineIdLeftShift = 10L; private final long clusterIdLeftShift = 16L; private final long timestampLeftShift = 22L; private final long sequenceMask = 511L; private long lastTimestamp = -1L; private long clusterId; private long machineId; private long serviceId; private long sequence = 0L; public SnowflakeDistributeId(long clusterId, long machineId, long serviceId) &#123; Objects.requireNonNull(this); Object[] var10003; if (clusterId &lt;= 63L &amp;&amp; clusterId &gt;= 0L) &#123; Objects.requireNonNull(this); if (machineId &lt;= 63L &amp;&amp; machineId &gt;= 0L) &#123; Objects.requireNonNull(this); if (serviceId &lt;= 1L &amp;&amp; serviceId &gt;= 0L) &#123; this.clusterId = clusterId; this.machineId = machineId; this.serviceId = serviceId; &#125; else &#123; var10003 = new Object[1]; Objects.requireNonNull(this); var10003[0] = 1L; throw new IllegalArgumentException(String.format(&quot;serviceId can&#x27;t be greater than %d or less than 0&quot;, var10003)); &#125; &#125; else &#123; var10003 = new Object[1]; Objects.requireNonNull(this); var10003[0] = 63L; throw new IllegalArgumentException(String.format(&quot;machineId can&#x27;t be greater than %d or less than 0&quot;, var10003)); &#125; &#125; else &#123; var10003 = new Object[1]; Objects.requireNonNull(this); var10003[0] = 63L; throw new IllegalArgumentException(String.format(&quot;clusterId can&#x27;t be greater than %d or less than 0&quot;, var10003)); &#125; &#125; public synchronized long nextId() &#123; long timestamp = this.timeGen(); if (timestamp &lt; this.lastTimestamp) &#123; throw new RuntimeException(String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, this.lastTimestamp - timestamp)); &#125; else &#123; if (this.lastTimestamp == timestamp) &#123; this.sequence = this.sequence + 1L &amp; 511L; if (this.sequence == 0L) &#123; timestamp = this.tilNextMillis(this.lastTimestamp); &#125; &#125; else &#123; this.sequence = 0L; &#125; this.lastTimestamp = timestamp; long var10000 = timestamp - this.startTime &lt;&lt; 22; long var10001 = this.clusterId; Objects.requireNonNull(this); var10000 |= var10001 &lt;&lt; 16; var10001 = this.machineId; Objects.requireNonNull(this); var10000 |= var10001 &lt;&lt; 10; var10001 = this.serviceId; Objects.requireNonNull(this); return var10000 | var10001 &lt;&lt; 9 | this.sequence; &#125; &#125; public static long getMaxId(Date endTime) &#123; Calendar c = Calendar.getInstance(); c.setTime(endTime); c.set(14, 999); SnowflakeDistributeId d = new SnowflakeDistributeId(0L, 0L, 0L); long var10000 = c.getTimeInMillis() - d.startTime; Objects.requireNonNull(d); var10000 &lt;&lt;= 22; Objects.requireNonNull(d); long var10001 = ~(-1L &lt;&lt; 6); Objects.requireNonNull(d); var10000 |= var10001 &lt;&lt; 16; Objects.requireNonNull(d); var10001 = ~(-1L &lt;&lt; 6); Objects.requireNonNull(d); var10000 |= var10001 &lt;&lt; 10; Objects.requireNonNull(d); var10001 = ~(-1L &lt;&lt; 1); Objects.requireNonNull(d); var10000 |= var10001 &lt;&lt; 9; Objects.requireNonNull(d); return var10000 | 511L; &#125; public static long getMinId(Date startTime) &#123; SnowflakeDistributeId d = new SnowflakeDistributeId(0L, 0L, 0L); long var10000 = startTime.getTime() - d.startTime; Objects.requireNonNull(d); var10000 &lt;&lt;= 22; Objects.requireNonNull(d); var10000 |= (long)(0 &lt;&lt; 16); Objects.requireNonNull(d); var10000 |= (long)(0 &lt;&lt; 10); Objects.requireNonNull(d); return var10000 | (long)(0 &lt;&lt; 9) | 0L; &#125; protected long tilNextMillis(long lastTimestamp) &#123; long timestamp; for(timestamp = this.timeGen(); timestamp &lt;= lastTimestamp; timestamp = this.timeGen()) &#123; &#125; return timestamp; &#125; protected long timeGen() &#123; return System.currentTimeMillis(); &#125; public static synchronized void check(Set&lt;Long&gt; set, long s) &#123; if (set.contains(s)) &#123; System.err.println(s); &#125; else &#123; set.add(s); &#125; &#125; public static void main(String[] args) &#123; Calendar c = Calendar.getInstance(); c.set(11, 21); c.set(12, 24); c.set(13, 44); c.set(14, 0); System.out.println(c.getTimeInMillis()); System.out.println(System.currentTimeMillis()); long max = getMaxId(c.getTime()); long min = getMinId(c.getTime()); System.out.println(max); System.out.println(min); Calendar c2 = Calendar.getInstance(); c2.set(1, 2090); System.out.println(&quot;---&quot; + c2.getTimeInMillis()); &#125;&#125; 1234567891011121314151617181920212223242526272829public class GeneratedIDFactory &#123; private final ConcurrentHashMap&lt;String, SnowflakeDistributeId&gt; distributeIds = new ConcurrentHashMap(); private final long clusterId; private final long machineId; private final long serviceId; public GeneratedIDFactory(long clusterId, long machineId, long serviceId) &#123; this.clusterId = clusterId; this.machineId = machineId; this.serviceId = serviceId; &#125; private SnowflakeDistributeId getSnowflakeDistributeId(String type) &#123; SnowflakeDistributeId distributeId = (SnowflakeDistributeId)this.distributeIds.get(type); if (distributeId == null) &#123; distributeId = new SnowflakeDistributeId(this.clusterId, this.machineId, this.serviceId); SnowflakeDistributeId tmp = (SnowflakeDistributeId)this.distributeIds.putIfAbsent(type, distributeId); if (tmp != null) &#123; distributeId = tmp; &#125; &#125; return distributeId; &#125; public long generatId(String type) &#123; return this.getSnowflakeDistributeId(type).nextId(); &#125;&#125; 用法 12345678910@Beanpublic GeneratedIDFactory id() &#123; GeneratedIDFactory generatedIDFactory = new GeneratedIDFactory(1, 1, 1); return generatedIDFactory;&#125;@Autowiredprivate GeneratedIDFactory generatedIDFactory;generatedIDFactory.generatId(&quot;user&quot;)","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"算法， 雪花算法","slug":"算法，-雪花算法","permalink":"https://idea360.cn/tags/%E7%AE%97%E6%B3%95%EF%BC%8C-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"}]},{"title":"springmvc基本配置","slug":"spring-mvc","date":"2020-07-23T07:39:25.000Z","updated":"2021-02-23T14:45:15.947Z","comments":true,"path":"2020/07/23/spring-mvc/","link":"","permalink":"https://idea360.cn/2020/07/23/spring-mvc/","excerpt":"","text":"xml配置 全局环境变量 1234567&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:conf.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; bean扫描 1&lt;context:component-scan base-package=&quot;cn.idea360&quot; /&gt; 引入其他xml配置文件 1&lt;import resource=&quot;classpath*:weixin/spring-mybatis.xml&quot;/&gt; 读取配置文件 1&lt;context:property-placeholder location=&quot;classpath:conf.properties&quot;/&gt; servlet配置 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:application.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编码配置 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注解 12&lt;mvc:annotation-driven/&gt;&lt;context:annotation-config /&gt;","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"springmvc","slug":"springmvc","permalink":"https://idea360.cn/tags/springmvc/"}]},{"title":"Spring过滤器与拦截器","slug":"Spring-filter-and-intercepter","date":"2020-07-19T15:21:47.000Z","updated":"2021-03-20T09:39:42.176Z","comments":true,"path":"2020/07/19/Spring-filter-and-intercepter/","link":"","permalink":"https://idea360.cn/2020/07/19/Spring-filter-and-intercepter/","excerpt":"","text":"Spring过滤器 什么是过滤器 过滤器Filter，是在Servlet规范中定义的，是Servlet容器支持的，该接口定义在 javax.servlet包下，主要是在客户端请求(HttpServletRequest)进行预处理，以及对服务器响应(HttpServletResponse)进行后处理。接口代码如下: 123456789101112package javax.servlet;import java.io.IOException;public interface Filter &#123; void init(FilterConfig var1) throws ServletException; void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; void destroy();&#125; 对上面三个接口方法进行分析: init(FilterConfig): 初始化接口，在用户自定义的Filter初始化时被调用，它与Servlet的 init方法的作用是一样的。 doFilter(ServletRequest,ServletResponse,FilterChain): 在每个用户的请求进来时这个方法都会被调用，并在Servlet的service方法之前调用(如果我们是开发Servlet项目)，而FilterChain就代表当前的整个请求链，通过调用 FilterChain.doFilter可以将请求继续传递下去，如果想拦截这个请求，可以不调用FilterChain.doFilter，那么这个请求就直接返回了，所以Filter是一种责任链设计模式，在spring security就大量使用了过滤器，有一条过滤器链。 destroy: 当Filter对象被销毁时，这个方法被调用，注意，当Web容器调用这个方法之后，容器会再调用一次doFilter方法。 注解注入 首先我们需要创建一个类，让它实现 Filter 接口，然后重写接口中的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.demojava.filter;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Component@Order(1) // 过滤顺序，值越小越先执行@WebFilter(urlPatterns = &quot;/demoFilter&quot;, filterName = &quot;filterTest&quot;)public class Filter1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;filter初始化中...&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doFilter()开始执行：发往 &quot; + ((HttpServletRequest) servletRequest).getRequestURL().toString() + &quot; 的请求已被拦截&quot;); System.out.println(&quot;检验接口是否被调用，尝试获取contentType如下： &quot; + servletResponse.getContentType()); // filter的链式调用；将请求转给下一条过滤链 filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;检验接口是否被调用，尝试获取contentType如下： &quot; + servletResponse.getContentType()); System.out.println(&quot;doFilter()执行结束。&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;filter销毁中...&quot;); &#125;&#125; 当我们配置了多个 filter，且一个请求能够被多次拦截时，该请求将沿着 客户端 -&gt; 过滤器1 -&gt; 过滤器2 -&gt; servlet -&gt; 过滤器2 -&gt; 过滤器1 -&gt; 客户端 链式流转 123456789101112131415161718192021222324252627282930313233343536/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Component@Order(2) // 过滤顺序，值越小越先执行@WebFilter(urlPatterns = &quot;/demoFilter&quot;, filterName = &quot;filterTest2&quot;)public class Filter2 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;filter2初始化中...&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doFilter2()开始执行：发往 &quot; + ((HttpServletRequest) servletRequest).getRequestURL().toString() + &quot; 的请求已被拦截&quot;); System.out.println(&quot;检验接口是否被调用，尝试获取contentType如下： &quot; + servletResponse.getContentType()); // filter的链式调用；将请求转给下一条过滤链 filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;检验接口是否被调用，尝试获取contentType如下： &quot; + servletResponse.getContentType()); System.out.println(&quot;doFilter2()执行结束。&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;filter2销毁中...&quot;); &#125;&#125; 然后创建一个 Controller，对外提供两条请求路径： 12345678910111213141516@RestController@RequestMapping(&quot;demoFilter&quot;)public class FilterController &#123; @GetMapping(&quot;hello&quot;) public String hello() &#123; System.out.println(&quot;接口被调用：hello() &quot;); return &quot;hello filter&quot;; &#125; @GetMapping(&quot;hi&quot;) public String hi() &#123; System.out.println(&quot;接口被调用：hi()&quot;); return &quot;hi filter&quot;; &#125;&#125; 启动项目，可以看到我们的过滤器已经随着程序的启动被成功初始化了。 分别对这两个接口发送请求, 看到结果: 12345678910111213doFilter()开始执行：发往 http:&#x2F;&#x2F;localhost:8080&#x2F;demoFilter&#x2F;hi 的请求已被拦截检验接口是否被调用，尝试获取contentType如下： nulldoFilter2()开始执行：发往 http:&#x2F;&#x2F;localhost:8080&#x2F;demoFilter&#x2F;hi 的请求已被拦截检验接口是否被调用，尝试获取contentType如下： null接口被调用：hi()检验接口是否被调用，尝试获取contentType如下： text&#x2F;plain;charset&#x3D;UTF-8doFilter2()执行结束。检验接口是否被调用，尝试获取contentType如下： text&#x2F;plain;charset&#x3D;UTF-8doFilter()执行结束。 最后使项目停止运行，则过滤器随之销毁。 可以看出，当请求同时满足多个过滤器的过滤条件时，filterChain.doFilter() 会将其按一定顺序（可以通过 @Order 指定）依次传递到下一个 filter，直到进入 servlet 进行接口的实际调用。调用完成后，响应结果将沿着原路返回，并在再一次经过各个 filter 后，最终抵达客户端。 Bean注入 123456789101112131415@Beanpublic FilterRegistrationBean xxlSsoFilterRegistration() &#123; JwtTokenFilter tokenFilter = new JwtTokenFilter(); tokenFilter.setTokenStore(redisTokenStore); FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setName(&quot;tokenFilter&quot;); registration.setOrder(1); registration.addUrlPatterns(&quot;/*&quot;); registration.setFilter(tokenFilter); registration.addInitParameter(Constants.EXCLUDED_PATHS, &quot;&quot;); registration.addInitParameter(Constants.AUTH_SERVICE_URL, &quot;http://localhost:8080/&quot;); return registration;&#125; 或者 1234@Beanpublic Filter helloFilter() &#123; return new HelloFilter();&#125; 自动注入 12345678910@Order(10)@Componentpublic class HelloFilterRegistrationBean extends FilterRegistrationBean&lt;Filter&gt; &#123; @Override public Filter getFilter() &#123; return new HelloFilter(); &#125;&#125; 补充说明 通过过滤器拦截请求的方式，有一个问题，只能拿到 http 的请求和响应(request、response)，意味着只能在请求或者响应里获取一些参数； 但是当前请求到底是哪个控制器的哪个方法处理的，在filter里是无法获取的，因为实现的 Filter 这个接口是由javax(j2e)定义的， 而我们要拦截的控制器(Controller)中的请求是springmvc定义的，所以 Filter 是无法获取 spring 相关信息。 拦截器 什么是拦截器 拦截器是 AOP 的一种实现策略，用于在某个方法或字段被访问前对它进行拦截，然后在其之前或之后加上某些操作。同 filter 一样，interceptor 也是链式调用。每个 interceptor 的调用会依据它的声明顺序依次执行。一般来说拦截器可以用于以下方面 ： 日志记录 ：几率请求信息的日志，以便进行信息监控、信息统计等等 权限检查 ：对用户的访问权限，认证，或授权等进行检查 性能监控 ：通过拦截器在进入处理器前后分别记录开始时间和结束时间，从而得到请求的处理时间 通用行为 ：读取 cookie 得到用户信息并将用户对象放入请求头中，从而方便后续流程使用 拦截器的接口方法 在SpringMVC中，DispatcherServlet捕获每个请求，在到达对应的Controller之前，请求可以被拦截器处理，在拦截器中进行前置处理后，请求最终才到达Controller。 拦截器的接口是 org.springframework.web.servlet.HandlerInterceptor接口，接口代码如下: 123456789101112public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; 接口方法解读: preHandle方法：对客户端发过来的请求进行前置处理，如果方法返回true,继续执行后续操作，如果返回false，执行中断请求处理，请求不会发送到Controller postHandler方法：在请求进行处理后执行，也就是在Controller方法调用之后处理，当然前提是之前的 preHandle方法返回 true。具体来说，postHandler方法会在DispatcherServlet进行视图返回渲染前被调用，也就是说我们可以在这个方法中对 Controller 处理之后的ModelAndView对象进行操作 afterCompletion方法: 该方法在整个请求结束之后执行，当然前提依然是 preHandle方法的返回值为 true才行。该方法一般用于资源清理工作 如何实现一个自己的拦截器 同样，首先创建一个类，让它实现 HandlerInterceptor 接口，然后重写接口中的方法 ： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.demo.demofilter.demofilter.interceptor;import org.springframework.lang.Nullable;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Componentpublic class DemoInterceptor implements HandlerInterceptor &#123; // spring interceptor 单例，线程不安全，所以使用threadlocal private ThreadLocal&lt;Long&gt; timerThreadLocal = new ThreadLocal&lt;&gt;(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); timerThreadLocal.set(new Date().getTime()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); Long start = timerThreadLocal.get(); System.out.println(&quot;time interceptor 耗时:&quot;+ (new Date().getTime() - start)); timerThreadLocal.remove(); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; System.out.println(&quot;afterHandle&quot;); &#125;&#125;复制代码 紧接着需要对拦截器进行注册，指明使用哪个拦截器，及该拦截器对应拦截的 URL ： 12345678910111213141516171819202122package com.demo.demofilter.demofilter.interceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //&amp;emsp;如果有多个拦截器，继续registry.add往下添加就可以啦 registry.addInterceptor(new DemoInterceptor()).addPathPatterns(&quot;/demoInterceptor/**&quot;); &#125;&#125;复制代码 最后是 Controller 1234567891011121314151617181920212223package com.demo.demofilter.demofilter.interceptor;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;demoInterceptor&quot;)public class InterceptorController &#123; @GetMapping(&quot;hello&quot;) public String hello() &#123; System.out.println(&quot;接口被调用：hello() &quot;); return &quot;hello interceptor&quot;; &#125; @GetMapping(&quot;hi&quot;) public String hi() &#123; System.out.println(&quot;接口被调用：hi()&quot;); return &quot;hi interceptor&quot;; &#125;&#125;复制代码 运行结果如下 ： 1234preHandler接口被调用: hello()postHandlerafterHandler 其他注意事项 在 Http 的请求执行过程中，要经过以下几个步骤 ： 由 DispatcherServlet 捕获请求 DispatcherServlet 将接收到的 URL 和对应的 Controller 进行映射 在请求到达相应的 Controller 之前，由拦截器对请求进行处理 处理完成之后，进行视图的解析 返回视图 所以，只有经过 DispatcherServlet 的请求才会被拦截器捕获，而我们自定义的 Servlet 请求则不会被拦截的。 补充说明 interceptor 其实等价于将 filter doFilter() 方法中的 chain.doFilter(request, response) 分成两部分：preHandle() 、 postHandle() interceptor比 filter 的优势在于方法上多了另外一个参数，Object handler 该参数是用来处理当前 request 请求的控制器方法的声明； 意味着，你可以通过该参数获取当前控制器相关的信息，如控制器名称、请求的方法名。 过滤器与拦截器两者对比总结 过滤器是基于函数的回调，而拦截器是基于 Java 反射机制的 过滤器Filter依赖于Servlet容器。拦截器Interceptor依赖于框架容器，可以调用 IOC 容器中的各种依赖 拦截器可以 preHandle方法内返回 false 进行中断。过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面 过滤器只能在请求的前后使用，而拦截器可以详细到每个方法 tomcat容器中执行顺序: Filter -&gt; Servlet -&gt; Interceptor -&gt; Aspect -&gt; Controller -&gt; Aspect -&gt; Interceptor -&gt; Servlet -&gt; Filter 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"过滤器","slug":"过滤器","permalink":"https://idea360.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"拦截器","slug":"拦截器","permalink":"https://idea360.cn/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"Java自定义登录实现","slug":"login-customer","date":"2020-07-19T09:24:01.000Z","updated":"2021-02-23T14:37:52.486Z","comments":true,"path":"2020/07/19/login-customer/","link":"","permalink":"https://idea360.cn/2020/07/19/login-customer/","excerpt":"","text":"前言 Java现在已经是Spring的天下了。本文不用Security自定义实现简单登录。 基于AOP maven依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; AuthorizeAspect.java 除了login接口其他均需要认证 unauth接口黑名单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.idcmind.antslogin01.config;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Arrays;/** * @author ：当我遇上你 * @email ：idea360@foxmail.com * @公众号 当我遇上你 */@Aspect@Component@Slf4jpublic class AuthorizeAspect &#123; @Pointcut( &quot;execution(public * com.idcmind.antslogin01.controller.*.*(..))&quot; +&quot;&amp;&amp; !execution(public * com.idcmind.antslogin01.controller.BController.login(..))&quot; ) public void verify() &#123;&#125; @Before(&quot;verify()&quot;) public void doBefore(JoinPoint joinPoint)&#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 记录下请求内容 log.info(&quot;URL : &quot; + request.getRequestURL().toString()); log.info(&quot;HTTP_METHOD : &quot; + request.getMethod()); log.info(&quot;CLASS_NAME : &quot; + joinPoint.getSignature().getDeclaringTypeName()); log.info(&quot;METHOD_NAME : &quot; + joinPoint.getSignature().getName()); log.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs())); if (&quot;unauth&quot;.equalsIgnoreCase(joinPoint.getSignature().getName())) &#123; throw new RuntimeException(&quot;模拟未通过认证&quot;); &#125; &#125;&#125; 基于拦截器 AuthorizationInterceptor.java 123456789101112131415161718192021222324252627282930313233package com.idcmind.antslogin02.config;import org.springframework.stereotype.Component;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author ：当我遇上你 * @email ：idea360@foxmail.com * @公众号 当我遇上你 */@Componentpublic class AuthorizationInterceptor extends HandlerInterceptorAdapter &#123; public static final String USER_KEY = &quot;userId&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI = request.getRequestURI(); if (requestURI.equalsIgnoreCase(&quot;/test1&quot;)) &#123; return true; &#125; if (requestURI.equalsIgnoreCase(&quot;/test2&quot;)) &#123; throw new RuntimeException(&quot;模拟认证失败&quot;); &#125; return true; &#125;&#125; 配置拦截器 WebMvcConfig.java 123456789101112131415161718192021222324package com.idcmind.antslogin02.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @author ：当我遇上你 * @email ：idea360@foxmail.com * @公众号 当我遇上你 */@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private AuthorizationInterceptor authorizationInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(authorizationInterceptor).addPathPatterns(&quot;/**&quot;); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"登录","slug":"登录","permalink":"https://idea360.cn/tags/%E7%99%BB%E5%BD%95/"}]},{"title":"Spring之AOP的简单用法","slug":"aop","date":"2020-07-16T15:58:17.000Z","updated":"2020-07-27T16:02:34.242Z","comments":true,"path":"2020/07/16/aop/","link":"","permalink":"https://idea360.cn/2020/07/16/aop/","excerpt":"","text":"AOP原理 初始化AOP容器 读取配置文件或注解 解析配置文件，将配置文件转换成为AOP容器能够识别的数据结构Advisor，Advisor中包含了两个重要的数据结构。Advice：描述一个切面行为，即干什么；Pointcut：描述切面的位置，即在哪里 Spring将这个Advisor转换成自己能够识别的数据结构-AdvisorSupport，Spring动态的将这些方法植入到对应的方法中 生成动态代理类，使用jdk动态代理和cglib动态代理 提供调用，在使用的时候调用方调用的就是代理方法，也就是已经植入了增强方法的方法。 AOP使用 添加maven依赖 12345&lt;!-- 引入aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 执行顺序 创建注解 1234567@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Log &#123; String value() default &quot;&quot;;&#125; AOP切面处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 1. 执行顺序: * * Around Before * Before * aop目标方法体 * Around After * After * AfterReturning * * * 2. 异常顺序： * * Around Before * Before * aop目标方法体 * After * AfterThrowing * * 3. @within @target */@Aspect@Componentpublic class LogAspect &#123; @Pointcut(&quot;@annotation(com.example.demojava.aop.Log)&quot;) public void logPointCut() &#123; &#125; /** * 前置方法: 目标方法运行之前运行 */ @Before(value = &quot;logPointCut()&quot;) public void logBefore(JoinPoint point) &#123; System.out.println(&quot;Before&quot;); &#125; /** * 后置通知: 目标方法结束之后 */ @AfterReturning(value = &quot;logPointCut()&quot;) public void afterReturning(JoinPoint point) &#123; System.out.println(&quot;AfterReturning&quot;); &#125; /** * 返回通知: 方法正常执行并返回 */ @AfterThrowing(value = &quot;logPointCut()&quot;) public void afterThrowing(JoinPoint point) &#123; System.out.println(&quot;AfterThrowing&quot;); &#125; /** * 异常通知: 方法出现异常以后调用 */ @After(value = &quot;logPointCut()&quot;) public void after(JoinPoint point) &#123; System.out.println(&quot;After&quot;); &#125; /** * 环绕通知: 最强大的通知（这就是动态代理） */ @Around(value = &quot;logPointCut()&quot;) public void around(ProceedingJoinPoint point) throws Throwable &#123; System.out.println(&quot;Around Before&quot;); Object result = point.proceed(); System.out.println(&quot;Around After&quot;); &#125;&#125; 测试 1234567891011@RestControllerpublic class LogController &#123; @Log(value = &quot;测试aop&quot;) @GetMapping(&quot;/log&quot;) public void log() &#123;// System.out.println(&quot;aop目标方法体&quot;); throw new RuntimeException(&quot;&quot;); &#125;&#125; 系统日志 接案例一，这里做个完善 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * @author 当我遇上你 * @email idea360@foxmail.com * @公众号 当我遇上你 * @description */@Slf4j@Aspect@Componentpublic class SysLogAspect &#123; @Autowired private SysLogService sysLogService; @Autowired private TokenUtils tokenUtils; @Pointcut(&quot;@annotation(com.idcmind.idcboot.common.annotation.SysLog)&quot;) public void logPointCut() &#123; &#125; @Around(&quot;logPointCut()&quot;) public Object around(ProceedingJoinPoint point) throws Throwable &#123; long beginTime = System.currentTimeMillis(); //执行方法 Object result = point.proceed(); //执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; //保存日志 saveSysLog(point, time); return result; &#125; private void saveSysLog(ProceedingJoinPoint joinPoint, long time) &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLogEntity sysLog = new SysLogEntity(); SysLog syslog = method.getAnnotation(SysLog.class); if(syslog != null)&#123; //注解上的描述 sysLog.setOperation(syslog.value()); &#125; //请求的方法名 String className = joinPoint.getTarget().getClass().getName(); String methodName = signature.getName(); sysLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;); //请求的参数 Object[] args = joinPoint.getArgs(); try&#123; String params = new Gson().toJson(args); sysLog.setParams(params); &#125;catch (Exception e)&#123; &#125; //获取request ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //设置IP地址 sysLog.setIp(IPUtils.getIpAddr(request)); //用户名 String username = tokenUtils.getUsernameFromToken(); sysLog.setUsername(username); sysLog.setTime(time); sysLog.setCreateDate(new Date()); //保存系统日志 sysLogService.save(sysLog); // 日志 log.info(&quot;请求接口: [&#123;&#125;]&quot;, request.getRequestURL().toString()); log.info(&quot;请求方法: [&#123;&#125;]&quot;, request.getMethod()); log.info(&quot;访问ip: [&#123;&#125;]&quot;, request.getRemoteAddr()); log.info(&quot;类名: [&#123;&#125;]&quot;, className); log.info(&quot;方法名: [&#123;&#125;]&quot;, methodName); log.info(&quot;表单参数: [&#123;&#125;]&quot;, new Gson().toJson(request.getParameterMap())); log.info(&quot;请求体参数: [&#123;&#125;]&quot;, params); log.info(&quot;耗时: [&#123;&#125;ms]&quot;, endTime - startTime); log.info(&quot;响应: [&#123;&#125;]&quot;, new Gson().toJson(proceed)); log.info(&quot;\\r\\n&quot;); &#125;&#125; 简单认证 设置注解 123456789101112/** * @author 当我遇上你 * @email idea360@foxmail.com * @date 2019/1/21 17:16 * @description */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequiresPermissions &#123; String value() default &quot;&quot;;&#125; 权限过滤 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author 当我遇上你 * @email idea360@foxmail.com * @公众号 当我遇上你 * @description */@Aspect@Component@Slf4jpublic class AuthorizeAspect &#123; @Autowired private TokenUtils tokenUtils; @Autowired private SysUserService sysUserService; @Pointcut( &quot;execution(public * com.idcmind.idcboot.modules.sys.controller.*.*(..))&quot; + &quot;&amp;&amp; !execution(public * com.idcmind.idcboot.modules.sys.controller.SysLoginController.login(..))&quot; ) public void verify() &#123;&#125; @Before(&quot;verify()&quot;) public void doBefore(JoinPoint joinPoint)&#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 记录下请求内容 log.info(&quot;URL : &quot; + request.getRequestURL().toString()); log.info(&quot;HTTP_METHOD : &quot; + request.getMethod()); log.info(&quot;CLASS_NAME : &quot; + joinPoint.getSignature().getDeclaringTypeName()); log.info(&quot;METHOD_NAME : &quot; + joinPoint.getSignature().getName()); log.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs())); //认证 String token = tokenUtils.getToken(request); boolean validateToken = tokenUtils.validateToken(token); if(!validateToken)&#123; throw new ApiException(ApiErrorCode.AUTH_ERR); &#125; //授权 MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); RequiresPermissions permissions = method.getAnnotation(RequiresPermissions.class); if (permissions == null) &#123; return; &#125; String value = permissions.value(); if (StringUtils.isNotEmpty(value)) &#123; Set&lt;String&gt; perms = sysUserService.getUserPermissions(tokenUtils.getUserFromToken(token).getUserId()); if (!perms.contains(value)) &#123; throw new ApiException(ApiErrorCode.AUTH_ERR); &#125; &#125; &#125;&#125; SpringMVC配置 application.xml配置 12345678&lt;!-- 命名空间 --&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd&lt;mvc:annotation-driven/&gt;&lt;!-- aop 注解实现 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; Non-Web配置 application.xml配置 1234&lt;!-- 命名空间 --&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"aop","slug":"aop","permalink":"https://idea360.cn/tags/aop/"}]},{"title":"Spring之logback日志配置","slug":"logback-spring","date":"2020-07-11T03:38:34.000Z","updated":"2021-02-23T14:37:36.603Z","comments":true,"path":"2020/07/11/logback-spring/","link":"","permalink":"https://idea360.cn/2020/07/11/logback-spring/","excerpt":"","text":"前言 日志在线上运维是重要的一环, 它会帮我们重现问题场景, 排除bug, 所以日志的配置在开发中是重中之重。 环境 springboot logback SpringBoot配置 配置日志输出路径 logback-spring.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;configuration&gt; &lt;contextName&gt;idea360-logs&lt;/contextName&gt; &lt;property name=&quot;pattern&quot; value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg %n&quot;/&gt; &lt;property name=&quot;pattern-color&quot; value=&quot;%yellow(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;) [%thread] %highlight(%-5level) %green(%logger&#123;50&#125;) - %highlight(%msg) %n&quot;/&gt; &lt;!-- 相对路径 --&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;logs&quot;/&gt; &lt;!-- 绝对路径 --&gt; &lt;!--&lt;property name=&quot;LOG_HOME&quot; value=&quot;/home/logs/xxx&quot;/&gt;--&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 控制台输出-带颜色 --&gt; &lt;appender name=&quot;CONSOLE-WITH-COLOR&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;$&#123;pattern-color&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件输出, 只匹配debug级别的日志 --&gt; &lt;appender name=&quot;DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt; %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n &lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/ai5.debug.%d.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件输出, 只匹配info级别的日志 --&gt; &lt;appender name=&quot;INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt; %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n &lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/ai5.info.%d.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件输出, 只匹配error级别的日志 --&gt; &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt; %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n &lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/ai5.error.%d.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE-WITH-COLOR&quot;/&gt; &lt;appender-ref ref=&quot;DEBUG&quot;/&gt; &lt;appender-ref ref=&quot;INFO&quot;/&gt; &lt;appender-ref ref=&quot;ERROR&quot;/&gt; &lt;/root&gt;&lt;!-- &lt;logger name=&quot;cn.idea360.com&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;--&gt;&lt;!-- &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;&lt;!-- &lt;/logger&gt;--&gt;&lt;/configuration&gt; 配置控制台日志输出等级 123logging: level: root: info SpringMVC配置 maven 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt; &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt; &lt;version&gt;0.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; web.xml 1234567&lt;context-param&gt; &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:logback-spring.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;ch.qos.logback.ext.spring.web.LogbackConfigListener&lt;/listener-class&gt;&lt;/listener&gt; Non-Web配置 非web项目没有web.xml配置，所以需要把日志配置加在启动参数上。 启动参数 1-Dlogback.configurationFile&#x3D;conf&#x2F;logback.xml 全局异常 以上日志当出现异常时无法输出堆栈信息到error.log中, 可以按如下配置 12345678910111213141516171819202122232425262728@RestControllerAdvice@Slf4jpublic class ApiExceptionHandler &#123; @ExceptionHandler(Throwable.class) @ResponseBody public R handleException(Throwable e) &#123; log.error(getStackTrace(e)); return R.failed(e.getMessage()); &#125; /** * 获取堆栈信息 * @param throwable * @return */ private String getStackTrace(Throwable throwable) &#123; StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); try &#123; throwable.printStackTrace(pw); return &quot;\\n&quot;+sw.toString(); &#125; finally &#123; pw.close(); &#125; &#125;&#125; 最后 本文到此结束，感谢阅读。祝大家工作愉快。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"log","slug":"log","permalink":"https://idea360.cn/tags/log/"},{"name":"日志","slug":"日志","permalink":"https://idea360.cn/tags/%E6%97%A5%E5%BF%97/"},{"name":"logback","slug":"logback","permalink":"https://idea360.cn/tags/logback/"}]},{"title":"正则表达式","slug":"regular-expression","date":"2020-07-09T15:25:31.000Z","updated":"2021-02-23T14:39:44.916Z","comments":true,"path":"2020/07/09/regular-expression/","link":"","permalink":"https://idea360.cn/2020/07/09/regular-expression/","excerpt":"","text":"概述 正则表达式是比较常见的格式校验方式。然而语法经常记不住, 这里做下笔记, 记录常用的正则表达式的用法。 案例 案例很简单, 无需过多文案, 直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-07-09 */@Slf4jpublic class RegExpTest &#123; /** * 结果 * * 00:12:06.852 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^1234$], content=[1234], result=[true] * 00:12:06.860 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^1234|5678$], content=[1234], result=[true] * 00:12:06.861 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^123[0-9]$], content=[1234], result=[true] * 00:12:06.862 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^123\\d$], content=[1234], result=[true] * 00:12:06.862 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^123\\d+$], content=[123456789], result=[true] * 00:12:06.862 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^123\\d*$], content=[123], result=[true] * 00:12:06.862 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^123], content=[1235], result=[false] * 00:12:06.862 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[123$], content=[4123], result=[false] * 00:12:06.862 [main] INFO cn.idea360.demo.modules.regular.RegExpTest - 正则表达式: regex=[^123\\d&#123;5&#125;], content=[12345678], result=[true] */ public static void main(String[] args) &#123; // &quot;^&quot; 匹配字符串的开头, &quot;$&quot; 匹配字符串的结尾, 所以本表达式严格匹配 1234 String regex = &quot;^1234$&quot;; String content = &quot;1234&quot;; boolean matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // &quot;|&quot; 是或的意思, 表示匹配 1234 或 5678 regex = &quot;^1234|5678$&quot;; content = &quot;1234&quot;; matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // &quot;[]&quot; 表示匹配其中的任意一个字符, 其中 &quot;-&quot; 表示一个区间, 即 0 到 9, 它等于 [0123456789], 也就是说它会匹配 1230, 31, 1232, ..., 1239 regex = &quot;^123[0-9]$&quot;; content = &quot;1234&quot;; matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // 同上, \\d 等于 [0-9] regex = &quot;^123\\\\d$&quot;; content = &quot;1234&quot;; matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // &quot;+&quot; 号匹配一个或多个它前面的字符, 这里, 由于 &quot;+&quot; 前面是 &quot;\\d&quot;, 所以它就等于1个或多个数字, 实际上它匹配任意以 123 开头的至少4位数的数字串, 如 1230, 12300, 12311, 23456789等 regex = &quot;^123\\\\d+$&quot;; content = &quot;123456789&quot;; matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // &quot;*&quot; 号与 &quot;+&quot; 号的不同在于, 它匹配0个或多个前面的字符, 所以, 它匹配以 123 开头的至少3位数的数字串, 如 123, 123789 regex = &quot;^123\\\\d*$&quot;; content = &quot;123&quot;; matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // 跟上面一样, 由于没有结尾的 &quot;$&quot;, 它匹配任意以 123 开头的数字串, 但除此之外, 它还匹配后面是字母的情况, 如123abc。(实测false, 不知道为啥) regex = &quot;^123&quot;; content = &quot;1235&quot;; matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // 匹配任何以 123 结尾的字符串(实测false, 不知道为啥) regex = &quot;123$&quot;; content = &quot;4123&quot;; matches = content.matches(regex); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); // &#123;5&#125; 表示精确匹配5位, 包含它前面的一个字符。在这里, 它匹配以 123 开头的所有8位的电话号码 regex = &quot;^123\\\\d&#123;5&#125;&quot;; content = &quot;12345678&quot;; matches = Pattern.matches(regex, content); log.info(&quot;正则表达式: regex=[&#123;&#125;], content=[&#123;&#125;], result=[&#123;&#125;]&quot;, regex, content, matches); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"正则","slug":"正则","permalink":"https://idea360.cn/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"DbSchema激活","slug":"dbschema-register","date":"2020-07-01T14:43:27.000Z","updated":"2021-02-23T14:13:42.739Z","comments":true,"path":"2020/07/01/dbschema-register/","link":"","permalink":"https://idea360.cn/2020/07/01/dbschema-register/","excerpt":"","text":"激活方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-07-01 */public class DbSchemaKeyGenerator &#123; public static void main(String[] args) &#123; String name = &quot;cuishiying&quot;; try &#123; String key = generateKey(name); System.out.println(&quot;key: &quot; + key); &#125; catch (NoSuchAlgorithmException | UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; private static String generateKey(String name) throws NoSuchAlgorithmException, UnsupportedEncodingException &#123; String salt = getSalt(); String encryptSource = &quot;ax5&quot; + name + &quot;b52w&quot; + salt + &quot;vb3&quot;; MessageDigest localMessageDigest = MessageDigest.getInstance(&quot;MD5&quot;); String hash = formatToHex(localMessageDigest.digest(encryptSource.getBytes(&quot;UTF-8&quot;))); return hash.substring(0, 4) + salt + hash.substring(4); &#125; private static String formatToHex(byte[] paramArrayOfByte) &#123; StringBuilder localStringBuilder = new StringBuilder(); for (int m = 0; m &lt; paramArrayOfByte.length; m++) &#123; if ((m % 32 == 0) &amp;&amp; (m != 0)) &#123; localStringBuilder.append(&quot;\\n&quot;); &#125; String str = Integer.toHexString(paramArrayOfByte[m]); if (str.length() &lt; 2) &#123; str = &quot;0&quot; + str; &#125; if (str.length() &gt; 2) &#123; str = str.substring(str.length() - 2); &#125; localStringBuilder.append(str); &#125; return localStringBuilder.toString(); &#125; private static int random(int min, int max) &#123; return rand() % (max - min + 1) + min; &#125; private static int rand() &#123; return new Random().nextInt(Integer.MAX_VALUE); &#125; private static String getSalt() &#123; int r = random(10000, 30000); return String.valueOf(r); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"激活","slug":"激活","permalink":"https://idea360.cn/tags/%E6%BF%80%E6%B4%BB/"},{"name":"DbSchema","slug":"DbSchema","permalink":"https://idea360.cn/tags/DbSchema/"}]},{"title":"CSS列表样式实例","slug":"css-list","date":"2020-06-14T11:45:20.000Z","updated":"2021-02-23T14:13:04.572Z","comments":true,"path":"2020/06/14/css-list/","link":"","permalink":"https://idea360.cn/2020/06/14/css-list/","excerpt":"","text":"前言 后端开发也有着前端的需求。闲话不多说, 上菜。以下模板都是源自各个网站扒下来的, 仅供学习。 图文混排(微信版) 该模板为卡片式图文混排模板。","categories":[{"name":"css","slug":"css","permalink":"https://idea360.cn/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://idea360.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://idea360.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"设计模式-建造者模式","slug":"design-patterns-builder","date":"2020-06-13T12:09:09.000Z","updated":"2021-02-23T14:14:25.737Z","comments":true,"path":"2020/06/13/design-patterns-builder/","link":"","permalink":"https://idea360.cn/2020/06/13/design-patterns-builder/","excerpt":"","text":"概述 建造者模式(Builder Pattern)，将一个复杂对象的构建与它的表示分离。 应用场景 建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 在 Android 和 Netty-protobuf 中对象的创建使用了大量的建造者模式 实现 这里模拟任务的创建, 任务的创建需要任务数据、任务策略、缓存策略等. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-13 */@Slf4jpublic class Task implements Runnable &#123; private CacheService cacheService; private StrategyService strategyService; private RepositoryService repositoryService; private Task(CacheService cacheService, StrategyService strategyService, RepositoryService repositoryService) &#123; this.cacheService = cacheService; this.strategyService = strategyService; this.repositoryService = repositoryService; &#125; @Override public void run() &#123; log.info(&quot;task is running...&quot;); &#125; public static Builder builder() &#123; return new Task.Builder(); &#125; public static class Builder &#123; private CacheService cacheService; private StrategyService strategyService; private RepositoryService repositoryService; public Builder() &#123; &#125; public Builder setCacheService(CacheService cacheService) &#123; this.cacheService = cacheService; return this; &#125; public Builder setStrategyService(StrategyService strategyService) &#123; this.strategyService = strategyService; return this; &#125; public Builder setRepositoryService(RepositoryService repositoryService) &#123; this.repositoryService = repositoryService; return this; &#125; public Task build() &#123; return new Task(cacheService, strategyService, repositoryService); &#125; &#125; public static void main(String[] args) &#123; CacheService cacheService = new CacheService(); StrategyService strategyService = new StrategyService(); RepositoryService repositoryService = new RepositoryService(); Task task = Task.builder() .setCacheService(cacheService) .setStrategyService(strategyService) .setRepositoryService(repositoryService) .build(); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"建造者模式","slug":"建造者模式","permalink":"https://idea360.cn/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"Http参数签名","slug":"http-params-sign","date":"2020-06-13T11:29:47.000Z","updated":"2021-02-23T14:20:34.406Z","comments":true,"path":"2020/06/13/http-params-sign/","link":"","permalink":"https://idea360.cn/2020/06/13/http-params-sign/","excerpt":"","text":"前言 Http接口传输有很多加密方式, 如 AES 对称加密, RSA 非对称加密, 参数验签等, 下文主要简单示例参数如何验签。 原理 将 GET 参数和 appkey 通过如 MD5 之类的算法生成一个唯一不可逆的参数 sign, 参数传递的同时传递签名参数 sign。HTTP接收参数后根据自己持有的 appkey 和 appsecret 再次计算, 比对是否和传递的 sign 相同。 注意：appKey并不在http中传输，是计算摘要的密码盐 简单实现 maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.12&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 * * 参数验签 * * 现没有统一的签名机制，无需按业务区分。采用唯一的appKey和appSecret */public class SignUtils &#123; private static final Logger logger = LoggerFactory.getLogger(SignUtils.class); public static final String appKey = &quot;idea360&quot;; public static final String appSecret = &quot;123456&quot;; /** * 获取签名参数 * @param params * @return */ public static String getSignData(Map&lt;String, String&gt; params) &#123; StringBuilder content = new StringBuilder(); // key 自然排序 List&lt;String&gt; keys = new ArrayList&lt;&gt;(params.keySet()); Collections.sort(keys); for (int i = 0; i &lt; keys.size(); i++) &#123; String key = keys.get(i); if (&quot;sign&quot;.equals(key)) &#123; continue; &#125; String value = params.get(key); if (value != null) &#123; content.append(i == 0 ? &quot;&quot; : &quot;&amp;&quot;).append(key).append(&quot;=&quot;).append(value); &#125; else &#123; content.append(i == 0 ? &quot;&quot; : &quot;&amp;&quot;).append(key).append(&quot;=&quot;); &#125; &#125; return content.toString(); &#125; /** * 参数签名 * @param params */ public static String sign(Map&lt;String, String&gt; params) &#123; String outSignData = getSignData(params); logger.info(&quot;outSignData:&#123;&#125;&quot;, outSignData); byte[] hmac = new HmacUtils(HmacAlgorithms.HMAC_SHA_1, appSecret).hmac(outSignData); String sign = new String(Base64.encodeBase64(hmac)); logger.info(&quot;sign:&#123;&#125;&quot;, sign); return sign; &#125; /** * 参数验签 * @param params */ public static boolean checkSignature(Map&lt;String, String&gt; params) &#123; // 校验请求是否过期 String inTimeStamp = params.getOrDefault(&quot;_t&quot;, &quot;0&quot;); LocalDateTime inTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(inTimeStamp)), ZoneOffset.ofHours(8)); Duration duration = Duration.between(inTime, LocalDateTime.now()); long seconds = duration.get(SECONDS); System.out.println(&quot;seconds: &quot; + seconds); if (seconds &gt; 3 * 60) &#123; System.out.println(&quot;请求超时&quot;); return Boolean.FALSE; &#125; String inSignData = getSignData(params); logger.info(&quot;inSignData:&#123;&#125;&quot;, inSignData); byte[] inHmac = new HmacUtils(HmacAlgorithms.HMAC_SHA_1, appSecret).hmac(inSignData); String sign2 = new String(Base64.encodeBase64(inHmac)); logger.info(&quot;sign2:&#123;&#125;&quot;, sign2); String sign1 = params.getOrDefault(&quot;sign&quot;, &quot;&quot;); return sign1.equals(sign2); &#125; /** 19:42:31.297 [main] INFO cn.idea360.demo.modules.login.SignUtils - outSignData:_t=1592048551294&amp;appKey=idea360&amp;c=v1&amp;sessionId=123&amp;state=&amp;u=v2 19:42:31.385 [main] INFO cn.idea360.demo.modules.login.SignUtils - sign:EKL+wkPtAWBo/NIhR0Vb72khyKc= seconds: 0 19:42:31.463 [main] INFO cn.idea360.demo.modules.login.SignUtils - inSignData:_t=1592048551294&amp;appKey=idea360&amp;c=v1&amp;sessionId=123&amp;state=&amp;u=v2 19:42:31.463 [main] INFO cn.idea360.demo.modules.login.SignUtils - sign2:EKL+wkPtAWBo/NIhR0Vb72khyKc= true * @param args */ public static void main(String[] args) &#123; Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); // TODO 传入为各个服务分配的的appKey params.put(&quot;appKey&quot;, appKey); // 业务参数 params.put(&quot;c&quot;, &quot;v1&quot;); params.put(&quot;u&quot;, &quot;v2&quot;); params.put(&quot;_t&quot;, String.valueOf(System.currentTimeMillis())); params.put(&quot;state&quot;, null); params.put(&quot;sessionId&quot;, &quot;123&quot;); // 签名 String sign1 = sign(params); params.put(&quot;sign&quot;, sign1); // 验签 boolean checkSignature = checkSignature(params); System.out.println(checkSignature); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"验签","slug":"验签","permalink":"https://idea360.cn/tags/%E9%AA%8C%E7%AD%BE/"}]},{"title":"Http参数验签(基于AOP)","slug":"http-params-sign2","date":"2020-06-13T11:29:47.000Z","updated":"2021-02-23T14:20:45.432Z","comments":true,"path":"2020/06/13/http-params-sign2/","link":"","permalink":"https://idea360.cn/2020/06/13/http-params-sign2/","excerpt":"","text":"实现 要实现参数验签, 首先需要提取出请求参数, 这里无论 GET 还是 POST 请求, 我们都将参数提取出来放在map中处理 提取参数并排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package cn.idea360.demo.modules.sign;import com.alibaba.fastjson.JSONObject;import org.springframework.http.HttpMethod;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.util.HashMap;import java.util.Map;import java.util.SortedMap;import java.util.TreeMap;import java.util.stream.Collectors;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-08-30 */public class RequestUtils &#123; /** * 将URL请求参数转换成Map * @author show * @param request */ public static Map&lt;String, String&gt; getUrlParams(HttpServletRequest request) &#123; String param = &quot;&quot;; try &#123; param = URLDecoder.decode(request.getQueryString(), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(16); String[] params = param.split(&quot;&amp;&quot;); for (String s : params) &#123; int index = s.indexOf(&quot;=&quot;); result.put(s.substring(0, index), s.substring(index + 1)); &#125; return result; &#125; /** * 获取body中参数 * @param request * @return * @throws IOException */ public static Map&lt;String, String&gt; getBodyParams (HttpServletRequest request) throws IOException &#123; String body = request.getReader().lines().collect(Collectors.joining(System.lineSeparator())); //转化成json对象 return JSONObject.parseObject(body, Map.class); &#125; /** * 获取url参数和body参数 * @param request * @return * @throws IOException */ public static SortedMap&lt;String, String&gt; getAllParams(HttpServletRequest request) throws IOException &#123; SortedMap&lt;String, String&gt; sortedParams = new TreeMap&lt;&gt;(); // 获取url参数 Map&lt;String, String&gt; urlParams = getUrlParams(request); for (Map.Entry entry : urlParams.entrySet()) &#123; sortedParams.put((String) entry.getKey(), (String) entry.getValue()); &#125; // 获取body参数 if (!HttpMethod.GET.name().equals(request.getMethod())) &#123; Map&lt;String, String&gt; bodyParams = getBodyParams(request); if (null != bodyParams) &#123; for (Map.Entry entry : bodyParams.entrySet()) &#123; sortedParams.put((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; &#125; return sortedParams; &#125;&#125; 参数验签 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.idea360.demo.modules.sign;import com.alibaba.fastjson.JSONObject;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.util.DigestUtils;import java.util.*;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-08-30 */@Slf4jpublic class SignUtils &#123; /** * 获取参数签名 * @param params * @return */ public static String getParamsSign(SortedMap&lt;String, String&gt; params) &#123; //要先去掉 Url 里的 Sign params.remove(&quot;sign&quot;); // 这里把map转换为了json对象字符串，当然也可以取出value拼接或者其他方式组成的String String paramsJsonStr = JSONObject.toJSONString(params); String md5 = DigestUtils.md5DigestAsHex(paramsJsonStr.getBytes()).toUpperCase(); log.info(&quot;加签参数: &#123;&#125;, md5摘要: &#123;&#125;&quot;, paramsJsonStr, md5); return md5; &#125; /** * 参数验签 * @param params 已排序参数 * @return 验证签名结果 */ public static boolean verifySign(SortedMap&lt;String, String&gt; params) &#123; String urlSign = params.get(&quot;sign&quot;); log.info(&quot;Url Sign : &#123;&#125;&quot;, urlSign); if (StringUtils.isBlank(urlSign)) &#123; return false; &#125; //把参数加密 String paramsSign = getParamsSign(params); log.info(&quot;Param Sign : &#123;&#125;&quot;, paramsSign); return StringUtils.isNotBlank(paramsSign) &amp;&amp; urlSign.equals(paramsSign); &#125;&#125; AOP实现 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 接口验签 */@Slf4j@Aspect@Componentpublic class SignAspect &#123; @Pointcut(&quot;@annotation(com.idea360.auth.common.annotation.Sign)&quot;) public void signPointCut() &#123; &#125; @Before(&quot;signPointCut()&quot;) public void doBefore(JoinPoint joinPoint) throws Throwable &#123; // 获取方法请求参数 Object[] args = joinPoint.getArgs(); // 参数名 String[] argNames = ((MethodSignature) joinPoint.getSignature()).getParameterNames(); Map&lt;String, String&gt; unSortedMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof ServletRequest || args[i] instanceof ServletResponse) &#123; continue; &#125; String json = GsonUtils.toJson(args[i]); if (GsonUtils.isJSON(json)) &#123; Map&lt;String, String&gt; map = GsonUtils.fromJson(json, Map.class); unSortedMap.putAll(map); &#125; else &#123; unSortedMap.put(argNames[i], String.valueOf(args[i])); &#125; &#125; // 自然排序 SortedMap&lt;String, String&gt; sortedMap = new TreeMap&lt;&gt;(unSortedMap); log.info(&quot;参数验签, request params: [&#123;&#125;]&quot;, sortedMap.toString()); if (!SignUtils.verifySign(sortedMap)) &#123; throw new RuntimeException(&quot;非法请求&quot;); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class GsonUtils &#123; private static final Gson gson = new Gson(); /** * 判断是否json格式 * @param jsonStr * @return */ public static boolean isJSON(String jsonStr) &#123; JsonElement jsonElement; try &#123; jsonElement = JsonParser.parseString(jsonStr); &#125; catch (Exception e) &#123; return false; &#125; if (jsonElement == null) &#123; return false; &#125; if (!jsonElement.isJsonObject()) &#123; return false; &#125; return true; &#125; /** * 判断是否json对象 * @param o * @return */ public static boolean isJSONObject(Object o) &#123; try &#123; String json = gson.toJson(o); return isJSON(json); &#125; catch(com.google.gson.JsonSyntaxException ex) &#123; return false; &#125; &#125; public static String toJson(Object o) &#123; return gson.toJson(o); &#125; public static &lt;T&gt; T fromJson(String json, Class&lt;T&gt; clz) &#123; return gson.fromJson(json, clz); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"验签","slug":"验签","permalink":"https://idea360.cn/tags/%E9%AA%8C%E7%AD%BE/"}]},{"title":"Json常用处理方式","slug":"json-handle","date":"2020-06-10T16:18:32.000Z","updated":"2021-02-23T14:35:07.073Z","comments":true,"path":"2020/06/11/json-handle/","link":"","permalink":"https://idea360.cn/2020/06/11/json-handle/","excerpt":"","text":"概述 作为 面向对象 开发的程序员，每天的业务代码会遇到大量的 Json 处理。本文从最常见的几个类库 gson, fastjson, jackson 进行基本操作, 仅作记录。 基础准备 首先创建java对象用于测试 角色 12345678910111213/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-10 */@Data@NoArgsConstructor@AllArgsConstructorpublic class Role &#123; private String roleName;&#125; 这里我们创建一个复合嵌套对象user 1234567891011/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-10 */@Datapublic class User &#123; private String userName; private List&lt;Role&gt; roles;&#125; 用户组 123456789101112/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-11 */@Datapublic class UserGroup implements Serializable &#123; private String groupName; private Map&lt;String, User&gt; idNumber;&#125; 菜单 12345678910111213/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-10 */@Data@AllArgsConstructorpublic class Menu &#123; @SerializedName(&quot;menu_name&quot;) private String menuName;&#125; 部门 12345678910/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-11 */@Data@AllArgsConstructorpublic class Dept &#123; private String deptName;&#125; 类型适配器 12345678910111213141516/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-11 */public class DeptAdapter implements JsonSerializer&lt;Dept&gt; &#123; @Override public JsonElement serialize(Dept dept, Type type, JsonSerializationContext jsonSerializationContext) &#123; JsonObject deptObject = new JsonObject(); deptObject.addProperty(&quot;dept_name&quot;, dept.getDeptName()); return deptObject; &#125;&#125; Gson maven依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 单元测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-10 */class GsonTest &#123; /** * &#123;&quot;userName&quot;:&quot;admin&quot;,&quot;roles&quot;:[&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;]&#125; */ @Test void toJson() &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); User user = new User(); user.setUserName(&quot;admin&quot;); user.setRoles(Arrays.asList(role1, role2)); // 对象转json String json = new Gson().toJson(user); System.out.println(json); &#125; /** * &#123;&quot;userName&quot;:&quot;admin&quot;,&quot;roles&quot;:[&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;]&#125; */ @Test void toJson2() &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); User user = new User(); user.setUserName(&quot;admin&quot;); user.setRoles(Arrays.asList(role1, role2)); String json = new GsonBuilder().create().toJson(user); System.out.println(json); &#125; /** * User(userName=admin, roles=[Role(roleName=系统管理员), Role(roleName=普通管理员)]) */ @Test void fromJson() &#123; String json = &quot;&#123;\\&quot;userName\\&quot;:\\&quot;admin\\&quot;,\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&#125;&quot;; User user = new Gson().fromJson(json, User.class); System.out.println(user); &#125; /** * admin * &#123;&quot;userName&quot;:&quot;admin&quot;,&quot;roles&quot;:&#123;&quot;roleName&quot;:&quot;超级管理员&quot;&#125;&#125; */ @Test void createJsonObject() &#123; JsonObject role = new JsonObject(); role.addProperty(&quot;roleName&quot;, &quot;超级管理员&quot;); JsonObject user = new JsonObject(); user.addProperty(&quot;userName&quot;, &quot;admin&quot;); user.add(&quot;roles&quot;, role); String username = user.get(&quot;userName&quot;).getAsString(); System.out.println(username); System.out.println(user); &#125; /** * admin */ @Test void json2Object() &#123; String json = &quot;&#123;\\&quot;userName\\&quot;:\\&quot;admin\\&quot;,\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&#125;&quot;; JsonObject jsonObject = JsonParser.parseString(json).getAsJsonObject(); String userName = jsonObject.get(&quot;userName&quot;).getAsString(); System.out.println(userName); &#125; /** * [&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;] */ @Test void list2Json() &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); String json = new Gson().toJson(Arrays.asList(role1, role2)); System.out.println(json); &#125; /** * [Role(roleName=系统管理员), Role(roleName=普通管理员)] */ @Test void json2List() &#123; String json = &quot;[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&quot;; List&lt;Role&gt; roles = new Gson().fromJson(json, new TypeToken&lt;List&lt;Role&gt;&gt;() &#123;&#125;.getType()); System.out.println(roles); &#125; /** * [&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;] */ @Test void json2Array() &#123; String json = &quot;[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&quot;; JsonArray jsonArray = JsonParser.parseString(json).getAsJsonArray(); System.out.println(jsonArray); &#125; /** * &#123;&quot;userName&quot;:&quot;admin&quot;&#125; */ @Test void map2Json() &#123; HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;userName&quot;, &quot;admin&quot;); String json = new Gson().toJson(hashMap); System.out.println(json); &#125; /** * admin */ @Test void json2Map() &#123; String json = &quot;&#123;\\&quot;userName\\&quot;:\\&quot;admin\\&quot;&#125;&quot;; HashMap hashMap = new Gson().fromJson(json, new TypeToken&lt;HashMap&lt;String, String&gt;&gt;() &#123;&#125;.getType()); System.out.println(hashMap.get(&quot;userName&quot;)); &#125; /** * 默认的字段转换规则，字段名不变 * &#123;&quot;roleName&quot;:&quot;超级管理员&quot;&#125; */ @Test void setFieldNamingPolicy1() &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.IDENTITY) .create(); Role role = new Role(&quot;超级管理员&quot;); String json = gson.toJson(role); System.out.println(json); &#125; /** * 将json中的字段名转换为首字母大写的格式 * &#123;&quot;RoleName&quot;:&quot;超级管理员&quot;&#125; */ @Test void setFieldNamingPolicy2() &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE) .create(); Role role = new Role(&quot;超级管理员&quot;); String json = gson.toJson(role); System.out.println(json); &#125; /** * 将json中的字段名转换为首字母大写，单词之间以空格分割的格式 * &#123;&quot;Role Name&quot;:&quot;超级管理员&quot;&#125; */ @Test void setFieldNamingPolicy3() &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES) .create(); Role role = new Role(&quot;超级管理员&quot;); String json = gson.toJson(role); System.out.println(json); &#125; /** * 将json中的字段名转换为小写字母，单词之间以下划线分割的格式 * &#123;&quot;role_name&quot;:&quot;超级管理员&quot;&#125; */ @Test void setFieldNamingPolicy4() &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES) .create(); Role role = new Role(&quot;超级管理员&quot;); String json = gson.toJson(role); System.out.println(json); &#125; /** * 将json中的字段名转换为小写字母，单词之间以分隔线分割的格式 * &#123;&quot;role-name&quot;:&quot;超级管理员&quot;&#125; */ @Test void setFieldNamingPolicy5() &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES) .create(); Role role = new Role(&quot;超级管理员&quot;); String json = gson.toJson(role); System.out.println(json); &#125; /** * 将json中的字段名转换为小写字母，单词之间以点分割的格式 * &#123;&quot;role.name&quot;:&quot;超级管理员&quot;&#125; */ @Test void setFieldNamingPolicy6() &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS) .create(); Role role = new Role(&quot;超级管理员&quot;); String json = gson.toJson(role); System.out.println(json); &#125; /** * 属性重命名 * &#123;&quot;menu_name&quot;:&quot;系统管理&quot;&#125; */ @Test void serializedName() &#123; Menu menu = new Menu(&quot;系统管理&quot;); String json = new Gson().toJson(menu); System.out.println(json); &#125; /** * &#123;&quot;dept_name&quot;:&quot;产品研发部&quot;&#125; */ @Test void adapter() &#123; Gson gson = new GsonBuilder() //为Dept注册TypeAdapter .registerTypeAdapter(Dept.class, new DeptAdapter()) .create(); Dept dept = new Dept(&quot;产品研发部&quot;); String json = gson.toJson(dept); System.out.println(json); &#125;&#125; FastJson maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt;&lt;/dependency&gt; 单元测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154public class FastJsonTest &#123; /** * &#123;&quot;roles&quot;:[&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;],&quot;userName&quot;:&quot;admin&quot;&#125; */ @Test void toJson() &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); User user = new User(); user.setUserName(&quot;admin&quot;); user.setRoles(Arrays.asList(role1, role2)); String userJson = JSON.toJSONString(user); System.out.println(userJson); &#125; /** * admin * &#123;&quot;roles&quot;:[&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;],&quot;userName&quot;:&quot;admin&quot;&#125; */ @Test void jsonParse() &#123; String json = &quot;&#123;\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;],\\&quot;userName\\&quot;:\\&quot;admin\\&quot;&#125;&quot;; JSONObject jsonObject = JSON.parseObject(json); System.out.println(jsonObject.getString(&quot;userName&quot;)); System.out.println(jsonObject); &#125; /** * [&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;] */ @Test void list2Json() &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); String jsonString = JSON.toJSONString(Arrays.asList(role1, role2)); System.out.println(jsonString); &#125; /** * [&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;] */ @Test void json2List() &#123; String json = &quot;[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&quot;; JSONArray jsonArray = JSON.parseArray(json); System.out.println(jsonArray); &#125; /** * [Role(roleName=系统管理员), Role(roleName=普通管理员)] */ @Test void json2List2() &#123; String json = &quot;[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&quot;; List&lt;Role&gt; users = JSON.parseArray(json, Role.class); System.out.println(users); &#125; /** * User(userName=admin, roles=[Role(roleName=系统管理员), Role(roleName=普通管理员)]) */ @Test void json2Bean() &#123; String json = &quot;&#123;\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;],\\&quot;userName\\&quot;:\\&quot;admin\\&quot;&#125;&quot;; User user = JSON.parseObject(json, User.class); System.out.println(user); &#125; /** * User(userName=admin, roles=[Role(roleName=系统管理员), Role(roleName=普通管理员)]) */ @Test void json2Bean2() &#123; String json = &quot;&#123;\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;],\\&quot;userName\\&quot;:\\&quot;admin\\&quot;&#125;&quot;; User user = JSON.parseObject(json, new TypeReference&lt;User&gt;()&#123;&#125;); System.out.println(user); &#125; /** * &#123;&quot;userName&quot;:&quot;admin&quot;&#125; */ @Test void map2Json() &#123; HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(&quot;userName&quot;, &quot;admin&quot;); String jsonString = JSON.toJSONString(hashMap); System.out.println(jsonString); &#125; /** * admin */ @Test void json2Map() &#123; String json = &quot;&#123;\\&quot;userName\\&quot;:\\&quot;admin\\&quot;&#125;&quot;; Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) JSON.parse(json); System.out.println(map.get(&quot;userName&quot;)); &#125; /** * &#123;&quot;userName&quot;:&quot;admin&quot;&#125; */ @Test void json2Map2() &#123; String json = &quot;&#123;\\&quot;userName\\&quot;:\\&quot;admin\\&quot;&#125;&quot;; Map map = JSON.parseObject(json); System.out.println(map); &#125; /** * &#123;&quot;groupName&quot;:&quot;分组1&quot;,&quot;idNumber&quot;:&#123;&quot;001&quot;:&#123;&quot;roles&quot;:[&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;],&quot;userName&quot;:&quot;admin&quot;&#125;&#125;&#125; */ @Test void obj2Json() &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); User user = new User(); user.setUserName(&quot;admin&quot;); user.setRoles(Arrays.asList(role1, role2)); HashMap&lt;String, User&gt; map = new HashMap&lt;&gt;(); map.put(&quot;001&quot;, user); UserGroup userGroup = new UserGroup(); userGroup.setGroupName(&quot;分组1&quot;); userGroup.setIdNumber(map); String jsonString = JSON.toJSONString(userGroup); System.out.println(jsonString); &#125; /** * UserGroup(groupName=分组1, idNumber=&#123;001=User(userName=admin, roles=[Role(roleName=系统管理员), Role(roleName=普通管理员)])&#125;) */ @Test void json2Obj() &#123; String json = &quot;&#123;\\&quot;groupName\\&quot;:\\&quot;分组1\\&quot;,\\&quot;idNumber\\&quot;:&#123;\\&quot;001\\&quot;:&#123;\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;],\\&quot;userName\\&quot;:\\&quot;admin\\&quot;&#125;&#125;&#125;&quot;; UserGroup userGroup = JSON.parseObject(json, UserGroup.class); System.out.println(userGroup); &#125;&#125; Jackson 单元测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-11 */public class JacksonTest &#123; /** * &#123;&quot;userName&quot;:&quot;admin&quot;,&quot;roles&quot;:[&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;]&#125; * @throws JsonProcessingException */ @Test void Obj2Json() throws JsonProcessingException &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); User user = new User(); user.setUserName(&quot;admin&quot;); user.setRoles(Arrays.asList(role1, role2)); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(user); System.out.println(json); &#125; /** * 需要无参构造方法 * User(userName=admin, roles=[Role(roleName=系统管理员), Role(roleName=普通管理员)]) * @throws JsonProcessingException */ @Test void json2Obj() throws JsonProcessingException &#123; String json = &quot;&#123;\\&quot;userName\\&quot;:\\&quot;admin\\&quot;,\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&#125;&quot;; ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(json, User.class); System.out.println(user); &#125; /** * admin * @throws JsonProcessingException */ @Test void json2Obj2() throws JsonProcessingException &#123; String json = &quot;&#123;\\&quot;userName\\&quot;:\\&quot;admin\\&quot;,\\&quot;roles\\&quot;:[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&#125;&quot;; ObjectMapper mapper = new ObjectMapper(); JsonNode jsonNode = mapper.readTree(json); String userName = jsonNode.get(&quot;userName&quot;).asText(); System.out.println(userName); &#125; /** * [&#123;&quot;roleName&quot;:&quot;系统管理员&quot;&#125;,&#123;&quot;roleName&quot;:&quot;普通管理员&quot;&#125;] * @throws JsonProcessingException */ @Test void list2Json() throws JsonProcessingException &#123; Role role1 = new Role(&quot;系统管理员&quot;); Role role2 = new Role(&quot;普通管理员&quot;); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(Arrays.asList(role1, role2)); System.out.println(json); &#125; /** * 需要无参构造方法 * [Role(roleName=系统管理员), Role(roleName=普通管理员)] * @throws JsonProcessingException */ @Test void json2List() throws JsonProcessingException &#123; String json = &quot;[&#123;\\&quot;roleName\\&quot;:\\&quot;系统管理员\\&quot;&#125;,&#123;\\&quot;roleName\\&quot;:\\&quot;普通管理员\\&quot;&#125;]&quot;; ObjectMapper mapper = new ObjectMapper(); List&lt;Role&gt; roles = mapper.readValue(json, new TypeReference&lt;List&lt;Role&gt;&gt;() &#123; &#125;); System.out.println(roles); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"json","slug":"json","permalink":"https://idea360.cn/tags/json/"}]},{"title":"SpringBoot-MongoDB入门教程","slug":"springboot-mongodb","date":"2020-06-08T15:43:45.000Z","updated":"2021-04-29T15:09:56.468Z","comments":true,"path":"2020/06/08/springboot-mongodb/","link":"","permalink":"https://idea360.cn/2020/06/08/springboot-mongodb/","excerpt":"","text":"概述 本篇是mongodb入门教程。 实战 pom依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idc-mongo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;idc-mongo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties 1spring.data.mongodb.uri=mongodb://root:root@localhost:27017/kcall 创建实体类 12345678910111213141516171819202122/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-08 */@Data@ToStringpublic class User implements Serializable &#123; private int id; private String userName; private String password; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime createTime; public User(int id, String userName, String password) &#123; this.id = id; this.userName = userName; this.password = password; this.createTime = LocalDateTime.now(); &#125;&#125; 配置不存储_class 1234567891011121314151617181920212223/** * 不保存_class到mongo中 * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-08 */@Configurationpublic class MongoConfig &#123; @Bean public MappingMongoConverter mappingMongoConverter(MongoDatabaseFactory factory, MongoMappingContext context, BeanFactory beanFactory) &#123; DbRefResolver dbRefResolver = new DefaultDbRefResolver(factory); MappingMongoConverter mappingConverter = new MappingMongoConverter(dbRefResolver, context); try &#123; mappingConverter.setCustomConversions(beanFactory.getBean(CustomConversions.class)); &#125; catch (NoSuchBeanDefinitionException ignore) &#123; &#125; // Don&#x27;t save _class to mongo mappingConverter.setTypeMapper(new DefaultMongoTypeMapper(null)); return mappingConverter; &#125;&#125; 基本操作 MongoTemplate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303package com.example.demo;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.example.demo.model.AiUser;import com.example.demo.model.Project;import com.example.demo.model.User;import com.mongodb.BasicDBObject;import com.mongodb.bulk.BulkWriteResult;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Sort;import org.springframework.data.mongodb.core.BulkOperations;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.aggregation.Aggregation;import org.springframework.data.mongodb.core.aggregation.AggregationResults;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import org.springframework.data.repository.support.PageableExecutionUtils;import org.springframework.data.util.Pair;import org.springframework.util.StringUtils;import java.util.*;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-06-08 */@Slf4j@SpringBootTestpublic class UserTest &#123; @Autowired private MongoTemplate mongoTemplate; /** * 1. 插入数据 * 2. 表名大小写敏感 * 3. id不用数据库自带的uuid，换为自定义自增主键 * 4. 不保存_class到mongo中 * User(id=100, userName=name100, password=123, createTime=2020-07-23T11:31:14.567044) */ @Test public void add1() &#123; User user = new User(100, &quot;name100&quot;, &quot;123&quot;); User save = mongoTemplate.save(user, &quot;user&quot;); log.info(save.toString()); &#125; /** * 主键相同会覆盖数据 * User(id=100, userName=name100, password=123, createTime=2021-04-29T22:21:15.694248) */ @Test public void add2() &#123; User user = new User(100, &quot;name100&quot;, &quot;123&quot;); User save = mongoTemplate.save(user, &quot;user&quot;); log.info(save.toString()); &#125; /** * 批量插入 * id存在会抛出异常: DuplicateKeyException */ @Test public void add3() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(i, &quot;name&quot; + i, &quot;123&quot;); list.add(user); &#125; Collection&lt;User&gt; users = mongoTemplate.insertAll(list); log.info(users.toString()); &#125; /** * 批量插入 * id存在会抛出异常: DuplicateKeyException */ @Test public void add4() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(i, &quot;name&quot; + i, &quot;123&quot;); list.add(user); &#125; Collection&lt;User&gt; users = mongoTemplate.insert(list, &quot;user&quot;); log.info(users.toString()); &#125; /** * User(id=1, userName=name1, password=123, createTime=2020-07-23T11:32:04.550) */ @Test public void query1() &#123; Query query = new Query(Criteria.where(&quot;_id&quot;).is(1)); // 模糊查询 query.addCriteria(Criteria.where(&quot;userName&quot;).regex(&quot;name&quot;)); User user = mongoTemplate.findOne(query, User.class, &quot;user&quot;); log.info(user.toString()); &#125; /** * User(id=1, userName=name1, password=123, createTime=2020-07-23T11:32:04.550) */ @Test public void query2() &#123; Query query = Query.query(Criteria.where(&quot;_id&quot;).is(1)); User user = mongoTemplate.findOne(query, User.class, &quot;user&quot;); log.info(user.toString()); &#125; /** * [User(id=1, userName=name1, password=123, createTime=2020-07-23T11:32:04.550), User(id=2, userName=name2, password=123, createTime=2020-07-23T11:32:04.550), User(id=3, userName=name3, password=123, createTime=2020-07-23T11:32:04.550)] */ @Test public void in() &#123; Query query = Query.query(Criteria.where(&quot;_id&quot;).in(1, 2, 3)); List&lt;User&gt; list = mongoTemplate.find(query, User.class, &quot;user&quot;); log.info(list.toString()); &#125; /** * 分页查询 * &#123;&quot;content&quot;:[&#123;&quot;createTime&quot;:&quot;2020-07-23T11:32:04.550&quot;,&quot;id&quot;:6,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name6&quot;&#125;,&#123;&quot;createTime&quot;:&quot;2020-07-23T11:32:04.550&quot;,&quot;id&quot;:7,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name7&quot;&#125;,&#123;&quot;createTime&quot;:&quot;2020-07-23T11:32:04.550&quot;,&quot;id&quot;:8,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name8&quot;&#125;,&#123;&quot;createTime&quot;:&quot;2020-07-23T11:32:04.550&quot;,&quot;id&quot;:9,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name9&quot;&#125;,&#123;&quot;createTime&quot;:&quot;2020-07-23T11:32:04.550&quot;,&quot;id&quot;:10,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name10&quot;&#125;],&quot;empty&quot;:false,&quot;first&quot;:false,&quot;last&quot;:false,&quot;number&quot;:1,&quot;numberOfElements&quot;:5,&quot;pageable&quot;:&#123;&quot;offset&quot;:5,&quot;pageNumber&quot;:1,&quot;pageSize&quot;:5,&quot;paged&quot;:true,&quot;sort&quot;:&#123;&quot;empty&quot;:true,&quot;sorted&quot;:false,&quot;unsorted&quot;:true&#125;,&quot;unpaged&quot;:false&#125;,&quot;size&quot;:5,&quot;sort&quot;:&#123;&quot;$ref&quot;:&quot;$.pageable.sort&quot;&#125;,&quot;totalElements&quot;:11,&quot;totalPages&quot;:3&#125; */ @Test public void page() &#123; PageRequest pageRequest = PageRequest.of(1, 5); Query query = Query.query(Criteria.where(&quot;password&quot;).is(&quot;123&quot;)) .with(Sort.by(Sort.Direction.ASC, &quot;_id&quot;)); // 查询总数 int count = (int) mongoTemplate.count(query, User.class, &quot;user&quot;); // 加入分页条件 query.with(pageRequest); List&lt;User&gt; users = mongoTemplate.find(query, User.class, &quot;user&quot;); // 分页 Page&lt;User&gt; page = PageableExecutionUtils.getPage(users, pageRequest, () -&gt; count); log.info(JSONObject.toJSONString(page)); &#125; /** * 时间段查询(注意时区) */ @Test public void time() &#123; String startTime = &quot;2021-04-20 14:14:20&quot;; String endTime = &quot;2021-04-30 14:15:41&quot;; PageRequest pageRequest = PageRequest.of(1, 5); Query query = Query.query(Criteria.where(&quot;password&quot;).is(&quot;123&quot;)) .with(Sort.by(Sort.Direction.ASC, &quot;_id&quot;)); // 时间段查询 if (!StringUtils.isEmpty(startTime) &amp;&amp; !StringUtils.isEmpty(endTime)) &#123; Criteria criteria = new Criteria(); criteria.andOperator(Criteria.where(&quot;createTime&quot;).gte(startTime), Criteria.where(&quot;createTime&quot;).lt(endTime)); query.addCriteria(criteria); &#125; else if (!Objects.isNull(startTime)) &#123; query.addCriteria(Criteria.where(&quot;createTime&quot;).gte(startTime)); &#125; else if (!Objects.isNull(endTime)) &#123; query.addCriteria(Criteria.where(&quot;createTime&quot;).lt(endTime)); &#125; // 查询总数 int count = (int) mongoTemplate.count(query, User.class, &quot;user&quot;); // 加入分页条件 query.with(pageRequest); List&lt;User&gt; users = mongoTemplate.find(query, User.class, &quot;user&quot;); // 分页 Page&lt;User&gt; page = PageableExecutionUtils.getPage(users, pageRequest, () -&gt; count); log.info(JSONObject.toJSONString(page)); &#125; /** * 如果查询字段中有list, 业务需要匹配子对象中的字段。 * * 示例实体: * @Data * public class AiUser &#123; * private long id; * private List&lt;Project&gt; projects; * &#125; * * @Data * public class Project &#123; * private String name; * &#125; * * 则 mongoTemplate 查询如下所示: [&#123;&quot;id&quot;:1,&quot;projects&quot;:[&#123;&quot;name&quot;:&quot;项目&quot;&#125;]&#125;] */ @Test public void queryChild() &#123; Project project = new Project(); project.setName(&quot;项目&quot;); AiUser aiUser = new AiUser(); aiUser.setId(1); aiUser.setProjects(Collections.singletonList(project)); // 保存嵌套数据 mongoTemplate.save(aiUser, &quot;ai_user&quot;); // 根据子集合中的数据查询 List&lt;AiUser&gt; aiUsers = mongoTemplate.find(Query.query(Criteria.where(&quot;projects.name&quot;).is(&quot;项目&quot;)), AiUser.class, &quot;ai_user&quot;); log.info(JSONArray.toJSONString(aiUsers)); &#125; /** * 批量查询 * [&#123;&quot;createTime&quot;:&quot;2021-04-29T22:51:27.636&quot;,&quot;id&quot;:1,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name1&quot;&#125;,&#123;&quot;createTime&quot;:&quot;2021-04-29T22:51:27.636&quot;,&quot;id&quot;:3,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name3&quot;&#125;,&#123;&quot;createTime&quot;:&quot;2021-04-29T22:51:27.636&quot;,&quot;id&quot;:5,&quot;password&quot;:&quot;123&quot;,&quot;userName&quot;:&quot;name5&quot;&#125;] */ @Test public void queryBatch() &#123; List&lt;String&gt; nameQuery = Arrays.asList(&quot;name1&quot;, &quot;name3&quot;, &quot;name5&quot;); Query query = new Query(); Criteria criteria = new Criteria(); Criteria[] cs = new Criteria[nameQuery.size()]; for(int i=0; i&lt;nameQuery.size(); i++)&#123; cs[i] = Criteria.where(&quot;userName&quot;).is(nameQuery.get(i)); &#125; criteria.orOperator(cs); query.addCriteria(criteria); List&lt;User&gt; users = mongoTemplate.find(query, User.class, &quot;user&quot;); log.info(JSONArray.toJSONString(users)); &#125; /** * 更新(save操作底层会调用upsert) * upsert操作会先在集合中进行数据查找，如果数据已经存在，则更新，否则才插入 */ @Test public void update() &#123; Query query = new Query(Criteria.where(&quot;_id&quot;).is(100)); Update update = new Update(); update.set(&quot;userName&quot;, &quot;admin&quot;); mongoTemplate.upsert(query, update, &quot;user&quot;); &#125; /** * 批量更新 * &#123;&quot;deletedCount&quot;:0,&quot;insertedCount&quot;:0,&quot;inserts&quot;:[],&quot;matchedCount&quot;:3,&quot;modifiedCount&quot;:3,&quot;upserts&quot;:[]&#125; */ @Test public void update2() &#123; List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3); List&lt;Pair&lt;Query, Update&gt;&gt; updateList = new ArrayList&lt;&gt;(3); BulkOperations operations = mongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED, &quot;user&quot;); ids.forEach(id -&gt; &#123; Query query = new Query(new Criteria(&quot;_id&quot;).is(id)); Update update = new Update(); update.set(&quot;userName&quot;, &quot;batch-update-&quot; + id); Pair&lt;Query, Update&gt; updatePair = Pair.of(query, update); updateList.add(updatePair); &#125;); operations.upsert(updateList); BulkWriteResult execute = operations.execute(); log.info(&quot;&#123;&#125;&quot;, JSONObject.toJSONString(execute)); &#125; /** * 删除 */ @Test public void delete() &#123; Query query = new Query(Criteria.where(&quot;_id&quot;).in(100)); mongoTemplate.findAllAndRemove(query, User.class, &quot;user&quot;); &#125; /** * 2021-04-29 22:51:48.436 INFO 97804 --- [ main] com.example.demo.UserTest : 聚合: [&#123;&quot;_id&quot;:&quot;name1&quot;,&quot;sum&quot;:1&#125;] * 2021-04-29 22:51:48.438 INFO 97804 --- [ main] com.example.demo.UserTest : 聚合: [&#123;&quot;_id&quot;:&quot;name10&quot;,&quot;sum&quot;:1&#125;] * 2021-04-29 22:51:48.438 INFO 97804 --- [ main] com.example.demo.UserTest : 聚合: [&#123;&quot;_id&quot;:&quot;name100&quot;,&quot;sum&quot;:1&#125;] */ @Test public void aggregation() &#123; // 将操作加入到聚合对象中 Aggregation aggregation = Aggregation.newAggregation( // 条件匹配 Aggregation.match(Criteria.where(&quot;userName&quot;).regex(&quot;name1&quot;)), // 使用管道操作符 $group 进行分组，然后统计各个组的文档数量 Aggregation.group(&quot;userName&quot;).count().as(&quot;sum&quot;), // 排序 Aggregation.sort(Sort.by(&quot;_id&quot;).ascending()) ); // 执行聚合查询 AggregationResults&lt;BasicDBObject&gt; results = mongoTemplate.aggregate(aggregation, &quot;user&quot;, BasicDBObject.class); for (Iterator&lt;BasicDBObject&gt; iterator = results.iterator(); iterator.hasNext(); ) &#123; BasicDBObject obj = iterator.next(); log.info(&quot;聚合: [&#123;&#125;]&quot;, JSONObject.toJSONString(obj)); &#125; &#125;&#125; 像 JPA 一样操作 123public interface CustomerRepository extends MongoRepository&lt;R, String&gt; &#123;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。 参考 https://www.baeldung.com/queries-in-spring-data-mongodb http://www.mydlq.club/article/85/","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"mongodb","slug":"mongodb","permalink":"https://idea360.cn/tags/mongodb/"}]},{"title":"Docker实战之MongoDB笔记","slug":"docker-mongodb","date":"2020-06-07T09:29:25.000Z","updated":"2021-08-04T14:31:47.765Z","comments":true,"path":"2020/06/07/docker-mongodb/","link":"","permalink":"https://idea360.cn/2020/06/07/docker-mongodb/","excerpt":"","text":"概述 有一些数据并不适合存储mysql, 比如工作流。 搭建过程 123456789101112131415161718version: &#x27;3.3&#x27;services: #第一个docker mongodb: image: mongo:latest container_name: mongodb environment: - MONGO_INITDB_ROOT_USERNAME=root - MONGO_INITDB_ROOT_PASSWORD=root #本地目录映射docker数据目录，做数据持久化 -v volumes: - ./mongodb/data:/data/db ports: - &quot;27017:27017&quot; restart: always command: mongod 创建帐号 12345678910db.createUser( &#123; user: &quot;root&quot;, pwd: &quot;123456&quot;, roles: [&#123; role: &quot;readWrite&quot;, db: &quot;testdb&quot; &#125;] &#125;) 运维 https://www.jb51.net/article/52498.htm 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"mongo","slug":"mongo","permalink":"https://idea360.cn/tags/mongo/"}]},{"title":"工作流流程结构分析","slug":"workflow","date":"2020-06-06T11:26:57.000Z","updated":"2021-02-23T14:50:14.827Z","comments":true,"path":"2020/06/06/workflow/","link":"","permalink":"https://idea360.cn/2020/06/06/workflow/","excerpt":"","text":"前言 本文中的流程结构出自activiti 对应的json结构如下: flow.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429&#123; &quot;resourceId&quot;:&quot;10010&quot;, &quot;properties&quot;:&#123; &quot;process_id&quot;:&quot;process&quot;, &quot;name&quot;:&quot;&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;process_author&quot;:&quot;&quot;, &quot;process_version&quot;:&quot;&quot;, &quot;process_namespace&quot;:&quot;http://www.activiti.org/processdef&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;eventlisteners&quot;:&quot;&quot;, &quot;signaldefinitions&quot;:&quot;&quot;, &quot;messagedefinitions&quot;:&quot;&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;BPMNDiagram&quot; &#125;, &quot;childShapes&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-8A2AA3F4-E527-4663-8C5C-82BE44A6010D&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;开始节点&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;initiator&quot;:&quot;&quot;, &quot;formkeydefinition&quot;:&quot;&quot;, &quot;formproperties&quot;:&quot;&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;StartNoneEvent&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-62ED91C7-0E2F-42D0-9053-C6595B50F2CC&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:150, &quot;y&quot;:214 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:120, &quot;y&quot;:184 &#125; &#125;, &quot;dockers&quot;:[ ] &#125;, &#123; &quot;resourceId&quot;:&quot;sid-99949B64-6CDC-497B-9A13-295BABEE0C49&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;网关节点&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;asynchronousdefinition&quot;:&quot;false&quot;, &quot;exclusivedefinition&quot;:&quot;false&quot;, &quot;sequencefloworder&quot;:&quot;&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;ExclusiveGateway&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-F760D015-20A7-4B45-A141-172F83C447B6&quot; &#125;, &#123; &quot;resourceId&quot;:&quot;sid-C37D01AF-703F-488F-8A44-A97732C323FB&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:303.375, &quot;y&quot;:219 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:263.375, &quot;y&quot;:179 &#125; &#125;, &quot;dockers&quot;:[ ] &#125;, &#123; &quot;resourceId&quot;:&quot;sid-E395D5E2-1058-459D-8A4A-4CF5BFF61212&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;组长&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;asynchronousdefinition&quot;:&quot;false&quot;, &quot;exclusivedefinition&quot;:&quot;false&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;multiinstance_type&quot;:&quot;None&quot;, &quot;multiinstance_cardinality&quot;:&quot;&quot;, &quot;multiinstance_collection&quot;:&quot;&quot;, &quot;multiinstance_variable&quot;:&quot;&quot;, &quot;multiinstance_condition&quot;:&quot;&quot;, &quot;isforcompensation&quot;:&quot;false&quot;, &quot;usertaskassignment&quot;:&quot;&quot;, &quot;formkeydefinition&quot;:&quot;&quot;, &quot;duedatedefinition&quot;:&quot;&quot;, &quot;prioritydefinition&quot;:&quot;&quot;, &quot;formproperties&quot;:&quot;&quot;, &quot;tasklisteners&quot;:&quot;&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;UserTask&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-6A6C6F11-6101-474A-8AF8-D5051B241778&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:569, &quot;y&quot;:239 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:469, &quot;y&quot;:159 &#125; &#125;, &quot;dockers&quot;:[ ] &#125;, &#123; &quot;resourceId&quot;:&quot;sid-DCA5E65D-8D8F-4CB9-AC24-D07AD78ECB90&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;主管&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;asynchronousdefinition&quot;:&quot;false&quot;, &quot;exclusivedefinition&quot;:&quot;false&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;multiinstance_type&quot;:&quot;None&quot;, &quot;multiinstance_cardinality&quot;:&quot;&quot;, &quot;multiinstance_collection&quot;:&quot;&quot;, &quot;multiinstance_variable&quot;:&quot;&quot;, &quot;multiinstance_condition&quot;:&quot;&quot;, &quot;isforcompensation&quot;:&quot;false&quot;, &quot;usertaskassignment&quot;:&quot;&quot;, &quot;formkeydefinition&quot;:&quot;&quot;, &quot;duedatedefinition&quot;:&quot;&quot;, &quot;prioritydefinition&quot;:&quot;&quot;, &quot;formproperties&quot;:&quot;&quot;, &quot;tasklisteners&quot;:&quot;&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;UserTask&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-841C8734-A5F2-49F3-971E-552140513465&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:333.375, &quot;y&quot;:380 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:233.375, &quot;y&quot;:300 &#125; &#125;, &quot;dockers&quot;:[ ] &#125;, &#123; &quot;resourceId&quot;:&quot;sid-0C384707-B9FC-48B3-852B-D471442FC379&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;结束节点&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;executionlisteners&quot;:&quot;&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;EndNoneEvent&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ ], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:533, &quot;y&quot;:354 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:505, &quot;y&quot;:326 &#125; &#125;, &quot;dockers&quot;:[ ] &#125;, &#123; &quot;resourceId&quot;:&quot;sid-62ED91C7-0E2F-42D0-9053-C6595B50F2CC&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;开始连线&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;conditionsequenceflow&quot;:&quot;&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;defaultflow&quot;:&quot;false&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;SequenceFlow&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-99949B64-6CDC-497B-9A13-295BABEE0C49&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:263.1025447022881, &quot;y&quot;:199.43023524669115 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:150.53856857896187, &quot;y&quot;:199.05218662830885 &#125; &#125;, &quot;dockers&quot;:[ &#123; &quot;x&quot;:15, &quot;y&quot;:15 &#125;, &#123; &quot;x&quot;:20.5, &quot;y&quot;:20.5 &#125;], &quot;target&quot;:&#123; &quot;resourceId&quot;:&quot;sid-99949B64-6CDC-497B-9A13-295BABEE0C49&quot; &#125; &#125;, &#123; &quot;resourceId&quot;:&quot;sid-F760D015-20A7-4B45-A141-172F83C447B6&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;组长连线&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;conditionsequenceflow&quot;:&quot;&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;defaultflow&quot;:&quot;false&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;SequenceFlow&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-E395D5E2-1058-459D-8A4A-4CF5BFF61212&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:468.40332257355396, &quot;y&quot;:199.45685785136587 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:304.16259539519604, &quot;y&quot;:199.10759527363413 &#125; &#125;, &quot;dockers&quot;:[ &#123; &quot;x&quot;:20.5, &quot;y&quot;:20.5 &#125;, &#123; &quot;x&quot;:50, &quot;y&quot;:40 &#125;], &quot;target&quot;:&#123; &quot;resourceId&quot;:&quot;sid-E395D5E2-1058-459D-8A4A-4CF5BFF61212&quot; &#125; &#125;, &#123; &quot;resourceId&quot;:&quot;sid-C37D01AF-703F-488F-8A44-A97732C323FB&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;主管连线&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;conditionsequenceflow&quot;:&quot;&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;defaultflow&quot;:&quot;false&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;SequenceFlow&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-DCA5E65D-8D8F-4CB9-AC24-D07AD78ECB90&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:283.80503505367324, &quot;y&quot;:299.4843813321798 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:283.51918369632676, &quot;y&quot;:219.16014991782018 &#125; &#125;, &quot;dockers&quot;:[ &#123; &quot;x&quot;:20.5, &quot;y&quot;:20.5 &#125;, &#123; &quot;x&quot;:50, &quot;y&quot;:40 &#125;], &quot;target&quot;:&#123; &quot;resourceId&quot;:&quot;sid-DCA5E65D-8D8F-4CB9-AC24-D07AD78ECB90&quot; &#125; &#125;, &#123; &quot;resourceId&quot;:&quot;sid-6A6C6F11-6101-474A-8AF8-D5051B241778&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;组长结束连线&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;conditionsequenceflow&quot;:&quot;&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;defaultflow&quot;:&quot;false&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;SequenceFlow&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-0C384707-B9FC-48B3-852B-D471442FC379&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:519, &quot;y&quot;:325.78125 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:519, &quot;y&quot;:239.65625 &#125; &#125;, &quot;dockers&quot;:[ &#123; &quot;x&quot;:50, &quot;y&quot;:40 &#125;, &#123; &quot;x&quot;:14, &quot;y&quot;:14 &#125;], &quot;target&quot;:&#123; &quot;resourceId&quot;:&quot;sid-0C384707-B9FC-48B3-852B-D471442FC379&quot; &#125; &#125;, &#123; &quot;resourceId&quot;:&quot;sid-841C8734-A5F2-49F3-971E-552140513465&quot;, &quot;properties&quot;:&#123; &quot;overrideid&quot;:&quot;&quot;, &quot;name&quot;:&quot;主管结束连线&quot;, &quot;documentation&quot;:&quot;&quot;, &quot;conditionsequenceflow&quot;:&quot;&quot;, &quot;executionlisteners&quot;:&quot;&quot;, &quot;defaultflow&quot;:&quot;false&quot; &#125;, &quot;stencil&quot;:&#123; &quot;id&quot;:&quot;SequenceFlow&quot; &#125;, &quot;childShapes&quot;:[ ], &quot;outgoing&quot;:[ &#123; &quot;resourceId&quot;:&quot;sid-0C384707-B9FC-48B3-852B-D471442FC379&quot; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:504.19384765625, &quot;y&quot;:340 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:334.0771484375, &quot;y&quot;:340 &#125; &#125;, &quot;dockers&quot;:[ &#123; &quot;x&quot;:50, &quot;y&quot;:40 &#125;, &#123; &quot;x&quot;:14, &quot;y&quot;:14 &#125;], &quot;target&quot;:&#123; &quot;resourceId&quot;:&quot;sid-0C384707-B9FC-48B3-852B-D471442FC379&quot; &#125; &#125;], &quot;bounds&quot;:&#123; &quot;lowerRight&quot;:&#123; &quot;x&quot;:1200, &quot;y&quot;:1050 &#125;, &quot;upperLeft&quot;:&#123; &quot;x&quot;:0, &quot;y&quot;:0 &#125; &#125;, &quot;stencilset&quot;:&#123; &quot;url&quot;:&quot;stencilsets/bpmn2.0/bpmn2.0.json&quot;, &quot;namespace&quot;:&quot;http://b3mn.org/stencilset/bpmn2.0#&quot; &#125;, &quot;ssextensions&quot;:[ ]&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"activiti","slug":"activiti","permalink":"https://idea360.cn/categories/activiti/"}],"tags":[{"name":"activiti","slug":"activiti","permalink":"https://idea360.cn/tags/activiti/"},{"name":"工作流","slug":"工作流","permalink":"https://idea360.cn/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}]},{"title":"Git多帐号配置","slug":"git-multiple-account","date":"2020-06-06T10:01:42.000Z","updated":"2020-06-06T11:24:06.600Z","comments":true,"path":"2020/06/06/git-multiple-account/","link":"","permalink":"https://idea360.cn/2020/06/06/git-multiple-account/","excerpt":"","text":"概述 在公司, 我们可能除了有公司的gitlab帐号，还有github、gitee等帐号。如何在一台机子上同时操作几个git帐号呢？以下以 macOS 为例说明 实战 取消全局设定 12git config --global --unset user.namegit config --global --unset user.email 生成github第一个帐号 SSH Key 12345678910111213141516171819202122ssh-keygen -t rsa -C &quot;idea360@foxmail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/cuishiying/.ssh/id_rsa): id_rsa_idea360Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in id_rsa_idea360.Your public key has been saved in id_rsa_idea360.pub.The key fingerprint is:SHA256:w6Kbf2JXBcRul4t48utPGHFBlX446qh8JUCs4NXS2tI idea360@foxmail.comThe key&#x27;s randomart image is:+---[RSA 3072]----+| + o..o... || . o = o .. || . o B ....o . || . +.E oo+ + .|| ..S+.+ o o || . .o.=o+ || . =.=. || oo.o +.. || oo.+o+oo. |+----[SHA256]-----+ 生成第二个帐号同理。 在github上添加key 1cat id_rsa_idea360.pub 登录 GitHub 账号，点击 Settings-&gt;SSH and GPG keys&gt;New SSH Key 进行添加 本地 SSH Agent中添加Key 1ssh-add -K ~&#x2F;.ssh&#x2F;id_rsa_idea360 修改 SSH config 文件 config 文件不是默认生产的，有些人可能会没有，所以可以先创建一个。先进入到 .ssh 文件中cd ~/.ssh，然后执行 touch config进行创建。 12345# idea360Host idea360.github.comHostName github.comUser gitIdentityFile ~&#x2F;.ssh&#x2F;id_rsa_idea360 OK，现在让我们测试一下配置是否成功： 12ssh -T git@idea360.github.comssh -T git@cuishiying163.github.com 如果输出以下内容： 1Hi qidian360! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 恭喜你，已经配置成功了！慢着慢着，刚才把全局设置给取消了，现在是不是要单独设置回来，没错，取消了全局设置的用户和邮箱后，我们要为每一个项目进行单独设置。 最后一步 由于我们设置了 Host，这就相当于是 HostName 的别名。比如现在对个人 GitHub 上的 repo 进行 clone 的时候，要改成 git clone git@idea360.github.com:xxx/xxx.git。即替换github.com域名为我们配置的Host 如 1git clone git@idea360.github.com:qidian360&#x2F;spring-cloud-learning.git 如果是已经克隆到本地的项目，则可以在项目中修改： 12$ git remote rm origin$ git remote add origin git@idea360.github.com:qidian360&#x2F;blog.git 可以执行 git remote -v 查看是否修改成功。 然后在每个项目中，执行： 12git config user.email &quot;idea360@foxmail.com&quot;git config user.name &quot;qidian360&quot; 对公司和个人项目单独设置用户名和邮箱。 可以查看一下： 12git config user.namegit config user.email push 的话还是照常使用：git push origin master 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"git","slug":"git","permalink":"https://idea360.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://idea360.cn/tags/git/"}]},{"title":"扫码登录流程","slug":"weixin-qr-login","date":"2020-06-04T14:24:23.000Z","updated":"2021-02-23T14:50:03.700Z","comments":true,"path":"2020/06/04/weixin-qr-login/","link":"","permalink":"https://idea360.cn/2020/06/04/weixin-qr-login/","excerpt":"","text":"概述 很多系统会对接 微信开放平台 的微信扫码登录。但是假设微信和业务帐号是 一对多 的关系。就需要我们根据微信自己实现登录了。 当然，前提是微信和业务帐号已经做了绑定。具体可参考 微信公众号开发(关注、取消、发送模板消息) 实现关注绑定。 本文主要讲解的是 微信网页开发 中的web扫码登录。 流程 以下流程中约定 PC端: 二维码载体 手机端: 微信扫码及授权载体 微信服务: 腾讯服务器 业务服务: 和业务相关联的服务 核心服务: 业务系统基础服务，这里主要指业务系统微信模块底层服务 PC请求微信扫码登录页(调用登录url) 业务服务调用核心服务，获取由核心服务返回的微信 oauth2 认证链接(传参: sessionId和callbackUrl, 核心服务缓存信息， 并将sessionId放在认证链接的state字段中) 业务服务生成url链接返回给前端,前端根据url 生成二维码 (未扫码)。 如 http://host:port/login?sessionId=123 。注意, 为了降低二维码的复杂性, 提高识别效率, url是业务服务web层url，不是核心服务返回的oauth2对应的url链接 手机端打开微信 扫码 , 实际上是调用了二维码对应的url请求 业务服务接收到上述请求后，在后台 重定向 核心服务返回的认证链接。(已扫码) 由于oauth2认证链接中配置的 redirect_url, 微信服务会把 code 返回到核心服务中 redirect_url 对应的接口 核心服务接收到 code 和 state 参数后，后台换取 openid, 然后根据 openid 去数据库中查询 业务账户信息, 然后将账户信息和sessionId返回到手机页面 手机端选择业务帐号并调用快捷登录接口，并生成token(已授权) PC端轮询到 sessionId 状态为授权状态后 获取token并校验 。(已完成) PC端轮询 sessionId 状态, 当 已完成 状态时路由到首页。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"微信","slug":"微信","permalink":"https://idea360.cn/categories/%E5%BE%AE%E4%BF%A1/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://idea360.cn/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"登录","slug":"登录","permalink":"https://idea360.cn/tags/%E7%99%BB%E5%BD%95/"},{"name":"扫码","slug":"扫码","permalink":"https://idea360.cn/tags/%E6%89%AB%E7%A0%81/"}]},{"title":"二维码前后端生成方案","slug":"qrcode","date":"2020-06-01T07:49:14.000Z","updated":"2021-02-23T14:39:21.786Z","comments":true,"path":"2020/06/01/qrcode/","link":"","permalink":"https://idea360.cn/2020/06/01/qrcode/","excerpt":"","text":"前言 二维码生产方案 Java后端生产 引入zxing包 123456789101112&lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 生成二维码并用base64编码返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Slf4jpublic class QrcodeUtil &#123; /** * 生成二维码并使用Base64编码 * * @param content 需要生产二维码的字符串 * @param width 二维码宽 * @param height 二维码高 * @return * @throws WriterException */ public static String getBase64QRCode(String content, int width, int height) &#123; MultiFormatWriter multiFormatWriter = new MultiFormatWriter(); Map hints = new HashMap(); //设置二维码四周白色区域的大小 hints.put(EncodeHintType.MARGIN, 3);//设置0-4之间 //设置二维码的容错性 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); //设置编码格式 hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;); //画二维码 BitMatrix bitMatrix = null; try &#123; bitMatrix = multiFormatWriter.encode(content, BarcodeFormat.QR_CODE, width, height, hints); &#125; catch (WriterException e) &#123; log.error(e.getMessage()); &#125; BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix); //注意此处拿到字节数据 byte[] bytes = imageToBytes(image, &quot;jpg&quot;); //Base64编码 return Base64.getEncoder().encodeToString(bytes); &#125; private static byte[] imageToBytes(BufferedImage image, String type) &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); try &#123; ImageIO.write(image, type, out); &#125; catch (IOException e) &#123; log.error(e.getLocalizedMessage()); &#125; return out.toByteArray(); &#125;&#125; web接口 123456789101112131415161718192021222324252627282930package cn.idea360.demo.modules.login;import cn.idea360.demo.common.utils.QrcodeUtil;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.OutputStream;import java.util.Base64;@RestController@RequestMapping(&quot;/qr&quot;)public class QrController &#123; /** * http://localhost:8888/qr/base64qr * * &lt;img src=&quot;data:image/jpg;base64,base64str...&quot; alt=&quot;&quot;&gt; * @return * @throws Exception */ @RequestMapping(value = &quot;/base64qr&quot;) public String getQrByBase64() throws Exception &#123; String base64QRCode = QrcodeUtil.getBase64QRCode(&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\1.jpg&quot;, 400, 400); return &quot;data:image/jpg;base64,&quot; + base64QRCode; &#125;&#125; Vue前端生产 笔者采用的是npm包管理 12&quot;@xkeshi/vue-qrcode&quot;: &quot;^1.0.0&quot;,&quot;qrcode&quot;: &quot;^1.3.2&quot;, 组件引入 1234567import VueQrcode from &#x27;@xkeshi/vue-qrcode&#x27;;export default &#123; components: &#123; VueQrcode &#125;,&#125; 使用 123456789&lt;el-table-column prop=&quot;deptQrcode&quot; header-align=&quot;center&quot; align=&quot;center&quot; label=&quot;二维码&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;vue-qrcode :value=&quot;scope.row.deptQrcode&quot; :options=&quot;&#123; size: 100 &#125;&quot;&gt;&lt;/vue-qrcode&gt; &lt;/template&gt;&lt;/el-table-column&gt; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"二维码","slug":"二维码","permalink":"https://idea360.cn/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"}]},{"title":"springboot如何展示图片","slug":"springboot-img","date":"2020-06-01T07:39:25.000Z","updated":"2021-02-23T14:46:56.111Z","comments":true,"path":"2020/06/01/springboot-img/","link":"","permalink":"https://idea360.cn/2020/06/01/springboot-img/","excerpt":"","text":"前言 本文主要做基本的图片下载示例 实现 通过字节流返回 这种方案是最基本的方案，包括oss图片链接和所有直接通过url请求的图片都是这种方式实现的。该方案的图片在浏览器可以直接打开 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.idea360.demo.modules.login;import cn.idea360.demo.common.utils.QrcodeUtil;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.OutputStream;import java.util.Base64;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@RestController@RequestMapping(&quot;/qr&quot;)public class QrController &#123; /** * 通过bytes返回图片 * http://localhost:8888/qr/img * @param response * @throws Exception */ @RequestMapping(value = &quot;/img&quot;, produces = MediaType.IMAGE_JPEG_VALUE) public void getImageByBytes(HttpServletResponse response) throws Exception&#123; File file = new File(&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\1.jpg&quot;); FileInputStream inputStream = new FileInputStream(file); byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes, 0, inputStream.available()); response.setContentType(&quot;image/jpeg&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;); OutputStream outputSream = response.getOutputStream(); outputSream.write(bytes); outputSream.flush(); &#125;&#125; 通过base64返回 该方案返回类型是base64编码的字符串, 放在h5的img标签中渲染。 1234567891011121314151617181920212223242526272829303132333435363738package cn.idea360.demo.modules.login;import cn.idea360.demo.common.utils.QrcodeUtil;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.OutputStream;import java.util.Base64;/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@RestController@RequestMapping(&quot;/qr&quot;)public class QrController &#123; /** * 通过base64返回图片 * http://localhost:8888/qr/base64img * * &lt;img src=&quot;data:image/jpg;base64,base64str...&quot; alt=&quot;&quot;&gt; * @return */ @RequestMapping(value = &quot;/base64img&quot;) public String getImageByBase64() throws Exception &#123; File file = new File(&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\1.jpg&quot;); FileInputStream inputStream = new FileInputStream(file); byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes, 0, inputStream.available()); return &quot;data:image/jpg;base64,&quot; + Base64.getEncoder().encodeToString(bytes); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"图片","slug":"图片","permalink":"https://idea360.cn/tags/%E5%9B%BE%E7%89%87/"}]},{"title":"雪花算法","slug":"algorithm-snowflake","date":"2020-05-28T15:42:41.000Z","updated":"2021-02-23T14:11:30.129Z","comments":true,"path":"2020/05/28/algorithm-snowflake/","link":"","permalink":"https://idea360.cn/2020/05/28/algorithm-snowflake/","excerpt":"","text":"概述 唯一id生成算法 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158package com.idc.order.common.utils;import org.springframework.stereotype.Component;/** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */public class SnowflakeIdWorker &#123; // ==============================Fields=========================================== /** 开始时间截 (2019-07-20) */ private final long twepoch = 1563597429000L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long datacenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; static SnowflakeIdWorker instance = new SnowflakeIdWorker(0, 0); //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; // ==============================Methods========================================== /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() &#123; long timestamp = timeGen(); //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException( String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); &#125; //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; //毫秒内序列溢出 if (sequence == 0) &#123; //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; //时间戳改变，毫秒内序列重置 else &#123; sequence = 0L; &#125; //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) // | (datacenterId &lt;&lt; datacenterIdShift) // | (workerId &lt;&lt; workerIdShift) // | sequence; &#125; /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) &#123; long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = timeGen(); &#125; return timestamp; &#125; /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() &#123; return System.currentTimeMillis(); &#125; /** * 单例工具入口 */ public static long getId() &#123; return instance.nextId(); &#125; //==============================Test============================================= /** 测试 */// public static void main(String[] args) &#123;// SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);// for (int i = 0; i &lt; 1000; i++) &#123;// long id = idWorker.nextId();// System.out.println(id);// &#125;// &#125;&#125; mybatis-plus中提取的源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.easyliao.css.utils;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.util.Assert;import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface;import java.util.concurrent.ThreadLocalRandom;public class Sequence &#123; private static final Log logger = LogFactory.getLog(Sequence.class); private final long twepoch = 1288834974657L; private final long workerIdBits = 5L; private final long datacenterIdBits = 5L; private final long maxWorkerId = 31L; private final long maxDatacenterId = 31L; private final long sequenceBits = 12L; private final long workerIdShift = 12L; private final long datacenterIdShift = 17L; private final long timestampLeftShift = 22L; private final long sequenceMask = 4095L; private final long workerId; private final long datacenterId; private long sequence = 0L; private long lastTimestamp = -1L; public Sequence() &#123; this.datacenterId = getDatacenterId(31L); this.workerId = getMaxWorkerId(this.datacenterId, 31L); &#125; public Sequence(long workerId, long datacenterId) &#123;// Assert.isFalse(workerId &gt; 31L || workerId &lt; 0L, String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, 31L), new Object[0]);// Assert.isFalse(datacenterId &gt; 31L || datacenterId &lt; 0L, String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, 31L), new Object[0]); if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuilder mpid = new StringBuilder(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (StringUtils.isNotBlank(name)) &#123; mpid.append(name.split(&quot;@&quot;)[0]); &#125; return (long)(mpid.toString().hashCode() &amp; &#x27;\\uffff&#x27;) % (maxWorkerId + 1L); &#125; protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); if (null != mac) &#123; id = (255L &amp; (long)mac[mac.length - 1] | 65280L &amp; (long)mac[mac.length - 2] &lt;&lt; 8) &gt;&gt; 6; id %= maxDatacenterId + 1L; &#125; &#125; &#125; catch (Exception var7) &#123; logger.warn(&quot; getDatacenterId: &quot; + var7.getMessage()); &#125; return id; &#125; public synchronized long nextId() &#123; long timestamp = this.timeGen(); if (timestamp &lt; this.lastTimestamp) &#123; long offset = this.lastTimestamp - timestamp; if (offset &gt; 5L) &#123; throw new RuntimeException(String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, offset)); &#125; try &#123; this.wait(offset &lt;&lt; 1); timestamp = this.timeGen(); if (timestamp &lt; this.lastTimestamp) &#123; throw new RuntimeException(String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, offset)); &#125; &#125; catch (Exception var6) &#123; throw new RuntimeException(var6); &#125; &#125; if (this.lastTimestamp == timestamp) &#123; this.sequence = this.sequence + 1L &amp; 4095L; if (this.sequence == 0L) &#123; timestamp = this.tilNextMillis(this.lastTimestamp); &#125; &#125; else &#123; this.sequence = ThreadLocalRandom.current().nextLong(1L, 3L); &#125; this.lastTimestamp = timestamp; return timestamp - 1288834974657L &lt;&lt; 22 | this.datacenterId &lt;&lt; 17 | this.workerId &lt;&lt; 12 | this.sequence; &#125; protected long tilNextMillis(long lastTimestamp) &#123; long timestamp; for(timestamp = this.timeGen(); timestamp &lt;= lastTimestamp; timestamp = this.timeGen()) &#123; &#125; return timestamp; &#125; protected long timeGen() &#123; return System.currentTimeMillis(); &#125; private static Sequence instance = new Sequence(1, 1); public static Sequence getInstance() &#123; return instance; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持。","categories":[{"name":"算法","slug":"算法","permalink":"https://idea360.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"雪花算法","slug":"雪花算法","permalink":"https://idea360.cn/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"https://idea360.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java线程调度","slug":"java-thread-scheduler","date":"2020-05-28T13:29:23.000Z","updated":"2021-02-23T14:28:17.995Z","comments":true,"path":"2020/05/28/java-thread-scheduler/","link":"","permalink":"https://idea360.cn/2020/05/28/java-thread-scheduler/","excerpt":"","text":"概述 多线程是Java开发中的基本内容, 线程有自己的生命周期，如何根据其生命周期实现调度呢？下文见分晓。 一些业务中，任务需要创建、启动、暂停、恢复、停止、销毁等操作，映射到线程就是 create、start、block、running、interrupte、stop。 在笔者的业务中, 目标是实现一个并发调度服务，每个任务的并发控制用一个线程来处理。 业务实现 线程池创建 由于线程与任务关联，每个任务的执行只是调度，无IO密集和CPU密集之说，所以不需要核心线程。直接根据任务数动态的创建和回收线程即可。 123456789101112131415161718192021/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-28 */@Configurationpublic class BeanConfig &#123; /** * 无核心线程 * 最大线程无限大 * 每个调度任务分配1个线程 * @return */ @Bean(&quot;executorService&quot;) public ExecutorService executorService() &#123; ExecutorService executorService = Executors.newCachedThreadPool(); return executorService; &#125;&#125; 作为一个服务，线程池是不需要回收的，只需要回收线程即可。线程池的使用如下: 12345@Autowiredprivate ExecutorService executorService;// 将实现了Runnable的线程加入线程池executorService.submit(task); 核心实现(任务) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-28 */@Slf4jpublic class Task implements Callable&lt;Job&gt;, Serializable &#123; // 获取不到令牌的默认休眠时间 private final Integer DEFAULT_BLOCK_TIME = 1000 * 5; private final Integer MIN_BLOCK_TIME = 500; private final Integer MAX_BLOCK_TIME = 1000 * 60 * 10; // 线程暂停标识 private volatile boolean suspend = false; // 线程运行标识 private volatile boolean running = true; // 线程锁 private final Object lock = new Object(); // 当前线程 private Thread currentThread; // 当前任务信息 private Job job; // 任务服务 private JobService jobService; // 令牌服务 private TokenService tokenService; // 呼叫服务 private CallService callService; // 任务存储 private TaskStorage taskStorage; private Task(Job job, JobService jobService, TokenService tokenService, CallService callService, TaskStorage taskStorage) &#123; this.job = job; this.jobService = jobService; this.tokenService = tokenService; this.callService = callService; this.taskStorage = taskStorage; this.onCreate(); &#125; @Override public Job call() throws Exception &#123; onStart(); currentThread = Thread.currentThread(); while (running &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; if (suspend) &#123; // 当前线程暂停 System.out.println(&quot;task:&quot; + this.job.getJobName() + &quot; suspend...&quot;); synchronized (lock) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; break; &#125; &#125; &#125; // 线程正常执行 System.out.println(&quot;\\ntask:&quot; + this.job.getJobName() + &quot; running...&quot;); // 获取到令牌 String token = tokenService.acquire(job); if (StringUtils.isNotEmpty(token)) &#123; CallData callData = jobService.loadTaskData(job); if (callData == null) &#123; // 如果没有数据，判断业务动作指令 Job taskInfo = jobService.getTaskInfo(job); if (taskInfo.getTaskAction() == TaskActionEnum.SUSPEND.getValue()) &#123; System.out.println(&quot;所有任务数据执行完成...暂停任务&quot;); this.suspend(); &#125; else if (taskInfo.getTaskAction() == TaskActionEnum.STOP.getValue()) &#123; System.out.println(&quot;所有任务数据执行完成...关闭任务&quot;); this.stop(); &#125; else &#123; System.out.println(&quot;所有任务数据执行完成...销毁任务&quot;); this.destroy(); &#125; &#125; else &#123; // 发送给外呼机器人拨打电话, 携带token, 挂机时归还token callData.setToken(token); callService.call(job, callData); continue; &#125; &#125; // 获取不到令牌, 则休眠30s后继续尝试获取令牌 try &#123; long blockTime = job.getBlockTime(); if (blockTime &lt; MIN_BLOCK_TIME || blockTime &gt; MAX_BLOCK_TIME) &#123; blockTime = DEFAULT_BLOCK_TIME; &#125; System.out.println(&quot;获取不到令牌，睡眠&quot; + blockTime/1000 + &quot;s后再次获取...&quot;); Thread.sleep(blockTime); &#125; catch (InterruptedException e) &#123; // 线程中断，当前线程结束 break; &#125; &#125; return null; &#125; /** * 获取任务信息 * @return */ public Job getJob() &#123; return job; &#125; /** * 暂停当前线程 */ public void suspend() &#123; onPause(); if (currentThread == null) &#123; throw new RuntimeException(&quot;任务未启动&quot;); &#125; this.suspend = true; &#125; /** * 唤起当前线程 */ public void resume() &#123; onResume(); if (currentThread == null) &#123; throw new RuntimeException(&quot;任务未启动&quot;); &#125; if (currentThread.isAlive() &amp;&amp; !currentThread.isInterrupted()) &#123; System.out.println(&quot;当前任务正在执行, 无需重复操作...&quot;); &#125; this.suspend = false; synchronized (lock) &#123; lock.notifyAll(); &#125; &#125; /** * 停止线程 */ public void stop() &#123; onStop(); if (currentThread == null) &#123; System.out.println(&quot;任务未启动&quot;); return;// throw new RuntimeException(&quot;任务未启动&quot;); &#125; if (!currentThread.isAlive() &amp;&amp; currentThread.isInterrupted()) &#123; System.out.println(&quot;当前任务已停止, 无需重复操作...&quot;); &#125; else &#123; currentThread.interrupt(); currentThread = null; &#125; &#125; /** * 主动销毁资源 */ public void destroy() &#123; onDestroy(); System.out.println(&quot;\\n&quot;); log.info(&quot;SchedulerService:stop:appName:[&#123;&#125;]:taskId:[&#123;&#125;]调度任务结束, 即将释放资源...&quot;, job.getAppName(), job.getTaskId()); // 清除任务基本信息 jobService.clearTaskInfo(job); // 销毁令牌 tokenService.destroyToken(job); // 停止任务 this.stop(); // 将内存中任务移除 taskStorage.removeTask(this); log.info(&quot;SchedulerService:stop:appName:[&#123;&#125;]:taskId:[&#123;&#125;]调度任务结束, 资源释放完成...&quot;, job.getAppName(), job.getTaskId()); &#125; /** * 线程创建回调 */ private void onCreate() &#123; System.out.println(&quot;\\nonCreate...&quot;); &#125; /** * 线程启动回调 */ private void onStart() &#123; System.out.println(&quot;\\nonStart...&quot;); &#125;; /** * 线程暂停回调 */ private void onPause() &#123; System.out.println(&quot;\\nonPause...&quot;); &#125;; /** * 线程唤起回调 */ private void onResume() &#123; System.out.println(&quot;\\nonResume...&quot;); &#125;; /** * 线程终止回调 */ private void onStop() &#123; System.out.println(&quot;\\nonStop...&quot;); &#125;; /** * 线程销毁回调 */ private void onDestroy() &#123; System.out.println(&quot;\\nonDestroy...&quot;); &#125;; public static Builder builder() &#123; return new Task.Builder(); &#125; public static class Builder &#123; // 任务基本信息 private Job job; // 任务数据 private JobService jobService; // 令牌管理 private TokenService tokenService; // 外呼服务 private CallService callService; // 任务存储 private TaskStorage taskStorage; public Builder() &#123; &#125; public Builder setJob(Job job) &#123; this.job = job; return this; &#125; public Builder setJobService(JobService jobService) &#123; this.jobService = jobService; return this; &#125; public Builder setTokenService(TokenService tokenService) &#123; this.tokenService = tokenService; return this; &#125; public Builder setCallService(CallService callService) &#123; this.callService = callService; return this; &#125; public Builder setTaskStorage(TaskStorage taskStorage) &#123; this.taskStorage = taskStorage; return this; &#125; public Task build() &#123; return new Task(job, jobService, tokenService, callService, taskStorage); &#125; &#125; public static void main(String[] args) throws Exception&#123; Job jobDetail = new Job(&quot;job1&quot;); ExecutorService executorService = Executors.newCachedThreadPool(); Task task = Task.builder().setJob(jobDetail).build(); Map&lt;Integer, Task&gt; tasks = new HashMap&lt;Integer, Task&gt;(); tasks.put(1, task); // 提交线程任务 Future&lt;?&gt; future = executorService.submit(task); // 暂停 TimeUnit.SECONDS.sleep(2); Task task1 = tasks.get(1); task1.suspend(); // 恢复 TimeUnit.SECONDS.sleep(2); task1.resume(); // 停止 TimeUnit.SECONDS.sleep(2); task1.stop(); // 销毁线程池 executorService.shutdown(); &#125;&#125; 调度 12345678910111213141516171819/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-28 */// 线程我们维护在map中public final static Map&lt;Serializable, Task&gt; taskMap = new ConcurrentHashMap&lt;&gt;();// 启动任务executorService.submit(task);// 暂停任务(线程阻塞)task.suspend();// 任务恢复执行task.resume();// 停止任务(回收线程,不回收令牌等其他资源，可以再次start用新线程执行任务)task.stop();// 销毁任务(回收所以资源, 由于令牌等其他业务数据被回收，除非create否则无法再次start线程)task.destroy() 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"thread","slug":"thread","permalink":"https://idea360.cn/tags/thread/"}]},{"title":"自定义RedisTemplate的spring-boot-starter","slug":"custom-redis-spring-boot-starter","date":"2020-05-27T03:22:36.000Z","updated":"2021-03-13T03:38:29.179Z","comments":true,"path":"2020/05/27/custom-redis-spring-boot-starter/","link":"","permalink":"https://idea360.cn/2020/05/27/custom-redis-spring-boot-starter/","excerpt":"","text":"pom.xml 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 参数配置 12345678910111213@ConfigurationProperties(prefix = &quot;spring.redis&quot;)public class EasyliaoRedisProperties &#123; private Boolean enable = true; public Boolean getEnable() &#123; return enable; &#125; public void setEnable(Boolean enable) &#123; this.enable = enable; &#125;&#125; Redis配置 12345678910111213141516171819202122232425262728@Configuration@EnableConfigurationProperties(EasyliaoRedisProperties.class)@ConditionalOnProperty(value = &quot;spring.redis.enable&quot;, havingValue = &quot;true&quot;)public class RedisConfiguration &#123; @Bean(&quot;redisTemplate&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) &#123; // 设置序列化 Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); // 配置redisTemplate RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;String, Object&gt;(); redisTemplate.setConnectionFactory(lettuceConnectionFactory); RedisSerializer&lt;?&gt; stringSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringSerializer);// key序列化 redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化 redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化 redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化 redisTemplate.afterPropertiesSet(); return redisTemplate; &#125;&#125; 配置spring.factories 在 resource/META-INF/spring.factories 中配置 12org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\ com.easyliao.framework.boot.redis.config.RedisConfiguration 使用 引入maven包后, 在 application.properties 中配置 spring.redis.enable=true 后可以自动注入bean, 直接调用 1234567891011@Autowiredprivate RedisTemplate&lt;String, Object&gt; redisTemplate;@Testvoid contextLoads() &#123; User user = new User(); user.setName(&quot;admin&quot;); redisTemplate.opsForValue().set(&quot;name&quot;, user); Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(name.toString());&#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"starter","slug":"starter","permalink":"https://idea360.cn/tags/starter/"},{"name":"redis","slug":"redis","permalink":"https://idea360.cn/tags/redis/"},{"name":"redisTemplate","slug":"redisTemplate","permalink":"https://idea360.cn/tags/redisTemplate/"}]},{"title":"SpringBoot使用RestTemplate做Http请求","slug":"springboot-resttemplate","date":"2020-05-26T17:18:45.000Z","updated":"2021-06-28T16:16:39.881Z","comments":true,"path":"2020/05/27/springboot-resttemplate/","link":"","permalink":"https://idea360.cn/2020/05/27/springboot-resttemplate/","excerpt":"","text":"前言 基本的网络请求 使用 配置 123456789101112131415161718192021/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Configurationpublic class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123; return new RestTemplate(factory); &#125; @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory() &#123; SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setConnectTimeout(15000); factory.setReadTimeout(5000); return factory; &#125;&#125; 测试 随便创建一个对象 1234567891011121314151617181920/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Datapublic class User &#123; private String username; private String password; // 注意需要无参构造方法 public User() &#123; &#125; public User(String username, String password) &#123; this.username = username; this.password = password; &#125;&#125; 自己提供2个接口供 RestTemplate 测试 12345678910111213141516171819202122232425262728293031323334/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@RestController@RequestMappingpublic class TestController &#123; // http://localhost:8888/user @GetMapping(&quot;/user&quot;) public User getUser() &#123; return new User(&quot;admin&quot;, &quot;123&quot;); &#125; // http://localhost:8888/user/1?name=admin&amp;age=17 @GetMapping(&quot;/user/&#123;id&#125;&quot;) public Object getInfo(@PathVariable(&quot;id&quot;) Integer id, @RequestParam String name, @RequestParam Integer age) &#123; return &quot;id=&quot; + id + &quot;;name=&quot; + name + &quot;;age=&quot; + age; &#125; // http://localhost:8888/save @PostMapping(&quot;/save&quot;) public User save(@RequestBody User user, HttpServletRequest request) &#123; user.setPassword(request.getHeader(&quot;Authorization&quot;)); return user; &#125; // http://localhost:8888/list @GetMapping(&quot;/list&quot;) public List&lt;User&gt; list() &#123; return Arrays.asList(new User(&quot;admin&quot;, &quot;456&quot;)); &#125;&#125; 单元测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@SpringBootTestclass TestControllerTest &#123; @Autowired RestTemplate restTemplate; /** * User(username=admin, password=123) */ @Test void getForEntity() &#123; ResponseEntity&lt;User&gt; response = restTemplate.getForEntity(&quot;http://localhost:8888/user&quot;, User.class); User body = response.getBody(); System.out.println(body); &#125; /** * User(username=admin, password=123) */ @Test void getForObject() &#123; User user = restTemplate.getForObject(&quot;http://localhost:8888/user&quot;, User.class); System.out.println(user); &#125; /** * User(username=admin, password=123) */ @Test void exchange() &#123; HttpHeaders httpHeaders = new HttpHeaders(); HttpEntity httpEntity = new HttpEntity(null, httpHeaders); ResponseEntity&lt;User&gt; exchange = restTemplate.exchange(&quot;http://localhost:8888/user&quot;, HttpMethod.GET, httpEntity, User.class); User body = exchange.getBody(); System.out.println(body); &#125; /** * id=1;name=当我遇上你;age=17 */ @Test void getForEntityByParams() &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;name&quot;, &quot;当我遇上你&quot;); params.put(&quot;age&quot;, 17); ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(&quot;http://localhost:8888/user/1?name=&#123;name&#125;&amp;age=&#123;age&#125;&quot;, String.class, params); System.out.println(responseEntity.getBody()); &#125; /** * id=1;name=当我遇上你;age=17 */ @Test void getForObjectByParams() &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;id&quot;, 1); params.put(&quot;name&quot;, &quot;当我遇上你&quot;); params.put(&quot;age&quot;, 17); String res = restTemplate.getForObject(&quot;http://localhost:8888/user/&#123;id&#125;?name=&#123;name&#125;&amp;age=&#123;age&#125;&quot;, String.class, params); System.out.println(res); &#125; /** * id=1;name=当我遇上你;age=17 */ @Test void getExchangeByParams() &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON)); HttpEntity httpEntity = new HttpEntity(headers); Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;id&quot;, 1); params.put(&quot;name&quot;, &quot;当我遇上你&quot;); params.put(&quot;age&quot;, 17); ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(&quot;http://localhost:8888/user/&#123;id&#125;?name=&#123;name&#125;&amp;age=&#123;age&#125;&quot;, HttpMethod.GET, httpEntity, String.class, params); System.out.println(exchange.getBody()); &#125; /** * id=1;name=当我遇上你;age=17 */ @Test void getExchangeByUriComponentsBuilder() &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON)); HttpEntity httpEntity = new HttpEntity(headers); UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(&quot;http://localhost:8888/user/1&quot;) .queryParam(&quot;name&quot;, &quot;当我遇上你&quot;) .queryParam(&quot;age&quot;, 17); ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(builder.build().encode().toUri(), HttpMethod.GET, httpEntity, String.class); System.out.println(exchange.getBody()); &#125; /** * User(username=当我遇上你, password=777) */ @Test void postForObject() &#123; HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Authorization&quot;, &quot;777&quot;); headers.setContentType(MediaType.APPLICATION_JSON); User body = new User(&quot;当我遇上你&quot;, &quot;123&quot;); HttpEntity&lt;User&gt; request = new HttpEntity&lt;&gt;(body, headers); User user = restTemplate.postForObject(&quot;http://localhost:8888/save&quot;, request, User.class); System.out.println(user); &#125; /** * [User(username=admin, password=456)] */ @Test void list1() &#123; User[] users = restTemplate.getForObject(&quot;http://localhost:8888/list&quot;, User[].class); List&lt;User&gt; list = Arrays.asList(users); System.out.println(list); &#125; /** * [User(username=admin, password=456)] */ @Test void list2() &#123; ResponseEntity&lt;List&lt;User&gt;&gt; responseEntity = restTemplate.exchange(&quot;http://localhost:8888/list&quot;, HttpMethod.GET, null, new ParameterizedTypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;); List&lt;User&gt; body = responseEntity.getBody(); System.out.println(body); &#125;&#125; 总结 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"http","slug":"http","permalink":"https://idea360.cn/tags/http/"},{"name":"restTemplate","slug":"restTemplate","permalink":"https://idea360.cn/tags/restTemplate/"}]},{"title":"SpringBoot使用RedisTemplate存储对象","slug":"springboot-redistemplate","date":"2020-05-26T16:28:56.000Z","updated":"2021-03-12T13:54:36.263Z","comments":true,"path":"2020/05/27/springboot-redistemplate/","link":"","permalink":"https://idea360.cn/2020/05/27/springboot-redistemplate/","excerpt":"","text":"概述 redis是最常用的缓存工具。SpringBoot2.x中将默认连接池更改为了 Lettuce。近期需要用redis存储对象，网上的大多不靠谱。以下为笔记。 pom.xml springboot版本为 2.3.0.RELEASE 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; Redis配置 自定义序列化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; &#123; static final byte[] EMPTY_ARRAY = new byte[0]; @Override public Object deserialize(byte[] bytes) &#123; if (isEmpty(bytes)) &#123; return null; &#125; ObjectInputStream oii = null; ByteArrayInputStream bis = null; bis = new ByteArrayInputStream(bytes); try &#123; oii = new ObjectInputStream(bis); Object obj = oii.readObject(); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override public byte[] serialize(Object object) &#123; if (object == null) &#123; return EMPTY_ARRAY; &#125; ObjectOutputStream obi = null; ByteArrayOutputStream bai = null; try &#123; bai = new ByteArrayOutputStream(); obi = new ObjectOutputStream(bai); obi.writeObject(object); byte[] byt = bai.toByteArray(); return byt; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private boolean isEmpty(byte[] data) &#123; return (data == null || data.length == 0); &#125;&#125; redisTemplate配置 12345678910111213141516171819202122/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(LettuceConnectionFactory redisConnectionFactory) &#123; StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); RedisObjectSerializer redisObjectSerializer = new RedisObjectSerializer(); RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); template.setKeySerializer(stringRedisSerializer); template.setValueSerializer(redisObjectSerializer); return template; &#125;&#125; 序列化为json 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526@Configurationpublic class RedisConfiguration &#123; @Bean(&quot;redisTemplate&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) &#123; // 设置序列化 Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); // 配置redisTemplate RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;String, Object&gt;(); redisTemplate.setConnectionFactory(lettuceConnectionFactory); RedisSerializer&lt;?&gt; stringSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringSerializer);// key序列化 redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化 redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化 redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化 redisTemplate.afterPropertiesSet(); return redisTemplate; &#125;&#125; 测试 随便写一个实体对象 123456789101112131415161718192021222324252627282930313233343536373839/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */public class User implements Serializable &#123; private String username; private String password; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 单元测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@SpringBootTestclass UserTest &#123; @Autowired private RedisTemplate&lt;String,Object&gt; template; /** * User&#123;username=&#x27;admin&#x27;, password=&#x27;123456&#x27;&#125; */ @Test public void saveValue() &#123; User u=new User(&quot;admin&quot;, &quot;123456&quot;); template.opsForValue().set(u.getUsername(), u); User result = (User) template.opsForValue().get(u.getUsername()); System.out.println(result.toString()); &#125; /** * [123456, admin] */ @Test public void saveHash()&#123; User u=new User(&quot;admin&quot;, &quot;123456&quot;); HashMap&lt;Object, Object&gt; objectHashMap = new HashMap&lt;&gt;(); objectHashMap.put(&quot;username&quot;, u.getUsername()); objectHashMap.put(&quot;password&quot;, u.getPassword()); template.opsForHash().putAll(&quot;hash&quot;, objectHashMap); List&lt;Object&gt; myCache = template.opsForHash().values(&quot;hash&quot;); System.out.println(myCache); &#125; /** * User&#123;username=&#x27;admin&#x27;, password=&#x27;123456&#x27;&#125; */ @Test public void saveList() &#123; User user = new User(&quot;admin&quot;, &quot;123456&quot;); template.opsForList().leftPush(&quot;list&quot;, user); Object rightPop = template.opsForList().rightPop(&quot;list&quot;); System.out.println(rightPop); &#125;&#125; 总结 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持。","categories":[{"name":"redis","slug":"redis","permalink":"https://idea360.cn/categories/redis/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"redis","slug":"redis","permalink":"https://idea360.cn/tags/redis/"},{"name":"redisTemplate","slug":"redisTemplate","permalink":"https://idea360.cn/tags/redisTemplate/"}]},{"title":"SpringBoot通过Redis调用Lua脚本实践笔记","slug":"springboot-redis-lua","date":"2020-05-21T16:58:26.000Z","updated":"2021-02-23T14:47:58.707Z","comments":true,"path":"2020/05/22/springboot-redis-lua/","link":"","permalink":"https://idea360.cn/2020/05/22/springboot-redis-lua/","excerpt":"","text":"概述 redis+lua可以做什么？ 限流 分布式锁 信号量 事务 相比Redis事务来说，Lua脚本有以下优点 减少网络开销： 不使用 Lua 的代码需要向 Redis 发送多次请求，而脚本只需一次即可，减少网络传输； 原子操作：Redis 将整个脚本作为一个原子执行，无需担心并发，也就无需事务； 复用：脚本会永久保存 Redis 中，其他客户端可继续使用。 代码实现 依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; redis配置 application.yml 12345678910111213spring: redis: database: 0 host: localhost port: 6379 password: timeout: 6000ms lettuce: pool: max-active: 1000 max-wait: -1ms max-idle: 10 min-idle: 5 配置RedisTemplate 1234567891011121314151617/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-21 */@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Serializable&gt; redisTemplate(LettuceConnectionFactory connectionFactory) &#123; RedisTemplate&lt;String, Serializable&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setConnectionFactory(connectionFactory); return redisTemplate; &#125;&#125; Lua脚本 在 resources/scripts/ 路径下创建 test.lua 脚本 1234567891011121314151617181920212223242526272829303132--获取KEYlocal key1 = KEYS[1]--获取参数local avg1 = ARGV[1]local avg2 = ARGV[2]--打印日志到reids--注意，这里的打印日志级别，需要和redis.conf配置文件中的日志设置级别一致才行redis.log(redis.LOG_WARNING,&quot;key1=&quot; ..key1)redis.log(redis.LOG_WARNING,&quot;avg=&quot; ..avg1, avg2)--将参数String转为数字类型--限流时间窗local expire = tonumber(ARGV[1])redis.log(redis.LOG_WARNING,&quot;时间窗=&quot; ..expire)--限流阈值local limit = tonumber(ARGV[2])redis.log(redis.LOG_WARNING,&quot;限流频次=&quot; ..limit)--当前并发数local current = tonumber(redis.call(&#x27;get&#x27;, key1) or &quot;0&quot;)redis.log(redis.LOG_WARNING,&quot;当前并发=&quot; ..current)if current + 1 &gt; limit then return 0else redis.call(&quot;INCRBY&quot;, key1, &quot;1&quot;) redis.call(&quot;expire&quot;, key1, expire) return 1end 加载lua脚本 12345678910111213141516/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-21 */@Configurationpublic class LuaConfiguration &#123; @Bean public DefaultRedisScript&lt;Long&gt; redisScript() &#123; DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(); redisScript.setResultType(Long.class); redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;scripts/test.lua&quot;))); return redisScript; &#125;&#125; 测试限流效果 12345678910111213141516171819202122232425/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-21 */@SpringBootTestclass RateLimitingServiceTest &#123; @Autowired private RedisTemplate redisTemplate; @Autowired private DefaultRedisScript&lt;Long&gt; redisScript; @Test void luaTest() &#123; List&lt;String&gt; keys = Arrays.asList(&quot;aaa&quot;); // 10秒内小于或等于3次时返回1，否则返回0 for (int i = 0; i &lt; 4; i++) &#123; Object execute = redisTemplate.execute(redisScript, keys, 10, 3); System.out.println(execute); &#125; &#125;&#125; 结果输出 12341110 可见限流生效 最后 本文到此结束，感谢阅读。原创不易, 如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"redis","slug":"redis","permalink":"https://idea360.cn/tags/redis/"},{"name":"脚本","slug":"脚本","permalink":"https://idea360.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"lua","slug":"lua","permalink":"https://idea360.cn/tags/lua/"}]},{"title":"Java批量导入时如何去除重复数据并返回结果","slug":"java-import-list-and-duplicate-remove","date":"2020-05-19T06:56:29.000Z","updated":"2021-02-23T14:24:12.980Z","comments":true,"path":"2020/05/19/java-import-list-and-duplicate-remove/","link":"","permalink":"https://idea360.cn/2020/05/19/java-import-list-and-duplicate-remove/","excerpt":"","text":"概述 本篇是 POI系列 的最后一篇。传送门 Java开发中如何用POI优雅的导出Excel文件, Java开发中如何用POI优雅的导入Excel文件. 场景分析 大多数开发中是不需要重复的数据的, 所以后端开发中需要做去重操作, 而且为了更加友好的交互, 我们需要将导入失败的数据返回给用户。一般数据重复有以下几个场景: Excel中本身存在重复数据, 即本次导入存在重复数据; 数据库中已经存在了该条数据, 即历史导入存在重复数据; 为了减轻数据库的压力, 这里在设计中引入缓存 Redis 。 整体思路如下: bitmap判断是否存在; 内存中数据是否重复; redis和mysql批量插入; 数据库中插入失败处理; 代码实现 为简化无聊的 CRUD 编写, 引入了 mybatis-plus 的逆向 generator 插件。 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idc-mp&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;idc-mp&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-generator --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 12345678910111213141516171819202122server: port: 8888spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mp_base?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true username: root password: root redis: database: 0 host: localhost port: 6379 password: # 密码（默认为空） timeout: 6000ms # 连接超时时长（毫秒） lettuce: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 mysql-schema 12345678910DROP TABLE IF EXISTS user;CREATE TABLE user( id BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, name VARCHAR(30) DEFAULT NULL UNIQUE COMMENT &#x27;姓名&#x27;, age INT(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;, email VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; generator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MysqlGenerator &#123; /** * RUN THIS */ public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/idc-mp/src/main/java&quot;); gc.setAuthor(&quot;当我遇上你&quot;); gc.setOpen(false); gc.setFileOverride(true);// 是否覆盖文件 gc.setBaseResultMap(true);// XML ResultMap gc.setBaseColumnList(true);// XML columList gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); // 实体属性 Swagger2 注解 gc.setIdType(IdType.AUTO); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setControllerName(&quot;%sController&quot;); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/mp_base?useUnicode=true&amp;serverTimezone=GMT&amp;useSSL=false&amp;characterEncoding=utf8&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;mp&quot;); pc.setParent(&quot;cn.idea360.demo.modules&quot;); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); focList.add(new FileOutConfig(&quot;/templates/mapper.xml.ftl&quot;) &#123; @Override public String outputFile(TableInfo tableInfo) &#123; // 自定义输入文件名称 return projectPath + &quot;/idc-mp/src/main/resources/mapper/&quot; + pc.getModuleName() + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML; &#125; &#125;); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); mpg.setTemplate(new TemplateConfig().setXml(null)); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel);// strategy.setSuperEntityClass(&quot;com.baomidou.mybatisplus.samples.generator.common.BaseEntity&quot;); strategy.setEntityLombokModel(true);// strategy.setSuperControllerClass(&quot;com.baomidou.mybatisplus.samples.generator.common.BaseController&quot;); strategy.setInclude(new String[]&#123;&quot;user&quot;&#125;); strategy.setRestControllerStyle(true); strategy.setSuperEntityColumns(&quot;id&quot;); strategy.setControllerMappingHyphenStyle(true);// strategy.setTablePrefix(pc.getModuleName() + &quot;_&quot;); mpg.setStrategy(strategy); // 选择 freemarker 引擎需要指定如下加，注意 pom 依赖必须有！ mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); &#125;&#125; Redis 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Serializable&gt; redisTemplate(LettuceConnectionFactory connectionFactory) &#123; RedisTemplate&lt;String, Serializable&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setConnectionFactory(connectionFactory); return redisTemplate; &#125;// @Bean// public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Serializable&gt; redisTemplate) &#123;// return redisTemplate.opsForHash();// &#125;//// @Bean// public ValueOperations&lt;String, Serializable&gt; valueOperations(RedisTemplate&lt;String, Serializable&gt; redisTemplate) &#123;// return redisTemplate.opsForValue();// &#125;//// @Bean// public ListOperations&lt;String, Serializable&gt; listOperations(RedisTemplate&lt;String, Serializable&gt; redisTemplate) &#123;// return redisTemplate.opsForList();// &#125;//// @Bean// public SetOperations&lt;String, Serializable&gt; setOperations(RedisTemplate&lt;String, Serializable&gt; redisTemplate) &#123;// return redisTemplate.opsForSet();// &#125;//// @Bean// public ZSetOperations&lt;String, Serializable&gt; zSetOperations(RedisTemplate&lt;String, Serializable&gt; redisTemplate) &#123;// return redisTemplate.opsForZSet();// &#125;&#125; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)@ApiModel(value=&quot;User对象&quot;, description=&quot;&quot;)public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; @ApiModelProperty(value = &quot;姓名&quot;) private String name; @ApiModelProperty(value = &quot;年龄&quot;) private Integer age; @ApiModelProperty(value = &quot;邮箱&quot;) private String email; public User(String name) &#123; this.name = name; &#125; /** * 因为会在List中判断user是否存在, 所以需要重写equals和hashCode方法 * @param o * @return */ @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return Objects.equals(name, user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name); &#125;&#125; HashUtils.java 123456public class HashUtils &#123; public static int hash(String data) &#123; return data.hashCode() &amp; Integer.MAX_VALUE; &#125;&#125; 核心逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * &lt;p&gt; * 服务实现类 * &lt;/p&gt; * * @author 当我遇上你 * @since 2020-05-19 */@Slf4j@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; @Autowired private RedisTemplate redisTemplate; /** * 1. bitmap判断是否存在 * 2. 内存中数据是否重复 * 3. redis和mysql批量插入 * 4. 数据库中是否插入失败 * @param list * @return */ @Override public JSONObject importBatch(List&lt;User&gt; list) &#123; if (CollectionUtils.isEmpty(list)) &#123; throw new NullPointerException(&quot;数据为空&quot;); &#125; CopyOnWriteArrayList&lt;User&gt; importFailList = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList&lt;User&gt; importSuccessList = new CopyOnWriteArrayList&lt;&gt;(); list.stream().forEach(user -&gt; &#123; Boolean exist = redisTemplate.opsForValue().getBit(&quot;user&quot;, HashUtils.hash(user.getName())); if (exist) &#123; log.error(&quot;Redis中name=&#123;&#125;的用户已存在&quot;, user.getName()); // 数据已存在，数据放入失败集合 importFailList.add(user); return; &#125; if (importSuccessList.contains(user)) &#123; log.error(&quot;内存中name=&#123;&#125;的用户已存在&quot;, user.getName()); importFailList.add(user); return; &#125; importSuccessList.add(user); &#125;); if (!CollectionUtils.isEmpty(importSuccessList)) &#123; try &#123; // 批量插入数据库 this.saveBatch(importSuccessList); &#125; catch (Exception e) &#123; log.error(&quot;MySQL写入冲突:&#123;&#125;&quot;, e.getMessage()); Iterator&lt;User&gt; iterator = importSuccessList.iterator(); while (iterator.hasNext()) &#123; User user = iterator.next(); if (user.getId() == null) &#123; log.error(&quot;MySQL中name=&#123;&#125;的用户已存在&quot;, user.getName()); importFailList.add(user); importSuccessList.remove(user); &#125; &#125; &#125; // 将导入成功的数据批量写入bitmap redisTemplate.executePipelined(new RedisCallback&lt;String&gt;() &#123; @Override public String doInRedis(RedisConnection redisConnection) throws DataAccessException &#123; importSuccessList.stream().forEach(user -&gt; &#123; redisConnection.setBit(&quot;user&quot;.getBytes(), HashUtils.hash(user.getName()), true); &#125;); return null; &#125; &#125;); &#125; JSONObject result = new JSONObject(); result.put(&quot;success&quot;, importSuccessList); result.put(&quot;failure&quot;, importFailList); return result; &#125;&#125; 场景测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Slf4j@SpringBootTestclass UserServiceImplTest &#123; @Autowired UserService userService; /** * 模拟内存中存在重复数据 * * 2020-05-19 15:18:10.468 ERROR 6612 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : 内存中name=张三的用户已存在 * 2020-05-19 15:18:10.475 WARN 6612 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@304e1e4e] was not registered for synchronization because DataSource is not transactional * 2020-05-19 15:18:10.533 INFO 6612 --- [ main] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; inited * 2020-05-19 15:18:10.794 INFO 6612 --- [ main] c.i.d.m.m.s.impl.UserServiceImplTest : &#123;&quot;success&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;&#125;],&quot;failure&quot;:[&#123;&quot;name&quot;:&quot;张三&quot;&#125;]&#125; */ @Test void importBatch1() &#123; User user1 = new User(&quot;张三&quot;); User user2 = new User(&quot;张三&quot;); List&lt;User&gt; userList = Arrays.asList(user1, user2); JSONObject result = userService.importBatch(userList); log.info(result.toJSONString()); &#125; /** * 模拟Redis中存在重复数据 * * 2020-05-19 15:18:40.700 ERROR 13352 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : Redis中name=张三的用户已存在 * 2020-05-19 15:18:40.708 WARN 13352 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@60251ddb] was not registered for synchronization because DataSource is not transactional * 2020-05-19 15:18:40.768 INFO 13352 --- [ main] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; inited * 2020-05-19 15:18:41.043 INFO 13352 --- [ main] c.i.d.m.m.s.impl.UserServiceImplTest : &#123;&quot;success&quot;:[&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;李四&quot;&#125;],&quot;failure&quot;:[&#123;&quot;name&quot;:&quot;张三&quot;&#125;]&#125; */ @Test void importBatch2() &#123; User user1 = new User(&quot;张三&quot;); User user2 = new User(&quot;李四&quot;); List&lt;User&gt; userList = Arrays.asList(user1, user2); JSONObject result = userService.importBatch(userList); log.info(result.toJSONString()); &#125; /** * 手动在MySQL中添加1条数据, 模拟MySQL中存在重复数据 * * 2020-05-19 15:19:22.337 ERROR 14128 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : Redis中name=张三的用户已存在 * 2020-05-19 15:19:22.339 ERROR 14128 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : Redis中name=李四的用户已存在 * 2020-05-19 15:19:22.347 WARN 14128 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@69fe8c75] was not registered for synchronization because DataSource is not transactional * 2020-05-19 15:19:22.405 INFO 14128 --- [ main] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; inited * 2020-05-19 15:19:22.609 ERROR 14128 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : MySQL写入冲突:cn.idea360.demo.modules.mp.mapper.UserMapper.insert (batch index #1) failed. Cause: java.sql.BatchUpdateException: Duplicate entry &#x27;王五&#x27; for key &#x27;name&#x27; * ; Duplicate entry &#x27;王五&#x27; for key &#x27;name&#x27;; nested exception is java.sql.BatchUpdateException: Duplicate entry &#x27;王五&#x27; for key &#x27;name&#x27; * 2020-05-19 15:19:22.609 ERROR 14128 --- [ main] c.i.d.m.mp.service.impl.UserServiceImpl : MySQL中name=王五的用户已存在 * 2020-05-19 15:19:22.697 INFO 14128 --- [ main] c.i.d.m.m.s.impl.UserServiceImplTest : &#123;&quot;success&quot;:[],&quot;failure&quot;:[&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;&quot;name&quot;:&quot;李四&quot;&#125;,&#123;&quot;name&quot;:&quot;王五&quot;&#125;]&#125; */ @Test void importBatch3() &#123; User user1 = new User(&quot;张三&quot;); User user2 = new User(&quot;李四&quot;); User user3 = new User(&quot;王五&quot;); List&lt;User&gt; userList = Arrays.asList(user1, user2, user3); JSONObject result = userService.importBatch(userList); log.info(result.toJSONString()); &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"excel","slug":"excel","permalink":"https://idea360.cn/tags/excel/"},{"name":"去重","slug":"去重","permalink":"https://idea360.cn/tags/%E5%8E%BB%E9%87%8D/"}]},{"title":"在Java中如何像docsify一样处理MarkDown文件","slug":"how-to-handle-markdown-like-docsify","date":"2020-05-18T03:46:53.000Z","updated":"2021-02-23T14:19:37.238Z","comments":true,"path":"2020/05/18/how-to-handle-markdown-like-docsify/","link":"","permalink":"https://idea360.cn/2020/05/18/how-to-handle-markdown-like-docsify/","excerpt":"","text":"概述 现在自己搭建博客越来越常见。在程序员的世界里更加流行用 markdown 来写博客，本文就 docsify 的后端实现部分做简单模拟。 原理 基本流程如下: 前端上传MarkDown文件 后端将文件存储在文件服务器(OSS、FastDFS、本地…) 前端根据文件名请求接口url 后端将MarkDown文件以流的形式返回 前端获取到流后根据MarkDown语法标签映射为css对应选择器(markdown-it…) 浏览器渲染 基本实现 application.yml 123456spring: servlet: multipart: max-file-size: 10240 max-request-size: 10240 enabled: true UploadController 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Slf4j@RestController@RequestMapping(&quot;/test&quot;)public class UploadController &#123; String filePath = &quot;&quot;; /** * localhost:8080/test/upload * @param file markdown文件 * @return */ @RequestMapping(value = &quot;/upload&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;) public Object upload(@RequestParam(value = &quot;file&quot;, required = false) MultipartFile file) &#123; String dir = System.getProperty(&quot;user.dir&quot;); filePath = dir + &quot;\\\\src\\\\main\\\\resources\\\\static\\\\md\\\\&quot;; String filename = file.getOriginalFilename(); File dest = new File(filePath + filename); try &#123; file.transferTo(dest); log.info(&quot;上传成功&quot;); return &quot;upload success&quot;; &#125; catch (IOException e) &#123; e.printStackTrace(); return &quot;upload failed&quot;; &#125; &#125; /** * http://localhost:8080/test/render/TEST.md * @param name markdown文件名 * @param response 以字节流的形式返回 * @throws IOException */ @GetMapping(&quot;/render/&#123;name&#125;&quot;) public void md(@PathVariable String name, HttpServletResponse response) throws IOException &#123; String dir = System.getProperty(&quot;user.dir&quot;); filePath = dir + &quot;\\\\src\\\\main\\\\resources\\\\static\\\\md\\\\&quot;; InputStream inputStream = new FileInputStream(new File(filePath, name)); OutputStream outputStream = response.getOutputStream(); response.addHeader(&quot;Content-Length&quot;, String.valueOf(inputStream.available())); response.setHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;); response.setContentType(&quot;text/markdown&quot;); IOUtils.copy(inputStream, outputStream); outputStream.flush(); &#125; /** * http://localhost:8080/test/download/TEST.md * @param name markdown文件名 * @param response 文件下载 * @throws IOException */ @GetMapping(&quot;/download/&#123;name&#125;&quot;) public void download(@PathVariable String name, HttpServletResponse response) throws IOException &#123; InputStream inputStream = new FileInputStream(new File(filePath, name)); OutputStream outputStream = response.getOutputStream(); response.setContentType(&quot;application/x-download&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + name); IOUtils.copy(inputStream, outputStream); outputStream.flush(); &#125;&#125; 响应头 request123456Accept-Ranges: bytesConnection: keep-aliveContent-Length: 23Content-Type: text/markdownDate: Mon, 18 May 2020 04:50:00 GMTKeep-Alive: timeout=60 响应体 访问 http://localhost:8080/test/render/TEST.md , 可见响应体就是我们上传的markdown文件内容 12345# Test- 1- 2- 3 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://idea360.cn/tags/markdown/"}]},{"title":"Java开发中如何用POI优雅的导入Excel文件","slug":"java-poi-import","date":"2020-05-18T02:55:45.000Z","updated":"2021-02-23T14:25:37.234Z","comments":true,"path":"2020/05/18/java-poi-import/","link":"","permalink":"https://idea360.cn/2020/05/18/java-poi-import/","excerpt":"","text":"前言 接上一篇Java开发中如何用POI优雅的导出Excel文件. 本篇基于 注解 + 反射 实现Excel导入功能的实现。 导入相对导出略复杂，需要考虑数据类型的合理转换。 实现 这里我们通过表头校验实现列数据的匹配。 废话不多说，直接上代码。相关注释已经足够完善。 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Slf4jpublic class ExcelUtils &#123; static DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); /** * * @param multipartFile * @param clz VO对象，对应Excel表头 * @param &lt;T&gt; * @throws IOException * @throws NoSuchMethodException * @throws IllegalAccessException * @throws InvocationTargetException * @throws InstantiationException */ public static &lt;T&gt; void importExcel(MultipartFile multipartFile, Class&lt;T&gt; clz) throws IOException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; if(null == multipartFile) &#123; throw new NullPointerException(&quot;请选择文件&quot;); &#125; log.info(multipartFile.getName()); log.info(&quot;文件类型:&#123;&#125;&quot;, multipartFile.getContentType()); String fileName = multipartFile.getOriginalFilename(); log.info(&quot;文件名:&#123;&#125;&quot;, fileName); if(!&quot;application/vnd.ms-excel&quot;.equals(multipartFile.getContentType())) &#123; throw new RuntimeException(&quot;请选择正确的文件类型与文件!&quot;); &#125; // 返回数据 List&lt;T&gt; list = new ArrayList&lt;&gt;(); InputStream inputStream = multipartFile.getInputStream(); Workbook wb = WorkbookFactory.create(inputStream); // 读取第一个sheet Sheet sheet = wb.getSheetAt(0); // 获取最大行数(或者sheet.getLastRowNum()) int rownum = sheet.getPhysicalNumberOfRows(); // 反射获取字段 Field[] fields = clz.getDeclaredFields(); // 获取第一行(表头) Row row = sheet.getRow(0); // 获取最大列数 int column = row.getPhysicalNumberOfCells(); // 表头校验 for (int j = 0; j &lt; fields.length; j++)&#123; Field field = fields[j]; if (field.isAnnotationPresent(ExcelHeader.class)) &#123; ExcelHeader annotation = field.getAnnotation(ExcelHeader.class); Cell cell = row.getCell(j); if (cell == null || !getCellValue(cell).equals(annotation.value())) &#123; throw new RuntimeException(&quot;Excel格式错误&quot;); &#125; &#125; &#125; // 处理行数据 for (int i = 1; i&lt;rownum; i++) &#123; row = sheet.getRow(i); // 遇到空行则结束 if (row == null) &#123; break; &#125; T rowData = clz.getDeclaredConstructor().newInstance(); // 处理列数据 for (int j = 0; j &lt; fields.length; j++)&#123; Field field = fields[j]; // 设置属性可访问 field.setAccessible(true); if (field.isAnnotationPresent(ExcelHeader.class)) &#123; ExcelHeader annotation = field.getAnnotation(ExcelHeader.class); // 这里默认按列顺序，也可以根据columnIndex设置列顺序 int columnIndex = annotation.columnIndex(); Cell cell = row.getCell(j); if (cell == null) &#123; continue; &#125; // 获取列值 Object value = getCellValue(cell); // 设置属性 setFieldValue(rowData, field, value); &#125; &#125; list.add(rowData); &#125; log.info(&quot;上传数据=&#123;&#125;&quot;, list.toString()); &#125; private static &lt;T&gt; void setFieldValue(T rowData, Field field, Object value) throws IllegalAccessException &#123; if (field.getType() == int.class || field.getType() == Integer.class) &#123; field.set(rowData, value); &#125; else if (field.getType() == long.class || field.getType() == Long.class) &#123; field.set(rowData, value); &#125; else if (field.getType() == double.class || field.getType() == Double.class) &#123; field.set(rowData, value); &#125; else if (field.getType() == String.class) &#123; field.set(rowData, String.valueOf(value)); &#125; else if (field.getType() == LocalDateTime.class) &#123; field.set(rowData, LocalDateTime.parse(String.valueOf(value), dateTimeFormatter)); &#125; &#125; private static Object getCellValue(Cell cell) &#123; CellType cellType = cell.getCellType(); Object cellValue = null; if (cellType == CellType._NONE) &#123; &#125; else if (cellType == CellType.NUMERIC) &#123; // 数值型 if (DateUtil.isCellDateFormatted(cell)) &#123; // 日期类型 Date d = cell.getDateCellValue(); cellValue = dateTimeFormatter.format(LocalDateTime.ofInstant(d.toInstant(), ZoneId.systemDefault())); &#125; else &#123; double numericCellValue = cell.getNumericCellValue(); BigDecimal bdVal = new BigDecimal(numericCellValue); if ((bdVal + &quot;.0&quot;).equals(Double.toString(numericCellValue))) &#123; // 整型 cellValue = bdVal; &#125; else if (String.valueOf(numericCellValue).contains(&quot;E10&quot;)) &#123; // 科学记数法 cellValue = new BigDecimal(numericCellValue).toPlainString(); &#125; else &#123; // 浮点型 cellValue = numericCellValue; &#125; &#125; &#125; else if (cellType == CellType.STRING) &#123; // 字符串型 cellValue = cell.getStringCellValue(); &#125; else if (cellType == CellType.FORMULA) &#123; // 公式型 &#125; else if (cellType == CellType.BLANK) &#123; // 空值 &#125; else if (cellType == CellType.BOOLEAN) &#123; // 布尔型 cellValue = cell.getBooleanCellValue(); &#125; else if (cellType == CellType.ERROR) &#123; // 错误 cellValue = cell.getErrorCellValue(); &#125; log.info(&quot;cellType=&#123;&#125;, cellValue=&#123;&#125;&quot;, cellType.name(), cellValue); return cellValue; &#125;&#125; 基本使用 123456789101112131415161718@Slf4j@RestControllerpublic class ExcelController &#123; /** * http://localhost:8080/import * @param request * @return */ @PostMapping(&quot;/import&quot;) public Object importExcel(HttpServletRequest request) throws IOException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123; if (request instanceof MultipartHttpServletRequest) &#123; MultipartFile multipartFile = ((MultipartHttpServletRequest)request).getFile(&quot;file&quot;); ExcelUtils.importExcel(multipartFile, User.class); &#125; return &quot;上传成功&quot;; &#125;&#125; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"excel","slug":"excel","permalink":"https://idea360.cn/tags/excel/"},{"name":"poi","slug":"poi","permalink":"https://idea360.cn/tags/poi/"}]},{"title":"Java开发中如何用POI优雅的导出Excel文件","slug":"java-poi-export","date":"2020-05-15T15:39:37.000Z","updated":"2021-02-23T14:24:54.399Z","comments":true,"path":"2020/05/15/java-poi-export/","link":"","permalink":"https://idea360.cn/2020/05/15/java-poi-export/","excerpt":"","text":"前言 故事是这样开始的: 公司给排了几天的工期，让完成2个功能模块的开发。其中有一个场景是这样的，从Excel导入数据，要求数据不能重复。用户可以下载导入失败的Excel文件。 这样就有2种实现 将失败数据存储数据库，需要下载时生成Excel下载即可 将失败数据生成Excel文件存储文件服务器,然后返回下载链接。 老大要求按方案二进行。好吧，导出Excel是再常见不过的功能了，然而总是觉得以前写的不够优雅，所以决定进行简单的封装，以适应简单场景的Excel导出。 实现 Excel导出的数据源一般是数据库中查询的数据。在Java开发这种面向对象的设计中，数据一般都是以对象为载体，填充在集合中的。所以入参之一便设计为Collection集合类。 导出的Excel一般需要表头说明每列数据的含义，这里计划用注解+反射来进行定义。Excel无论是通过 HttpServletResponse 还是 File 存储，本质上都是IO流操作。 具体实现如下: pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt; 注解定义 该注解添加在字段上，标识哪些字段需要导出到Excel，并且添加表头说明。 1234567891011121314151617181920212223/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ExcelHeader &#123; /** * 表头 * @return */ String value() default &quot;&quot;; /** * 列索引 * @return */ int columnIndex() default 0;&#125; 实体类 以下实体类中根据注解可知，age字段不需要导出到Excel。 123456789101112131415161718192021222324252627282930/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; @ExcelHeader(value = &quot;账号&quot;) private String username; @ExcelHeader(value = &quot;密码&quot;) private String password; @ExcelHeader(value = &quot;生日&quot;) @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime birthday; // 该字段没有添加注解, Excel不导出 private Integer age; public User(String username, String password, LocalDateTime birthday) &#123; this.username = username; this.password = password; this.birthday = birthday; &#125;&#125; 单元测试 注释已经足够清晰，这里不再过多复述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Slf4jclass IdcPoiApplicationTests &#123; @Test void contextLoads() throws NoSuchFieldException, IllegalAccessException, IOException &#123; // 创建模拟数据 User user1 = new User(&quot;admin&quot;, &quot;123456&quot;, LocalDateTime.now()); User user2 = new User(&quot;test&quot;, &quot;123456&quot;, LocalDateTime.now()); List&lt;User&gt; users = Arrays.asList(user1, user2); // 文件路径 String basePath = &quot;/Users/cuishiying/Documents/spring-cloud-learning/idc-poi/oss/&quot;; String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).format(new Date()).toString() +&quot;.xls&quot;; // 将Excel写入文件 HSSFWorkbook workbook = exportExcel(users, User.class); workbook.setSheetName(0,&quot;sheetName&quot;);//设置sheet的Name // 无论是通过HttpServletResponse导出还是导出到本地磁盘,本质都是IO操作，所以这里将IO操作提取到外层。 workbook.write(new File(basePath + File.separator + fileName)); &#125; /** * * @param data 需要导出的数据 * @param clz 数据对应的实体类 * @param &lt;T&gt; 泛型 * @return Excel文件 * @throws NoSuchFieldException * @throws IllegalAccessException */ public &lt;T&gt; HSSFWorkbook exportExcel(List&lt;T&gt; data, Class&lt;T&gt; clz) throws NoSuchFieldException, IllegalAccessException &#123; Field[] fields = clz.getDeclaredFields(); List&lt;String&gt; headers = new LinkedList&lt;&gt;(); List&lt;String&gt; variables = new LinkedList&lt;&gt;(); // 创建工作薄对象 HSSFWorkbook workbook=new HSSFWorkbook();//这里也可以设置sheet的Name // 创建工作表对象 HSSFSheet sheet = workbook.createSheet(); // 创建表头 Row rowHeader = sheet.createRow(0); // 表头处理 for (int h = 0; h &lt; fields.length; h++) &#123; Field field = fields[h]; if (field.isAnnotationPresent(ExcelHeader.class)) &#123; // 表头 if (field.isAnnotationPresent(ExcelHeader.class)) &#123; ExcelHeader annotation = field.getAnnotation(ExcelHeader.class); headers.add(annotation.value()); rowHeader.createCell(h).setCellValue(annotation.value()); &#125; // 字段 variables.add(field.getName()); &#125; &#125; // 数据处理 for (int i = 0; i &lt; data.size() ; i++) &#123; //创建工作表的行(表头占用1行, 这里从第二行开始) HSSFRow row = sheet.createRow(i + 1); // 获取一行数据 T t = data.get(i); Class&lt;?&gt; aClass = t.getClass(); // 填充列数据 for (int j = 0; j &lt; variables.size(); j++) &#123; Field declaredField = aClass.getDeclaredField(variables.get(j)); declaredField.setAccessible(true); String key = declaredField.getName(); Object value = declaredField.get(t); row.createCell(j).setCellValue(value.toString()); &#125; &#125; log.info(&quot;Excel文件创建成功&quot;); return workbook; &#125;&#125; Web导出 123456789101112131415161718192021222324252627282930313233/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-27 */@Slf4j@RestControllerpublic class ExcelController &#123; /** * http://localhost:8080/export * @param response * @throws Exception */ @GetMapping(&quot;export&quot;) public void export(HttpServletResponse response) throws Exception&#123; // 创建模拟数据 User user1 = new User(&quot;admin&quot;, &quot;123456&quot;, LocalDateTime.now()); User user2 = new User(&quot;test&quot;, &quot;123456&quot;, LocalDateTime.now()); List&lt;User&gt; users = Arrays.asList(user1, user2); // TODO 日期的处理可以在数据部分处理好, 然后@JsonIgnore注释LocalDateTime类型的字段即可 HSSFWorkbook workbook = ExcelUtils.exportExcel(users, User.class); workbook.setSheetName(0,&quot;sheetName&quot;);//设置sheet的Name String downloadName = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).format(new Date()).toString() +&quot;.xls&quot;; response.setContentType(&quot;application/vnd.ms-excel;charset=utf-8&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+ URLEncoder.encode(downloadName, StandardCharsets.UTF_8)); OutputStream outputStream = response.getOutputStream(); workbook.write(outputStream); outputStream.close(); &#125;&#125; 总结 上边的案例只是表达基本设计思路。大家项目中使用的话还请斟酌。本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"excel","slug":"excel","permalink":"https://idea360.cn/tags/excel/"},{"name":"poi","slug":"poi","permalink":"https://idea360.cn/tags/poi/"}]},{"title":"MySQL联表查询操作之left-join","slug":"mysql-left-join","date":"2020-05-14T13:18:20.000Z","updated":"2021-02-23T14:39:02.038Z","comments":true,"path":"2020/05/14/mysql-left-join/","link":"","permalink":"https://idea360.cn/2020/05/14/mysql-left-join/","excerpt":"","text":"概述 对于中小体量的项目而言，联表查询是再常见不过的操作了，尤其是在做报表的时候。然而校对数据的时候，您发现坑了吗？本篇文章就mysql常用联表查询复现常见的坑。 基础环境 建表语句 123456789101112131415161718192021222324252627282930313233DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `role_name` VARCHAR(50) DEFAULT NULL COMMENT &#x27;角色名&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;角色表&#x27;;insert into `role` VALUES(1, &#x27;管理员&#x27;);insert into `role` VALUES(2, &#x27;总经理&#x27;);insert into `role` VALUES(3, &#x27;科长&#x27;);insert into `role` VALUES(4, &#x27;组长&#x27;);DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `role_id` int(11) NOT NULL COMMENT &#x27;角色id&#x27;, `user_name` VARCHAR(50) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `sex` int(1) DEFAULT 0 COMMENT &#x27;性别&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27;;insert into `user` VALUES(1, 1, &#x27;admin&#x27;, 1);insert into `user` VALUES(2, 2, &#x27;王经理&#x27;, 1);insert into `user` VALUES(3, 2, &#x27;李经理&#x27;, 2);insert into `user` VALUES(4, 2, &#x27;张经理&#x27;, 2);insert into `user` VALUES(5, 3, &#x27;王科长&#x27;, 1);insert into `user` VALUES(6, 3, &#x27;李科长&#x27;, 1);insert into `user` VALUES(7, 3, &#x27;吕科长&#x27;, 2);insert into `user` VALUES(8, 3, &#x27;邢科长&#x27;, 1);insert into `user` VALUES(9, 4, &#x27;范组长&#x27;, 2);insert into `user` VALUES(10, 4, &#x27;赵组长&#x27;, 2);insert into `user` VALUES(11, 4, &#x27;姬组长&#x27;, 1); 数据如下 12345678910111213141516171819202122232425262728mysql&gt; select * from role;+----+-----------+| id | role_name |+----+-----------+| 1 | 管理员 || 2 | 总经理 || 3 | 科长 || 4 | 组长 |+----+-----------+4 rows in set (0.00 sec)mysql&gt; select * from user;+----+---------+-----------+------+| id | role_id | user_name | sex |+----+---------+-----------+------+| 1 | 1 | admin | 1 || 2 | 2 | 王经理 | 1 || 3 | 2 | 李经理 | 2 || 4 | 2 | 张经理 | 2 || 5 | 3 | 王科长 | 1 || 6 | 3 | 李科长 | 1 || 7 | 3 | 吕科长 | 2 || 8 | 3 | 邢科长 | 1 || 9 | 4 | 范组长 | 2 || 10 | 4 | 赵组长 | 2 || 11 | 4 | 姬组长 | 1 |+----+---------+-----------+------+11 rows in set (0.00 sec) 基本业务 简单信息报表: 查询用户信息 123456789101112131415161718192021mysql&gt; SELECT -&gt; id, -&gt; user_name AS &#x27;姓名&#x27;, -&gt; ( CASE WHEN sex = 1 THEN &#x27;男&#x27; WHEN sex = 2 THEN &#x27;女&#x27; ELSE &#x27;未知&#x27; END ) AS &#x27;性别&#x27; -&gt; FROM -&gt; USER;+----+-----------+--------+| id | 姓名 | 性别 |+----+-----------+--------+| 1 | admin | 男 || 2 | 王经理 | 男 || 3 | 李经理 | 女 || 4 | 张经理 | 女 || 5 | 王科长 | 男 || 6 | 李科长 | 男 || 7 | 吕科长 | 女 || 8 | 邢科长 | 男 || 9 | 范组长 | 女 || 10 | 赵组长 | 女 || 11 | 姬组长 | 男 |+----+-----------+--------+ 查询每个角色名称及对应人员中女性数量 123456789101112131415161718192021mysql&gt; SELECT -&gt; r.id, -&gt; r.role_name AS role, -&gt; count( u.sex ) AS sex -&gt; FROM -&gt; role r -&gt; LEFT JOIN USER u ON r.id = u.role_id -&gt; AND u.sex = 2 -&gt; GROUP BY -&gt; r.role_name -&gt; ORDER BY -&gt; r.id ASC;+----+-----------+-----+| id | role | sex |+----+-----------+-----+| 1 | 管理员 | 0 || 2 | 总经理 | 2 || 3 | 科长 | 1 || 4 | 组长 | 2 |+----+-----------+-----+4 rows in set (0.00 sec) 假如我们把性别过滤的条件改为where操作结果会怎么样呢？ 123456789101112131415161718192021mysql&gt; SELECT -&gt; r.id, -&gt; r.role_name AS role, -&gt; count( u.sex ) AS sex -&gt; FROM -&gt; role r -&gt; LEFT JOIN USER u ON r.id = u.role_id -&gt; WHERE -&gt; u.sex = 2 -&gt; GROUP BY -&gt; r.role_name -&gt; ORDER BY -&gt; r.id ASC;+----+-----------+-----+| id | role | sex |+----+-----------+-----+| 2 | 总经理 | 2 || 3 | 科长 | 1 || 4 | 组长 | 2 |+----+-----------+-----+3 rows in set (0.00 sec) 这里可以看到角色数据不完整了。 找出角色为总经理的员工数量 12345678910111213141516171819mysql&gt; SELECT -&gt; r.id, -&gt; r.role_name AS role, -&gt; count( u.sex ) AS sex -&gt; FROM -&gt; role r -&gt; LEFT JOIN USER u ON r.id = u.role_id -&gt; WHERE -&gt; r.role_name = &#x27;总经理&#x27; -&gt; GROUP BY -&gt; r.role_name -&gt; ORDER BY -&gt; r.id ASC;+----+-----------+-----+| id | role | sex |+----+-----------+-----+| 2 | 总经理 | 3 |+----+-----------+-----+1 row in set (0.00 sec) 同样将过滤条件由where改为on 123456789101112131415161718192021mysql&gt; SELECT -&gt; r.id, -&gt; r.role_name AS role, -&gt; count( u.sex ) AS sex -&gt; FROM -&gt; role r -&gt; LEFT JOIN USER u ON r.id = u.role_id -&gt; AND r.role_name = &#x27;总经理&#x27; -&gt; GROUP BY -&gt; r.role_name -&gt; ORDER BY -&gt; r.id ASC;+----+-----------+-----+| id | role | sex |+----+-----------+-----+| 1 | 管理员 | 0 || 2 | 总经理 | 3 || 3 | 科长 | 0 || 4 | 组长 | 0 |+----+-----------+-----+4 rows in set (0.00 sec) 这里可以看到数据多余了 总结 在left join语句中，左表过滤必须放where条件中，右表过滤必须放on条件中，这样结果才能不多不少，刚刚好。 本文到此结束。感谢阅读，如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"},{"name":"连表","slug":"连表","permalink":"https://idea360.cn/tags/%E8%BF%9E%E8%A1%A8/"}]},{"title":"Java基础之反射","slug":"java-reflect","date":"2020-05-13T15:11:20.000Z","updated":"2021-02-23T14:00:13.299Z","comments":true,"path":"2020/05/13/java-reflect/","link":"","permalink":"https://idea360.cn/2020/05/13/java-reflect/","excerpt":"","text":"反射基本介绍 基本过程: 1、编译Java文件，生成.class文件 2、使用Java虚拟机（JVM）将字节码文件（字节码文件在内存中使用Class类表示）加载到内存 4、使用反射的时候，首先获取到Class类，就可以得到class文件里的所有内容，包含属性、构造方法、普通方法 5、属性通过Filed类表示、构造方法通过Constructor表示、普通方法通过Method表示 API学习 接口定义 123public interface Pc &#123; void run();&#125; 实现类 123456789101112131415161718192021222324252627282930313233343536373839404142public class Dell implements Pc &#123; // 私有变量 private String cpu; public int price; // 无参构造方法 public Dell() &#123; &#125; // 有构造方法 public Dell(String cpu) &#123; this.cpu = cpu; &#125; @Override public void run() &#123; System.out.println(&quot;Dell PC&quot;); &#125; public String getCpu() &#123; return cpu; &#125; public void setCpu(String cpu) &#123; this.cpu = cpu; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; // 私有方法 private void desc() &#123; System.out.println(&quot;私有方法: 散热不好&quot;); &#125;&#125; API学习 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@Slf4jpublic class ReflectEntrance &#123; public static void main(String[] args) throws Exception&#123; // 1. Class.forName() Class&lt;?&gt; dClazz = Class.forName(&quot;com.example.ref.Dell&quot;); log.info(&quot;Class.forName()=======:&#123;&#125;&quot;, dClazz); // 2. 类名.class Class&lt;Dell&gt; dClazz2 = Dell.class; log.info(&quot;类名.class=======:&#123;&#125;&quot;, dClazz); // 3. 对象.getClass() Dell dell = new Dell(); Class&lt;?&gt; dClazz3 = dell.getClass(); log.info(&quot;对象.getClass()=======:&#123;&#125;&quot;, dClazz3); System.out.println(&quot;\\r&quot;); // 获取所有的公共方法(没有private),但是有它所有有关联的类的方法，包括接口，它的父类Object Method[] methods = dClazz.getMethods(); for (Method method: methods) &#123; log.info(&quot;dClazz.getMethods()=======:&#123;&#125;&quot;, method.getName()); &#125; System.out.println(&quot;\\r&quot;); // 可以得到当前类的所有的方法: 包括私有的方法 Method[] declaredMethods = dClazz.getDeclaredMethods(); for(Method method : declaredMethods) log.info(&quot;dClazz.getDeclaredMethods()=======:&#123;&#125;&quot;, method.getName()); System.out.println(&quot;\\r&quot;); // 获取Dell实现的所有的接口 Class&lt;?&gt;[] interfaces = dClazz.getInterfaces(); for(Class&lt;?&gt;inter : interfaces) log.info(&quot;dClazz.getInterfaces()=======:&#123;&#125;&quot;, inter); System.out.println(&quot;\\r&quot;); // 获取公共变量 Field[] fields = dClazz.getFields(); for(Field field : fields) log.info(&quot;dClazz.getFields()=======:&#123;&#125;&quot;, field); System.out.println(&quot;\\r&quot;); // 获取私有变量 Field[] declaredFields = dClazz.getDeclaredFields(); for(Field field : declaredFields) log.info(&quot;dClazz.getDeclaredFields()=======:&#123;&#125;&quot;, field.getName()); System.out.println(&quot;\\r&quot;); // 获取构造器 Constructor&lt;?&gt;[] constructors = dClazz.getConstructors(); for (Constructor&lt;?&gt; c : constructors) log.info(&quot;dClazz.getConstructors()=======:&#123;&#125;&quot;, c); System.out.println(&quot;\\r&quot;); // 获取父类 Class&lt;?&gt; superclass = dClazz.getSuperclass(); log.info(&quot;dClazz.getSuperclass()=======:&#123;&#125;&quot;, superclass); // 默认就是Object System.out.println(&quot;\\r&quot;); // 用反射创建实例 Dell dell1 = (Dell)dClazz.newInstance(); log.info(&quot;dClazz.newInstance()=======:&#123;&#125;&quot;, dell1); dell1.run(); System.out.println(&quot;\\r&quot;); // 设置变量 Field cpu = dClazz.getDeclaredField(&quot;cpu&quot;); cpu.setAccessible(true); cpu.set(dell1, &quot;intel&quot;); log.info(&quot;设置变量=======:&#123;&#125;&quot;, dell1.getCpu()); System.out.println(&quot;\\r&quot;); // 调用方法 Method setCpu = dClazz.getDeclaredMethod(&quot;setCpu&quot;, String.class); setCpu.setAccessible(true); setCpu.invoke(dell1, &quot;AMD&quot;); log.info(&quot;调用方法=======:&#123;&#125;&quot;, dell1.getCpu()); System.out.println(&quot;\\r&quot;); // 操作构造方法 Constructor&lt;?&gt; declaredConstructor = dClazz.getDeclaredConstructor(String.class); Dell hw = (Dell)declaredConstructor.newInstance(&quot;华为&quot;); log.info(&quot;构造方法=======:&#123;&#125;&quot;, hw.getCpu()); &#125;&#125; 输出结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454623:24:02.109 [main] INFO com.example.ref.ReflectEntrance - Class.forName()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:class com.example.ref.Dell23:24:02.117 [main] INFO com.example.ref.ReflectEntrance - 类名.class&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:class com.example.ref.Dell23:24:02.117 [main] INFO com.example.ref.ReflectEntrance - 对象.getClass()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:class com.example.ref.Dell23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:run23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:getPrice23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:setPrice23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:setCpu23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:getCpu23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:wait23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:wait23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:wait23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:equals23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:toString23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:hashCode23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:getClass23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:notify23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:notifyAll23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:run23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:desc23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:getPrice23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:setPrice23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:setCpu23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredMethods()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:getCpu23:24:02.118 [main] INFO com.example.ref.ReflectEntrance - dClazz.getInterfaces()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:interface com.example.ref.Pc23:24:02.119 [main] INFO com.example.ref.ReflectEntrance - dClazz.getFields()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:public int com.example.ref.Dell.price23:24:02.119 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredFields()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:cpu23:24:02.119 [main] INFO com.example.ref.ReflectEntrance - dClazz.getDeclaredFields()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:price23:24:02.119 [main] INFO com.example.ref.ReflectEntrance - dClazz.getConstructors()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:public com.example.ref.Dell()23:24:02.119 [main] INFO com.example.ref.ReflectEntrance - dClazz.getConstructors()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:public com.example.ref.Dell(java.lang.String)23:24:02.119 [main] INFO com.example.ref.ReflectEntrance - dClazz.getSuperclass()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:class java.lang.Object23:24:02.120 [main] INFO com.example.ref.ReflectEntrance - dClazz.newInstance()&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:com.example.ref.Dell@3a5ed7a6Dell PC23:24:02.120 [main] INFO com.example.ref.ReflectEntrance - 设置变量&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:intel23:24:02.121 [main] INFO com.example.ref.ReflectEntrance - 调用方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:AMD23:24:02.121 [main] INFO com.example.ref.ReflectEntrance - 构造方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;:华为 有参构造反射 12345678910public static ConfigService createConfigService(Properties properties) throws NacosException &#123; try &#123; Class&lt;?&gt; driverImplClass = Class.forName(&quot;com.alibaba.nacos.client.config.NacosConfigService&quot;); Constructor constructor = driverImplClass.getConstructor(Properties.class); ConfigService vendorImpl = (ConfigService) constructor.newInstance(properties); return vendorImpl; &#125; catch (Throwable e) &#123; throw new NacosException(NacosException.CLIENT_INVALID_PARAM, e); &#125;&#125; 简单演示场景 我们做一个对象转map的演示: 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-28 */public class User implements Serializable &#123; private String username; private String password; public User() &#123; &#125; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 通过反射操作字段变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @author 当我遇上你 * @公众号 当我遇上你 * @since 2020-05-28 */@Slf4jpublic class BeanUtils &#123; /** * 对象转map * @param o * @param &lt;T&gt; * @return * @throws IllegalAccessException */ public static &lt;T&gt; Map&lt;String, Object&gt; obj2map(T o) throws IllegalAccessException &#123; Class&lt;?&gt; aClass = o.getClass(); Field[] declaredFields = aClass.getDeclaredFields(); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); for (int j = 0; j &lt; declaredFields.length; j++) &#123; Field declaredField = declaredFields[j]; // 获取属性 String key = declaredField.getName(); declaredField.setAccessible(true); // 获取属性值 Object value = declaredField.get(o); log.info(&quot;key=&#123;&#125;, value=&#123;&#125;&quot;, key, value == null? &quot;&quot; : value.toString()); map.put(key, value); &#125; return map; &#125; /** * map转对象 * @param map * @param beanClass * @return * @throws Exception */ public static Object map2Obj(Map&lt;Object, Object&gt; map, Class&lt;?&gt; beanClass) throws Exception &#123; if (map == null) return null; Object obj = beanClass.getDeclaredConstructor().newInstance(); Field[] fields = obj.getClass().getDeclaredFields(); for (Field field : fields) &#123; int mod = field.getModifiers(); if(Modifier.isStatic(mod) || Modifier.isFinal(mod))&#123; continue; &#125; Class&lt;?&gt; type = field.getType(); Object o = convertValType(map.get(field.getName()), type); field.setAccessible(true); field.set(obj, o); &#125; return obj; &#125; private static Object convertValType(Object value, Class&lt;?&gt; fieldTypeClass) &#123; Object retVal = null; if (Long.class.getName().equals(fieldTypeClass.getName()) || long.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Long.parseLong(value.toString()); &#125; else if (Integer.class.getName().equals(fieldTypeClass.getName()) || int.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Integer.parseInt(value.toString()); &#125; else if (Float.class.getName().equals(fieldTypeClass.getName()) || float.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Float.parseFloat(value.toString()); &#125; else if (Double.class.getName().equals(fieldTypeClass.getName()) || double.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Double.parseDouble(value.toString()); &#125; else &#123; retVal = value; &#125; return retVal; &#125; public static void main(String[] args) throws Exception&#123; User user = new User(&quot;admin&quot;, &quot;123456&quot;); Map&lt;String, Object&gt; map = BeanUtils.obj2map(user); System.out.println(map); Object o = BeanUtils.map2Obj(map, User.class); System.out.println(o); &#125;&#125; 输出 12&#123;password&#x3D;123456, username&#x3D;admin&#125;User&#123;username&#x3D;&#39;admin&#39;, password&#x3D;&#39;123456&#39;&#125; 最后 本文到此结束。感谢阅读，如果您觉得不错，请关注公众号【当我遇上你】支持一下。","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"反射","slug":"反射","permalink":"https://idea360.cn/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"教你如何用PPT创建数据结构与算法演示动画","slug":"how-to-create-animation-by-ppt","date":"2020-05-06T13:34:27.000Z","updated":"2021-02-23T14:19:01.890Z","comments":true,"path":"2020/05/06/how-to-create-animation-by-ppt/","link":"","permalink":"https://idea360.cn/2020/05/06/how-to-create-animation-by-ppt/","excerpt":"","text":"前言 写技术博客总会有一种感觉，图文并茂才能够讲解的更加清晰。尤其是在《数据结构与算法》部分。本文基于 PPT 教大家如何用PPT简单实现演示动画。 环境 MacOS PPT for mac 16.34 动画制作 下边做个简单的排序交换动画来演示制作过程。 绘制图形元素 点击 插入——&gt;形状 , 选择我们需要的形状并添加文字描述。图中的矩形以下称呼为 动画单元 动画制作 点击 动画——&gt;动画窗格, 展示动作管理列表。选中 动画单元3, 路径动画按钮变为可编辑状态。选择 直线 绘制动画路径。 默认的路径是垂直的，选中绘制的箭头 路径 ，效果选项变为可编辑状态。点击右(代表由左向右运动)。 同理，选中 动画单元2 编辑，结果如下: 如果动画需要同时执行(表现为交换动画)，则按下图进行设置。至此，已完成了我们的动画演示的第一步(1和2进行交换)。后续同理。 导出动画 PPT有自带的gif导出功能，但是我测试的不管用。大家可以导出视频转为gif即可。 最后 本文到此结束，如果您觉得不错，请分享转发给身边的朋友。欢迎关注公众号【当我遇上你】，您的支持是我最大的动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"ppt","slug":"ppt","permalink":"https://idea360.cn/tags/ppt/"},{"name":"动画","slug":"动画","permalink":"https://idea360.cn/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"Flex布局教程","slug":"css-flex-learning","date":"2020-05-04T11:56:17.000Z","updated":"2021-02-23T14:13:03.432Z","comments":true,"path":"2020/05/04/css-flex-learning/","link":"","permalink":"https://idea360.cn/2020/05/04/css-flex-learning/","excerpt":"","text":"前言 本篇为学习笔记。内容来自网络。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局 CSS Grid Layout，可以同时处理行和列上的布局。 基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;项目&quot;。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 容器属性 flex-direction flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap flex-wrap决定如何换行 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。(2个属性组合) justify-content justify-content属性定义了项目在主轴上的对齐方式。(默认是水平方向对齐方式，如水平居中等) flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items align-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴 项目属性 以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 案例 默认布局 html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/html&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;content box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css 123456789101112131415.content &#123; width: 210px; height: 210px; border: 1px solid red;&#125;.item &#123; width: 60px; height: 60px; background-color: blue; margin: 10px;&#125;.box &#123; display: flex; flex-direction: row;&#125; 主轴row水平居中 12345.box &#123; display: flex; flex-direction: row; justify-content: center;&#125; 主轴column水平居中 12345.box &#123; display: flex; flex-direction: column; align-items: center;&#125; 主轴row垂直居中 12345.box &#123; display: flex; flex-direction: row; align-items: center;&#125; 主轴column垂直居中 12345.box &#123; display: flex; flex-direction: column; justify-content: center;&#125; 水平垂直居中 12345.box &#123; display: flex; justify-content: center; align-items: center;&#125; 参考 https://www.ruanyifeng.com/blog/2015/07/flex-examples.html https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox","categories":[{"name":"css","slug":"css","permalink":"https://idea360.cn/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://idea360.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://idea360.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"CSS 定位详解","slug":"css-position-learning","date":"2020-05-03T08:08:23.000Z","updated":"2021-02-23T14:12:43.469Z","comments":true,"path":"2020/05/03/css-position-learning/","link":"","permalink":"https://idea360.cn/2020/05/03/css-position-learning/","excerpt":"","text":"前言 作为一个后台开发，最不爱写的就是CSS。然而有些时候还是要了解CSS。本文作为前端学习的第一篇，主要讲定位部分。position属性用来指定一个元素在网页上的位置，一共有5种定位方式 static(默认) relative fixed absolute sticky 定义 static static是position属性的默认值。如果省略position属性，浏览器就认为该元素是static定位。 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative relative表示，相对于默认位置（即static时的位置）进行偏移，即定位基点是元素的默认位置。 它必须搭配top、bottom、left、right这四个属性一起使用，用来指定偏移的方向和距离。 absolute absolute表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。 它有一个重要的限制条件：定位基点（一般是父元素）不能是static定位，否则定位基点就会变成整个网页的根元素html。 另外，absolute定位也必须搭配top、bottom、left、right这四个属性一起使用。 fixed fixed表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。 元素的位置通过left、top、right以及bottom属性进行规定。 sticky sticky跟前面四个属性值都不一样，它会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口）。比如型表格滚动的时候，表头始终固定。 sticky生效的前提是，必须搭配top、bottom、left、right这四个属性一起使用，不能省略，否则等同于relative定位，不产生&quot;动态固定&quot;的效果。原因是这四个属性用来定义&quot;偏移距离&quot;，浏览器把它当作sticky的生效门槛。 示例 默认定位static html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box&quot; id=&quot;one&quot;&gt;One&lt;/div&gt; &lt;div class=&quot;box&quot; id=&quot;two&quot;&gt;Two&lt;/div&gt; &lt;div class=&quot;box&quot; id=&quot;three&quot;&gt;Three&lt;/div&gt; &lt;div class=&quot;box&quot; id=&quot;four&quot;&gt;Four&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css 1234567891011121314.box &#123; display: inline-block; width: 100px; height: 100px; background: red; color: white;&#125;#two &#123; position: static; top: 20px; left: 20px; background: blue;&#125; 相对定位relative 相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。下面的例子中，注意未应用定位的其它元素是按照 “Two” 在正常位置的情况下进行布局的。 将上述代码样式改为: 1234567891011121314.box &#123; display: inline-block; width: 100px; height: 100px; background: red; color: white;&#125;#two &#123; position: relative; top: 20px; left: 20px; background: blue;&#125; 绝对定位absolute 相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。 父元素static定位 123456789101112131415161718.content &#123; margin-left: 100px; border: 2px solid blue;&#125;.box &#123; display: inline-block; width: 100px; height: 100px; background: red; color: white;&#125;#two &#123; position: absolute; top: 20px; left: 20px; background: blue;&#125; 父元素realtive定位 12345678910111213141516171819.content &#123; margin-left: 100px; border: 2px solid blue; position: relative;&#125;.box &#123; display: inline-block; width: 100px; height: 100px; background: red; color: white;&#125;#two &#123; position: absolute; top: 20px; left: 20px; background: blue;&#125; 固定定位fixed 固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。在下面的示例中，“One” 元素定位在离页面顶部 80px，离页面左侧 20px 的位置。 html 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/html&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;header&quot;&gt;Header&lt;/div&gt; &lt;div class=&quot;blank&quot;&gt;&lt;/div&gt; &lt;p&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; 我是内容~ &lt;br/&gt; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css 123456789101112131415.content &#123; width: 500px; height: 200px; overflow: scroll;&#125;.header &#123; width: 100%; height: 50px; background: red; color: white; position: fixed;&#125;p &#123; margin-top: 50px;&#125; 粘性布局sticky 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。 html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/html&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;dl&gt; &lt;dt&gt;A&lt;/dt&gt; &lt;dd&gt;Andrew W.K.&lt;/dd&gt; &lt;dd&gt;Apparat&lt;/dd&gt; &lt;dd&gt;Arcade Fire&lt;/dd&gt; &lt;dd&gt;At The Drive-In&lt;/dd&gt; &lt;dd&gt;Aziz Ansari&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;C&lt;/dt&gt; &lt;dd&gt;Chromeo&lt;/dd&gt; &lt;dd&gt;Common&lt;/dd&gt; &lt;dd&gt;Converge&lt;/dd&gt; &lt;dd&gt;Crystal Castles&lt;/dd&gt; &lt;dd&gt;Cursive&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;E&lt;/dt&gt; &lt;dd&gt;Explosions In The Sky&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;T&lt;/dt&gt; &lt;dd&gt;Ted Leo &amp; The Pharmacists&lt;/dd&gt; &lt;dd&gt;T-Pain&lt;/dd&gt; &lt;dd&gt;Thrice&lt;/dd&gt; &lt;dd&gt;TV On The Radio&lt;/dd&gt; &lt;dd&gt;Two Gallants&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css 12345678910111213141516171819202122232425262728293031* &#123; box-sizing: border-box;&#125;.content &#123; width: 500px; height: 200px; overflow: scroll;&#125;dl &#123; margin: 0; padding: 24px 0 0 0;&#125;dt &#123; background: #B8C1C8; border-bottom: 1px solid #989EA4; border-top: 1px solid #717D85; color: #FFF; margin: 0; padding: 2px 0 0 12px; position: -webkit-sticky; position: sticky; top: -1px;&#125;dd &#123; margin: 0; padding: 0 0 0 12px; white-space: nowrap;&#125;dd + dd &#123; border-top: 1px solid #CCC&#125; 本文到此结束，感谢阅读。欢迎关注公众号【当我遇上你】。您的关注是我最大的动力。 参考 https://developer.mozilla.org/zh-CN/docs/Web/CSS/position https://www.ruanyifeng.com/blog/2019/11/css-position.html","categories":[{"name":"css","slug":"css","permalink":"https://idea360.cn/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://idea360.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://idea360.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Docker实战之Gitlab搭建","slug":"docker-gitlab","date":"2020-05-01T18:47:38.000Z","updated":"2021-02-23T14:17:04.807Z","comments":true,"path":"2020/05/02/docker-gitlab/","link":"","permalink":"https://idea360.cn/2020/05/02/docker-gitlab/","excerpt":"","text":"前言 GitLab 是一个用于仓库管理系统的开源项目。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用。 搭建过程 docker-compose-gitlab.yml 1234567891011121314151617181920212223242526272829303132333435web: image: &#x27;gitlab/gitlab-ce:latest&#x27; container_name: gitlab restart: always hostname: &#x27;192.168.124.5:8888&#x27; environment: GITLAB_OMNIBUS_CONFIG: | external_url &#x27;http://192.168.124.5&#x27; # Add any other gitlab.rb configuration here, each on its own line # nginx # nginx[&#x27;redirect_http_to_https&#x27;] = true # nginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/tfss.me.cer&quot; # nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/tfss.me.key&quot; # nginx[&#x27;real_ip_header&#x27;] = &#x27;X-Real-IP&#x27; # nginx[&#x27;real_ip_recursive&#x27;] = &#x27;on&#x27; # nginx[&#x27;listen_port&#x27;] = 8081 # email setting # gitlab_rails[&#x27;smtp_enable&#x27;] = true # gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.gmail.com&quot; # gitlab_rails[&#x27;smtp_port&#x27;] = 587 # gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;my.email@gmail.com&quot; # gitlab_rails[&#x27;smtp_password&#x27;] = &quot;my-gmail-password&quot; # gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;smtp.gmail.com&quot; # gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot; # gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true # gitlab_rails[&#x27;smtp_tls&#x27;] = false # gitlab_rails[&#x27;smtp_openssl_verify_mode&#x27;] = &#x27;peer&#x27; ports: - &#x27;8888:80&#x27; - &#x27;442:443&#x27; - &#x27;21:22&#x27; volumes: - &#x27;$HOME/app/gitlab/config:/etc/gitlab&#x27; - &#x27;$HOME/app/gitlab/logs:/var/log/gitlab&#x27; - &#x27;$HOME/app/gitlab/data:/var/opt/gitlab&#x27; 启动 1docker-compose -f docker-compose-gitlab.yml up -d 访问 1http:&#x2F;&#x2F;192.168.124.5:8888&#x2F; 然后设置初始root密码即可。 最后 谨以此做笔记，方便开发测试。","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"https://idea360.cn/tags/gitlab/"}]},{"title":"微信公众号开发(关注、取消、发送模板消息)","slug":"weixin-mp-develop","date":"2020-04-23T15:55:43.000Z","updated":"2021-02-23T14:49:43.672Z","comments":true,"path":"2020/04/23/weixin-mp-develop/","link":"","permalink":"https://idea360.cn/2020/04/23/weixin-mp-develop/","excerpt":"","text":"前言 现在很多业务会基于微信公众号实现。笔者做这部分开发的时候，项目不允许再引入外部jar包，故做的相当蛋疼。这里是总结时写的demo节选。 如何将xml消息转换成json对象？ xstream maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.12&lt;/version&gt;&lt;/dependency&gt; 消息原型(xmlString) 12345678&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[gh_d0c6b73cc08e]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[oHOLJw-r6lBxSXU4pRDKpoDyqWI0]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1587459486&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt; &lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt; &lt;EventKey&gt;&lt;![CDATA[]]&gt;&lt;/EventKey&gt; &lt;/xml&gt; 对应的java对象 123456789101112131415161718192021222324252627282930@Data@XStreamAlias(&quot;xml&quot;)public class XmlMessage implements Serializable &#123; @XStreamAlias(&quot;ToUserName&quot;) @XStreamConverter(XStreamCDataConverter.class) private String toUser; @XStreamAlias(&quot;FromUserName&quot;) @XStreamConverter(XStreamCDataConverter.class) private String fromUser; @XStreamAlias(&quot;CreateTime&quot;) private Long createTime; @XStreamAlias(&quot;MsgType&quot;) @XStreamConverter(XStreamCDataConverter.class) private String msgType; @XStreamAlias(&quot;Event&quot;) @XStreamConverter(XStreamCDataConverter.class) private String event; @XStreamAlias(&quot;EventKey&quot;) @XStreamConverter(XStreamCDataConverter.class) private String eventKey; @XStreamAlias(&quot;Ticket&quot;) @XStreamConverter(XStreamCDataConverter.class) private String ticket; @XStreamAlias(&quot;MsgID&quot;) private Long msgId; @XStreamAlias(&quot;Status&quot;) @XStreamConverter(value = XStreamCDataConverter.class) private String status;&#125; 123456789public class XStreamCDataConverter extends StringConverter &#123; public XStreamCDataConverter() &#123; &#125; public String toString(Object obj) &#123; return &quot;&lt;![CDATA[&quot; + super.toString(obj) + &quot;]]&gt;&quot;; &#125;&#125; 类型转换 1234567891011@Testvoid xml2ObjectByXStream() &#123; XStream xStream = new XStream(); XStream.setupDefaultSecurity(xStream); xStream.allowTypes(new Class[]&#123;XmlMessage.class&#125;); xStream.processAnnotations(XmlMessage.class); XmlMessage message = (XmlMessage)xStream.fromXML(xmlString); log.info(message.toString());&#125; w3c.Dom 类型转换 123456789101112131415161718192021222324@Testvoid xml2ObjectByDom() throws Exception&#123; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); InputSource is = new InputSource(new StringReader(xmlString)); Document document = builder.parse(is); // xml标签 Element rootElement = document.getDocumentElement(); NodeList childNodes = rootElement.getChildNodes(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); for (int i = 0; i &lt; childNodes.getLength(); i++) &#123; Node node = childNodes.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; Element child = (Element) node; String nodeName = child.getNodeName(); String textContent = child.getTextContent(); map.put(nodeName, textContent); &#125; &#125; log.info(map.toString());&#125; dom4j maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt; 类型转换 12345678910111213@Testvoid xml2ObjectByDom4j() throws Exception&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(16); SAXReader saxReader = new SAXReader(); org.dom4j.Document doc = saxReader.read(new StringReader(xmlString)); org.dom4j.Element root = doc.getRootElement(); List&lt;org.dom4j.Element&gt; elements = root.elements(); for (org.dom4j.Element element : elements) &#123; map.put(element.getName(), element.getTextTrim()); &#125; log.info(map.toString());&#125; Json对象如何适配字段格式？ 微信公众号默认的模板消息结构如下 1234567891011&#123; &quot;touser&quot;: &quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;, &quot;template_id&quot;: &quot;7BsKKP1MsDxbNmfYfTaNVm9guRvgwH8l2PmFbDCMip0&quot;, &quot;url&quot;: &quot;http://idea360.cn&quot;, &quot;data&quot;: &#123; &quot;name&quot;: &#123; &quot;value&quot;: &quot;登高射太阳！&quot;, &quot;color&quot;: &quot;#173177&quot; &#125; &#125;&#125; 消息占位符字典的形式很难扩展，所以我们想办法把它变为List集合处理 maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt;&lt;/dependency&gt; 消息结构定义 1234567@Datapublic class WeixinTemplateMessage implements Serializable &#123; private String toUser; private String templateId; private String url; private List&lt;WeixinTemplateData&gt; data;&#125; 123456@Datapublic class WeixinTemplateData implements Serializable &#123; private String key; private String value; private String color;&#125; 类型转换适配器 1234567891011121314151617181920212223public class TemplateMessageGsonAdapter implements JsonSerializer&lt;WeixinTemplateMessage&gt; &#123; @Override public JsonElement serialize(WeixinTemplateMessage message, Type typeOfSrc, JsonSerializationContext context) &#123; JsonObject messageJson = new JsonObject(); messageJson.addProperty(&quot;touser&quot;, message.getToUser()); messageJson.addProperty(&quot;template_id&quot;, message.getTemplateId()); messageJson.addProperty(&quot;url&quot;, message.getUrl()); JsonObject data = new JsonObject(); messageJson.add(&quot;data&quot;, data); WeixinTemplateData item; JsonObject dataJson; for(Iterator itemData = message.getData().iterator(); itemData.hasNext(); data.add(item.getKey(), dataJson)) &#123; item = (WeixinTemplateData)itemData.next(); dataJson = new JsonObject(); dataJson.addProperty(&quot;value&quot;, item.getValue()); dataJson.addProperty(&quot;color&quot;, item.getColor()); &#125; return messageJson; &#125;&#125; gson注册转换器 123456789101112131415public class WeixinGsonBuilder &#123; private static final GsonBuilder INSTANCE = new com.google.gson.GsonBuilder(); public WeixinGsonBuilder() &#123; &#125; public static Gson create() &#123; return INSTANCE.create(); &#125; static &#123; INSTANCE.registerTypeAdapter(WeixinTemplateMessage.class, new TemplateMessageGsonAdapter()); &#125;&#125; 格式转换 123456789101112131415161718@Testvoid gsonAdapter() &#123; WeixinTemplateMessage weixinTemplateMessage = new WeixinTemplateMessage(); weixinTemplateMessage.setTemplateId(&quot;7BsKKP1MsDxbNmfYfTaNVm9guRvgwH8l2PmFbDCMip0&quot;); weixinTemplateMessage.setToUser(&quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;); weixinTemplateMessage.setUrl(&quot;http://idea360.cn&quot;); WeixinTemplateData weixinTemplateData = new WeixinTemplateData(); weixinTemplateData.setKey(&quot;name&quot;); weixinTemplateData.setValue(&quot;当我遇上你&quot;); weixinTemplateData.setColor(&quot;#ff0000&quot;); weixinTemplateMessage.setData(Arrays.asList(weixinTemplateData)); String message = WeixinGsonBuilder.create().toJson(weixinTemplateMessage); log.info(message);&#125; 结果输出发现就是前边我们需要的 json 格式。 消息推送 根据上述 gson 对模板消息的处理。参照 微信公众号接口学习 一文，即可轻松实现模板消息的推送。 模板没有创建接口，在公众号后台配置即可。 关注与取关 关注与取关的实现都是基于微信的事件推送来实现的。上述关于 xml 消息的处理即是为这里做铺垫。微信默认的推送消息是xml格式的。这里需要注意的是: 认证后的公众号有EncodingAESKey, 即可实现消息的加密选项。 微信事件推送接口和签名校验接口地址相同，区别在于时间推送接口基于 POST。 对于事件推送的处理的伪代码如下: 123456789101112131415161718192021222324252627282930@Overridepublic void handleEvent(String encType, String timestamp, String nonce, String signature, String xmlMessage, String msgSignature) throws WxException &#123; logger.info(&quot;收到微信推送消息:encType=&#123;&#125;, timestamp=&#123;&#125;, nonce=&#123;&#125;, signature=&#123;&#125;, xmlMessage=&#123;&#125;&quot;, encType, timestamp, nonce, signature, xmlMessage); WxMpXmlMessage message = null; XStream xStream = new XStream(); XStream.setupDefaultSecurity(xStream); xStream.allowTypes(new Class[]&#123;WxMpXmlMessage.class&#125;); xStream.processAnnotations(WxMpXmlMessage.class); if (encType == null) &#123; // 明文传输的消息 message = (WxMpXmlMessage)xStream.fromXML(xmlMessage); &#125; else if (&quot;aes&quot;.equalsIgnoreCase(encType)) &#123; // aes加密的消息 WxMpCryptUtil cryptUtil = new WxMpCryptUtil(wxMpService.getWxMpConfigStorage()); String plainText = cryptUtil.decrypt(msgSignature, timestamp, nonce, xmlMessage); logger.debug(&quot;解密后的原始xml消息内容：&#123;&#125;&quot;, plainText); message = (WxMpXmlMessage)xStream.fromXML(plainText); &#125; if (message.getMsgType().equals(&quot;event&quot;)) &#123; wxMpEventHandlerFactory.handler(message.getEvent(), message); &#125;&#125; 这里由于事件比较多，我们可以基于 工厂+策略 的模式来做业务处理。 定义handler接口 123456public interface WxMpEventHandler &#123; String event(); void handler(WxMpXmlMessage message) throws WxException;&#125; handler实现 123456789101112131415161718@Componentpublic class SubscribeHandler implements WxMpEventHandler &#123; private static final Logger logger = LoggerFactory.getLogger(SubscribeHandler.class); @Override public String event() &#123; return &quot;subscribe&quot;; &#125; @Transactional(rollbackFor = Exception.class) @Override public void handler(WxMpXmlMessage message) throws WxException &#123; // 可以获取个人信息，绑定系统账户 logger.info(&quot;有新用户关注:&#123;&#125;&quot;, userInfo); &#125;&#125; 工厂类实现 123456789101112131415161718192021222324252627@Componentpublic class WxMpEventHandlerFactory implements ApplicationContextAware &#123; private static final Logger logger = LoggerFactory.getLogger(WxMpEventHandlerFactory.class); private static Map&lt;String, WxMpEventHandler&gt; handlerMap = new HashMap&lt;&gt;(); public WxMpEventHandlerFactory() &#123; &#125; public void handler(String event, WxMpXmlMessage message) throws WxException &#123; WxMpEventHandler eventHandler = handlerMap.get(event); if (null != eventHandler) &#123; eventHandler.handler(message); &#125; else &#123; logger.error(&quot;暂无该类型消息处理器&quot;); &#125; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; Map&lt;String, WxMpEventHandler&gt; beansOfType = applicationContext.getBeansOfType(WxMpEventHandler.class); for (WxMpEventHandler bean : beansOfType.values()) &#123; handlerMap.put(bean.event(), bean); &#125; &#125;&#125; 事件处理 123if (message.getMsgType().equals(&quot;event&quot;)) &#123; wxMpEventHandlerFactory.handler(message.getEvent(), message);&#125; 最后 本篇到此结束。代码比较多，节选了关键代码。大家如有疑问可公众号【当我遇上你】后台留言。感谢阅读。","categories":[{"name":"公众号","slug":"公众号","permalink":"https://idea360.cn/categories/%E5%85%AC%E4%BC%97%E5%8F%B7/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://idea360.cn/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"公众号","slug":"公众号","permalink":"https://idea360.cn/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"maven学习笔记","slug":"maven-learning","date":"2020-04-21T16:28:57.000Z","updated":"2021-02-23T14:38:17.598Z","comments":true,"path":"2020/04/22/maven-learning/","link":"","permalink":"https://idea360.cn/2020/04/22/maven-learning/","excerpt":"","text":"仓库 本地仓库 12 &lt;!-- Default: $&#123;user.home&#125;/.m2/repository--&gt;&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; Aliyun仓库 第一步:修改 maven 根目录下的 conf 文件夹中的 setting.xml 文件，在 mirrors 节点上，添加内容如下： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 第二步: pom.xml文件里添加： 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 仓库安全认证 有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中配置，这些信息可以配置在settings.xml中. 12345678910111213141516171819202122232425262728293031323334353637&lt;servers&gt; &lt;server&gt; &lt;id&gt;idea360_server&lt;/id&gt; &lt;username&gt;idea360&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt;&lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;idea360_server&lt;/id&gt; &lt;name&gt;idea360 Repository&lt;/name&gt; &lt;url&gt;http://svn.idea360.cn:8082/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/profile&gt;&lt;profile&gt; &lt;id&gt;jdk-11&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;11&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;11&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 发布到私服配置 pom.xml 12345678910&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;idea360_server&lt;/id&gt; &lt;url&gt;http://svn.idea360.cn:8082/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;idea360_server&lt;/id&gt; &lt;url&gt;http://svn.idea360.cn:8082/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 注意：id应该与setting.xml中保持一致 私服浏览 访问 http://svn.idea360.cn:8082/ , 登录后即可看到仓库。 默认仓库说明 maven-central：maven中央库，默认从https://repo1.maven.org/maven2/拉取jar maven-releases：私库发行版jar，初次安装请将Deployment policy设置为Allow redeploy maven-snapshots：私库快照（调试版本）jar maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml或项目pom.xml中使用 本地完整配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;pluginGroups/&gt; &lt;proxies/&gt; &lt;servers&gt; &lt;server&gt; &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt; &lt;id&gt;idea360_server&lt;/id&gt; &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;username&gt;idea360&lt;/username&gt; &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; &lt;id&gt;aliyun-public&lt;/id&gt; &lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 镜像名称 --&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyun-google&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;阿里云谷歌仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/google&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyun-apache&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;阿里云阿帕奇仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyun-spring&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;阿里云spring仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyun-plugin&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;阿里云spring插件仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;!-- profile的唯一标识 --&gt; &lt;id&gt;idea360&lt;/id&gt; &lt;!-- 自动触发profile的条件逻辑 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;11&lt;/jdk&gt; &lt;/activation&gt; &lt;!-- 扩展属性列表 --&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;11&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;!-- 远程仓库列表 --&gt; &lt;repositories&gt; &lt;!-- 阿里云spring仓库 --&gt; &lt;repository&gt; &lt;id&gt;spring&lt;/id&gt; &lt;name&gt;aliyun Repository&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;!-- 公司私服 --&gt; &lt;repository&gt; &lt;id&gt;idea360_server&lt;/id&gt; &lt;name&gt;idea360 Repository&lt;/name&gt; &lt;url&gt;http://idea360.cn:8082/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 插件仓库列表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 阿里云spring插件 --&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;idea360&lt;/activeProfile&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"maven","slug":"maven","permalink":"https://idea360.cn/categories/maven/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://idea360.cn/tags/maven/"}]},{"title":"Dubbo入门demo","slug":"dubbo-demo","date":"2020-04-21T15:56:21.000Z","updated":"2020-04-21T16:12:02.859Z","comments":true,"path":"2020/04/21/dubbo-demo/","link":"","permalink":"https://idea360.cn/2020/04/21/dubbo-demo/","excerpt":"","text":"概述 初次接触 Dubbo, 先跑个 Hello World, 看看dubbo微服务究竟是如何运作的。下边是快速启动的完整项目。 服务接口 首先创建一个 dubbo-api 服务,用来暴露服务接口 服务接口maven pom.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo-demo&lt;/artifactId&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 服务接口定义 DemoService.java 1234public interface DemoService &#123; String sayHello(String name);&#125; 服务提供者 服务提供方maven 创建 dubbo-provider 服务 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo-demo&lt;/artifactId&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt; &lt;!-- 打包方式 --&gt; &lt;!--&lt;packaging&gt;jar&lt;/packaging&gt;--&gt; &lt;properties&gt; &lt;!-- 源文件编码格式 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- jdk编译源码版本 --&gt; &lt;jdk.compile.source.version&gt;1.8&lt;/jdk.compile.source.version&gt; &lt;!-- jdk编译目标版本 --&gt; &lt;jdk.compile.target.version&gt;1.8&lt;/jdk.compile.target.version&gt; &lt;!-- springframework版本 --&gt; &lt;springframe.version&gt;5.1.5.RELEASE&lt;/springframe.version&gt; &lt;!-- junit版本 --&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;!-- log4j版本 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;!-- dubbo版本 --&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;!-- zookeeper版本 --&gt; &lt;zookeeper.version&gt;3.4.6&lt;/zookeeper.version&gt; &lt;!-- zkclient版本 --&gt; &lt;zkclient.version&gt;0.1&lt;/zkclient.version&gt; &lt;/properties&gt; &lt;!-- 依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;springframe.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 构建配置 --&gt; &lt;build&gt; &lt;finalName&gt;Provider&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;cn.idea360.provider.Provider&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在服务提供方实现接口 DemoServiceImpl.java 12345public class DemoServiceImpl implements DemoService &#123; public String sayHello(String name) &#123; return &quot;Hello &quot; + name; &#125;&#125; 用 Spring 配置声明暴露服务 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=&quot;dubbo-provider&quot; /&gt; &lt;!-- 使用zookeeper广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; client=&quot;zkclient&quot; /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=&quot;cn.idea360.api.DemoService&quot; ref=&quot;demoService&quot; /&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id=&quot;demoService&quot; class=&quot;cn.idea360.provider.DemoServiceImpl&quot; /&gt;&lt;/beans&gt; 加载 Spring 配置 Provider.java： 12345678910111213package cn.idea360.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;&quot;dubbo/provider.xml&quot;&#125;); context.start(); System.out.println(&quot;服务已经启动...&quot;); System.in.read(); // 按任意键退出 &#125;&#125; 服务消费者 服务消费者maven 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo-demo&lt;/artifactId&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-consumer&lt;/artifactId&gt; &lt;!-- 打包方式 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;!-- 源文件编码格式 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- jdk编译源码版本 --&gt; &lt;jdk.compile.source.version&gt;1.8&lt;/jdk.compile.source.version&gt; &lt;!-- jdk编译目标版本 --&gt; &lt;jdk.compile.target.version&gt;1.8&lt;/jdk.compile.target.version&gt; &lt;!-- springframework版本 --&gt; &lt;springframe.version&gt;5.1.5.RELEASE&lt;/springframe.version&gt; &lt;!-- junit版本 --&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;!-- log4j版本 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;!-- dubbo版本 --&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;!-- zookeeper版本 --&gt; &lt;zookeeper.version&gt;3.4.6&lt;/zookeeper.version&gt; &lt;!-- zkclient版本 --&gt; &lt;zkclient.version&gt;0.1&lt;/zkclient.version&gt; &lt;/properties&gt; &lt;!-- 依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;springframe.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 构建配置 --&gt; &lt;build&gt; &lt;finalName&gt;Consumer&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 通过 Spring 配置引用远程服务 consumer.xml： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=&quot;dubbo-consumer&quot; /&gt; &lt;!-- 使用zookeeper广播注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; client=&quot;zkclient&quot; /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;cn.idea360.api.DemoService&quot; /&gt;&lt;/beans&gt; 加载Spring配置，并调用远程服务 Consumer.java 1234567891011121314package cn.idea360.consumer;import cn.idea360.api.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;&quot;dubbo/consumer.xml&quot;&#125;); context.start(); DemoService demoService = (DemoService)context.getBean(&quot;demoService&quot;); // 获取远程服务代理 String hello = demoService.sayHello(&quot;world&quot;); // 执行远程方法 System.out.println( hello ); // 显示调用结果 &#125;&#125; 该接口需单独打包，在服务提供方和消费方共享 对服务消费方隐藏实现 也可以使用 IoC 注入 最后 本篇纯属入门笔记。参照 官方说明 的入门demo。大家绕道即可。","categories":[{"name":"dubbo","slug":"dubbo","permalink":"https://idea360.cn/categories/dubbo/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://idea360.cn/tags/dubbo/"}]},{"title":"微信公众号接口学习","slug":"wechat-api-learning","date":"2020-04-18T03:38:09.000Z","updated":"2021-02-23T14:49:34.435Z","comments":true,"path":"2020/04/18/wechat-api-learning/","link":"","permalink":"https://idea360.cn/2020/04/18/wechat-api-learning/","excerpt":"","text":"概述 微信公众号的集成现在在很多业务上都需要。看着官方一大堆的 文档，大家可能不知道如何下手。本篇从 api 入手和大家一起了解下公众号在业务上如何集成。 基础环境 公众号的开发需要认证的服务号，不过官方也提供了 测试帐号 供开发测试。 开发过程中需要的环境如下: 测试号 公网 内网穿透 公网主要用于接收微信推送消息，比方有新用户关注、取消关注等事件。 如果大家没有公网，可以通过内网穿透来本机调试。比较常用的有 ngrok、Sunny-Ngrok、natapp、花生壳、钉钉 等。 笔者这里用的 Sunny-Ngrok 免费版，不过网络不稳定，经常断开。 测试号 验证 接口配置信息, 需要启动程序响应公众平台验证。验证通过即可响应公众平台事件消息, 比方说 关注事件, 然后将微信用户与平台用户进行 绑定。 回调域名配置。编辑网页服务-网页帐号，配置如下: 回调验证 这里基于 Java 实现，笔者采用的 SpringBoot。 application.properties 12345server.port=80wx.appID=wx3f2f5354f615c639wx.appsecret=80ae2299328c6c8f6ae0c774a69b08b0wx.token=123456 工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Arrays;public class SHA1 &#123; public static String gen(String... arr) &#123; Arrays.sort(arr); StringBuilder sb = new StringBuilder(); String[] parr = arr; int size = arr.length; for(int i = 0; i &lt; size; ++i) &#123; String a = parr[i]; sb.append(a); &#125; return sha1(sb.toString()); &#125; public static String sha1(String str) &#123; try &#123; MessageDigest digest = MessageDigest.getInstance(&quot;SHA-1&quot;); digest.update(str.getBytes()); byte[] messageDigest = digest.digest(); // Create Hex String StringBuffer hexString = new StringBuffer(); // 字节数组转换为 十六进制 数 for (int i = 0; i &lt; messageDigest.length; i++) &#123; String shaHex = Integer.toHexString(messageDigest[i] &amp; 0xFF); if (shaHex.length() &lt; 2) &#123; hexString.append(0); &#125; hexString.append(shaHex); &#125; return hexString.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125;&#125; 123456789101112131415161718/** * 签名校验 * @param timestamp * @param nonce * @param signature * @return */public boolean checkSignature(String timestamp, String nonce, String signature) &#123; try &#123; return SHA1.gen(new String[]&#123;wxConfig.getToken(), timestamp, nonce&#125;).equals(signature); &#125; catch (Exception e) &#123; logger.error(&quot;签名校验失败: &#123;&#125;&quot;, e.getMessage()); return false; &#125;&#125; 签名校验与回调消息接收 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@RestController@RequestMapping(&quot;/weixin/sign&quot;)public class WxPortalController &#123; private static final Logger logger = LoggerFactory.getLogger(WxPortalController.class); @Autowired private WxService wxService; /** * * @param signature 微信加密签名 * @param timestamp 时间戳 * @param nonce 随机数 * @param echostr 随机字符串 * @return */ @GetMapping(produces = &quot;text/plain;charset=utf-8&quot;) public String authGet(@RequestParam(name = &quot;signature&quot;, required = false) String signature, @RequestParam(name = &quot;timestamp&quot;, required = false) String timestamp, @RequestParam(name = &quot;nonce&quot;, required = false) String nonce, @RequestParam(name = &quot;echostr&quot;, required = false) String echostr) &#123; logger.info(&quot;\\n接收到来自微信服务器的认证消息：[&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;]&quot;, signature, timestamp, nonce, echostr); if (wxService.checkSignature(timestamp, nonce, signature)) &#123; return echostr; &#125; return &quot;非法请求&quot;; &#125; /** * * @param requestBody 回调消息 * @param signature * @param timestamp * @param nonce * @param openid * @param encType * @param msgSignature * @return */ @PostMapping(produces = &quot;application/xml; charset=UTF-8&quot;) public String post(@RequestBody String requestBody, @RequestParam(&quot;signature&quot;) String signature, @RequestParam(&quot;timestamp&quot;) String timestamp, @RequestParam(&quot;nonce&quot;) String nonce, @RequestParam(&quot;openid&quot;) String openid, @RequestParam(name = &quot;encrypt_type&quot;, required = false) String encType, @RequestParam(name = &quot;msg_signature&quot;, required = false) String msgSignature) &#123; // 获取到openId logger.info(&quot;\\n接收微信请求：[openid=[&#123;&#125;], [signature=[&#123;&#125;], encType=[&#123;&#125;], msgSignature=[&#123;&#125;],&quot; + &quot; timestamp=[&#123;&#125;], nonce=[&#123;&#125;], requestBody=[\\n&#123;&#125;\\n] &quot;, openid, signature, encType, msgSignature, timestamp, nonce, requestBody); try &#123; wxService.handleEvent(requestBody); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 至此，微信的基本开发就ok了。大家可以根据回调事件的消息做相应的业务处理。 接口分析 获取 access_token 基本所有的接口调用都需要 access_token。 GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=wx3f2f5354f615c639&amp;secret=80ae2299328c6c8f6ae0c774a69b08b0 Response 1234&#123; &quot;access_token&quot;: &quot;32_S2GVg7DuHc1VxsHY5Hf9kdqCCP1BBI9pBv-ZvK_JHtN1HTjXyN0NmIPYvRHZwkiHy7cDA_944K9V0WU3_XC3GuL8Q8rVF93PDXGDZpuN8-3V6gKFELbEnrF-sN-Ps24he8zrQs8Db_gxqrtYULKeAFAYPO&quot;, &quot;expires_in&quot;: 7200&#125; 获取用户基本信息 GET https://api.weixin.qq.com/cgi-bin/user/info?access_token=32_ybQmVgsXDCHKSiG3bRIL7xRq1Y39sKVylwUOMQls8IKlpY5dqiycEPvQmzBvsl2REtAi11WUSn5Nc29ZnOddO0V8Rll0RtKw6WLtwgzhr3_4h5-I1pGShVa1KuD1GQXcPIKblSae5Bt8PkxiVEHjACAFOR&amp;openid=oHOLJw-r6lBxSXU4pRDKpoDyqWI0&amp;lang=zh_CN Response 123456789101112131415161718&#123; &quot;subscribe&quot;: 1, &quot;openid&quot;: &quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;, &quot;nickname&quot;: &quot;当我遇上你&quot;, &quot;sex&quot;: 1, &quot;language&quot;: &quot;zh_CN&quot;, &quot;city&quot;: &quot;朝阳&quot;, &quot;province&quot;: &quot;北京&quot;, &quot;country&quot;: &quot;中国&quot;, &quot;headimgurl&quot;: &quot;http://thirdwx.qlogo.cn/mmopen/RFKUCMNiaHBDu2OOyCcvq5uTIteIlicusVTVUVNtIicjSyNY2su0eSYAIUzDtlAkE3Ff6uaKN8UvryLwicX1c2OeLNHJR3ibBeo9G/132&quot;, &quot;subscribe_time&quot;: 1587187948, &quot;remark&quot;: &quot;&quot;, &quot;groupid&quot;: 0, &quot;tagid_list&quot;: [], &quot;subscribe_scene&quot;: &quot;ADD_SCENE_QR_CODE&quot;, &quot;qr_scene&quot;: 0, &quot;qr_scene_str&quot;: &quot;1234567&quot;&#125; 基于 Oauth2 获得授权码，需要在微信客户端打开 GET https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx3f2f5354f615c639&amp;redirect_uri=http://idcmind.com/weixin/sign&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE Java代码web接口 123456789101112@RestController@RequestMapping(&quot;/weixin/code&quot;)public class WxCodeController &#123; private static final Logger logger = LoggerFactory.getLogger(WxCodeController.class); @GetMapping public Object code(@RequestParam(&quot;code&quot;) String code, @RequestParam(&quot;state&quot;) String state) &#123; logger.info(&quot;code=&#123;&#125;, state=&#123;&#125;&quot;, code, state); return code; &#125;&#125; 微信端访问日志 1code&#x3D;061PRu4d2jOFiH0Kh83d2Hig4d2PRu4m, state&#x3D;123456 获取 OpenId GET 带入刚才获得的 code https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx3f2f5354f615c639&amp;secret=80ae2299328c6c8f6ae0c774a69b08b0&amp;code=061PRu4d2jOFiH0Kh83d2Hig4d2PRu4m&amp;grant_type=authorization_code Response 1234567&#123; &quot;access_token&quot;: &quot;32_kCTsG4G6Vp-p2NWQQbelmpTshAHldad7XNBf9FFAtUn6QwhNHuFIM9utpRaabhn4NcT5ObK4XY4_Hc3wWPf5nMVs0zqXtOL5YJvB7Lk2XBg&quot;, &quot;expires_in&quot;: 7200, &quot;refresh_token&quot;: &quot;32_oO-cHAoZdugyzJ0uvi49_E81PsddQdO7pBSGjjlmxZqRcXBGqu1aVHQRu4TW_T7_FuGMF4te3CxtCvc7H_21tfqOPWSJMEalhBrgQ3Is8K4&quot;, &quot;openid&quot;: &quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;, &quot;scope&quot;: &quot;snsapi_base&quot;&#125; openid 是微信用户在 公众号 的唯一身份标识。 获取用户基本信息(UnionID机制-网页开发获取用户信息， 此处的token和公众号token不是一个token) GET https://api.weixin.qq.com/sns/userinfo?access_token=36_9LM_Fr2s2yfcJRlF6Zz9sDdARIXXrVNJFutEh8bURe2NoglsLzeBUiGlYQhhWePWllTOnf1_8vZFwUll97tD-NC5KFq6Gz37uFgDfo7ZIFwZEG7JgTCecJikRkCRqAvjp4_R68u9KdgomRFTTCLeACAHQZ&amp;openid=oHOLJw-r6lBxSXU4pRDKpoDyqWI0&amp;lang=zh_CN Response 123456789101112&#123; &quot;openid&quot;: &quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;, &quot;nickname&quot;: &quot;当我遇上你&quot;, &quot;sex&quot;:&quot;1&quot;, &quot;province&quot;:&quot;朝阳&quot;, &quot;city&quot;:&quot;北京&quot;, &quot;country&quot;:&quot;中国&quot;, &quot;headimgurl&quot;: &quot;http://thirdwx.qlogo.cn/mmopen/RFKUCMNiaHBDu2OOyCcvq5uTIteIlicusVTVUVNtIicjSyNY2su0eSYAIUzDtlAkE3Ff6uaKN8UvryLwicX1c2OeLNHJR3ibBeo9G/132&quot;, &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot;, &quot;PRIVILEGE2&quot;], &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;&#125; 获取用户列表 GET https://api.weixin.qq.com/cgi-bin/user/get?access_token=32_ybQmVgsXDCHKSiG3bRIL7xRq1Y39sKVylwUOMQls8IKlpY5dqiycEPvQmzBvsl2REtAi11WUSn5Nc29ZnOddO0V8Rll0RtKw6WLtwgzhr3_4h5-I1pGShVa1KuD1GQXcPIKblSae5Bt8PkxiVEHjACAFOR Response 12345678910&#123; &quot;total&quot;: 1, &quot;count&quot;: 1, &quot;data&quot;: &#123; &quot;openid&quot;: [ &quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot; ] &#125;, &quot;next_openid&quot;: &quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;&#125; 生成带参数的二维码 这里演示带字符串参数的永久二维码 POST https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=32_9o3KwEVvZho6PxWqnmhVpUNiWcaGpgl_TvvJH1NHS_3ZAPQl-2dh4XCqbxdqtahdd39hKTP9kYAcnr2Jmu1-V7n0szIdiAkoHZmd0BGOUGHrSro4i4oY0I2I4zPxcPfXxmsTJKrvlotsvwjBALCbAAAPAR 请求体 12345678&#123; &quot;action_name&quot;: &quot;QR_LIMIT_STR_SCENE&quot;, &quot;action_info&quot;: &#123; &quot;scene&quot;: &#123; &quot;scene_str&quot;: &quot;1234567&quot; &#125; &#125;&#125; Response 1234&#123; &quot;ticket&quot;: &quot;gQG18TwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyTGhyV01tc3lmOTMxMDAwMGcwN24AAgTQippeAwQAAAAA&quot;, &quot;url&quot;: &quot;http://weixin.qq.com/q/02LhrWMmsyf9310000g07n&quot;&#125; 通过ticket换取二维码 GET https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQG18TwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyTGhyV01tc3lmOTMxMDAwMGcwN24AAgTQippeAwQAAAAA Response 基于字节流的图片，在浏览器访问上述地址即可渲染出二维码。该二维码是带参数的二维码，扫码关注后回调消息中会携带参数。比如按 userId 生成二维码，扫码关注后回调消息包含 openid 和 userid, 可以用于后续绑定操作。 用户关注后java后台会收到xml消息: 123456789&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[gh_d0c6b73cc08e]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[oHOLJw-r6lBxSXU4pRDKpoDyqWI0]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1587187948&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt; &lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt; &lt;EventKey&gt;&lt;![CDATA[qrscene_1234567]]&gt;&lt;/EventKey&gt; &lt;Ticket&gt;&lt;![CDATA[gQG18TwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyTGhyV01tc3lmOTMxMDAwMGcwN24AAgTQippeAwQAAAAA]]&gt;&lt;/Ticket&gt; &lt;/xml&gt; 新增临时素材 POST https://api.weixin.qq.com/cgi-bin/media/upload?access_token=32_LtMp7FPdxSvV1kmPHoQTqCjhGAjigFDvhzVPnAIQsknmHyFOtTO9g5XBr7DVVNPepYLPZjSRCX0fDKZqTzBufliVoWTMmRI1Uu-T2aMt3vfTzlluzm6eANZ6nJNEa_BXLwHxIx3yLP49fr_MZTZfACAGAG&amp;type=image Content-Type:multipart/form-data body中选择file类型的key，value选择本地图片 Response 123456&#123; &quot;type&quot;: &quot;image&quot;, &quot;media_id&quot;: &quot;51TAwv-DI7RucNhJr8tzqbYLWSZFH-m1b40Td2rLz3L2WUo881sQ8DgGxeRKXMG5&quot;, &quot;created_at&quot;: 1587187471, &quot;item&quot;: []&#125; 获取临时素材 GET https://api.weixin.qq.com/cgi-bin/media/get?access_token=32_LtMp7FPdxSvV1kmPHoQTqCjhGAjigFDvhzVPnAIQsknmHyFOtTO9g5XBr7DVVNPepYLPZjSRCX0fDKZqTzBufliVoWTMmRI1Uu-T2aMt3vfTzlluzm6eANZ6nJNEa_BXLwHxIx3yLP49fr_MZTZfACAGAG&amp;media_id=51TAwv-DI7RucNhJr8tzqbYLWSZFH-m1b40Td2rLz3L2WUo881sQ8DgGxeRKXMG5 Response 返回图片素材 获取模板列表 创建模板不需要调用接口，在公众号后台即可设置。 我创建的模板如下: 1欢迎你: &#123;&#123;name.DATA&#125;&#125; GET https://api.weixin.qq.com/cgi-bin/template/get_all_private_template?access_token=32_ybQmVgsXDCHKSiG3bRIL7xRq1Y39sKVylwUOMQls8IKlpY5dqiycEPvQmzBvsl2REtAi11WUSn5Nc29ZnOddO0V8Rll0RtKw6WLtwgzhr3_4h5-I1pGShVa1KuD1GQXcPIKblSae5Bt8PkxiVEHjACAFOR Response 123456789101112&#123; &quot;template_list&quot;: [ &#123; &quot;template_id&quot;: &quot;7BsKKP1MsDxbNmfYfTaNVm9guRvgwH8l2PmFbDCMip0&quot;, &quot;title&quot;: &quot;欢迎模板&quot;, &quot;primary_industry&quot;: &quot;&quot;, &quot;deputy_industry&quot;: &quot;&quot;, &quot;content&quot;: &quot;欢迎你: &#123;&#123;name.DATA&#125;&#125;&quot;, &quot;example&quot;: &quot;&quot; &#125; ]&#125; 发送模板消息 POST https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=32_ybQmVgsXDCHKSiG3bRIL7xRq1Y39sKVylwUOMQls8IKlpY5dqiycEPvQmzBvsl2REtAi11WUSn5Nc29ZnOddO0V8Rll0RtKw6WLtwgzhr3_4h5-I1pGShVa1KuD1GQXcPIKblSae5Bt8PkxiVEHjACAFOR 请求体 1234567891011 &#123; &quot;touser&quot;:&quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;, &quot;template_id&quot;:&quot;7BsKKP1MsDxbNmfYfTaNVm9guRvgwH8l2PmFbDCMip0&quot;, &quot;url&quot;:&quot;http://idea360.cn&quot;, &quot;data&quot;:&#123; &quot;name&quot;: &#123; &quot;value&quot;:&quot;登高射太阳！&quot;, &quot;color&quot;:&quot;#173177&quot; &#125; &#125;&#125; 查看微信，会看到测试号给推送了一条模板消息。 同时，我们的java日志中会看到收到xml消息 123456789&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[gh_d0c6b73cc08e]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[oHOLJw-r6lBxSXU4pRDKpoDyqWI0]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1587188459&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt; &lt;Event&gt;&lt;![CDATA[TEMPLATESENDJOBFINISH]]&gt;&lt;/Event&gt; &lt;MsgID&gt;1301848003480829954&lt;/MsgID&gt; &lt;Status&gt;&lt;![CDATA[success]]&gt;&lt;/Status&gt; &lt;/xml&gt; 发送客服消息 POST https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=32_LBmSoFhAku0mBL8dQ3mj4pSPSe6_EFBGUt_uCEu3ZGZX-auOe9etVmtKBfwnK9FgMd9BsrTWKo-mmgy86EVCjJkpvuu2h6_VZXJ_S-fCHtW7VJIKlQ9P7tNEDlWEwDsTCUCN6Cj8dVJqK4e5PNViAJAKIQ 消息体 12345678910111213141516&#123; &quot;touser&quot;:&quot;oHOLJw-r6lBxSXU4pRDKpoDyqWI0&quot;, &quot;msgtype&quot;:&quot;news&quot;, &quot;news&quot;:&#123; &quot;articles&quot;: [ &#123; &quot;title&quot;:&quot;当我遇上你&quot;, &quot;description&quot;:&quot;当我遇上你&quot;, &quot;url&quot;:&quot;https://www.baidu.com&quot;, &quot;picurl&quot;:&quot;https://gitee.com/idea360/oss/raw/master/images/one.png&quot; &#125; ] &#125;&#125; Response 1234&#123; &quot;errcode&quot;: 0, &quot;errmsg&quot;: &quot;ok&quot;&#125; 查看公众号会看到消息。 监测token是否失效 GET https://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=%s 刷新模板消息10W/日限额 GET https://api.weixin.qq.com/cgi-bin/clear_quota?access_token=%s 最后 本文到此结束，感谢阅读。欢迎关注公众号【当我遇上你】, 您的支持是我最大的动力。","categories":[{"name":"公众号","slug":"公众号","permalink":"https://idea360.cn/categories/%E5%85%AC%E4%BC%97%E5%8F%B7/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://idea360.cn/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"公众号","slug":"公众号","permalink":"https://idea360.cn/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"springboot-mybatis-oracle学习笔记","slug":"springboot-mybatis-oracle-learn","date":"2020-04-10T16:57:42.000Z","updated":"2021-02-23T14:47:14.237Z","comments":true,"path":"2020/04/11/springboot-mybatis-oracle-learn/","link":"","permalink":"https://idea360.cn/2020/04/11/springboot-mybatis-oracle-learn/","excerpt":"","text":"前言 最近公司的项目是基于 oracle 数据库的，这里记录下 springboot+mybatis+oracle 的踩坑过程。 开发前准备 环境参数 开发工具：IDEA 基础工具：Maven+JDK8 所用技术：SpringBoot+Mybatis+Oracle 数据库：MySQL5.7 SpringBoot版本：2.2.6.RELEASE Mybatis版本: 2.1.2 Oracle: oracle-xe-11g 基于Docker搭建Oracle docker-compose-oracle.yml 12345678910version: &#x27;2&#x27;services: oracle: image: sath89/oracle-xe-11g container_name: oracle ports: - 1521:1521 - 8082:8080 volumes: - ./oracle/data:/u01/app/oracle 连接参数 Connection Type: Basic Host: localhost Port: 1521 Service Name: xe Username: system Password: oracle 创建 表空间 Navicat 创建表空间 脚本创建表空间 123456-- 表空间 OA-- 表空间物理文件位置 /u01/app/oracle/oradata/XE/OA-- 大小20M-- 每次20M自动增大-- 最大100MCREATE TABLESPACE &quot;OA&quot; DATAFILE &#x27;/u01/app/oracle/oradata/XE/OA&#x27; SIZE 20 M AUTOEXTEND ON NEXT 20 M MAXSIZE 100 M 创建 用户 并绑定 角色 Navicat 创建用户 Navicat 绑定角色 脚本创建用户并绑定角色 12345CREATE USER &quot;OA&quot; IDENTIFIED BY &quot;123456&quot; DEFAULT TABLESPACE &quot;OA&quot; TEMPORARY TABLESPACE &quot;TEMP&quot;;GRANT &quot;DBA&quot; TO &quot;root&quot;;ALTER USER &quot;root&quot; DEFAULT ROLE &quot;DBA&quot; 设计Entity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Account &#123; // 主键 private Integer id; // 用户名(唯一) private String realName; // 工号(递增) private Integer jobNumber; // 创建时间 private Date createTime; public Account() &#123; &#125; public Account(String realName, Integer jobNumber) &#123; this.realName = realName; this.jobNumber = jobNumber; this.createTime = new Date(); &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getRealName() &#123; return realName; &#125; public void setRealName(String realName) &#123; this.realName = realName; &#125; public Integer getJobNumber() &#123; return jobNumber; &#125; public void setJobNumber(Integer jobNumber) &#123; this.jobNumber = jobNumber; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, realName=&#x27;&quot; + realName + &#x27;\\&#x27;&#x27; + &quot;, jobNumber=&quot; + jobNumber + &quot;, createTime=&quot; + createTime + &#x27;&#125;&#x27;; &#125;&#125; 创建数据库 12345678910111213141516171819202122232425262728293031323334-- ID 主键、自增-- USER_NAME 唯一索引-- JOB_NUMBER 递增CREATE TABLE &quot;OA&quot;.&quot;ACCOUNT&quot; (&quot;ID&quot; NUMBER(18, 0) NOT NULL ,&quot;REAL_NAME&quot; VARCHAR2(128) NOT NULL ,&quot;JOB_NUMBER&quot; NUMBER(18,0) DEFAULT 0 NOT NULL ,&quot;CREATE_TIME&quot; TIMESTAMP(6) NULL ,PRIMARY KEY (&quot;ID&quot;));-- 字段说明COMMENT ON table ACCOUNT IS &#x27;账户表&#x27;;COMMENT ON COLUMN &quot;OA&quot;.&quot;ACCOUNT&quot;.&quot;ID&quot; IS &#x27;主键&#x27;;COMMENT ON COLUMN &quot;OA&quot;.&quot;ACCOUNT&quot;.&quot;REAL_NAME&quot; IS &#x27;用户名&#x27;;COMMENT ON COLUMN &quot;OA&quot;.&quot;ACCOUNT&quot;.&quot;JOB_NUMBER&quot; IS &#x27;工号&#x27;;COMMENT ON COLUMN &quot;OA&quot;.&quot;ACCOUNT&quot;.&quot;CREATE_TIME&quot; IS &#x27;创建时间&#x27;;-- 创建唯一索引CREATE UNIQUE INDEX INDEX_REAL_NAME on ACCOUNT(REAL_NAME);-- 创建ID递增序列CREATE SEQUENCE ACCOUNT_ID_SEQ INCREMENT BY 1 START WITH 1 NOMAXVALUE NOCYCLE NOCACHE;-- 创建触发器实现主键自增CREATE OR REPLACE TRIGGER ACCOUNT_TRG BEFORE INSERT ON ACCOUNT FOR EACH ROW BEGIN SELECT ACCOUNT_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;END;-- 查看序列SELECT * FROM user_sequences;-- 查看触发器SELECT * FROM user_triggers; 代码实践 配置文件 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;idc-oracle&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;idc-oracle&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 1234567891011121314151617server: port: 9090spring: profiles: active: localmybatis: type-aliases-package: cn.idea360.oracle.model configuration: map-underscore-to-camel-case: true default-fetch-size: 100 default-statement-timeout: 30 mapper-locations: mapper/*.xmllogging: level: root: info application-local.yml 123456spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@127.0.0.1:1521:XE username: oa password: 123456 mybatis-config.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias=&quot;account&quot; type=&quot;cn.idea360.oracle.model.Account&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; Java代码 mapper包扫描配置 123456789@MapperScan(&quot;cn.idea360.oracle.dao&quot;)@SpringBootApplicationpublic class OracleApp &#123; public static void main(String[] args) &#123; SpringApplication.run(OracleApp.class, args); &#125;&#125; 分页 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * Mapper进一步实现可以基于拦截器实现 * @param &lt;T&gt; */@Datapublic class Page&lt;T&gt; &#123; /** * 查询数据列表 */ private List&lt;T&gt; records = Collections.emptyList(); /** * 总数 */ private long total = 0; /** * 每页显示条数，默认 10 */ private long size = 10; /** * 当前页 */ private long current = 1; /** * KEY/VALUE 条件 */ private Map&lt;Object, Object&gt; condition; /** * oracle分页： start */ private Integer startIndex = 1; /** * oracle分页： end */ private Integer endIndex = 10; public Page() &#123; &#125; public Page(long current, long size) &#123; this(current, size, 0); &#125; public Page(long current, long size, long total) &#123; if (current &gt; 1) &#123; this.current = current; &#125; this.size = size; this.total = total; &#125; /** * 计算当前分页偏移量 */ public long offset() &#123; return getCurrent() &gt; 0 ? (getCurrent() - 1) * getSize() : 0; &#125; /** * 当前分页总页数 */ public long getPages() &#123; if (getSize() == 0) &#123; return 0L; &#125; long pages = getTotal() / getSize(); if (getTotal() % getSize() != 0) &#123; pages++; &#125; return pages; &#125; /** * oracle分页开始 * @return */ public long getStartIndex() &#123; return (getCurrent()-1)*size+1; &#125; /** * oracle分页结束 * @return */ public long getEndIndex() &#123; return getCurrent()*size; &#125;&#125; mapper定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public interface AccountMapper &#123; /** * 插入单条数据 * @param account * @return 返回主键id */ int insert(Account account); /** * 批量插入list * @param data */ void insertBatch(@Param(&quot;coll&quot;) Collection&lt;Account&gt; data); /** * 更新数据 * @param account * @return */ int updateIgnoreNullById(@Param(&quot;et&quot;) Account account); /** * 删除数据 * @param id * @return */ int removeById(@Param(&quot;id&quot;) Integer id); /** * 根据id查询数据 * @param id * @return */ Account selectById(@Param(&quot;id&quot;) Integer id); /** * 根据其他字段查询数据 * @param columnMap * @return */ Account selectByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap); /** * 根据id数组批量查询数据 * @param idArray * @return */ List&lt;Account&gt; selectByIds(@Param(&quot;coll&quot;) Integer[] idArray); /** * 根据分页参数查询数据 * @param page * @return */ List&lt;Account&gt; selectPage(@Param(&quot;page&quot;) Page page); /** * 查询所有 * @return */ List&lt;Account&gt; listAll();&#125; AccountMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.idea360.oracle.dao.AccountMapper&quot;&gt; &lt;!--resultType是直接表示返回类型的(对应着我们的model对象中的实体)，而resultMap则是对外部ResultMap的引用(提前定义了db和model之间的隐射key-value关系)--&gt; &lt;resultMap id=&quot;accountMap&quot; type=&quot;account&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;real_name&quot; property=&quot;realName&quot;/&gt; &lt;result column=&quot;job_number&quot; property=&quot;jobNumber&quot; /&gt; &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; /&gt; &lt;/resultMap&gt; &lt;!--插入单条数据，自增主键通过序列和触发器实现--&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;account&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into account (real_name, job_number, create_time) values (#&#123;realName&#125;, #&#123;jobNumber&#125;, #&#123;createTime&#125;) &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;java.lang.Integer&quot; order=&quot;AFTER&quot;&gt; select ACCOUNT_ID_SEQ.CURRVAL from dual &lt;/selectKey&gt; &lt;/insert&gt; &lt;!--通过list批量插入数据--&gt; &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;java.util.List&quot;&gt; insert into account (real_name, job_number, create_time) &lt;foreach collection=&quot;coll&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;UNION ALL&quot;&gt; select #&#123;item.realName&#125;, #&#123;item.jobNumber&#125;, #&#123;item.createTime&#125; from dual &lt;/foreach&gt; &lt;/insert&gt; &lt;!--更新数据--&gt; &lt;update id=&quot;updateIgnoreNullById&quot;&gt; update account &lt;set&gt; &lt;if test=&quot;et.realName != null&quot;&gt; real_name = #&#123;et.realName&#125;, &lt;/if&gt; &lt;if test=&quot;et.jobNumber != null&quot;&gt; job_number = #&#123;et.jobNumber&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;et.id&#125; &lt;/update&gt; &lt;!--根据主键id移除数据--&gt; &lt;delete id=&quot;removeById&quot;&gt; delete from account where id = #&#123;id&#125; &lt;/delete&gt; &lt;!--根据主键id查询数据--&gt; &lt;select id=&quot;selectById&quot; parameterType=&quot;integer&quot; resultMap=&quot;accountMap&quot;&gt; select * from account where id = #&#123;id&#125; &lt;/select&gt; &lt;!--根据其他字段查询数据--&gt; &lt;select id=&quot;selectByMap&quot; resultMap=&quot;accountMap&quot;&gt; select * from account &lt;where&gt; &lt;if test=&quot;cm != null and cm.realName != null&quot;&gt; and real_name = #&#123;cm.realName&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--根据id数组查询数据--&gt; &lt;select id=&quot;selectByIds&quot; resultMap=&quot;accountMap&quot;&gt; select * from account where id in &lt;foreach collection=&quot;coll&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!--根据分页参数查询数据--&gt; &lt;select id=&quot;selectPage&quot; resultMap=&quot;accountMap&quot;&gt; SELECT T2.* FROM ( SELECT T1.*, ROWNUM RN FROM ( SELECT a.* FROM account a &lt;where&gt; &lt;if test=&quot;page != null and page.condition != null and page.condition.keyword != null&quot;&gt; AND a.real_name LIKE &#x27;%&#x27; || #&#123;page.condition.keyword&#125; || &#x27;%&#x27; &lt;/if&gt; &lt;/where&gt; ORDER BY id DESC ) T1 ) T2 &lt;where&gt; &lt;if test=&quot;page != null and page.startIndex != null&quot;&gt; and RN &lt;![CDATA[ &gt;= ]]&gt; #&#123;page.startIndex&#125; &lt;/if&gt; &lt;if test=&quot;page != null and page.endIndex != null&quot;&gt; AND RN &lt;![CDATA[ &lt;= ]]&gt; #&#123;page.endIndex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;listAll&quot; resultType=&quot;cn.idea360.oracle.model.Account&quot;&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; 单元测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@SpringBootTestclass AccountMapperTest &#123; @Autowired private AccountMapper accountMapper; @Test public void insert() &#123; Account account = new Account(&quot;admin&quot;, 1); accountMapper.insert(account); System.out.println(account.getId()); &#125; @Test public void insertBatch() &#123; List&lt;Account&gt; data = new ArrayList&lt;&gt;(); for (int i=0; i&lt;3; i++) &#123; Account account = new Account(&quot;test&quot; + i, i+2); data.add(account); &#125; accountMapper.insertBatch(data); &#125; @Test public void updateIgnoreNullById() &#123; Account account = new Account(&quot;admin0&quot;, 1); account.setId(1); accountMapper.updateIgnoreNullById(account); &#125; @Test public void removeById() &#123; accountMapper.removeById(4); &#125; @Test public void selectById() &#123; Account account = accountMapper.selectById(4); System.out.println(account.toString()); &#125; @Test public void selectByMap() &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;realName&quot;, &quot;admin&quot;); Account account = accountMapper.selectByMap(params); System.out.println(account); &#125; @Test public void selectByIds() &#123; Integer[] ids = &#123;1, 2&#125;; List&lt;Account&gt; accounts = accountMapper.selectByIds(ids); System.out.println(accounts); &#125; @Test public void selectPage() &#123; Page&lt;Account&gt; page = new Page&lt;&gt;(1, 10); HashMap&lt;Object, Object&gt; condition = new HashMap&lt;&gt;(); condition.put(&quot;keyword&quot;, &quot;ad&quot;); page.setCondition(condition); List&lt;Account&gt; accounts = accountMapper.selectPage(page); page.setRecords(accounts); System.out.println(page); &#125; @Test public void listAll() &#123; List&lt;Account&gt; accounts = accountMapper.listAll(); System.out.println(accounts); &#125;&#125; 最后 oracle 在自增主键、分页、模糊查询、批量操作上和 mysql 略有不同，上边的例子里基本都演示到了。初次接触 oracle, 如有错误还请指出, 共同进步。同时，希望大家关注公众号【当我遇上你】, 您的支持就是我最大的动力。","categories":[{"name":"oracle","slug":"oracle","permalink":"https://idea360.cn/categories/oracle/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"oracle","slug":"oracle","permalink":"https://idea360.cn/tags/oracle/"},{"name":"mybatis","slug":"mybatis","permalink":"https://idea360.cn/tags/mybatis/"}]},{"title":"spring-cloud-gateway降级","slug":"spring-cloud-gateway-hystrix","date":"2020-04-07T13:44:36.000Z","updated":"2021-07-10T12:05:07.843Z","comments":true,"path":"2020/04/07/spring-cloud-gateway-hystrix/","link":"","permalink":"https://idea360.cn/2020/04/07/spring-cloud-gateway-hystrix/","excerpt":"","text":"前言 本文主要研究一下spring cloud gateway如何集成hystrix。 当下游接口负载很大，或者接口不通等其他原因导致超时，如果接口不熔断的话将会影响到下游接口得不到喘息，网关也会因为超时连接一直挂起，很可能因为一个子系统的问题导致整个系统的雪崩。所以我们的网关需要设计熔断，当因为熔断器打开时，网关将返回一个降级的应答。 Maven配置 添加hystrix依赖 pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 项目实战 在 provider1 服务中添加一个方法，延时2秒返回响应。 12345678910@GetMapping(&quot;/timeout&quot;)public String timeout() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;休眠了2秒&quot;); return &quot;timeout test&quot;;&#125; 修改网关配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950server: port: 2000spring: application: name: idc-gateway2 redis: host: localhost port: 6379 timeout: 6000ms # 连接超时时长（毫秒） jedis: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 cloud: consul: host: localhost port: 8500 gateway: discovery: locator: enabled: true # gateway可以通过开启以下配置来打开根据服务的serviceId来匹配路由,默认是大写 routes: - id: provider1 uri: lb://idc-provider1 predicates: - Path=/p1/** filters: - StripPrefix=1 - name: Hystrix args: name: default fallbackUri: forward:/defaultfallback # 只有该id下的服务会降级 - id: provider2 uri: lb://idc-provider2 predicates: - Path=/p2/** filters: - StripPrefix=1# hystrix 信号量隔离，1.5秒后自动超时hystrix: command: default: execution: isolation: strategy: SEMAPHORE thread: timeoutInMilliseconds: 1500 网关添加降级处理类 12345678910111213@RestControllerpublic class FallbackController &#123; @RequestMapping(&quot;/defaultfallback&quot;) public Map&lt;String,Object&gt; defaultfallback()&#123; System.out.println(&quot;降级操作...&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,200); map.put(&quot;msg&quot;,&quot;服务超时降级&quot;); map.put(&quot;data&quot;,null); return map; &#125;&#125; 降级测试 超时服务降级 1curl http:&#x2F;&#x2F;localhost:2000&#x2F;p1&#x2F;timeout 返回 1&#123;&quot;msg&quot;:&quot;服务超时降级&quot;,&quot;code&quot;:200,&quot;data&quot;:null&#125; 其他异常 spring-cloud-gateway 调用下游服务返回的异常，网关不做任何处理，会直接返回。大家想一下为什么在网关不去处理下游异常呢? 因为很多时候下游的异常是包含有效信息的(异常信息千千万)，如果在网关处做了统一返回，就失去了返回异常的意义。 spring-cloud-starter-netflix-hystrix 内置的Hystrix过滤器是 HystrixGatewayFilterFactory。 感兴趣的小伙伴可以自行阅读相关源码。 结语 本文到此结束，感谢大家的阅读。欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://idea360.cn/tags/SpringCloud/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"},{"name":"降级","slug":"降级","permalink":"https://idea360.cn/tags/%E9%99%8D%E7%BA%A7/"}]},{"title":"spring-cloud-gateway限流","slug":"spring-cloud-gateway-limit","date":"2020-04-06T11:13:28.000Z","updated":"2021-07-10T12:05:19.754Z","comments":true,"path":"2020/04/06/spring-cloud-gateway-limit/","link":"","permalink":"https://idea360.cn/2020/04/06/spring-cloud-gateway-limit/","excerpt":"","text":"概述 限流：网关上有大量请求，对指定服务进行限流，可以很大程度上提高服务的可用性与稳定性，限流的目的是通过对并发访问/请求进行限速，或对一个时间窗口内的请求进行限速来保护系统。一旦达到限制速率则可以拒绝服务、排队或等待、降级。 在Spring Cloud Gateway中，有 Filter过滤器，因此可以在 pre 类型的Filter中自行实现上述三种过滤器。但是限流作为网关最基本的功能，Spring Cloud Gateway官方就提供了 RequestRateLimiterGatewayFilterFactory 这个类，适用在Redis内的通过执行Lua脚本实现了令牌桶的方式。具体实现逻辑在 RequestRateLimiterGatewayFilterFactory 类中，lua脚本在如下图所示的文件夹中： 限流配置 应一小伙伴要求, 将demo升级到了最新版本 spring-cloud-dependencies: Hoxton.SR3 spring-boot-dependencies: 2.2.6.RELEASE 代码放置在 github. 修改配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041server: port: 2000spring: application: name: idc-gateway2 redis: host: localhost port: 6379 timeout: 6000ms # 连接超时时长（毫秒） jedis: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 cloud: consul: host: localhost port: 8500 gateway: discovery: locator: enabled: true # gateway可以通过开启以下配置来打开根据服务的serviceId来匹配路由,默认是大写 routes: - id: provider1 uri: lb://idc-provider1 predicates: - Path=/p1/** filters: - StripPrefix=1 - name: RequestRateLimiter args: key-resolver: &#x27;#&#123;@ipKeyResolver&#125;&#x27; redis-rate-limiter.replenishRate: 1 redis-rate-limiter.burstCapacity: 3 - id: provider2 uri: lb://idc-provider2 predicates: - Path=/p2/** filters: - StripPrefix=1 在上面的配置文件，指定程序的端口为2000，配置了 redis的信息，并配置了RequestRateLimiter的限流过滤器，该过滤器需要配置三个参数： burstCapacity，令牌桶总容量。 replenishRate，令牌桶每秒填充平均速率。 key-resolver，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。 限流配置 这里根据用户ID限流，请求路径中必须携带userId参数 1234@BeanKeyResolver userKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;));&#125; KeyResolver需要实现resolve方法，比如根据userid进行限流，则需要用userid去判断。实现完KeyResolver之后，需要将这个类的Bean注册到Ioc容器中。 如果需要根据IP限流，定义的获取限流Key的bean为： 12345@Primary@BeanKeyResolver ipKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());&#125; 通过exchange对象可以获取到请求信息，这边用了HostName，如果你想根据用户来做限流的话这边可以获取当前请求的用户ID或者用户名就可以了，比如： 如果需要根据接口的URI进行限流，则需要获取请求地址的uri作为限流key，定义的Bean对象为： 1234@BeanKeyResolver apiKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getPath().value());&#125; 完整的配置文件: 123456789101112131415161718@Componentpublic class RateLimitConfig &#123; @Bean KeyResolver userKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;)); &#125; @Primary @Bean KeyResolver ipKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName()); &#125; @Bean KeyResolver apiKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getPath().value()); &#125;&#125; 限流演练 这里我们用 postman 进行测试 基于系统负载的动态限流 在实际工作中，我们可能还需要根据网络连接数、网络流量、CPU 或内存负载等来进行动态限流。在这里我们以 CPU 为栗子。 我们需要借助 Spring Boot Actuator 提供的 Metrics 能力进行实现基于 CPU 的限流 —— 当 CPU 使用率高于某个阈值就开启限流，否则不开启限流。 我们在项目中引入 Actuator 的依赖坐标 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 然后基于过滤器和metrics指标判断是否需要限流。 最后 本文到此结束，感谢大家的阅读。欢迎关注公众号【当我遇上你】","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"限流","slug":"限流","permalink":"https://idea360.cn/tags/%E9%99%90%E6%B5%81/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"https://idea360.cn/tags/Spring-Cloud/"},{"name":"压测","slug":"压测","permalink":"https://idea360.cn/tags/%E5%8E%8B%E6%B5%8B/"},{"name":"postman","slug":"postman","permalink":"https://idea360.cn/tags/postman/"}]},{"title":"Docker实战之Oracle学习笔记","slug":"docker-oracle-intro","date":"2020-04-06T07:32:05.000Z","updated":"2021-02-23T14:17:34.177Z","comments":true,"path":"2020/04/06/docker-oracle-intro/","link":"","permalink":"https://idea360.cn/2020/04/06/docker-oracle-intro/","excerpt":"","text":"前言 公司现在用的数据库是 oracle , 所以就搭建一个测试环境学习。 docker-compose配置 12345678910version: &#x27;2&#x27;services: oracle: image: sath89/oracle-xe-11g container_name: oracle ports: - 1521:1521 - 8082:8080 volumes: - ./oracle/data:/u01/app/oracle 启动docker 1docker-compose -f docker-compose-oracle.yml up -d 连接 Connection Type: Basic Host: localhost Port: 1521 Service Name: xe Username: system Password: oracle 基本概念 数据库: Database 实例: Instance 表空间: Tablespace(schema) 用户: User 表: Table Database-Instance: OneToMany User-Tablespace: ManyToMany Tablespace-Table: OneToMany 基本操作 自增序列 123456-- 查看所有序列SELECT * FROM user_sequences;-- 创建序列CREATE SEQUENCE USER_SEQ INCREMENT BY 1 START WITH 1 NOMAXVALUE NOCYCLE NOCACHE;-- 删除指定序列DROP SEQUENCE USER_SEQ; 创建表 1234567891011-- TESTSPACE 表空间, USER 表CREATE TABLE &quot;TESTSPACE&quot;.&quot;USER&quot; (&quot;ID&quot; NUMBER(20,0) NOT NULL,&quot;USERNAME&quot; VARCHAR2(128) NOT NULL,&quot;CREATE_TIME&quot; TIMESTAMP(6) NULL,&quot;UPDATE_TIME&quot; TIMESTAMP(6) NULL, PRIMARY KEY (&quot;ID&quot;));COMMENT ON table USER IS &#x27;用户表&#x27;;COMMENT ON COLUMN &quot;TESTSPACE&quot;.&quot;USER&quot;.&quot;ID&quot; IS &#x27;主键&#x27;; 自增主键 基于序列 12INSERT INTO PERSON(ID, NAME) VALUES (USER_SEQ.NEXTVAL, &#x27;admin&#x27;);commit ; 基于序列+触发器 1234CREATE OR REPLACE TRIGGER USER_TRG BEFORE INSERT ON USER FOR EACH ROW BEGIN SELECT USER_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;END;","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"oracle","slug":"oracle","permalink":"https://idea360.cn/tags/oracle/"}]},{"title":"spring-cloud-gateway动态路由","slug":"spring-cloud-gateway-route-dynamic","date":"2020-04-04T06:35:30.000Z","updated":"2021-07-10T12:05:26.176Z","comments":true,"path":"2020/04/04/spring-cloud-gateway-route-dynamic/","link":"","permalink":"https://idea360.cn/2020/04/04/spring-cloud-gateway-route-dynamic/","excerpt":"","text":"概述 线上项目发布一般有以下几种方案: 停机发布 蓝绿部署 滚动部署 灰度发布 停机发布 这种发布一般在夜里或者进行大版本升级的时候发布，因为需要停机，所以现在大家都在研究 Devops 方案。 蓝绿部署 需要准备两个相同的环境。一个环境新版本，一个环境旧版本，通过负载均衡进行切换与回滚，目的是为了减少服务停止时间。 滚动部署 就是在升级过程中，并不一下子启动所有新版本，是先启动一台新版本，再停止一台老版本，然后再启动一台新版本，再停止一台老版本，直到升级完成。基于 k8s 的升级方案默认就是滚动部署。 灰度发布 也叫金丝雀发布，灰度发布中，常常按照用户设置路由权重，例如90%的用户维持使用老版本，10%的用户尝鲜新版本。不同版本应用共存，经常与A/B测试一起使用，用于测试选择多种方案。 上边介绍的几种发布方案，主要是引出我们接下来介绍的 spring-cloud-gateway 动态路由，我们可以基于动态路由、负载均衡和策略加载去实现 灰度发布。当然现在有很多开源的框架可以实现 灰度发布，这里只是研究学习。 动态路由 spring-cloud-gateway 默认将路由加载在内存中。具体可以参见 InMemoryRouteDefinitionRepository 类的实现。 这里我们基于 Redis 实现动态路由。基础项目见 spring-cloud-gateway简介 1. 将 actuator 的端点暴露出来。 12345management: endpoints: web: exposure: include: &quot;*&quot; 2. redis配置 1234567891011@Configurationpublic class RedisConfig &#123; @Bean(name = &#123;&quot;redisTemplate&quot;, &quot;stringRedisTemplate&quot;&#125;) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate redisTemplate = new StringRedisTemplate(); redisTemplate.setConnectionFactory(factory); return redisTemplate; &#125;&#125; 3. 将原内存路由持久化到redis 12345678910111213141516171819202122232425262728293031323334353637383940414243@Componentpublic class RedisRouteDefinitionRepository implements RouteDefinitionRepository &#123; /** * hash存储的key */ public static final String GATEWAY_ROUTES = &quot;gateway_dynamic_route&quot;; @Resource private StringRedisTemplate redisTemplate; /** * 获取路由信息 * @return */ @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() &#123; List&lt;RouteDefinition&gt; routeDefinitions = new ArrayList&lt;&gt;(); redisTemplate.opsForHash().values(GATEWAY_ROUTES).stream() .forEach(routeDefinition -&gt; routeDefinitions.add(JSON.parseObject(routeDefinition.toString(), RouteDefinition.class))); return Flux.fromIterable(routeDefinitions); &#125; @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route) &#123; return route.flatMap(routeDefinition -&gt; &#123; redisTemplate.opsForHash().put(GATEWAY_ROUTES, routeDefinition.getId(), JSONObject.toJSONString(routeDefinition)); return Mono.empty(); &#125;); &#125; @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId) &#123; return routeId.flatMap(id -&gt; &#123; if (redisTemplate.opsForHash().hasKey(GATEWAY_ROUTES, id)) &#123; redisTemplate.opsForHash().delete(GATEWAY_ROUTES, id); return Mono.empty(); &#125; return Mono.defer(() -&gt; Mono.error(new NotFoundException(&quot;route definition is not found, routeId:&quot; + routeId))); &#125;); &#125;&#125; 4. 重写动态路由服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Servicepublic class GatewayDynamicRouteService implements ApplicationEventPublisherAware &#123; @Resource private RedisRouteDefinitionRepository redisRouteDefinitionRepository; private ApplicationEventPublisher applicationEventPublisher; /** * 增加路由 * @param routeDefinition * @return */ public int add(RouteDefinition routeDefinition) &#123; redisRouteDefinitionRepository.save(Mono.just(routeDefinition)).subscribe(); applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this)); return 1; &#125; /** * 更新 * @param routeDefinition * @return */ public int update(RouteDefinition routeDefinition) &#123; redisRouteDefinitionRepository.delete(Mono.just(routeDefinition.getId())); redisRouteDefinitionRepository.save(Mono.just(routeDefinition)).subscribe(); applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this)); return 1; &#125; /** * 删除 * @param id * @return */ public Mono&lt;ResponseEntity&lt;Object&gt;&gt; delete(String id) &#123; return redisRouteDefinitionRepository.delete(Mono.just(id)).then(Mono.defer(() -&gt; Mono.just(ResponseEntity.ok().build()))) .onErrorResume(t -&gt; t instanceof NotFoundException, t -&gt; Mono.just(ResponseEntity.notFound().build())); &#125; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125;&#125; 5. 对外暴露接口 12345678910111213141516171819202122232425@RestController@RequestMapping(&quot;/gateway&quot;)public class GatewayDynamicRouteController &#123; @Resource private GatewayDynamicRouteService gatewayDynamicRouteService; @PostMapping(&quot;/add&quot;) public String create(@RequestBody RouteDefinition entity) &#123; int result = gatewayDynamicRouteService.add(entity); return String.valueOf(result); &#125; @PostMapping(&quot;/update&quot;) public String update(@RequestBody RouteDefinition entity) &#123; int result = gatewayDynamicRouteService.update(entity); return String.valueOf(result); &#125; @DeleteMapping(&quot;/delete/&#123;id&#125;&quot;) public Mono&lt;ResponseEntity&lt;Object&gt;&gt; delete(@PathVariable String id) &#123; return gatewayDynamicRouteService.delete(id); &#125;&#125; 测试 测试前删除我们配置的静态路由，因为静态路由和redis动态路由同时存在时取并集。 访问 http://localhost:2000/actuator/gateway/routes , 可以看到只有默认路由。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106[ &#123; &quot;route_id&quot;: &quot;CompositeDiscoveryClient_consul&quot;, &quot;route_definition&quot;: &#123; &quot;id&quot;: &quot;CompositeDiscoveryClient_consul&quot;, &quot;predicates&quot;: [ &#123; &quot;name&quot;: &quot;Path&quot;, &quot;args&quot;: &#123; &quot;pattern&quot;: &quot;/consul/**&quot; &#125; &#125; ], &quot;filters&quot;: [ &#123; &quot;name&quot;: &quot;RewritePath&quot;, &quot;args&quot;: &#123; &quot;regexp&quot;: &quot;/consul/(?&lt;remaining&gt;.*)&quot;, &quot;replacement&quot;: &quot;/$&#123;remaining&#125;&quot; &#125; &#125; ], &quot;uri&quot;: &quot;lb://consul&quot;, &quot;order&quot;: 0 &#125;, &quot;order&quot;: 0 &#125;, &#123; &quot;route_id&quot;: &quot;CompositeDiscoveryClient_idc-gateway&quot;, &quot;route_definition&quot;: &#123; &quot;id&quot;: &quot;CompositeDiscoveryClient_idc-gateway&quot;, &quot;predicates&quot;: [ &#123; &quot;name&quot;: &quot;Path&quot;, &quot;args&quot;: &#123; &quot;pattern&quot;: &quot;/idc-gateway/**&quot; &#125; &#125; ], &quot;filters&quot;: [ &#123; &quot;name&quot;: &quot;RewritePath&quot;, &quot;args&quot;: &#123; &quot;regexp&quot;: &quot;/idc-gateway/(?&lt;remaining&gt;.*)&quot;, &quot;replacement&quot;: &quot;/$&#123;remaining&#125;&quot; &#125; &#125; ], &quot;uri&quot;: &quot;lb://idc-gateway&quot;, &quot;order&quot;: 0 &#125;, &quot;order&quot;: 0 &#125;, &#123; &quot;route_id&quot;: &quot;CompositeDiscoveryClient_idc-provider1&quot;, &quot;route_definition&quot;: &#123; &quot;id&quot;: &quot;CompositeDiscoveryClient_idc-provider1&quot;, &quot;predicates&quot;: [ &#123; &quot;name&quot;: &quot;Path&quot;, &quot;args&quot;: &#123; &quot;pattern&quot;: &quot;/idc-provider1/**&quot; &#125; &#125; ], &quot;filters&quot;: [ &#123; &quot;name&quot;: &quot;RewritePath&quot;, &quot;args&quot;: &#123; &quot;regexp&quot;: &quot;/idc-provider1/(?&lt;remaining&gt;.*)&quot;, &quot;replacement&quot;: &quot;/$&#123;remaining&#125;&quot; &#125; &#125; ], &quot;uri&quot;: &quot;lb://idc-provider1&quot;, &quot;order&quot;: 0 &#125;, &quot;order&quot;: 0 &#125;, &#123; &quot;route_id&quot;: &quot;CompositeDiscoveryClient_idc-provider2&quot;, &quot;route_definition&quot;: &#123; &quot;id&quot;: &quot;CompositeDiscoveryClient_idc-provider2&quot;, &quot;predicates&quot;: [ &#123; &quot;name&quot;: &quot;Path&quot;, &quot;args&quot;: &#123; &quot;pattern&quot;: &quot;/idc-provider2/**&quot; &#125; &#125; ], &quot;filters&quot;: [ &#123; &quot;name&quot;: &quot;RewritePath&quot;, &quot;args&quot;: &#123; &quot;regexp&quot;: &quot;/idc-provider2/(?&lt;remaining&gt;.*)&quot;, &quot;replacement&quot;: &quot;/$&#123;remaining&#125;&quot; &#125; &#125; ], &quot;uri&quot;: &quot;lb://idc-provider2&quot;, &quot;order&quot;: 0 &#125;, &quot;order&quot;: 0 &#125;] 这个时候访问 http://192.168.124.5:2000/idc-provider1/provider1/1 根据结果可以推测能正确路由到 provider1， 测试结果一致。 创建 provider1 路由，将路径设置为 /p1/**，测试是否生效。 POST 请求 http://localhost:2000/gateway/add 123456789101112131415161718192021222324252627&#123; &quot;id&quot;:&quot;provider1&quot;, &quot;predicates&quot;:[ &#123; &quot;name&quot;:&quot;Path&quot;, &quot;args&quot;:&#123; &quot;_genkey_0&quot;:&quot;/p1/**&quot; &#125; &#125;, &#123; &quot;name&quot;:&quot;RemoteAddr&quot;, &quot;args&quot;:&#123; &quot;_genkey_0&quot;:&quot;192.168.124.5/16&quot; &#125; &#125; ], &quot;filters&quot;:[ &#123; &quot;name&quot;:&quot;StripPrefix&quot;, &quot;args&quot;:&#123; &quot;_genkey_0&quot;:&quot;1&quot; &#125; &#125; ], &quot;uri&quot;:&quot;lb://idc-provider1&quot;, &quot;order&quot;:0&#125; 查看 redis 存储，或者请求 http://localhost:2000/actuator/gateway/routes , 都可以看到配置成功。 访问 1curl http://localhost:2000/p1/provider1/1 结果输出2001，与期望一致。 由此可见动态路由已经生效。 结语 本文到此结束。感兴趣的小伙伴后续可以通过加载配置文件，基于权重进行灰度。欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"https://idea360.cn/tags/Spring-Cloud/"},{"name":"动态路由","slug":"动态路由","permalink":"https://idea360.cn/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"}]},{"title":"spring-cloud-gateway静态路由","slug":"spring-cloud-gateway-route-static","date":"2020-04-04T04:21:18.000Z","updated":"2021-07-10T12:05:32.330Z","comments":true,"path":"2020/04/04/spring-cloud-gateway-route-static/","link":"","permalink":"https://idea360.cn/2020/04/04/spring-cloud-gateway-route-static/","excerpt":"","text":"为什么引入API网关 使用 API 网关后的优点如下： 易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。 易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。 减少了客户端与各个微服务之间的交互次数。 基本环境见 spring-cloud-gateway简介, 项目中 provider1的maven配置在此做下更正 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-learning&lt;/artifactId&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;idc-provider1&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 静态路由基本实现 静态路由比较简单，这里做简单实现。 更改路由模块application.yml配置，更改后的配置文件如下: 123456789101112131415161718192021222324252627282930313233343536server: port: 2000spring: application: name: idc-gateway redis: host: localhost port: 6379 timeout: 6000ms # 连接超时时长（毫秒） jedis: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 cloud: consul: host: localhost port: 8500 gateway: discovery: locator: enabled: true # gateway可以通过开启以下配置来打开根据服务的serviceId来匹配路由,默认是大写 routes: - id: provider1 # 路由 ID，保持唯一 uri: lb://idc-provider1 # uri指目标服务地址，lb代表从注册中心获取服务 predicates: # 路由条件。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非） - Path=/p/** filters: - StripPrefix=1 # 过滤器StripPrefix，作用是去掉请求路径的最前面n个部分截取掉。StripPrefix=1就代表截取路径的个数为1，比如前端过来请求/test/good/1/view，匹配成功后，路由到后端的请求路径就会变成http://localhost:8888/good/1/view - id: provider2 # 路由 ID，保持唯一 uri: lb://idc-provider2 # uri指目标服务地址，lb代表从注册中心获取服务 predicates: # 路由条件。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非） - Path=/p2/** filters: - StripPrefix=1 # 过滤器StripPrefix，作用是去掉请求路径的最前面n个部分截取掉。StripPrefix=1就代表截取路径的个数为1，比如前端过来请求/test/good/1/view，匹配成功后，路由到后端的请求路径就会变成http://localhost:8888/good/1/view 测试 执行以下请求测试路由1 1curl http://localhost:2000/p/provider1/1 结果 返回 2001 。说明成功路由到了 provider1 服务。 执行以下请求测试路由2 1curl http://localhost:2000/p2/provider2 返回 &#123;&quot;port&quot;:&quot;2002&quot;&#125; 。说明成功路由到了 provider2 服务。 Predicate 断言条件 1 通过请求参数匹配 Query Route Predicate 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。 12345678... - id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/** - Query=username filters: - StripPrefix=1 这样配置，只要请求中包含 username 属性的参数即可匹配路由。否则404 测试 1curl http://localhost:2000/p/provider1/1?username=admin 经过测试发现只要请求汇总带有 username 参数即会匹配路由，不带 username 参数则不会匹配。 还可以将 Query 的值以键值对的方式进行配置，这样在请求过来时会对属性值和正则进行匹配，匹配上才会走路由。 1234567- id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/** - Query=username, ad. filters: - StripPrefix=1 这样只要当请求中包含 username 属性并且参数值是以 admin 开头的长度为三位的字符串才会进行匹配和路由。 测试 1curl http://localhost:2000/p/provider1/1?username=adm 测试可以返回页面代码，将 username 的属性值改为 admin 再次访问就会报 404,证明路由需要匹配正则表达式才会进行路由。 2 通过 Header 属性匹配 Header Route Predicate 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。 1234567- id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/** - Header=token, \\d+ filters: - StripPrefix=1 测试 1curl http://localhost:2000/p/provider1/1 -H &quot;token:11&quot; 则返回页面代码证明匹配成功。将参数-H &quot;token:11&quot;改为-H &quot;token:spring&quot;再次执行时返回404证明没有匹配。 3 通过 Cookie 匹配 Cookie Route Predicate 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。 1234567- id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/** - Cookie=sessionId, test filters: - StripPrefix=1 使用 curl 测试，命令行输入: 1curl http://localhost:2000/p/provider1/1 --cookie &quot;sessionId=test&quot; 则会返回页面代码，如果去掉–cookie “sessionId=test”，后台会报 404 错误。 4 通过 Host 匹配 Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。 1234567- id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/** - Host=**.baidu.com filters: - StripPrefix=1 使用 curl 测试，命令行输入: 12curl http://localhost:2000/p/provider1/1 -H &quot;Host: www.baidu.com&quot;curl http://localhost:2000/p/provider1/1 -H &quot;Host: md.baidu.com&quot; 经测试以上两种 host 均可匹配到 host_route 路由，去掉 host 参数则会报 404 错误。 5 通过请求方式匹配 可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由。 1234567- id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/** - Method=GET filters: - StripPrefix=1 使用 curl 测试，命令行输入: 1curl http://localhost:2000/p/provider1/1 测试返回页面代码，证明匹配到路由，我们再以 POST 的方式请求测试。 1curl -X POST http://localhost:2000/p/provider1/1 返回 404 没有找到，证明没有匹配上路由 6 通过请求路径匹配 Path Route Predicate 接收一个匹配路径的参数来判断是否走路由。 1234567- id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/&#123;segment&#125; - Method=POST filters: - StripPrefix=1 如果请求路径符合要求，则此路由将匹配，例如：/foo/1 或者 /foo/bar。 7 通过请求 ip 地址进行匹配 Predicate 也支持通过设置某个 ip 区间号段的请求才会路由，RemoteAddr Route Predicate 接受 cidr 符号(IPv4 或 IPv6 )字符串的列表(最小大小为1)，例如 192.168.124.5/16 (其中 192.168.124.5 是 IP 地址，16 是子网掩码)。 1234567- id: provider1 uri: lb://idc-provider1 predicates: - Path=/p/** - RemoteAddr=192.168.124.5/16 filters: - StripPrefix=1 可以将此地址设置为本机的 ip 地址进行测试。 1curl http://192.168.124.5:2000/p/provider1/1 如果请求的远程地址是 192.168.124.5，则此路由将匹配。 8 组合使用 各种 Predicates 同时存在于同一个路由时，请求必须同时满足所有的条件才被这个路由匹配。 一个请求满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发 结语 本篇到此结束，欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"https://idea360.cn/tags/Spring-Cloud/"},{"name":"静态路由","slug":"静态路由","permalink":"https://idea360.cn/tags/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/"}]},{"title":"activiti6官方示例笔记","slug":"activiti6-official-demo","date":"2020-04-01T15:35:10.000Z","updated":"2021-02-23T14:50:19.699Z","comments":true,"path":"2020/04/01/activiti6-official-demo/","link":"","permalink":"https://idea360.cn/2020/04/01/activiti6-official-demo/","excerpt":"","text":"概述 要想学习 activiti工作流, 入门便是学习官方的示例。下边我将基于官方的demo做一遍流程，考虑自己的业务该如何基于 activiti 设计逻辑。 工作流要素: 流程 表单 用户 有了以上3大要素，流程便可以流转。 表单绑定在流程节点上，用来输入当前流程信息 用户绑定在流程节点上，用来处理当前流程任务 下载安装 首先到 官方 下载activiti6.0.0。 对 activiti7 感兴趣的可以看 这里 然后将war包置于 tomcat/webapps 目录下，启动tomcat即可。 应用 说明 地址 帐号/密码 activiti-app 流程、表单、用户、发布、任务… http://localhost:8080/activiti-app admin/test activiti-admin 平台管理查看流程平台运行详情 http://localhost:8080/activiti-admin admin/admin activiti-rest rest-api接口应用 http://localhost:8080/activiti-rest kermit/kermit 用户管理 登录 http://localhost:8080/activiti-app/#/ Kickstart App：主要用于流程模型管理、表单管理及应用（App）管理，一个应用可以包含多个流程模型，应用可发布给其他用户使用。 Task App：用于管理整个activiti-app的任务，在该功能里面也可以启动流程 Idenity management：身份信息管理，可以管理用户、用户组等数据 创建用户 创建过程如下，注意id即是登录帐号。依次分别创建3个帐号用户审批流程。 流程定义 在主界面点击 Kickstart App 进入流程定义页面。 上图中模拟了一个请假流程，但是流程的执行需要人来参与，所以下边我们进行流程和帐号绑定。 选定流程节点后点击 Assignment 属性，会有弹窗进行绑定。 同理，将其他节点进行绑定。然后保存关闭即可，可以看到一个流程已创建完毕。 动态表单 之前的都是基本演示，假设我们需要复杂的表单，那么可以在流程节点上绑定表单即可，这里做下动态表单的基本演示。 选中流程节点，编辑 Referenced form, 动态创建节点关联表单。 编辑表单字段 保存表单 这样在流程中我们就可以通过表单流转复杂的信息了，大家可以实践下，下边的流程就不演示了。 流程发布 将应用和我们之前创建的流程绑定。 然后点击发布流程 发布完成后回到首页可以看到发布结果 流程测试 登录 zhangsan 帐号创建请假任务 查看流程当前流转状态。 点击 complete, 任务流转到下一个流程节点。 登录 lisi 审批 同理，登录 wangwu 审批，流程结束。 流程管理 登录 http://localhost:8080/activiti-admin/#/login 配置应用服务节点 配置后即可查看历史流程记录 持久化 tomcat 重启后，activiti 相关的数据会重置，如果想持久化，可以把数据持久化到 MySQL。 首先删除3个war包，避免重启覆盖我们修改的配置 activiti-app持久化 修改 activiti-app/WEB-INF/classes/META-INF/activiti-app/activiti-app.properties。修改后的配置文件如下(需要手动创建activiti6ui库，下边几个项目类似): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667## SECURITY#security.rememberme.key&#x3D;testkey## DATABASE## datasource.driver&#x3D;org.h2.Driver# datasource.url&#x3D;jdbc:h2:mem:activiti;DB_CLOSE_DELAY&#x3D;-1datasource.driver&#x3D;com.mysql.jdbc.Driverdatasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;activiti6ui?characterEncoding&#x3D;UTF-8datasource.username&#x3D;rootdatasource.password&#x3D;root# hibernate.dialect&#x3D;org.hibernate.dialect.H2Dialecthibernate.dialect&#x3D;org.hibernate.dialect.MySQLDialect#hibernate.dialect&#x3D;org.hibernate.dialect.Oracle10gDialect#hibernate.dialect&#x3D;org.hibernate.dialect.SQLServerDialect#hibernate.dialect&#x3D;org.hibernate.dialect.DB2Dialect#hibernate.dialect&#x3D;org.hibernate.dialect.PostgreSQLDialect# # EMAIL# #email.enabled&#x3D;true#email.host&#x3D;localhost#email.port&#x3D;1025#email.useCredentials&#x3D;false#email.username&#x3D;#email.password&#x3D;# The base url that will be used to create urls in emails.#email.base.url&#x3D;http:&#x2F;&#x2F;localhost:9999&#x2F;activiti-app#email.from.default&#x3D;no-reply@activiti.alfresco.com#email.from.default.name&#x3D;Activiti#email.feedback.default&#x3D;activiti@alfresco.com ## ACTIVITI#activiti.process-definitions.cache.max&#x3D;500## DEFAULT ADMINISTRATOR ACCOUNT#admin.email&#x3D;adminadmin.password&#x3D;testadmin.lastname&#x3D;Administratoradmin.group&#x3D;Superusers# The maximum file upload limit. Set to -1 to set to &#39;no limit&#39;. Expressed in bytesfile.upload.max.size&#x3D;104857600# For development purposes, data folder is created inside the sources .&#x2F;data foldercontentstorage.fs.rootFolder&#x3D;data&#x2F;contentstorage.fs.createRoot&#x3D;truecontentstorage.fs.depth&#x3D;4contentstorage.fs.blockSize&#x3D;1024 activiti-admin持久化 修改 activiti-admin/WEB-INF/classes/META-INF/activiti-admin/activiti-admin.properties。修改后的配置文件如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120# security configuration (this key should be unique for your application, and kept secret)security.rememberme.key&#x3D;activitis3cr3tk3y# H2 example (default)#datasource.driver&#x3D;org.h2.Driver#datasource.url&#x3D;jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;activitiadmin# MySQL exampledatasource.driver&#x3D;com.mysql.jdbc.Driverdatasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;activitiadmin?characterEncoding&#x3D;UTF-8#datasource.driver&#x3D;org.postgresql.Driver#datasource.url&#x3D;jdbc:postgresql:&#x2F;&#x2F;localhost:5432&#x2F;activitiadmin#datasource.driver&#x3D;com.microsoft.sqlserver.jdbc.SQLServerDriver#datasource.url&#x3D;jdbc:sqlserver:&#x2F;&#x2F;localhost:1433;databaseName&#x3D;activitiadmin#datasource.driver&#x3D;oracle.jdbc.driver.OracleDriver#datasource.url&#x3D;jdbc:oracle:thin:@localhost:1521:ACTIVITIADMIN#datasource.driver&#x3D;com.ibm.db2.jcc.DB2Driver#datasource.url&#x3D;jdbc:db2:&#x2F;&#x2F;localhost:50000&#x2F;activitiadmindatasource.username&#x3D;rootdatasource.password&#x3D;root# JNDI CONFIG# If uncommented, the datasource will be looked up using the configured JNDI name.# This will have preference over any datasource configuration done below that doesn&#39;t use JNDI## Eg for JBoss: java:jboss&#x2F;datasources&#x2F;activitiDS##datasource.jndi.name&#x3D;jdbc&#x2F;activitiDS# Set whether the lookup occurs in a J2EE container, i.e. if the prefix &quot;java:comp&#x2F;env&#x2F;&quot; needs to be added if the JNDI# name doesn&#39;t already contain it. Default is &quot;true&quot;.#datasource.jndi.resourceRef&#x3D;true#hibernate.dialect&#x3D;org.hibernate.dialect.H2Dialecthibernate.dialect&#x3D;org.hibernate.dialect.MySQLDialect#hibernate.dialect&#x3D;org.hibernate.dialect.Oracle10gDialect#hibernate.dialect&#x3D;org.hibernate.dialect.SQLServerDialect#hibernate.dialect&#x3D;org.hibernate.dialect.DB2Dialect#hibernate.dialect&#x3D;org.hibernate.dialect.PostgreSQLDialect#hibernate.show_sql&#x3D;false#hibernate.generate_statistics&#x3D;false## Connection pool (see http:&#x2F;&#x2F;www.mchange.com&#x2F;projects&#x2F;c3p0&#x2F;#configuration)##datasource.min-pool-size&#x3D;5#datasource.max-pool-size&#x3D;100#datasource.acquire-increment&#x3D;5# test query for H2, MySQL, PostgreSQL and Microsoft SQL Server#datasource.preferred-test-query&#x3D;select 1# test query for Oracle#datasource.preferred-test-query&#x3D;SELECT 1 FROM DUAL# test query for DB2#datasource.preferred-test-query&#x3D;SELECT current date FROM sysibm.sysdummy1#datasource.test-connection-on-checkin&#x3D;true#datasource.test-connection-on-checkout&#x3D;true#datasource.max-idle-time&#x3D;1800#datasource.max-idle-time-excess-connections&#x3D;1800## Cluster settings## This a period of time, expressed in milliseconds, that indicates# when a node is deemed to be inactive and is removed from the list# of nodes of a cluster (nor will it appear in the &#39;monitoring&#39; section of the application).## When a node is properly shut down, it will send out an event indicating# it is shut down. From that point on, the data will be kept in memory for the amount# of time indicated here.# When a node is not properly shut down (eg hardware failure), this is the period of time# before removal, since the time the last event is received.## Make sure the value here is higher than the sending interval of the nodes, to avoid# that nodes incorrectly removed.## By default 10 minutescluster.monitoring.max.inactive.time&#x3D;600000# A cron expression that configures when the check for inactive nodes is made.# When executed, this will mark any node that hasn&#39;t been active for &#39;cluster.monitoring.max.inactive.time&#39;# seconds, as an inactive node. Default: every 5 minutes.cluster.monitoring.inactive.check.cronexpression&#x3D;0 0&#x2F;5 * * * ?# REST endpoint configrest.app.name&#x3D;Activiti apprest.app.description&#x3D;Activiti app Rest configrest.app.host&#x3D;http:&#x2F;&#x2F;localhostrest.app.port&#x3D;8080rest.app.contextroot&#x3D;activiti-apprest.app.restroot&#x3D;apirest.app.user&#x3D;adminrest.app.password&#x3D;test# Passwords for rest endpoints and master configs are stored encrypted in the database using AES&#x2F;CBC&#x2F;PKCS5PADDING# It needs a 128-bit initialization vector (http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Initialization_vector)# and a 128-bit secret key represented as 16 ascii characters below## Do note that if these properties are changed after passwords have been saved, all existing passwords# will not be able to be decrypted and the password would need to be reset in the UI.security.encryption.credentialsIVSpec&#x3D;j8kdO2hejA9lKmm6security.encryption.credentialsSecretSpec&#x3D;9FGl73ngxcOoJvmL# BPMN 2.0 Modeler configmodeler.url&#x3D;https:&#x2F;&#x2F;activiti.alfresco.com&#x2F;activiti-app&#x2F;api&#x2F;# Enable multi tenant support, disabled by default#multi-tenant.enabled&#x3D;true 由于该项目下没有mysql驱动包，手动复制 activiti-app/WEB-INF/lib/mysql-connector-java-5.1.30.jar 到 activiti-admin/WEB-INF/lib 下。 activiti-rest持久化 修改 activiti-rest/WEB-INF/classes/db.properties, 修改后的配置文件如下: 123456789101112# db&#x3D;h2# jdbc.driver&#x3D;org.h2.Driver# jdbc.url&#x3D;jdbc:h2:mem:activiti;DB_CLOSE_DELAY&#x3D;-1# jdbc.username&#x3D;sa# jdbc.password&#x3D;db&#x3D;MySQLdatasource.driver&#x3D;com.mysql.jdbc.Driverdatasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;activiti6ui?characterEncoding&#x3D;UTF-8datasource.username&#x3D;rootdatasource.password&#x3D;roothibernate.dialect&#x3D;org.hibernate.dialect.MySQLDialect 同样，将 activiti-app/WEB-INF/lib/mysql-connector-java-5.1.30.jar 复制到 activiti-rest/WEB-INF/lib。 文档路径: http://127.0.0.1:8080/activiti-rest/docs/ 启动Tomcat, 按照默认url和帐号访问3个项目即可 最后 官方 activiti6 前端是基于 angular 编写的，UI也不太符合国人习惯，大家可以基于官方设计重写UI即可。","categories":[{"name":"activiti","slug":"activiti","permalink":"https://idea360.cn/categories/activiti/"}],"tags":[{"name":"activiti","slug":"activiti","permalink":"https://idea360.cn/tags/activiti/"},{"name":"工作流","slug":"工作流","permalink":"https://idea360.cn/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}]},{"title":"curl用法指南","slug":"curl-study","date":"2020-03-29T09:35:28.000Z","updated":"2021-02-23T14:12:32.109Z","comments":true,"path":"2020/03/29/curl-study/","link":"","permalink":"https://idea360.cn/2020/03/29/curl-study/","excerpt":"","text":"简介 curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。 它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。 本文介绍它的主要命令行参数，作为日常的参考，方便查阅。内容主要翻译自《curl cookbook》。为了节约篇幅，下面的例子不包括运行时的输出，初学者可以先看我以前写的《curl 初学者教程》。 不带有任何参数时，curl 就是发出 GET 请求。 1$ curl https://www.example.com 上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出。 -A -A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。 1$ curl -A &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#x27; https://google.com 上面命令将User-Agent改成 Chrome 浏览器。 1$ curl -A &#x27;&#x27; https://google.com 上面命令会移除User-Agent标头。 也可以通过-H参数直接指定标头，更改User-Agent。 1$ curl -H &#x27;User-Agent: php/1.0&#x27; https://google.com -b -b参数用来向服务器发送 Cookie。 1$ curl -b &#x27;foo=bar&#x27; https://google.com 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。 1$ curl -b &#x27;foo1=bar;foo2=bar2&#x27; https://google.com 上面命令发送两个 Cookie。 1$ curl -b cookies.txt https://www.google.com 上面命令读取本地文件cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。 -c -c参数将服务器设置的 Cookie 写入一个文件。 1$ curl -c cookies.txt https://www.google.com 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。 -d -d参数用于发送 POST 请求的数据体。 123$ curl -d&#x27;login=emma＆password=123&#x27;-X POST https://google.com/login# 或者$ curl -d &#x27;login=emma&#x27; -d &#x27;password=123&#x27; -X POST https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。 -d参数可以读取本地文本文件的数据，向服务器发送。 1$ curl -d &#x27;@data.txt&#x27; https://google.com/login 上面命令读取data.txt文件的内容，作为数据体向服务器发送。 –data-urlencode --data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 1$ curl --data-urlencode &#x27;comment=hello world&#x27; https://google.com/login 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。 -e -e参数用来设置 HTTP 的标头Referer，表示请求的来源。 1curl -e &#x27;https://google.com?q=example&#x27; https://www.example.com 上面命令将Referer标头设为https://google.com?q=example。 -H参数可以通过直接添加标头Referer，达到同样效果。 1curl -H &#x27;Referer: https://google.com?q=example&#x27; https://www.example.com -F -F参数用来向服务器上传二进制文件。 1$ curl -F &#x27;file=@photo.png&#x27; https://google.com/profile 上面命令会给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。 -F参数可以指定 MIME 类型。 1$ curl -F &#x27;file=@photo.png;type=image/png&#x27; https://google.com/profile 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。 -F参数也可以指定文件名。 1$ curl -F &#x27;file=@photo.png;filename=me.png&#x27; https://google.com/profile 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。 -G -G参数用来构造 URL 的查询字符串。 1$ curl -G -d &#x27;q=kitties&#x27; -d &#x27;count=20&#x27; https://google.com/search 上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求。 如果数据需要 URL 编码，可以结合--data--urlencode参数。 1$ curl -G --data-urlencode &#x27;comment=hello world&#x27; https://www.example.com -H -H参数添加 HTTP 请求的标头。 1$ curl -H &#x27;Accept-Language: en-US&#x27; https://google.com 上面命令添加 HTTP 标头Accept-Language: en-US。 1$ curl -H &#x27;Accept-Language: en-US&#x27; -H &#x27;Secret-Message: xyzzy&#x27; https://google.com 上面命令添加两个 HTTP 标头。 1$ curl -d &#x27;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#x27; -H &#x27;Content-Type: application/json&#x27; https://google.com/login 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。 -i -i参数打印出服务器回应的 HTTP 标头。 1$ curl -i https://www.example.com 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 -I -I参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。 1$ curl -I https://www.example.com 上面命令输出服务器对 HEAD 请求的回应。 --head参数等同于-I。 1$ curl --head https://www.example.com -k -k参数指定跳过 SSL 检测。 1$ curl -k https://www.example.com 上面命令不会检查服务器的 SSL 证书是否正确。 -L -L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 1$ curl -L -d &#x27;tweet=hi&#x27; https://api.twitter.com/tweet –limit-rate --limit-rate用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。 1$ curl --limit-rate 200k https://google.com 上面命令将带宽限制在每秒 200K 字节。 -o -o参数将服务器的回应保存成文件，等同于wget命令。 1$ curl -o example.html https://www.example.com 上面命令将www.example.com保存成example.html。 -O -O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 1$ curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为bar.html。 -s -s参数将不输出错误和进度信息。 1$ curl -s https://www.example.com 上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。 如果想让 curl 不产生任何输出，可以使用下面的命令。 1$ curl -s -o /dev/null https://google.com -S -S参数指定只输出错误信息，通常与-s一起使用。 1$ curl -s -o /dev/null https://google.com 上面命令没有任何输出，除非发生错误。 -u -u参数用来设置服务器认证的用户名和密码。 1$ curl -u &#x27;bob:12345&#x27; https://google.com/login 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。 curl 能够识别 URL 里面的用户名和密码。 1$ curl https://bob:12345@google.com/login 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。 1$ curl -u &#x27;bob&#x27; https://google.com/login 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。 -v -v参数输出通信的整个过程，用于调试。 1$ curl -v https://www.example.com --trace参数也可以用于调试，还会输出原始的二进制数据。 1$ curl --trace - https://www.example.com -x -x参数指定 HTTP 请求的代理。 1$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。 如果没有指定代理协议，默认为 HTTP。 1$ curl -x james:cats@myproxy.com:8080 https://www.example.com 上面命令中，请求的代理使用 HTTP 协议。 -X -X参数指定 HTTP 请求的方法。 1$ curl -X POST https://www.example.com 上面命令对https://www.example.com发出 POST 请求。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"curl","slug":"curl","permalink":"https://idea360.cn/tags/curl/"}]},{"title":"spring-cloud-gateway过滤器实践","slug":"spring-cloud-gateway-filter","date":"2020-03-29T07:17:16.000Z","updated":"2021-07-10T12:04:13.254Z","comments":true,"path":"2020/03/29/spring-cloud-gateway-filter/","link":"","permalink":"https://idea360.cn/2020/03/29/spring-cloud-gateway-filter/","excerpt":"","text":"概述 这里是 SpringCloud Gateway 实践的第一篇，主要讲过滤器的相关实现。Spring-Cloud-Gateway是以 WebFlux 为基础的响应式架构设计, 是异步非阻塞式的，它能够充分利用多核 CPU 的硬件资源去处理大量的并发请求。 本篇将基于 spring-cloud-gateway简介 基础环境进行改造。 工作原理 Spring-Cloud-Gateway基于过滤器实现，同zuul类似，有pre和post两种方式的filter,分别处理前置逻辑和后置逻辑。客户端的请求先经过pre类型的filter，然后将请求转发到具体的业务服务，收到业务服务的响应之后，再经过post类型的filter处理，最后返回响应到客户端。 过滤器执行流程如下，order越大，优先级越低 接下来我们来验证下 filter 执行顺序。 这里创建3个过滤器，分别配置不同的优先级 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Slf4jpublic class AFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(&quot;AFilter前置逻辑&quot;); return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; log.info(&quot;AFilter后置逻辑&quot;); &#125;)); &#125;&#125;@Slf4jpublic class BFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(&quot;BFilter前置逻辑&quot;); return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; log.info(&quot;BFilter后置逻辑&quot;); &#125;)); &#125;&#125;@Slf4jpublic class CFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(&quot;CFilter前置逻辑&quot;); return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123; log.info(&quot;CFilter后置逻辑&quot;); &#125;)); &#125;&#125;@Configurationpublic class FilterConfig &#123; @Bean @Order(-1) public GlobalFilter a() &#123; return new AFilter(); &#125; @Bean @Order(0) public GlobalFilter b() &#123; return new BFilter(); &#125; @Bean @Order(1) public GlobalFilter c() &#123; return new CFilter(); &#125;&#125; 123curl -X POST -H &quot;Content-Type:application/json&quot; -d &#x27;&#123;&quot;name&quot;: &quot;admin&quot;&#125;&#x27; http://192.168.124.5:2000/p/provider1curl -X GET -G -d &quot;username=admin&quot; http://192.168.124.5:2000/p/provider1/1 查看网关输出日志 12345672020-03-29 16:23:22.832 INFO 59326 --- [ctor-http-nio-6] cn.idea360.gateway.filter1.AFilter : AFilter前置逻辑2020-03-29 16:23:22.832 INFO 59326 --- [ctor-http-nio-6] cn.idea360.gateway.filter1.BFilter : BFilter前置逻辑2020-03-29 16:23:22.832 INFO 59326 --- [ctor-http-nio-6] cn.idea360.gateway.filter1.CFilter : CFilter前置逻辑2020-03-29 16:23:22.836 INFO 59326 --- [ctor-http-nio-6] cn.idea360.gateway.filter1.CFilter : CFilter后置逻辑2020-03-29 16:23:22.836 INFO 59326 --- [ctor-http-nio-6] cn.idea360.gateway.filter1.BFilter : BFilter后置逻辑2020-03-29 16:23:22.836 INFO 59326 --- [ctor-http-nio-6] cn.idea360.gateway.filter1.AFilter : AFilter后置逻辑 自定义过滤器 现在假设我们要统计某个服务的响应时间，我们可以在代码中 1234long beginTime = System.currentTimeMillis();// do something...long elapsed = System.currentTimeMillis() - beginTime;log.info(&quot;elapsed: &#123;&#125;ms&quot;, elapsed); 每次都要这么写是不是很烦？Spring 告诉我们有个东西叫 AOP。但是我们是微服务啊，在每个服务里都写也很烦。这时候就该网关的过滤器登台表演了。 自定义过滤器需要实现 GatewayFilter 和 Ordered 。其中 GatewayFilter 中的这个方法就是用来实现你的自定义的逻辑的 1Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); 而 Ordered 中的 int getOrder() 方法是来给过滤器设定优先级别的，值越大则优先级越低。 好了，让我们来撸代码吧. 1234567891011121314151617181920212223242526272829/** * 此过滤器功能为计算请求完成时间 */public class ElapsedFilter implements GatewayFilter, Ordered &#123; private static final String ELAPSED_TIME_BEGIN = &quot;elapsedTimeBegin&quot;; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; exchange.getAttributes().put(ELAPSED_TIME_BEGIN, System.currentTimeMillis()); return chain.filter(exchange).then( Mono.fromRunnable(() -&gt; &#123; Long startTime = exchange.getAttribute(ELAPSED_TIME_BEGIN); if (startTime != null) &#123; System.out.println(exchange.getRequest().getURI().getRawPath() + &quot;: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125; &#125;) ); &#125; /* *过滤器存在优先级，order越大，优先级越低 */ @Override public int getOrder() &#123; return Ordered.LOWEST_PRECEDENCE; &#125;&#125; 我们在请求刚刚到达时，往 ServerWebExchange 中放入了一个属性 elapsedTimeBegin，属性值为当时的毫秒级时间戳。然后在请求执行结束后，又从中取出我们之前放进去的那个时间戳，与当前时间的差值即为该请求的耗时。因为这是与业务无关的日志所以将 Ordered 设为 Integer.MAX_VALUE 以降低优先级。 现在再来看我们之前的问题：怎么来区分是 “pre” 还是 “post” 呢？其实就是 chain.filter(exchange) 之前的就是 “pre” 部分，之后的也就是 then 里边的是 “post” 部分。 创建好 Filter 之后我们将它添加到我们的 Filter Chain 里边 1234567891011121314151617181920212223242526@Configurationpublic class FilterConfig &#123; /** * http://localhost:8100/filter/provider * @param builder * @return */ @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) &#123; // @formatter:off // 可以对比application.yml中关于路由转发的配置 return builder.routes() .route(r -&gt; r.path(&quot;/filter/**&quot;) .filters(f -&gt; f.stripPrefix(1) .filter(new ElapsedFilter())) .uri(&quot;lb://idc-cloud-provider&quot;) .order(0) .id(&quot;filter&quot;) ) .build(); // @formatter:on &#125;&#125; 基于全局过滤器实现审计功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// AdaptCachedBodyGlobalFilter@Componentpublic class LogFilter implements GlobalFilter, Ordered &#123; private Logger log = LoggerFactory.getLogger(LogFilter.class); private final ObjectMapper objectMapper = new ObjectMapper(); private static final String START_TIME = &quot;startTime&quot;; private static final List&lt;HttpMessageReader&lt;?&gt;&gt; messageReaders = HandlerStrategies.withDefaults().messageReaders(); @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; ServerHttpRequest request = exchange.getRequest(); // 请求路径 String path = request.getPath().pathWithinApplication().value(); // 请求schema: http/https String scheme = request.getURI().getScheme(); // 请求方法 HttpMethod method = request.getMethod(); // 路由服务地址 URI targetUri = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR); // 请求头 HttpHeaders headers = request.getHeaders(); // 设置startTime exchange.getAttributes().put(START_TIME, System.currentTimeMillis()); // 获取请求地址 InetSocketAddress remoteAddress = request.getRemoteAddress(); MultiValueMap&lt;String, String&gt; formData = null; AccessRecord accessRecord = new AccessRecord(); accessRecord.setPath(path); accessRecord.setSchema(scheme); accessRecord.setMethod(method.name()); accessRecord.setTargetUri(targetUri.toString()); accessRecord.setRemoteAddress(remoteAddress.toString()); accessRecord.setHeaders(headers); if (method == HttpMethod.GET) &#123; formData = request.getQueryParams(); accessRecord.setFormData(formData); writeAccessRecord(accessRecord); &#125; if (method == HttpMethod.POST) &#123; Mono&lt;Void&gt; voidMono = null; if (headers.getContentType().equals(MediaType.APPLICATION_JSON)) &#123; // JSON voidMono = readBody(exchange, chain, accessRecord); &#125; if (headers.getContentType().equals(MediaType.APPLICATION_FORM_URLENCODED)) &#123; // x-www-form-urlencoded voidMono = readFormData(exchange, chain, accessRecord); &#125; if (voidMono != null) &#123; return voidMono; &#125; &#125; return chain.filter(exchange); &#125; private Mono&lt;Void&gt; readFormData(ServerWebExchange exchange, GatewayFilterChain chain, AccessRecord accessRecord) &#123; return null; &#125; private Mono&lt;Void&gt; readBody(ServerWebExchange exchange, GatewayFilterChain chain, AccessRecord accessRecord) &#123; return DataBufferUtils.join(exchange.getRequest().getBody()).flatMap(dataBuffer -&gt; &#123; byte[] bytes = new byte[dataBuffer.readableByteCount()]; dataBuffer.read(bytes); DataBufferUtils.release(dataBuffer); Flux&lt;DataBuffer&gt; cachedFlux = Flux.defer(() -&gt; &#123; DataBuffer buffer = exchange.getResponse().bufferFactory().wrap(bytes); DataBufferUtils.retain(buffer); return Mono.just(buffer); &#125;); // 重写请求体,因为请求体数据只能被消费一次 ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator(exchange.getRequest()) &#123; @Override public Flux&lt;DataBuffer&gt; getBody() &#123; return cachedFlux; &#125; &#125;; ServerWebExchange mutatedExchange = exchange.mutate().request(mutatedRequest).build(); return ServerRequest.create(mutatedExchange, messageReaders) .bodyToMono(String.class) .doOnNext(objectValue -&gt; &#123; accessRecord.setBody(objectValue); writeAccessRecord(accessRecord); &#125;).then(chain.filter(mutatedExchange)); &#125;); &#125; @Override public int getOrder() &#123; return Ordered.LOWEST_PRECEDENCE; &#125; /** * TODO 异步日志 * @param accessRecord */ private void writeAccessRecord(AccessRecord accessRecord) &#123; log.info(&quot;\\n\\n start------------------------------------------------- \\n &quot; + &quot;请求路径:&#123;&#125;\\n &quot; + &quot;scheme:&#123;&#125;\\n &quot; + &quot;请求方法:&#123;&#125;\\n &quot; + &quot;目标服务:&#123;&#125;\\n &quot; + &quot;请求头:&#123;&#125;\\n &quot; + &quot;远程IP地址:&#123;&#125;\\n &quot; + &quot;表单参数:&#123;&#125;\\n &quot; + &quot;请求体:&#123;&#125;\\n &quot; + &quot;end------------------------------------------------- \\n &quot;, accessRecord.getPath(), accessRecord.getSchema(), accessRecord.getMethod(), accessRecord.getTargetUri(), accessRecord.getHeaders(), accessRecord.getRemoteAddress(), accessRecord.getFormData(), accessRecord.getBody()); &#125;&#125; 123curl -X POST -H &quot;Content-Type:application/json&quot; -d &#x27;&#123;&quot;name&quot;: &quot;admin&quot;&#125;&#x27; http://192.168.124.5:2000/p/provider1curl -X GET -G -d &quot;username=admin&quot; http://192.168.124.5:2000/p/provider1/1 输出结果 12345678910start------------------------------------------------- 请求路径:&#x2F;provider1scheme:http请求方法:POST目标服务:http:&#x2F;&#x2F;192.168.124.5:2001&#x2F;provider1请求头:[Content-Type:&quot;application&#x2F;json&quot;, User-Agent:&quot;PostmanRuntime&#x2F;7.22.0&quot;, Accept:&quot;*&#x2F;*&quot;, Cache-Control:&quot;no-cache&quot;, Postman-Token:&quot;2a4ce04d-8449-411d-abd8-247d20421dc2&quot;, Host:&quot;192.168.124.5:2000&quot;, Accept-Encoding:&quot;gzip, deflate, br&quot;, Content-Length:&quot;16&quot;, Connection:&quot;keep-alive&quot;]远程IP地址:&#x2F;192.168.124.5:49969表单参数:null请求体:&#123;&quot;name&quot;:&quot;admin&quot;&#125;end------------------------------------------------- 接下来，我们来配置日志，方便日志系统提取日志。SpringBoot默认的日志为logback。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS&quot; value=&quot;/Users/cuishiying/Documents/spring-cloud-learning/logs&quot; /&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt; %black(%d&#123;ISO8601&#125;) %highlight(%-5level) [%blue(%t)] %yellow(%C&#123;1.&#125;): %msg%n%throwable &lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;RollingFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;LOGS&#125;/spring-boot-logger.log&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d %p %C&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt; &lt;fileNamePattern&gt;$&#123;LOGS&#125;/archived/spring-boot-logger-%d&#123;yyyy-MM-dd&#125;.%i.log &lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- LOG everything at INFO level --&gt; &lt;root level=&quot;info&quot;&gt; &lt;!--&lt;appender-ref ref=&quot;RollingFile&quot; /&gt;--&gt; &lt;appender-ref ref=&quot;Console&quot; /&gt; &lt;/root&gt; &lt;!-- LOG &quot;cn.idea360*&quot; at TRACE level additivity:是否向上级loger传递打印信息。默认是true--&gt; &lt;logger name=&quot;cn.idea360.gateway&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot; /&gt; &lt;appender-ref ref=&quot;Console&quot; /&gt; &lt;/logger&gt;&lt;/configuration&gt; 这样console和日志目录下就都有日志了。 自定义过滤器工厂 如果你看过静态路由的配置，你应该对如下配置有印象。 123filters: - StripPrefix&#x3D;1 - AddResponseHeader&#x3D;X-Response-Default-Foo, Default-Bar StripPrefix、AddResponseHeader 这两个实际上是两个过滤器工厂（GatewayFilterFactory），用这种配置的方式更灵活方便。 我们就将之前的那个 ElapsedFilter 改造一下，让它能接收一个 boolean 类型的参数，来决定是否将请求参数也打印出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ElapsedGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;ElapsedGatewayFilterFactory.Config&gt; &#123; private static final Log log = LogFactory.getLog(GatewayFilter.class); private static final String ELAPSED_TIME_BEGIN = &quot;elapsedTimeBegin&quot;; private static final String KEY = &quot;withParams&quot;; public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(KEY); &#125; public ElapsedGatewayFilterFactory() &#123; super(Config.class); &#125; public GatewayFilter apply(Config config) &#123; return (exchange, chain) -&gt; &#123; exchange.getAttributes().put(ELAPSED_TIME_BEGIN, System.currentTimeMillis()); return chain.filter(exchange).then( Mono.fromRunnable(() -&gt; &#123; Long startTime = exchange.getAttribute(ELAPSED_TIME_BEGIN); if (startTime != null) &#123; StringBuilder sb = new StringBuilder(exchange.getRequest().getURI().getRawPath()) .append(&quot;: &quot;) .append(System.currentTimeMillis() - startTime) .append(&quot;ms&quot;); if (config.isWithParams()) &#123; sb.append(&quot; params:&quot;).append(exchange.getRequest().getQueryParams()); &#125; log.info(sb.toString()); &#125; &#125;) ); &#125;; &#125; public static class Config &#123; private boolean withParams; public boolean isWithParams() &#123; return withParams; &#125; public void setWithParams(boolean withParams) &#123; this.withParams = withParams; &#125; &#125;&#125; 过滤器工厂的顶级接口是 GatewayFilterFactory，我们可以直接继承它的两个抽象类来简化开发 AbstractGatewayFilterFactory 和 AbstractNameValueGatewayFilterFactory，这两个抽象类的区别就是前者接收一个参数（像 StripPrefix 和我们创建的这种），后者接收两个参数（像 AddResponseHeader）。 GatewayFilter apply(Config config) 方法内部实际上是创建了一个 GatewayFilter 的匿名类，具体实现和之前的几乎一样，就不解释了。 静态内部类 Config 就是为了接收那个 boolean 类型的参数服务的，里边的变量名可以随意写，但是要重写 List shortcutFieldOrder() 这个方法。 这里注意一下，一定要调用一下父类的构造器把 Config 类型传过去，否则会报 ClassCastException 123public ElapsedGatewayFilterFactory() &#123; super(Config.class);&#125; 工厂类我们有了，再把它注册到 Spring 当中 1234@Beanpublic ElapsedGatewayFilterFactory elapsedGatewayFilterFactory() &#123; return new ElapsedGatewayFilterFactory();&#125; 然后添加配置（主要改动在 default-filters 配置） 123456789101112131415161718192021222324252627282930313233server: port: 2000spring: application: name: idc-gateway redis: host: localhost port: 6379 timeout: 6000ms # 连接超时时长（毫秒） jedis: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 cloud: consul: host: localhost port: 8500 gateway: discovery: locator: enabled: true # 修改在这里。gateway可以通过开启以下配置来打开根据服务的serviceId来匹配路由,默认是大写 default-filters: - Elapsed=true routes: - id: provider # 路由 ID，保持唯一 uri: lb://idc-provider1 # uri指目标服务地址，lb代表从注册中心获取服务 predicates: # 路由条件。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非） - Path=/p/** filters: - StripPrefix=1 # 过滤器StripPrefix，作用是去掉请求路径的最前面n个部分截取掉。StripPrefix=1就代表截取路径的个数为1，比如前端过来请求/test/good/1/view，匹配成功后，路由到后端的请求路径就会变成http://localhost:8888/good/1/view 结语 本文到此结束。关于 Webflux 的学习刚入门，觉得可以像 Rxjava 那样在 onNext 中拿到异步数据，然而在 post 获取body中没生效。经测试可知 getBody 获得的数据输出为null，而自己通过 Flux.create 创建的数据可以在订阅者中获取到。此处还有待研究，希望抛砖引玉，大家有研究出来的不吝赐教。同时，希望大家关注公众号【当我遇上你】。 参考 https://programming.vip/docs/spring-cloud-gateway-intercepts-request-body.html http://www.throwable.club/2019/05/05/spring-cloud-gateway-custom-global-filter/","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"过滤器","slug":"过滤器","permalink":"https://idea360.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://idea360.cn/tags/SpringCloud/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"}]},{"title":"spring-cloud-gateway简介","slug":"spring-cloud-gateway-introduce","date":"2020-03-29T06:47:53.000Z","updated":"2021-07-10T12:05:14.200Z","comments":true,"path":"2020/03/29/spring-cloud-gateway-introduce/","link":"","permalink":"https://idea360.cn/2020/03/29/spring-cloud-gateway-introduce/","excerpt":"","text":"概述 API网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求。如果让客户端直接与各个微服务通信，会有以下的问题： 客户端会多次请求不同的微服务，增加了客户端的复杂性。 存在跨域请求，在一定场景下处理相对复杂。 认证复杂，每个服务都需要独立认证。 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。 某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。 以上这些问题可以借助API网关解决。API网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由API网关来做，这样既提高业务灵活性又不缺安全性。 由于篇幅比较长, 决定分几篇来介绍相关知识: spring-cloud-gateway简介+基本环境搭建 spring-cloud-gateway过滤器+审计 spring-cloud-gateway静态路由 spring-cloud-gateway动态路由 spring-cloud-gateway限流+过载保护 spring-cloud-gateway认证 spring-cloud-gateway鉴权 环境参数 开发工具: IDEA 基础工具: Maven+JDK8 SpringBoot版本: 2.1.4.RELEASE SpringCloud版本: Greenwich.SR3 服务发现: consul consul搭建可以参照官网,开箱即用。也可以参照Docker实战之Consul集群 基于docker环境搭建。 SpringCloud项目搭建 项目pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-learning&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;modules&gt; &lt;module&gt;idc-provider1&lt;/module&gt; &lt;module&gt;idc-provider2&lt;/module&gt; &lt;module&gt;idc-gateway&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;spring-cloud-learning&lt;/name&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache License, Version 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;name&gt;cuishiying&lt;/name&gt; &lt;email&gt;cuishiying163@163.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot.version&gt;2.1.4.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt; &lt;docker.image.prefix&gt;csy&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.51&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.name&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19.1&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;!--默认关掉单元测试 --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;!--阿里云主仓库，代理了maven central和jcenter仓库--&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;!--阿里云代理Spring 官方仓库--&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!--阿里云代理Spring 插件仓库--&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-plugin&lt;/id&gt; &lt;name&gt;spring-plugin&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 服务提供者1(服务提供+服务消费) pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-learning&lt;/artifactId&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;idc-provider1&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置文件application.yml 12345678910111213141516spring: application: name: idc-provider1 cloud: consul: host: localhost port: 8500server: port: 2001feign: client: config: remote-service: #服务名，填写default为所有服务 connectTimeout: 1000 readTimeout: 3000 SpringBoot项目入口Provider1App.java 12345678910@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Provider1App &#123; public static void main(String[] args) &#123; SpringApplication.run(Provider1App.class, args); &#125;&#125; 远程调用RemoteService.java 1234567891011@FeignClient(&quot;idc-provider2&quot;)public interface RemoteService &#123; /** * 方法名随意，url路径匹配即可 * @return */ @GetMapping(&quot;/provider2&quot;) Object getProvider2();&#125; web服务 1234567891011121314151617181920212223242526@RestControllerpublic class TestController &#123; @Autowired Environment env; @Autowired RemoteService remoteService; @GetMapping(&quot;/provider1/&#123;id&#125;&quot;) public Object getTest(@PathVariable(required = false) Integer id, @RequestParam(required = false) String username) &#123; return env.getProperty(&quot;local.server.port&quot;); &#125; @PostMapping(&quot;/provider1&quot;) public Object postTest(@RequestBody Map&lt;String, String&gt; params) &#123; System.out.println(params); return env.getProperty(&quot;local.server.port&quot;); &#125; @GetMapping(&quot;/remote/get&quot;) public Object remoteGetTest() &#123; Object provider2 = remoteService.getProvider2(); System.out.println(&quot;remote load data from provider2:&quot; + provider2); return provider2; &#125;&#125; 服务提供者2(服务提供) provider2和provider1类似，这里只改写下web实现类 123456789101112131415161718@RestControllerpublic class TestController &#123; @Autowired Environment env; @GetMapping(&quot;/provider2&quot;) public Object getTest() &#123; String port = env.getProperty(&quot;local.server.port&quot;); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;port&quot;, port); System.out.println(&quot;idc-provider2:&quot; + port); return jsonObject; &#125;&#125; Feign中集成了Ribbon负载均衡。这里可以用不同端口启动2个provider2实例, 然后通过provider1调用provider2，可以看到轮询输出不同的端口。 网关服务 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-learning&lt;/artifactId&gt; &lt;groupId&gt;cn.idea360&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;idc-gateway&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--consul客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--健康监控--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.51&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml 123456789101112131415161718192021222324252627282930313233343536server: port: 2000spring: application: name: idc-gateway redis: host: localhost port: 6379 timeout: 6000ms # 连接超时时长（毫秒） jedis: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 cloud: consul: host: localhost port: 8500 gateway: discovery: locator: enabled: true # gateway可以通过开启以下配置来打开根据服务的serviceId来匹配路由,默认是大写 routes: - id: provider1 # 路由 ID，保持唯一 uri: lb://idc-provider1 # uri指目标服务地址，lb代表从注册中心获取服务 predicates: # 路由条件。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非） - Path=/p/** filters: - StripPrefix=1 # 过滤器StripPrefix，作用是去掉请求路径的最前面n个部分截取掉。StripPrefix=1就代表截取路径的个数为1，比如前端过来请求/test/good/1/view，匹配成功后，路由到后端的请求路径就会变成http://localhost:8888/good/1/viewlogging: level: org.springframework.cloud.gateway: DEBUG reactor.netty.http.client: DEBUG 启动类 12345678@SpringBootApplication@EnableDiscoveryClientpublic class GatewayApp &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApp.class, args); &#125;&#125; 结语 到这里基本环境就搭建完毕了，下节做过滤器的相关实现。感谢大家阅读，欢迎关注公众号【当我遇上你】学习交流。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"https://idea360.cn/tags/Spring-Cloud/"}]},{"title":"MySQL经典笔试题","slug":"mysql-interview-classic","date":"2020-03-27T02:11:11.000Z","updated":"2021-02-23T14:38:50.757Z","comments":true,"path":"2020/03/27/mysql-interview-classic/","link":"","permalink":"https://idea360.cn/2020/03/27/mysql-interview-classic/","excerpt":"","text":"题目 1. 表结构 Student（s_id, sname, sage, ssex） 学生表 Course（c_id, cname, t_id）课程表 SC（s_id, c_id, score）成绩表 Teacher（t_id，tname）教师表 2. 建表 1234567891011121314151617181920212223242526272829create database edu;CREATE TABLE student ( s_id int(11) NOT NULL AUTO_INCREMENT, sname varchar(32) DEFAULT NULL, sage int(11) DEFAULT NULL, ssex varchar(8) DEFAULT NULL, PRIMARY KEY ( s_id ) ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_general_ci COMMENT &#39;学生表&#39;;DROP TABLE IF EXISTS &#96;course&#96;;CREATE TABLE course ( c_id int(11) NOT NULL, cname varchar(32) DEFAULT NULL, t_id int(11) DEFAULT NULL ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_general_ci COMMENT &#39;课程表&#39;;DROP TABLE IF EXISTS &#96;sc&#96;;CREATE TABLE sc ( s_id int(11) NOT NULL, c_id int(11) DEFAULT NULL, score int(11) DEFAULT NULL ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_general_ci COMMENT &#39;成绩表&#39;;DROP TABLE IF EXISTS &#96;teacher&#96;;CREATE TABLE teacher ( t_id int(11) NOT NULL, tname varchar(16) DEFAULT NULL ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_general_ci COMMENT &#39;教师表&#39;; 3. 初始化数据 1234567891011121314151617181920insert into &#96;student&#96; values(1, &#39;张三&#39;, 18, &#39;男&#39;),(2, &#39;李四&#39;, 17, &#39;女&#39;),(3, &#39;王五&#39;, 18, &#39;男&#39;);insert into &#96;teacher&#96; values(1, &#39;赵六&#39;),(2, &#39;吕七&#39;);insert into &#96;course&#96; values(1, &#39;语文&#39;, 1),(2, &#39;数学&#39;, 2);insert into &#96;sc&#96; values(1, 1, 90),(1, 2, 80),(2, 1, 70),(2, 2, 99),(3, 1, 97),(3, 2, 87); 问题与答案 1. select的结果可以当做一个表 查询“1”课程比“2”课程成绩高的所有学生的学号； 12345select a.s_id from (select s_id,score from SC where c_id&#x3D;1) a,(select s_id,score from SC where c_id&#x3D;2) b where a.score&gt;b.score and a.s_id&#x3D;b.s_id; 2. 查询平均成绩大于60分的同学的学号和平均成绩； 聚集函数和groupby一起出现，where不能连用 1select s_id,avg(score) from sc group by s_id having avg(score) &gt;60; 3. 查询所有同学的学号、姓名、选课数、总成绩 连接查询+groupby 1select s.s_id, s.sname, count(c.c_id), sum(c.score) from student s, sc c where s.s_id &#x3D; c.s_id group by s.s_id; 4. 查询没学过“赵六”老师课的同学的学号、姓名； 子查询 in 、not in 12345678910select Student.S#,Student.Sname from Studentwhere s_id not in ( select distinct( SC.S_id) from SC,Course,Teacher where SC.c_id&#x3D;Course.c_id and Teacher.t_id&#x3D;Course.t_id and Teacher.Tname&#x3D;&#39;赵六&#39;); 5. 查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名； 1select distinct s_ic,sname from Student,SC where Student.s_id&#x3D;SC.s_id and SC.c_id in (select c_id from SC where s_id&#x3D;1); 6. 查询学过1并且也学过编号2课程的同学的学号、姓名； and 不能连接同一个字段 正确写法 1select s_id from sc where score &#x3D; 90 and c_id in (1,2); 错误写法 1select s_id from sc where score &#x3D; 90 and c_id &#x3D; 1 and c_id &#x3D; 2; 7. 查询同名同性学生名单，并统计同名人数 1select sname,count() from Student group by sname having count()&gt;1; 8. 查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列 Order by 多个字段 例如order by id， score desc 首先会按照id降序排列，当id相同时，再按score降序排列 1select c_id, avg(score) from sc GROUP BY c_id order by avg(score) , c_id desc; 9. 查询平均成绩大于85的所有学生的姓名和平均成绩； group by多个字段 例如group by s_id， c_id 表示属于s_id， 又属于c_id的，例如属于1号学生的，又属于2号课程的 工作流程： 首先按照s_id分组，分组的结果再用c_id来分组。 1select s.s_id, s.sname, avg(c.score) from student s, sc c where s.s_id &#x3D; c.s_id group by s.sname , s.sage having avg(score) &gt; 80; 因为学生可能同名，所以group by s.sname , s.sage的作用就是，先按姓名分组，要是有重复的姓名，再按照性别分组。 10. 查询每门功成绩最好的前两名 MySQL不支持top，用limit，而且limit不能用于子查询 错误写法 1select s.s_id, s.sname , c.score from student s, sc c where s.s_id &#x3D; c.s_id and score in( select score from sc GROUP BY s_id order by score desc limit 2); 正确写法 1select s.s_id, s.sname , c.score from student s, sc c where s.s_id &#x3D; c.s_id and score in( select score from sc GROUP BY s_id order by score desc) limit 2;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"MySQL列行转换","slug":"mysql-column-to-row","date":"2020-03-26T10:47:06.000Z","updated":"2021-02-23T14:38:39.061Z","comments":true,"path":"2020/03/26/mysql-column-to-row/","link":"","permalink":"https://idea360.cn/2020/03/26/mysql-column-to-row/","excerpt":"","text":"概述 业务中我们经常会基于MySQL做报表统计, 或者修改了表结构后需要做数据迁移, 本文做一个列行转换的演示 环境准备 创建数据库 1create database score; 创建表 1234567DROP TABLE IF EXISTS &#96;score&#96;;CREATE table &#96;score&#96;(&#96;id&#96; int PRIMARY KEY auto_increment COMMENT &#39;主键&#39;,&#96;name&#96; VARCHAR(20) COMMENT &#39;姓名&#39;,&#96;subject&#96; VARCHAR(20) COMMENT &#39;科目&#39;,&#96;score&#96; DOUBLE default 0 COMMENT &#39;得分&#39;)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_general_ci COMMENT &#39;成绩表&#39;; 初始化数据 1234567INSERT INTO &#96;score&#96; VALUES(1, &#39;张三&#39;, &#39;语文&#39;, 90),(2, &#39;张三&#39;, &#39;数学&#39;, 99),(3, &#39;张三&#39;, &#39;英文&#39;, 70),(4, &#39;李四&#39;, &#39;语文&#39;, 95),(5, &#39;李四&#39;, &#39;数学&#39;, 78),(6, &#39;李四&#39;, &#39;英文&#39;, 97); 初始化数据如下: 123456789101112mysql&gt; select * from score;+----+--------+---------+-------+| id | name | subject | score |+----+--------+---------+-------+| 1 | 张三 | 语文 | 90 || 2 | 张三 | 数学 | 99 || 3 | 张三 | 英文 | 70 || 4 | 李四 | 语文 | 95 || 5 | 李四 | 数学 | 78 || 6 | 李四 | 英文 | 97 |+----+--------+---------+-------+6 rows in set (0.00 sec) 列行转换 12345678SELECT &#96;id&#96;,&#96;name&#96;,SUM(CASE &#96;subject&#96; WHEN &#39;语文&#39; THEN &#96;score&#96; ELSE 0 END) AS &#39;语文&#39;,SUM(CASE &#96;subject&#96; WHEN &#39;数学&#39; THEN &#96;score&#96; ELSE 0 END) AS &#39;数学&#39;,SUM(CASE &#96;subject&#96; WHEN &#39;英文&#39; THEN &#96;score&#96; ELSE 0 END) AS &#39;英文&#39;FROM &#96;score&#96;GROUP BY &#96;name&#96;; 列行转换后数据结果如下 1234567+----+--------+--------+--------+--------+| id | name | 语文 | 数学 | 英文 |+----+--------+--------+--------+--------+| 1 | 张三 | 90 | 99 | 70 || 4 | 李四 | 95 | 78 | 97 |+----+--------+--------+--------+--------+2 rows in set (0.01 sec)","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"}]},{"title":"数据结构之二叉堆","slug":"heap-introduce","date":"2020-03-25T11:52:20.000Z","updated":"2021-02-23T14:18:19.575Z","comments":true,"path":"2020/03/25/heap-introduce/","link":"","permalink":"https://idea360.cn/2020/03/25/heap-introduce/","excerpt":"","text":"概述 二叉堆本质上是完全二叉树，分最大堆和最小堆。 最大堆的任何一个父节点的值，都大于或等于它左右孩子节点的值。 最小堆的任何一个父节点的值，都小于或等于它左右孩子节点的值。 二叉堆的根节点叫做堆顶。 构建二叉堆 堆的插入操作是单一节点的上浮。 堆的删除操作是单一节点的下沉。 二叉堆的物理存储方式基于数组。 二叉堆代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Heap &#123; // 上浮调整 public static void upAdjust(int[] array) &#123; int childIndex = array.length - 1; int parentIndex = (childIndex-1)/2; int temp = array[childIndex]; while (childIndex&gt;0 &amp;&amp; temp&lt;array[parentIndex]) &#123; array[childIndex] = array[parentIndex]; childIndex = parentIndex; parentIndex = (parentIndex-1)/2; &#125; array[childIndex] = temp; &#125; // 下沉调整 public static void downAdjust(int[] array, int parentIndex, int length) &#123; int temp = array[parentIndex]; int childIndex = 2*parentIndex+1; while (childIndex&lt;length) &#123; if (childIndex+1&lt;length&amp;&amp;array[childIndex+1]&lt;array[childIndex]) &#123; childIndex++; &#125; if (temp&lt;array[childIndex]) &#123; break; &#125; array[parentIndex] = array[childIndex]; parentIndex = childIndex; childIndex=2*childIndex+1; &#125; array[parentIndex]=temp; &#125; public static void buildHeap(int[] array) &#123; // 从最后一个非叶子节点开始，依次做下沉操作 for (int i=(array.length-2)/2; i&gt;=0; i--) &#123; downAdjust(array, i, array.length); &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[]&#123;1,3,2,6,5,7,8,9,10,0&#125;; upAdjust(array); System.out.printf(Arrays.toString(array)); // 输出: [0, 1, 2, 6, 3, 7, 8, 9, 10, 5]// array = new int[]&#123;7,1,3,10,5,2,8,9,6&#125;; array = new int[]&#123;1,3,2,6,5,7,8,9,10,0&#125;; buildHeap(array); System.out.printf(Arrays.toString(array)); // 输出: [0, 1, 2, 6, 3, 7, 8, 9, 10, 5] &#125;&#125; 堆排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HeapSort &#123; /** * 将数组调整为符合堆规律的结构 * @param arr 传入需要调整的数组 * @param parent 父结点 * @param length 需要调整的数组长度 */ public static void heapAdjust(int[] arr, int parent, int length) &#123; int temp = arr[parent];//先保存父结点的值，以便后续移动交换 int child = parent * 2 + 1;//先获取到该父结点的左子结点 while (child &lt; length) &#123; //如果存在右子结点，且右子结点大于左子结点，则选取右子结点 if (child + 1 &lt; length &amp;&amp; arr[child] &lt; arr[child + 1]) &#123; child++; &#125; //判断父结点（待插入的值）是否比子节点大 if(temp&gt;arr[child])&#123; break;//父结点大，结束当前循环 &#125;else &#123; /*此处类似与直接插入排序的思想*/ arr[parent]=arr[child];//将子结点的值覆盖父节点的值 parent=child; child=child *2+1; &#125; &#125; //此时已经找到合适的位置,将待插入的值插入合适的位置 arr[parent]=temp; &#125; /** *堆排序(升序) * @param list */ public static void sort(int[] list)&#123; // 把无序数组构建成最大堆 for (int i = list.length/2; i &gt;=0 ; i--) &#123; heapAdjust(list,i,list.length); &#125; //循环删除堆顶元素 for (int i = list.length-1; i &gt;0; i--) &#123; //将最大值list[0]与最后一个元素交换 int temp=list[i]; list[i]=list[0]; list[0]=temp; //交换完之后，最大值已经在底层数组的末尾，然后将交换后的堆进行调整 heapAdjust(list,0,i);//注意这里的长度已经-1了，所以堆调整不包含最后一个元素 &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; TopN问题求解 题目描述 有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。 解答思路 由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。 思路如下 首先遍历大文件，对遍历到的每个词x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。 接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1)；若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。 上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。 (即删除当前最小堆顶元素，留下100个) 方法总结 分而治之，进行哈希取余； 使用 HashMap 统计频数； 求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。 下集预告 今日内容整理自网络。后期将会抽时间出一个实战系列。包括SpringCloud、docker、k8s、jenkins、prometheus等集开发、测试、部署、运维流程的笔记。","categories":[{"name":"算法","slug":"算法","permalink":"https://idea360.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://idea360.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://idea360.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉堆","slug":"二叉堆","permalink":"https://idea360.cn/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"}]},{"title":"Jenkins自由构建SpringBoot项目(一)","slug":"devops-jenkins-1","date":"2020-03-24T14:21:48.000Z","updated":"2021-02-23T14:16:00.320Z","comments":true,"path":"2020/03/24/devops-jenkins-1/","link":"","permalink":"https://idea360.cn/2020/03/24/devops-jenkins-1/","excerpt":"","text":"安装Jenkins Jenkins是由java开发的，安装比较简单，直接从 官网 下载war包启动即可。 注意: 启动后先别安装插件, 切换源后再进行安装。 我更换的源是 https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json, 同时，替换jenkins安装目录 /updates/default.json 中的谷歌链接为百度。 插件安装 Credentials Binding Plugin Git Deploy to container Maven Integration pipeline 环境配置 Global Tool Configuration配置 配置 jdk 和 maven 目录 openjdk8: /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home maven3: /Users/cuishiying/app/apache-maven-3.6.0 Configure System配置 配置全局属性 JAVA_HOME: /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home M3_HOME: /Users/cuishiying/app/apache-maven-3.6.0 PATH+EXTRA: $M3_HOME/bin 添加git凭据 这里我省去了SSH的配置，直接用的帐号密码 自由风格项目构建 新建item创建一个任务 源码管理选择git,添加仓库地址和刚才创建的凭据 编辑构建脚本 12345echo &quot;开始编译和打包&quot;mvn clean packageecho &quot;编译和打包结束&quot; Build Now构建，查看日志可以看到构建过程，在Jenkins的工作空间中可以看到下载的代码和构建结果。","categories":[{"name":"devops","slug":"devops","permalink":"https://idea360.cn/categories/devops/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"devops","slug":"devops","permalink":"https://idea360.cn/tags/devops/"},{"name":"jenkins","slug":"jenkins","permalink":"https://idea360.cn/tags/jenkins/"}]},{"title":"Shell脚本学习","slug":"shell","date":"2020-03-24T03:31:55.000Z","updated":"2021-02-23T14:40:29.531Z","comments":true,"path":"2020/03/24/shell/","link":"","permalink":"https://idea360.cn/2020/03/24/shell/","excerpt":"","text":"Hello World 创建脚本 1touch hello.sh 授权 默认是没有执行权限的 12➜ shell .&#x2F;hello.shzsh: permission denied: .&#x2F;hello.sh 查看现有权限 123➜ shell lltotal 0-rw-r--r-- 1 cuishiying staff 0B 3 24 11:50 hello.sh 权限说明 文件类型 用户u 用户组g 其他用户o 说明(全部a) 位说明 1 2-4 5-7 8-10 共10位(+增加权限, -减少权限) 字符说明 -/d rwx r– rw- -文件,d目录|r可读,w可写,x可执行,-无权限 数字 无 111=7 100=4 110=6 出现字符（r、w、x）为1，出现-为0 根据上述权限说明，hello.sh是文件，当前用户有读写权限，无可执行权限，所以需要授权才能执行。 1chmod u+x hello.sh 编辑脚本 12#! /bin/bashecho &quot;Hello World&quot; Shell变量 变量一般用到自定义变量和环境变量。 自定义变量 1234#! &#x2F;bin&#x2F;bashhello&#x3D;&quot;Hello World&quot;echo $helloecho &quot;$hello&quot; 字符串 获取字符串长度 123#! &#x2F;bin&#x2F;bashhello&#x3D;&quot;Hello World&quot;echo $&#123;#hello&#125; 数组 12345678910#!&#x2F;bin&#x2F;basharray&#x3D;(1 2 3 4 5);# 获取数组长度length&#x3D;$&#123;#array[@]&#125;#输出数组长度echo $length #输出：5# 输出数组第三个元素echo $&#123;array[2]&#125; #输出：3unset array[1] # 删除下标为1的元素也就是删除第二个元素for i in $&#123;array[@]&#125;;do echo $i ;done # 遍历数组，输出： 1 3 4 5 Shell流程控制 if条件 123456789101112#!&#x2F;bin&#x2F;basha&#x3D;3;b&#x3D;9;if [ $a -eq $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;else echo &quot;a 小于 b&quot;fi for循环 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done Shell函数 无参无返回值 1234567#!&#x2F;bin&#x2F;bashhello()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;helloecho &quot;-----函数执行完毕-----&quot; 有返回值有参数 123456789#! &#x2F;bin&#x2F;bashtest()&#123; echo &quot;第一个参数 $1&quot; echo &quot;第二个参数 $2&quot; # 只能返回数字 return $(($1+$2))&#125;test 1 2echo &quot;结果为 $?&quot;","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://idea360.cn/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://idea360.cn/tags/shell/"},{"name":"脚本","slug":"脚本","permalink":"https://idea360.cn/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Hello-","slug":"hello-Minikube","date":"2020-03-20T14:00:29.000Z","updated":"2021-02-23T14:18:32.985Z","comments":true,"path":"2020/03/20/hello-Minikube/","link":"","permalink":"https://idea360.cn/2020/03/20/hello-Minikube/","excerpt":"","text":"概述 基础环境mac。在mac下的docker中是自带k8s的，但是由于网络原因，安装特别慢，本文介绍社区中另一版本Minikube的安装, 仅做笔记用。 Minikube是由Kubernetes社区维护的单机版的Kubernetes集群，支持macOS, Linux, and Windows等多种操作系统平台。 安装 安装kubectl 1brew install kubectl 测试安装的版本是最新的 1kubectl version --client 安装Minikube 1brew install minikube 启动 1minikube start --image-repository=&#x27;registry.cn-hangzhou.aliyuncs.com/google_containers&#x27; 查看状态 1minikube status 启动dashboard 1minikube dashboard 使用Minikube 准备开始 本教程提供了从以下文件构建的容器镜像： server.js 123456789var http = require(&#x27;http&#x27;);var handleRequest = function(request, response) &#123; console.log(&#x27;Received request for URL: &#x27; + request.url); response.writeHead(200); response.end(&#x27;Hello World!&#x27;);&#125;;var www = http.createServer(handleRequest);www.listen(8080); Dockerfile 1234FROM node:6.14.2EXPOSE 8080COPY server.js .CMD node server.js 打包docker镜像 打包指令，注意. 1docker build -t cuishiying/hello-node:v1 . 本地测试镜像是否ok 1docker run -d -p 8080:8080 cuishiying/hello-node:v1 访问 http://localhost:8080/ 返回 Hello World!。 login后把镜像推送到仓库 1docker push cuishiying/hello-node:v1 创建Deployment Kubernetes Pod 是由一个或多个为了管理和联网而绑定在一起的容器构成的组。本教程中的 Pod 只有一个容器。Kubernetes Deployment 检查 Pod 的健康状况，并在 Pod 中的容器终止的情况下重新启动新的容器。Deployment 是管理 Pod 创建和扩展的推荐方法。 使用 kubectl create 命令创建管理 Pod 的 Deployment。该 Pod 根据提供的 Docker 镜像运行 Container。 1kubectl create deployment hello-node --image=cuishiying/hello-node:v1 查看 Deployment： 1kubectl get deployments 查看 Pod： 1kubectl get pods 查看集群事件： 1kubectl get events 查看 kubectl 配置： 1kubectl config view 创建Service 默认情况下，Pod 只能通过 Kubernetes 集群中的内部 IP 地址访问。要使得 hello-node 容器可以从 Kubernetes 虚拟网络的外部访问，您必须将 Pod 暴露为 Kubernetes Service。 使用 kubectl expose 命令将 Pod 暴露给公网： 1kubectl expose deployment hello-node --type&#x3D;LoadBalancer --port&#x3D;8080 The --type=LoadBalancer flag indicates that you want to expose your Service outside of the cluster. 查看您刚刚创建的服务: 1kubectl get services 输出 123NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-node LoadBalancer 10.102.110.103 &lt;pending&gt; 8080:31863&#x2F;TCP 47skubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443&#x2F;TCP 4d1h 在支持负载均衡器的云服务提供商上，将提供一个外部 IP 来访问该服务。在 Minikube 上，LoadBalancer 使得服务可以通过命令 minikube service 访问。 运行下面的命令： 1minikube service hello-node 输出 123456|-----------|------------|-------------|---------------------------|| NAMESPACE | NAME | TARGET PORT | URL ||-----------|------------|-------------|---------------------------|| default | hello-node | | http:&#x2F;&#x2F;192.168.64.2:31863 ||-----------|------------|-------------|---------------------------|🎉 正通过默认浏览器打开服务 default&#x2F;hello-node... 显示有关 Service 的信息 1kubectl get services hello-node 显示有关 Service 的详细信息 1kubectl describe services my-service 如果您在 Minikube 上运行服务，您可以通过以下命令找到分配的 IP 地址和端口 1minikube service hello-node --url 更新版本 123docker build -t cuishiying&#x2F;hello-node:v2 .docker push cuishiying&#x2F;hello-node:v2kubectl set image deployment&#x2F;hello-node hello-node&#x3D;cuishiying&#x2F;hello-node:v2 版本回滚 回滚到上一个版本 1kubectl rollout undo deployment&#x2F;hello-node revision 12kubectl rollout history deployment&#x2F;hello-nodekubectl rollout undo deployment&#x2F;hello-node --to-revision&#x3D;3 启用插件 Minikube 有一组内置的插件，可以在本地 Kubernetes 环境中启用、禁用和打开。 列出当前支持的插件： 1minikube addons list 启用插件，例如 heapster 1minikube addons enable heapster 查看刚才创建的 Pod 和 Service： 1kubectl get pod,svc -n kube-system 禁用 heapster： 1minikube addons disable heapster 清理 现在可以清理您在集群中创建的资源： 12kubectl delete service hello-nodekubectl delete deployment hello-node 可以停止 Minikube VM： 1minikube stop 或者，删除 Minikube VM： 1minikube delete Rancher 安装 123docker pull rancher&#x2F;rancher:latestdocker run -d --restart&#x3D;unless-stopped -p 80:80 -p 443:443 rancher&#x2F;rancher:latestdocker logs -f rancher rancher自签名证书可以在hosts文件配置域名。 12create_self-signed-cert.sh --ssl-domain&#x3D;rancher.local.com --ssl-trusted-domain&#x3D;rancher.local.com \\--ssl-trusted-ip&#x3D;192.168.124.5 --ssl-size&#x3D;2048 --ssl-date&#x3D;3650 具体可参考官方文档 安装部分介绍。 rancher导入minikube 导入后的样子是这样的，导入过程比较慢，会显示一直处于 pending 状态， 切莫着急。 用户空间 我们关心的是用户空间，因为我们部署的应用默认在这里 rancher部署应用 之前我们通过k8s部署的 hello-node 先卸载了，重新通过 rancher 部署下应用。 点击右上角 部署服务。 部署完成后如图。访问 http://192.168.64.2:30001/ 返回 Hello World! 升级应用版本 在刚才的页面点击右边隐藏按钮 升级，进入升级配置页面。 升级后测试ok。","categories":[{"name":"k8s","slug":"k8s","permalink":"https://idea360.cn/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://idea360.cn/tags/k8s/"},{"name":"Minikube","slug":"Minikube","permalink":"https://idea360.cn/tags/Minikube/"}]},{"title":"数据结构-队列","slug":"java-queue","date":"2020-03-19T14:33:31.000Z","updated":"2021-02-23T14:26:29.518Z","comments":true,"path":"2020/03/19/java-queue/","link":"","permalink":"https://idea360.cn/2020/03/19/java-queue/","excerpt":"","text":"概述 队列(Queue)和栈一样，也是 线性数据结构，它属于逻辑结构，物理实现既可以用 数组，也可以用 链表来完成。和栈不同的是，链表中的元素 先进先出 (First In First Out, 简称 FIFO)。队列的出口端叫 对头 (front), 队列的入口端叫 队尾 (rear)。 基本方法 添加元素 put: 如果队列满，则阻塞 add: 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 offer: 如果队列已满，则返回false 移除并返回队列头部元素 remove: 如果队列为空，则抛出一个NoSuchElementException异常 poll: 如果队列为空，则返回null take: 如果队列为空，则阻塞 返回队列头部的元素 element: 如果队列为空，则抛出一个NoSuchElementException异常 peek: 如果队列为空，则返回null 基于数组实现队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ArrayQueue&lt;E&gt; &#123; private E[] queue;//队列数组 private int head=0;//头下标E private int tail=0;//尾下标 private int count=0;//元素个数 public ArrayQueue() &#123; queue=(E[])new Object[10]; this.head=0;//头下标为零 this.tail=0; this.count=0; &#125; public ArrayQueue(int size) &#123; queue=(E[])new Object[size]; this.head=0; this.tail=0; this.count=0; &#125; //入队 public boolean offer(E t) &#123; if(count==queue.length) return false; queue[tail++%(queue.length)]=t;//如果不为空就放入下一个 count++; return true; &#125; //出队 public E poll() &#123; if(count==0)//如果是空的那就不能再出栈了 return null; count--; return queue[head++%(queue.length)]; &#125; //查队头 public E showHead() &#123; if(count==0) return null; return queue[head]; &#125; //判满 public boolean isFull() &#123; return count==queue.length; &#125; //判空 public boolean isEmpty() &#123; return count==0; &#125; public static void main(String[] args) throws Exception&#123; ArrayQueue queue = new ArrayQueue&lt;Object&gt;(3); for (int i=0; i&lt;3; i++) &#123; queue.offer(i); &#125; for (int i=0; i&lt;4; i++) &#123; System.out.print(queue.poll()); &#125; // 输出: 012null &#125;&#125; 基于链表实现队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class LinkedListQueue &#123; class Node&#123; public Object data; public Node next; public Node(Object data) &#123; this.data = data; &#125; &#125; private Node head; private Node tail; public LinkedListQueue() &#123; this.head = null; this.tail = null; &#125; public void offer(Object data) &#123; Node node = new Node(data); if (tail != null) &#123; tail.next = node; &#125; tail = node; if (head == null) &#123; head = tail; &#125; &#125; public Object poll() throws Exception &#123; if (head != null) &#123; Object data = head.data; head = head.next; return data; &#125; else &#123; return null; &#125; &#125; public static void main(String[] args) throws Exception&#123; LinkedListQueue queue = new LinkedListQueue(); for (int i=0; i&lt;3; i++) &#123; queue.offer(i); &#125; for (int i=0; i&lt;4; i++) &#123; System.out.print(queue.poll()); &#125; // 输出：012null &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://idea360.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://idea360.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"https://idea360.cn/tags/%E9%98%9F%E5%88%97/"}]},{"title":"数据结构-栈","slug":"java-stack","date":"2020-03-19T13:24:25.000Z","updated":"2021-02-23T14:28:14.683Z","comments":true,"path":"2020/03/19/java-stack/","link":"","permalink":"https://idea360.cn/2020/03/19/java-stack/","excerpt":"","text":"概述 栈(stack)是常用的 线性数据结构，它属于逻辑结构，物理实现既可以用 数组，也可以用 链表来完成。栈中的元素只能先进后出(First In Last Out, 简称FILO)，最早进入的元素存放的位置叫做 栈底， 最后进入的元素存放的位置叫做 栈顶。 Java栈 Java中栈继承自Vector，是线程安全的，底层基于数组实现。 Stack类 12345678910111213141516171819202122232425262728publicclass Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; // 入栈 public E push(E item) &#123; // 在Vector中实现 addElement(item); return item; &#125; // 出栈(返回栈顶元素，并删除栈顶值) public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; // 返回栈顶元素，不删除栈顶值 public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125;&#125; Vector类 12345678// 底层基于数组实现protected Object[] elementData;// vector类在方法上加synchronized同步锁public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 基于数组自定义实现 这里简单实现下，主要做原理演示 123456789101112131415161718192021222324252627282930313233343536373839public class ArrayStack &#123; private Object[] elementData; // 数据 private int elementCount; // 数组长度 public ArrayStack(int initialCapacity) &#123; this.elementCount = 0; this.elementData = new Object[initialCapacity]; &#125; public Object push(Object item) &#123; if (full()) &#123; throw new IllegalArgumentException(&quot;栈满了&quot;); &#125; elementData[elementCount++] = item; return item; &#125; public Object pop() &#123; if (empty()) &#123; throw new IllegalArgumentException(&quot;栈空了&quot;); &#125; Object data = peek(); elementCount--; return data; &#125; public Object peek() &#123; return elementData[elementCount-1]; &#125; public boolean empty() &#123; return elementCount == 0; &#125; public boolean full() &#123; return elementCount == elementData.length; &#125;&#125; 测试 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; ArrayStack stack = new ArrayStack(3); for (int i=0; i&lt;3; i++) &#123; stack.push(i); &#125; for (int i=0; i&lt;4; i++) &#123; if (i==3) &#123; stack.push(i); &#125; System.out.print(stack.pop()); &#125; // 输出2103 &#125;&#125; 基于链表自定义实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class LinkedListStack&lt;E&gt; &#123; StackNode&lt;E&gt; top = null; //栈顶，也是一个node节点 class StackNode&lt;E&gt;&#123; E data; StackNode&lt;E&gt; next; public StackNode(E data) &#123; this.data = data; &#125; &#125; public boolean isEmpty() &#123; return top == null; &#125; /** * 往栈中push一个数据： * 首先将要push的数据的next赋值为栈顶top * 然后将栈顶指针指向新push进来的节点 * */ public void push(E data) &#123; StackNode&lt;E&gt; newNode = new StackNode&lt;E&gt;(data); newNode.next = top; top = newNode; &#125; /** * 从栈中弹出一个数据， * 将栈顶指针指向弹出节点的下一个 * */ public E pop() &#123; if(this.isEmpty()) &#123; System.out.println(&quot;栈已经空啦&quot;); return null; &#125; E data = top.data; top = top.next; return data; &#125; /** * 返回栈顶数据，但是不出栈。数据任然保存在栈中 * */ public E peek() &#123; if(isEmpty()) &#123; return null; &#125; return top.data; &#125; //将栈中所有数据出栈 public void printStack() &#123; System.out.println(&quot;开始出栈:&quot;); while(!isEmpty()) &#123; System.out.println(top.data); top = top.next; &#125; System.out.println(&quot;出栈结束！&quot;); &#125; public static void main(String[] args) &#123; LinkedListStack&lt;Integer&gt; stack = new LinkedListStack&lt;&gt;(); //创建一个栈 for (int i=0; i&lt;3; i++) &#123; stack.push(i); &#125; for (int i=0; i&lt;4; i++) &#123; System.out.print(stack.pop()); &#125; // 输出： 210栈已经空啦 &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://idea360.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://idea360.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://idea360.cn/tags/%E6%A0%88/"}]},{"title":"设计模式——模板方法","slug":"design-patterns-template","date":"2020-03-19T10:32:21.000Z","updated":"2021-02-23T14:15:43.039Z","comments":true,"path":"2020/03/19/design-patterns-template/","link":"","permalink":"https://idea360.cn/2020/03/19/design-patterns-template/","excerpt":"","text":"概述 模板方法模式(TemplateMethod Pattern)，父类中定义处理流程的框架，在子类中实现具体处理。模块方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模式结构 抽象类: 负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 基本方法：是整个算法中的一个步 具体子类: 实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤 适用环境 有多个子类共有的方法，且逻辑相同 重要的、复杂的方法，可以考虑作为模板方法 典型案例 AQS 在并发编程中，ReentrantLock锁大家一定不陌生，看过源码的小伙伴一定知道，ReentrantLock内部基于 AQS 实现。这里 acquire() 相当于模板方法，tryAcquire(arg) 相当于基本方法。 在 模板方法 中，模板方法一般用 final 修饰，避免子类对整体流程进行修改。 123456789101112// 模板方法，定义获取同步锁的策略。public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 selfInterrupt();&#125;// 基本方法，子类实现。protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 接下来，我们看下具体的子类实现 ReentrantLock非公平锁 12345678910111213141516171819abstract static class Sync extends AbstractQueuedSynchronizer &#123;&#125;static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; ThreadPoolExecutor线程池Worker类 12345678910111213private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; // ... protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; &#125; 登录流程 现在的应用, 很多是支持 验证码 、邮箱 、 用户名 等多种方式登录的。 在后台，除了校验方式不同外，其他流程基本相同。这里我们可以在父类实现主要流程，将不同的逻辑放在子类实现，同时还要保证流程的一致性，这里可以用模板方法来实现。 首先来个超类，定义登录流程。 1234567891011121314151617181920212223public abstract class LoginService &#123; // 模板方法。登录流程 public final void login(Map&lt;String, String&gt; params) &#123; verifyData(); doSomething(); packAndRetureData(); &#125; // 普通方法 private void packAndRetureData() &#123; System.out.println(&quot;all return login data&quot;); &#125; // 普通方法 private void doSomething() &#123; System.out.println(&quot;all do some thing&quot;); &#125; // 抽象方法，子类实现 protected abstract void verifyData();&#125; 具体子类，email登录 123456public class EmailLoginService extends LoginService &#123; @Override protected void verifyData() &#123; System.out.println(&quot;verify email data&quot;); &#125;&#125; 短信登录 123456public class SmsLoginService extends LoginService &#123; @Override protected void verifyData() &#123; System.out.println(&quot;verify sms data&quot;); &#125;&#125; 登录业务模拟 1234567891011/** * verify email data * all do some thing * all return login data */public class LoginTest &#123; public static void main(String[] args) &#123; EmailLoginService loginService = new EmailLoginService(); loginService.login(null); &#125;&#125; 应用支付 对接过第三方支付的小伙伴都知道，在接入第三方支付时，一般支付结果都会通过异步回调的形式，通知商户服务器。而我们得到这些数据时一般都是同一流程的处理方式：验签 — 更新订单状态 — 给第三方支付服务器响应。 下面以支付宝和微信为例：支付宝和微信的验签方式和响应结果方式都是不一样的， 而更新订单状态都是商户这边处理所以业务逻辑是一样的。 抽象模板类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class AbstractPayNotifyTemplate &#123; /** * 支付异步回调处理 * * @param params 回调参数 */ public void onNotify(Map&lt;String, String&gt; params) &#123; //验证签名 final boolean sign = verifySign(params); if (sign) &#123; // 给第三方支付服务器回复支付失败状态 setResponse(PayStatus.ERROR); return; &#125; //从参数获取订单编号并更新订单支付状态，为支付成功 final String orderSn = params.get(&quot;out_trade_no&quot;); updateOrderPayStatusSuccess(orderSn); // 给第三方支付服务器回复支付成功状态 setResponse(PayStatus.SUCCESS); &#125; /** * 验签 * * @param params 回调参数 * @return 验签结果 */ protected abstract boolean verifySign(Map&lt;String, String&gt; params); /** * 更新订单支付状态为支付成功 * * @param orderSn 订单编号 */ private void updateOrderPayStatusSuccess(String orderSn) &#123; // 根据订单编号更新订单支付状态为支付成功 &#125; /** * 给第三方支付返回 * * @param status 支付状态 */ protected abstract void setResponse(PayStatus status);&#125; 具体模板类 123456789101112131415161718192021222324252627282930313233343536373839// 支付宝支付回调类public class AliPayNotifyTemplate extends AbstractPayNotifyTemplate &#123; @Override protected boolean verifySign(Map&lt;String, String&gt; params) &#123; // 调用支付宝验签接口， 并返回验签结果 return true; &#125; @Override protected void setResponse(PayStatus status) &#123; String res = Objects.equals(PayStatus.SUCCESS, status) ? &quot;success&quot; : &quot;error&quot;; // 调用 ResponseUtils 直接返回 res 字符串 &#125;&#125;// 微信支付回调类public class WxPayNotifyTemplate extends AbstractPayNotifyTemplate &#123; @Override protected boolean verifySign(Map&lt;String, String&gt; params) &#123; // 调用微信支付验签接口， 并返回验签结果 return true; &#125; @Override protected void setResponse(PayStatus status) &#123; String returnCode = &quot;FAIL&quot;; String returnMsg = &quot;&quot;; if (Objects.equals(PayStatus.SUCCESS, status)) &#123; returnCode = &quot;SUCCESS&quot;; returnMsg = &quot;OK&quot;; &#125; String res = String.format(&quot;&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[%s]]&gt;&lt;/return_code&gt;&lt;return_msg&gt;&lt;![CDATA[%s]]&gt;&lt;/return_msg&gt;&lt;/xml&gt;&quot;, returnCode, returnMsg); // 调用 ResponseUtils 返回 res xml格式内容 &#125;&#125; 总结 从作用上来看，模板方法模式与策略模式都是对一个基类的方法有多种不同的实现。 而策略模式的具体实现中，采用的是组合 + 接口的策略。而模板方法模式就完全基于 Java 语言的多态特性实现的继承。从设计模式的思想来说，组合是优于继承的。 更大的区别在于，策略模式是从一个功能整体上出发的，每种策略对该功能都有不同的实现。而模板方法模式是对一个算法或流程细分为多个步骤，每个步骤都可以被子类重写，但是整个流程是不能被重新定义的。从代码实现上来讲，当模板方法中的需要重写的步骤占了绝大部分时，子类只有几个方法不用重写，在这种情况下不如使用策略模式。而当模板方法中需要重写的步骤不多时，使用策略模式会造成不同的实现类中有很多重复的代码。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"模板方法","slug":"模板方法","permalink":"https://idea360.cn/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"}]},{"title":"Java排序算法","slug":"java-sorting-algorithm","date":"2020-03-18T12:39:09.000Z","updated":"2021-02-23T14:27:57.519Z","comments":true,"path":"2020/03/18/java-sorting-algorithm/","link":"","permalink":"https://idea360.cn/2020/03/18/java-sorting-algorithm/","excerpt":"","text":"各种内部排序算法的比较 冒泡排序 冒泡排序：一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。稳定排序算法 时间复杂度 O(n2)，里层循环每趟比较第 j 项和第 j+1项，如果前项大于后项，则发生交换。缺点是每次比较后都可能发生交换，交换次数太多了，值从小到大。 通俗概述：依次比较相邻两关键字，如果反序则立即发生交换，如果正序则继续比较下一个相邻项，双重嵌套循环实现 具体如何移动呢？我们先看一个例子 有8个数字组成一个无序数列{5,6,3,1,8,7,2,4},希望按照从小到大的顺序 对其进行排序。详细排序如下，第一轮排序结束，最大元素8冒泡排到最后。以此类推，下一轮7排序到倒数第二的位置… 实现代码： 12345678910111213141516171819202122public class BubbleSort &#123; // 利用双重循环，如果前一个数比后一个数大，则发生交换，每次比较都发生交换 public static void sort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 1; j &lt; arr.length - i; j++) &#123; if (arr[j-1] &gt; arr[j]) &#123; swap(arr, j-1, j); &#125; &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 选择排序 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 代码实现 12345678910111213141516171819202122232425public class SelectionSort &#123; public static void sort(int array[])&#123; for (int i = 0; i &lt; array.length; i++) &#123; int minIndex = i; // 用来保存最小的索引,初始指向当前第i项 for (int j = i; j &lt; array.length; j++) &#123; // 找到最小的数 if (array[j] &lt; array[minIndex]) &#123; //将最小数的索引保存 minIndex = j; &#125; &#125; // 交换元素。最小元素排在前边，依次递增 int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 插入排序 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。就像打扑克整理牌一样。 代码实现 1234567891011121314151617181920212223public class InsertionSort &#123; public static void sort(int[] arr) &#123; // 第一个肯定是有序的，所以从第二个数开始遍历 for (int i=1; i&lt;arr.length; i++) &#123; int current = arr[i]; // 取出第i个数，和前i-1个数比较，插入合适位置。 int preIndex = i - 1; // 前一个数索引 // 当发现小元素时，将已排序元素中所有大于它的后移一个单位 while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; // 将目标元素插入到位移后留下的空位。最后一次交换结束后再自减运算，所以这里需要+1 arr[preIndex + 1] = current; &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 快速排序 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class QuickSort &#123; public static void sort(int[] arr, int startIndex, int endIndex) &#123; // 递归结束条件: startIndex大于等于endIndex if (startIndex &gt;= endIndex) &#123; return; &#125; //得到基准元素位置 int pivotIndex = partition(arr, startIndex, endIndex); // 根据基准元素，分成2部分进行递归排序 sort(arr, startIndex, pivotIndex-1); sort(arr, pivotIndex+1, endIndex); &#125; // 分治(双边循环法) public static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个位置的元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; // 控制right指针比较并左移,找到第一个小于基准值的元素索引 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; // 控制left指针比较并右移, 找到第一个大于基准值的元素索引 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; // 交换left和right指针所指向的元素 if (left &lt; right) &#123; int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; &#125; // pivot和指针重合点交换 arr[startIndex] = arr[left]; arr[left] = pivot; return left; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 总结快速排序的思想：冒泡+二分+递归分治 希尔排序 希尔排序：又称为增量排序，它是一种插入排序，它是直接插入排序算法的一种威力加强版。它的基本思想是：把记录按步长 gap(差距，间隙) 分组，对每组记录采用直接插入排序方法进行排序。 随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。 时间复杂度为O(nlogn)，该方法因DL．Shell于1959年提出而得名。超越了O(n2)的算法的历史。他是在直接插入排序的增强，将记录按步长gap分组，然后在分组内进行直接插入排序。不稳定算法。 代码实现 123456789101112131415161718192021222324252627282930public class ShellSort &#123; public static void sort(int[] arr) &#123; //初始化步长为数组长度的一半 int gap = arr.length / 2; //循环结束条件，当gap&lt;1是，循环结束，即排序结束 while (gap &gt;= 1) &#123; //把距离为gap的元素编为一个组，扫描所有组 for (int i = gap; i &lt; arr.length; i++) &#123; int current = arr[i];//保存待插入元素，以便组内元素向后移动覆盖 int j = i; //对距离为gap的组内元素进行直接选择排序 while (j-gap &gt;=0 &amp;&amp; current &lt; arr[j-gap]) &#123; arr[j] = arr[j-gap]; j-=gap; &#125; //将待插入元素插入合适位置 arr[j] = current; &#125; //一次循环结束，所有分组均已完成直接选择排序，则可将将距离缩小为原本的一半 gap/=2; &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 堆排序 堆排序：就是利用堆进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点，将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1给序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列。--------用直接插入排序，将数组调整为堆结构，然后再简单选择排序，选择最值交换，再调整堆结构。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HeapSort &#123; /** * 将数组调整为符合堆规律的结构 * @param arr 传入需要调整的数组 * @param parent 父结点 * @param length 需要调整的数组长度 */ public static void heapAdjust(int[] arr, int parent, int length) &#123; int temp = arr[parent];//先保存父结点的值，以便后续移动交换 int child = parent * 2 + 1;//先获取到该父结点的左子结点 while (child &lt; length) &#123; //如果存在右子结点，且右子结点大于左子结点，则选取右子结点 if (child + 1 &lt; length &amp;&amp; arr[child] &lt; arr[child + 1]) &#123; child++; &#125; //判断父结点（待插入的值）是否比子节点大 if(temp&gt;arr[child])&#123; break;//父结点大，结束当前循环 &#125;else &#123; /*此处类似与直接插入排序的思想*/ arr[parent]=arr[child];//将子结点的值覆盖父节点的值 parent=child; child=child *2+1; &#125; &#125; //此时已经找到合适的位置,将待插入的值插入合适的位置 arr[parent]=temp; &#125; /** *堆排序(升序) * @param list */ public static void sort(int[] list)&#123; // 把无序数组构建成最大堆 for (int i = list.length/2; i &gt;=0 ; i--) &#123; heapAdjust(list,i,list.length); &#125; //循环删除堆顶元素 for (int i = list.length-1; i &gt;0; i--) &#123; //将最大值list[0]与最后一个元素交换 int temp=list[i]; list[i]=list[0]; list[0]=temp; //交换完之后，最大值已经在底层数组的末尾，然后将交换后的堆进行调整 heapAdjust(list,0,i);//注意这里的长度已经-1了，所以堆调整不包含最后一个元素 &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 归并排序 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MergeSort &#123; /** * 递归分治 * @param arr * @param left * @param right */ public static void sort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int mid = (left + right) / 2; sort(arr, left, mid); //递归排序左边 sort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并 &#125; /** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */ public static void merge(int[] arr, int left, int mid, int right) &#123; //[left, mid] [mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= right) &#123; if(arr[i] &lt;= arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; while(i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; while(j &lt;= right) &#123; temp[k++] = arr[j++]; &#125; for(int p=0; p&lt;temp.length; p++) &#123; arr[left + p] = temp[p]; &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr,0, arr.length-1); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 计数排序 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 代码实现 12345678910111213141516171819202122232425262728293031323334public class CountingSort &#123; public static void sort(int[] arr) &#123; //找出数组中的最大值 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //初始化计数数组 int[] countArr = new int[max + 1]; Arrays.fill(countArr, 0); //计数 for (int i = 0; i &lt; arr.length; i++) &#123; countArr[arr[i]]++; &#125; //排序 int index = 0; for (int i = 0; i &lt; countArr.length; i++) &#123; for(int j=0; j&lt; countArr[i]; j++) &#123; arr[index++] = i; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class BucketSort &#123; public static void sort(int[] arr)&#123; //最大最小值 int max = arr[0]; int min = arr[0]; int length = arr.length; for(int i=1; i&lt;length; i++) &#123; if(arr[i] &gt; max) &#123; max = arr[i]; &#125; else if(arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; //最大值和最小值的差 int diff = max - min; //桶列表 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; length; i++)&#123; bucketList.add(new ArrayList&lt;&gt;()); &#125; //每个桶的存数区间 float section = (float) diff / (float) (length - 1); //数据入桶 for(int i = 0; i &lt; length; i++)&#123; //当前数除以区间得出存放桶的位置 减1后得出桶的下标 int num = (int) (arr[i] / section) - 1; if(num &lt; 0)&#123; num = 0; &#125; bucketList.get(num).add(arr[i]); &#125; //桶内排序 for(int i = 0; i &lt; bucketList.size(); i++)&#123; //jdk的排序速度当然信得过 Collections.sort(bucketList.get(i)); &#125; //写入原数组 int index = 0; for(ArrayList&lt;Integer&gt; arrayList : bucketList)&#123; for(int value : arrayList)&#123; arr[index] = value; index++; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125; 基数排序 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class RadixSort &#123; public static void sort(int[] arr)&#123; int length = arr.length; //最大值 int max = arr[0]; for(int i = 0;i &lt; length;i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; &#125; &#125; //当前排序位置 int location = 1; //桶列表 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(); //长度为10 装入余数0-9的数据 for(int i = 0; i &lt; 10; i++)&#123; bucketList.add(new ArrayList()); &#125; while(true) &#123; //判断是否排完 int dd = (int)Math.pow(10, (location - 1)); if(max &lt; dd)&#123; break; &#125; //数据入桶 for(int i = 0; i &lt; length; i++) &#123; //计算余数 放入相应的桶 int number = ((arr[i] / dd) % 10); bucketList.get(number).add(arr[i]); &#125; //写回数组 int nn = 0; for (int i=0;i&lt;10;i++)&#123; int size = bucketList.get(i).size(); for(int ii = 0;ii &lt; size;ii ++)&#123; arr[nn++] = bucketList.get(i).get(ii); &#125; bucketList.get(i).clear(); &#125; location++; &#125; &#125; public static void main(String[] args) &#123; int[] arr=new int[]&#123;5,6,3,1,8,7,2,4&#125;; sort(arr); System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://idea360.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://idea360.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://idea360.cn/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"设计模式——策略模式","slug":"design-patterns-strategy","date":"2020-03-18T03:29:01.000Z","updated":"2021-02-23T14:15:34.999Z","comments":true,"path":"2020/03/18/design-patterns-strategy/","link":"","permalink":"https://idea360.cn/2020/03/18/design-patterns-strategy/","excerpt":"","text":"1. 概述 策略模式(Strategy Pattern)是比较典型的对象行为型模式，它是将对处理对象的一系列不同算法都单独抽离出来，单独封装成一个个类。策略的出现，主要是为了解决不同算法替换时的逻辑判断，将逻辑判断移到Client中去(即由客户端自己决定在什么情况下使用什么具体策略)。 2. 模式结构 策略模式包含如下角色： Context: 环境类，也叫做上下文角色，起承上启下封装作用; 屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化. Strategy: 抽象策略类，策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性 ConcreteStrategy: 具体策略类，实现抽象策略中的操作，含有具体的算法 3. 适用环境 在以下情况下可以使用策略模式： 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。 4. 典型案例 学习设计模式就是为了写出更加优雅的代码, 然而很多时候项目中不知道在什么场景下用什么设计模式合适。这里提供几个案例, 让大家在实践中去理解应用, 去悟道。 4.1 JDK排序比较器 首先最经典的就是JDK中排序器的应用了。 策略接口 12345@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); ...&#125; 具体策略类 1234567// 排序策略实现public class AscComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String o1, String o2) &#123; return o1.compareTo(o2); &#125;&#125; 环境类 123456public class Collections &#123; public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c); &#125; ...&#125; 应用 1234567public class StrategyDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.sort(list, new AscComparator()); &#125;&#125; 4.2 线程池拒绝策略 拒绝策略接口 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 默认拒绝策略实现 12345678910public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125; 应用 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;&#125; 4.3 排序算法 排序算法是最常见的基本算法, 面试中经常会问到各种各样的排序。假如说我们的应用中需要用到不同时间复杂度的排序，是否可以用策略模式来实现呢? 策略接口 123public interface SortStrategy &#123; void sort();&#125; 策略实现类 123456public class BubbleSortStrategy implements SortStrategy &#123; @Override public void sort() &#123; System.out.println(&quot;冒泡排序&quot;); &#125;&#125; 上下文策略管理类 12345public class SortHandler &#123; void sort(SortStrategy strategy) &#123; strategy.sort(); &#125;&#125; 应用 123456public class StrategyDemo3 &#123; public static void main(String[] args) &#123; SortHandler sortHandler = new SortHandler(); sortHandler.sort(new BubbleSortStrategy()); &#125;&#125; 4.4 缓存失效策略 在Redis中有各种各样的缓存淘汰策略, 比如 LRU、LFU 等等, 这里用策略模式来模拟下相关实现。 策略接口 1234public interface CacheInvalidStrategy &#123; void invalid();&#125; LRU策略实现 123456public class LRUStrategy implements CacheInvalidStrategy &#123; @Override public void invalid() &#123; System.out.println(&quot;LRU&quot;); &#125;&#125; 上下文 12345public class RedisCache &#123; void setCacheStrategy(CacheInvalidStrategy cacheStrategy)&#123; cacheStrategy.invalid(); &#125;&#125; 应用 123456public class Demo4 &#123; public static void main(String[] args) &#123; RedisCache redisCache = new RedisCache(); redisCache.setCacheStrategy(new LRUStrategy()); &#125;&#125; 4.5 缓存存储方案 大家在项目中肯定经常用到缓存，假设某个场景中需要根据key动态选择缓存策略，其中一部分存储在JVM本地缓存，一部分需要存储在分布式缓存。 策略接口 123public interface Cache &#123; boolean add (String key, Object object);&#125; 本地缓存策略实现 12345678public class CacheMemoryImpl implements Cache &#123; @Override public boolean add(String key, Object object) &#123; System.out.println(&quot;保存到map&quot;); return false; &#125;&#125; redis缓存策略实现 12345678public class CacheRedisImpl implements Cache &#123; @Override public boolean add(String key, Object object) &#123; System.out.println(&quot;保存到Redis&quot;); return false; &#125;&#125; 上下文对策略的管理达到动态切换缓存的目的 12345678910111213public class CacheManage &#123; private Cache cacheMemory = new CacheMemoryImpl(); private Cache cacheRedis = new CacheRedisImpl(); void putChche(String key, Object value)&#123; if (key.contains(&quot;local&quot;)) &#123; cacheMemory.add(key, value); &#125; else &#123; cacheRedis.add(key, value); &#125; &#125;&#125; 应用 1234567public class CacheService &#123; public static void main(String[] args) &#123; CacheManage cacheManage = new CacheManage(); cacheManage.putChche(&quot;local-key&quot;, &quot;value&quot;); &#125;&#125; 4.6 压缩算法选择 假设项目中的重要数据需要备份，一般需要压缩归档。但是我们又不能把压缩算法写死了，比方说前期选型zip，后期可能觉得压缩比不够，需要切换成7z。 压缩策略接口 1234public interface CompressionStrategy &#123; void compress(Object data);&#125; zip压缩实现 123456public class ZipCompression implements CompressionStrategy &#123; @Override public void compress(Object data) &#123; System.out.println(&quot;zip压缩&quot;); &#125;&#125; 压缩器 12345public class Compressor &#123; void compress(Object data, CompressionStrategy compressionStrategy)&#123; compressionStrategy.compress(data); &#125;&#125; 备份服务 1234567public class CompressService &#123; public static void main(String[] args) &#123; Compressor compressor = new Compressor(); compressor.compress(new Object(), new ZipCompression()); &#125;&#125; 4.7 解密算法 物联网场景中，传感器上报的数据经常有各种各样的协议和对应的加密算法，我们需要根据上行消息中的固定报文字段进行解码。 解密策略接口 1234567public interface DecryptStrategy &#123; //加密类型 String type(); //加密 void decrypt();&#125; base64解密策略实现 1234567891011@Component(&quot;base64Strategy&quot;)public class Base64Strategy implements DecryptStrategy &#123; public String type() &#123; return &quot;BASE64&quot;; &#125; @Override public void decrypt() &#123; System.out.println(&quot;--BASE64策略模式---&quot;); &#125;&#125; 解密处理上下文 1234567891011121314151617181920212223@Componentpublic class DecryptHandler implements ApplicationContextAware &#123; //所有加密实现类放入一个map中 private Map&lt;String, DecryptStrategy&gt; strategyMap = new HashMap&lt;&gt;(); public DecryptHandler() &#123;&#125; public void decrypt(String type) &#123; DecryptStrategy strategy = strategyMap.get(type); strategy.decrypt(); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; //获取所有Strategy的实现类 Map&lt;String, DecryptStrategy&gt; beansOfType = applicationContext.getBeansOfType(DecryptStrategy.class); for (DecryptStrategy bean : beansOfType.values()) &#123; strategyMap.put(bean.type(), bean); &#125; System.out.println(beansOfType.size()); &#125;&#125; 应用 123456789101112@SpringBootTest@RunWith(SpringRunner.class)public class DecryptHandlerTest &#123; @Autowired DecryptHandler decryptHandler; @Test public void test()&#123; decryptHandler.decrypt(&quot;MD5&quot;); &#125;&#125; 4.8 促销策略 做过电商项目的都知道促销模块可能会有不同的促销策略。 促销策略接口 1234567public interface PromotionStrategy &#123; /** * 促销 */ void doPromotion();&#125; 返现促销策略实现 123456public class FanxianPromotionStrategy implements PromotionStrategy &#123; @Override public void doPromotion() &#123; System.out.println(&quot;返现促销&quot;); &#125;&#125; 满减促销策略实现 1234567public class manjianPromotionStrategy implements PromotionStrategy &#123; @Override public void doPromotion() &#123; System.out.println(&quot;满减促销&quot;); &#125;&#125; 策略工厂类对策略进行管理 1234567891011121314151617181920212223242526272829/** * @description：策略+工厂模式 */public class PromotionStrategyFactory &#123; private static Map&lt;String, PromotionStrategy&gt; PROMOTION_STRATEGY_MAP = new HashMap&lt;&gt;(); static &#123; PROMOTION_STRATEGY_MAP.put(PromotionKey.MANJIAN, new LijianPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.FANXIAN, new FanxianPromotionStrategy()); &#125; private static final PromotionStrategy NON_PROMOTION = new EmptyPromotionStrategy(); /** * 不希望外部调用 */ private PromotionStrategyFactory()&#123;&#125; public static PromotionStrategy getPromotionStrategy(String promotionKey) &#123; PromotionStrategy promotionStrategy = PROMOTION_STRATEGY_MAP.get(promotionKey); return promotionStrategy == null ? NON_PROMOTION : promotionStrategy; &#125; private interface PromotionKey &#123; String MANJIAN = &quot;manjian&quot;; String FANXIAN = &quot;fanxian&quot;; &#125;&#125; 上下文包装策略 1234567891011121314151617public class PromotionActivity &#123; private PromotionStrategy promotionStrategy; /** * 构造器注入 * * @param promotionStrategy */ public PromotionActivity(PromotionStrategy promotionStrategy) &#123; this.promotionStrategy = promotionStrategy; &#125; public void executePromotionStrategy() &#123; promotionStrategy.doPromotion(); &#125;&#125; 对外应用提供策略 123456789public class PromotionStrategyTest &#123; public static void main(String[] args) &#123; String promotionKey = &quot;lijian&quot;; PromotionActivity promotionActivity = new PromotionActivity( PromotionStrategyFactory.getPromotionStrategy(promotionKey)); promotionActivity.executePromotionStrategy(); &#125;&#125; 4.9 文件上传oss 一般项目中涉及到文件存储的部分，要么是存储在类似与阿里的OSS，要么是自己基于 FastDFS 搭建分布式存储系统。如果我们条件有限，但是又需要后期可扩展，那么这里可以用策略模式实现。 策略接口 123public interface FileUpload &#123; void upload(MultipartFile file);&#125; FastDFS策略实现 123456public class FastDFSUpload implements FileUpload &#123; @Override public void upload(MultipartFile file) &#123; System.out.println(&quot;FastDFS&quot;); &#125;&#125; 上下文文件管理 123456public class FileManage &#123; void upload(MultipartFile file, FileUpload fileUpload)&#123; fileUpload.upload(file); &#125;&#125; 应用接口 123456public class FileService &#123; public static void main(String[] args) &#123; FileManage fileManage = new FileManage(); fileManage.upload(null, new FastDFSUpload()); &#125;&#125; 最后 本文到此结束, 感谢您的阅读。如果您觉得有所帮助, 请关注公众号【当我遇上你】, 并分享给身边的小伙伴。您的支持是我持续写作的最大动力。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"https://idea360.cn/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"学习ConcurrentHashMap1.7分段锁原理","slug":"source-code-concurrenthashmap-version7","date":"2020-03-17T07:18:15.000Z","updated":"2021-02-23T14:40:38.086Z","comments":true,"path":"2020/03/17/source-code-concurrenthashmap-version7/","link":"","permalink":"https://idea360.cn/2020/03/17/source-code-concurrenthashmap-version7/","excerpt":"","text":"1. 概述 接上一篇 学习ConcurrentHashMap1.8并发写机制, 本文主要学习 Segment分段锁 的实现原理。 虽然 JDK1.7 在生产环境已逐渐被 JDK1.8 替代，然而一些好的思想还是需要进行学习的。比方说位图中寻找 bit 位的思路是不是和 ConcurrentHashMap1.7 有点相似？ 接下来，本文基于 OpenJDK7 来做源码解析。 2. ConcurrentHashMap1.7初认识 ConcurrentHashMap中put()是线程安全的。但是很多时候, 由于业务需求, 需要先 get() 操作再 put() 操作，这2个操作无法保证原子性，这样就会产生线程安全问题了。大家在开发中一定要注意。 ConcurrentHashMap的结构示意图如下: 在进行数据的定位时，会首先找到 segment, 然后在 segment 中定位 bucket。如果多线程操作同一个 segment, 就会触发 segment 的锁 ReentrantLock, 这就是分段锁的基本实现原理。 3. 源码分析 3.1 HashEntry HashEntry 是 ConcurrentHashMap 的基础单元(节点)，是实际数据的载体。 1234567891011121314151617181920212223242526272829303132333435static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; /** * Sets next field with volatile write semantics. (See above * about use of putOrderedObject.) */ final void setNext(HashEntry&lt;K,V&gt; n) &#123; UNSAFE.putOrderedObject(this, nextOffset, n); &#125; // Unsafe mechanics static final sun.misc.Unsafe UNSAFE; static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = HashEntry.class; nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 3.2 Segment Segment 继承 ReentrantLock 锁,用于存放数组 HashEntry[]。在这里可以看出, 无论1.7还是1.8版本, ConcurrentHashMap 底层并不是对 HashMap 的扩展, 而是同样从底层基于数组+链表进行功能实现。 12345678910111213141516171819202122232425static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1; // 数据节点存储在这里(基础单元是数组) transient volatile HashEntry&lt;K,V&gt;[] table; transient int count; transient int modCount; transient int threshold; final float loadFactor; Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123; this.loadFactor = lf; this.threshold = threshold; this.table = tab; &#125; // 具体方法不在这里讨论...&#125; 3.3 构造方法 1234567891011121314151617181920212223242526272829303132333435363738394041public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); // 对于concurrencyLevel的理解, 可以理解为segments数组的长度，即理论上多线程并发数(分段锁), 默认16 if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments int sshift = 0; int ssize = 1; // 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4 // ssize = 2^sshift 即 ssize = 1 &lt;&lt; sshift while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; // 段偏移量，32是因为hash是int值，int值32位，默认值情况下此时segmentShift = 28 this.segmentShift = 32 - sshift; // 散列算法的掩码，默认值情况下segmentMask = 15, 定位segment的时候需要根据segment[]长度取模, 即hash(key)&amp;(ssize - 1) this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 计算每个segment中table的容量, 初始容量=16, 并发数=16, 则segment中的Entry[]长度为1。 int c = initialCapacity / ssize; // 处理无法整除的情况，取上限 if (c * ssize &lt; initialCapacity) ++c; // MIN_SEGMENT_TABLE_CAPACITY默认时2，cap是2的n次方 int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0] // 创建segments并初始化第一个segment数组,其余的segment延迟初始化 Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); // 默认并发数=16 Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss;&#125; 由图和源码可知，当用默认构造函数时，最大并发数是16，即最大允许16个线程同步写操作，且无法扩展。所以如果我们的场景数据量比较大时，应该设置合适的并发数，避免频繁锁冲突。 3.4 put()操作 1234567891011121314151617public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); // 根据key的hash再次进行hash运算 int hash = hash(key.hashCode()); // 基于hash定位segment数组的索引。 // hash值是int值，32bits。segmentShift=28，无符号右移28位，剩下高4位，其余补0。 // segmentMask=15，二进制低4位全部是1，所以j相当于hash右移后的低4位。 int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment // 找到对应segment s = ensureSegment(j); // 将新节点插入segment中 return s.put(key, hash, value, false);&#125; 找出对应segment，如果不存在就创建并初始化 123456789101112131415161718192021222324252627282930@SuppressWarnings(&quot;unchecked&quot;)private Segment&lt;K,V&gt; ensureSegment(int k) &#123; // 当前的segments数组 final Segment&lt;K,V&gt;[] ss = this.segments; // 计算原始偏移量,在segments数组的位置 long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset Segment&lt;K,V&gt; seg; // 判断没有被初始化 if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123; // 获取第一个segment ss[0]作为原型 Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype int cap = proto.table.length; // 容量 float lf = proto.loadFactor; // 负载因子 int threshold = (int)(cap * lf); // 阈值 // 初始化ss[k] 内部的tab数组 // recheck HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap]; // 再次检查这个ss[k] 有没有被初始化 if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123; // recheck Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab); // 自旋。getObjectVolatile 保证了读的可见性,所以一旦有一个线程初始化了,那么就结束自旋 while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123; if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s)) break; &#125; &#125; &#125; return seg;&#125; 3.5 segment插入节点 上一步找到segment位置后计算节点在segment中的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // 是否获取锁,失败自旋获取锁(直到成功) HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); // 失败了才会scanAndLockForPut V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; // 获取到bucket位置的第一个节点 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; // hash冲突 if (e != null) &#123; K k; // key相等则覆盖 if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; // 不相等则遍历链表 e = e.next; &#125; else &#123; if (node != null) // 将新节点插入链表作为表头 node.setNext(first); else // 创建新节点并插入表头 node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 判断元素个数是否超过了阈值或者segment中数组的长度超过了MAXIMUM_CAPACITY，如果满足条件则rehash扩容！ if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) // 扩容 rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; // 解锁 unlock(); &#125; return oldValue;&#125; 如果加锁失败则先走 scanAndLockForPut() 方法。 123456789101112131415161718192021222324252627282930313233343536373839private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123; // 根据hash获取头结点 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; int retries = -1; // negative while locating node // 尝试获取锁,成功就返回,失败就开始自旋 while (!tryLock()) &#123; HashEntry&lt;K,V&gt; f; // to recheck first below if (retries &lt; 0) &#123; // 如果头结点不存在 if (e == null) &#123; if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; &#125; // 和头结点key相等 else if (key.equals(e.key)) retries = 0; else // 下一个节点 直到为null e = e.next; &#125; // 达到自旋的最大次数 else if (++retries &gt; MAX_SCAN_RETRIES) &#123; // lock()是阻塞方法。进入加锁方法,失败进入队列,阻塞当前线程 lock(); break; &#125; // TODO (retries &amp; 1) == 0 没理解 else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; // 头结点变化,需要重新遍历,说明有新的节点加入或者移除 e = first = f; // re-traverse if entry changed retries = -1; &#125; &#125; return node;&#125; (retries &amp; 1) == 0 没理解是在做什么，有小伙伴看明白了请赐教。 最后 本文到此结束，主要是学习分段锁是如何工作的。谢谢大家的观看。","categories":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"https://idea360.cn/tags/ConcurrentHashMap/"}]},{"title":"学习ConcurrentHashMap1.8并发写机制","slug":"source-code-concurrenthashmap-version8","date":"2020-03-15T13:51:58.000Z","updated":"2021-02-23T14:40:43.100Z","comments":true,"path":"2020/03/15/source-code-concurrenthashmap-version8/","link":"","permalink":"https://idea360.cn/2020/03/15/source-code-concurrenthashmap-version8/","excerpt":"","text":"1. 前言 上篇文章讲了Unsafe类中CAS的实现，其实是在为这篇文章打基础。不太熟悉的小伙伴请移步Unsafe中CAS的实现。本篇文章主要基于 OpenJDK8 来做源码解析。 2. 源码 ConcurrentHashMap基于HashMap实现。 JDK1.7和JDK1.8作为并发容器在实现上是有差别的。JDK1.7通过Segment分段锁实现，而JDK1.8通过CAS+synchronized实现。 2.1 ConcurrentHashMap几个重要方法 在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static final sun.misc.Unsafe U;private static final long SIZECTL;private static final long TRANSFERINDEX;private static final long BASECOUNT;private static final long CELLSBUSY;private static final long CELLVALUE;private static final long ABASE;private static final int ASHIFT;static &#123; try &#123; U = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = ConcurrentHashMap.class; SIZECTL = U.objectFieldOffset (k.getDeclaredField(&quot;sizeCtl&quot;)); TRANSFERINDEX = U.objectFieldOffset (k.getDeclaredField(&quot;transferIndex&quot;)); BASECOUNT = U.objectFieldOffset (k.getDeclaredField(&quot;baseCount&quot;)); CELLSBUSY = U.objectFieldOffset (k.getDeclaredField(&quot;cellsBusy&quot;)); Class&lt;?&gt; ck = CounterCell.class; CELLVALUE = U.objectFieldOffset (ck.getDeclaredField(&quot;value&quot;)); Class&lt;?&gt; ak = Node[].class; ABASE = U.arrayBaseOffset(ak); int scale = U.arrayIndexScale(ak); if ((scale &amp; (scale - 1)) != 0) throw new Error(&quot;data type scale not a power of two&quot;); ASHIFT = 31 - Integer.numberOfLeadingZeros(scale); &#125; catch (Exception e) &#123; throw new Error(e); &#125;&#125;static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;// CAS 将Node插入bucketstatic final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125; 2.2 put()流程 还是老规矩，先上流程图帮助阅读源码。 主体源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public V put(K key, V value) &#123; return putVal(key, value, false);&#125;/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; // 基础数组 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) // 初始化 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 如果bucket==null，即没有hash冲突，CAS插入 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; // 如果在进行扩容操作，则先扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); // 否则，存在hash冲突 else &#123; V oldVal = null; // 加锁同步 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; // 遍历过程中出现相同key直接覆盖 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; // 尾插法插入 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; // 如果是树节点，遍历红黑树 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; put操作过程如下: 如果没有初始化就先调用initTable（）方法来进行初始化过程 如果没有hash冲突就直接CAS插入 如果还在进行扩容操作就先进行扩容 如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入 最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环 如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容 2.3 ConcurrentHashMap的存储结构 下边的示意图来自网络 3. 结语 本文只分析了 ConcurrentHashMap 的 put() 方法，并没有分析get()、扩容、删除节点等方法。主要目的是初步了解ConcurrentMap确保并发写的设计思路。至此，本篇文章结束，感谢大家的阅读！欢迎大家关注公众号【当我遇上你】。","categories":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"https://idea360.cn/tags/ConcurrentHashMap/"}]},{"title":"Unsafe中CAS的实现","slug":"source-code-unsafe-cas","date":"2020-03-14T17:05:24.000Z","updated":"2021-02-23T14:41:19.554Z","comments":true,"path":"2020/03/15/source-code-unsafe-cas/","link":"","permalink":"https://idea360.cn/2020/03/15/source-code-unsafe-cas/","excerpt":"","text":"前言 Unsafe是位于sun.misc包下的一个类。Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类。由于并发相关的源码很多用到了CAS，比如java.util.concurrent.atomic相关类、AQS、CurrentHashMap等相关类。所以本文主要讲Unsafe中CAS的实现。笔者源码环境为 OpenJDK8。 CAS相关 主要相关源码 12345678910111213141516171819/** * 参数说明 * @param o 包含要修改field的对象 * @param offset 对象中某个参数field的偏移量,该偏移量不会改变 * @param expected 期望该偏移量对应的field值 * @param x 更新值 * @return true|false */public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x); CAS是实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的 原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。 说明：对象的基地址baseAddress+valueOffset得到value的内存地址valueAddress Unsafe类获取 首先看下Unsafe的单例实现 12345678910private static final Unsafe theUnsafe = new Unsafe();// 注解表明需要引导类加载器@CallerSensitivepublic static Unsafe getUnsafe() &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); // 仅在引导类加载器`BootstrapClassLoader`加载时才合法 if (!VM.isSystemDomainLoader(caller.getClassLoader())) throw new SecurityException(&quot;Unsafe&quot;); return theUnsafe;&#125; 那如若想使用这个类，该如何获取其实例？有如下两个可行方案。 其一，从 getUnsafe 方法的使用限制条件出发，通过Java命令行命令 -Xbootclasspath/a 把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过 Unsafe.getUnsafe 方法安全的获取Unsafe实例。 1java -Xbootclasspath/a: $&#123;path&#125; // 其中path为调用Unsafe相关方法的类所在jar包路径 其二，通过反射获取单例对象theUnsafe。 123456789101112131415161718@Slf4jpublic class UnsafeTest &#123; private static Unsafe reflectGetUnsafe() &#123; try &#123; Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); return (Unsafe) field.get(null); &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); return null; &#125; &#125; public static void main(String[] args) &#123; Unsafe unsafe = UnsafeTest.reflectGetUnsafe(); &#125;&#125; CAS演练 创建一个类 12345@Getter@Setterpublic class User &#123; private String name; private int age;&#125; 反射获取Unsafe并测试CAS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Slf4jpublic class UnsafeTest &#123; private static Unsafe reflectGetUnsafe() &#123; try &#123; Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); return (Unsafe) field.get(null); &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); return null; &#125; &#125; public static void main(String[] args) throws Exception&#123; Unsafe unsafe = UnsafeTest.reflectGetUnsafe(); // allocateInstance: 对象操作。绕过构造方法、初始化代码来创建对象 User user = (User)unsafe.allocateInstance(User.class); user.setName(&quot;admin&quot;); user.setAge(17); Field name = User.class.getDeclaredField(&quot;name&quot;); Field age = User.class.getDeclaredField(&quot;age&quot;); // objectFieldOffset: 返回对象成员属性在内存地址相对于此对象的内存地址的偏移量 long nameOffset = unsafe.objectFieldOffset(name); long ageOffset = unsafe.objectFieldOffset(age); System.out.println(&quot;name内存偏移地址:&quot; + nameOffset); System.out.println(&quot;age 内存偏移地址:&quot; + ageOffset); System.out.println(&quot;---------------------&quot;); // CAS操作 int currentValue = unsafe.getIntVolatile(user, ageOffset); System.out.println(&quot;age内存当前值:&quot; + currentValue); boolean casAge = unsafe.compareAndSwapInt(user, ageOffset, 17, 18); System.out.println(&quot;age进行CAS更新成功:&quot; + casAge); System.out.println(&quot;age更新后的值:&quot; + user.getAge()); System.out.println(&quot;---------------------&quot;); // volatile修饰,保证可见性、有序性 unsafe.putObjectVolatile(user, nameOffset, &quot;test&quot;); System.out.println(&quot;name更新后的值:&quot; + unsafe.getObjectVolatile(user, nameOffset)); &#125;&#125; 结果输出 12345678name内存偏移地址:16age 内存偏移地址:12---------------------age内存当前值:17age进行CAS更新成功:trueage更新后的值:18---------------------name更新后的值:test Unsafe中CAS操作是原子性的，所以在秒杀、库存扣减中也可以使用Unsafe来扣减库存。 结语 本文对Java中的sun.misc.Unsafe的用法及应用场景进行了基本介绍，仅做后续源码阅读的铺垫。到此，本篇文章就写完了，感谢大家的阅读！如果您觉得对您有帮助，请关注公众号【当我遇上你】。","categories":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://idea360.cn/tags/%E5%B9%B6%E5%8F%91/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"cas","slug":"cas","permalink":"https://idea360.cn/tags/cas/"},{"name":"unsafe","slug":"unsafe","permalink":"https://idea360.cn/tags/unsafe/"}]},{"title":"Java并发知识笔记","slug":"Java-concurrent-interview-summary","date":"2020-03-14T07:01:11.000Z","updated":"2020-03-15T03:53:46.230Z","comments":true,"path":"2020/03/14/Java-concurrent-interview-summary/","link":"","permalink":"https://idea360.cn/2020/03/14/Java-concurrent-interview-summary/","excerpt":"","text":"1. 线程状态 线程状态 说明 NEW 初始状态，线程被构建，但是还没调用start()方法 RUNNABLE 运行状态，Java线程将操作系统中的就绪和运行两种状态统称运行中 BLOCKED 阻塞状态，表示线程阻塞于锁 WAITING 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定状态(通知或中断) TIMED_WAITING 超时等待状态，该状态不同于WAITING，它是可以在指定时间自行返回的 TERMINATED 终止状态，表示当前线程已经执行完毕 2. 内存模型 CPU执行计算的过程 程序以及数据被加载到主内存 指令和数据被加载到CPU缓存 CPU执行指令，把结果写到高速缓存 高速缓存中的数据写回主内存 JMM是基于共享内存的多线程并发模型 工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。 交互协议（原子操作） lock：作用于主内存的变量，把一个变量标识为一条线程独占的状态 unlock：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load：作用于工作内存的变量，把read操作从主内存得到的变量放入工作内存的变量副本中 use：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎；每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行这个操作 assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量；每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 store：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write动作使用 write：作用于主内存的变量，把store操作从工作内存中得到的变量值放入主内存的变量中 3. 原子性、可见性、有序性 原子性: 一个操作是不可中断的 可见性: 当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改 有序性: 程序执行的顺序按照代码的先后顺序执行 特性 实现 可见性 volatile、final、synchronized、lock 有序性 volatile、synchronized、lock 原子性 synchronized、JUC-原子类 4. happens-before规则 happens-before规则用于描述线程的内存可见性问题，是判断数据是否存在竞争、线程是否安全的主要依据 程序顺序规则: 在一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作; 监视器锁规则: 对一个锁的解锁Happens-Before 于后续对这个锁的加锁; volatile变量规则: 对一个volatile域的写，happens-before于任意后续对这个volatile域的读; 传递性规则: 如果AHappens-BeforeB，且 BHappens-BeforeC，那么 AHappens- BeforeC; 线程start()规则: 如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作Happens-Before于线程B中的任意操作; 线程join()规则: 主线程A等待子线程B完成(主线程A通过调用子线程B的join()方法实现)，当子线程 B 完成后(主线程A中join()方法返回)，主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。 5. 内存屏障 屏障类型 指令示例 说明 LoadLoad Barriers Load1;LoadLoad;Load2 确保Load1数据的装载先于Load2及其后所有装载指令的的操作 StoreStore Barriers Store1;StoreStore;Store2 确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作 LoadStore Barriers Load1;LoadStore;Store2 确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作 StoreLoad Barriers Store1;StoreLoad;Load2 确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作.它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令 6. volatile 可见性 用 volatile 关键字修饰的共享变量，编译成字节码后增加Lock前缀指令，该指令要做两件事: 将当前工作内存缓存行的数据立即写回到主内存。 写回主内存的操作会使其他工作内存里缓存了该共享变量地址的数据无效（缓存一致性协议保证的操作）。 对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。LOCK＃信号一般不锁总线，而是锁缓存。它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。 在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。MESI协议是当前最主流的缓存一致性协议。 有序性 volatile写 volatile读 7. synchronized 简介 synchronize实现的锁本质上是一种阻塞锁，也就是说多个线程要排队访问同一个共享对象。 synchronized是无法禁止指令重排和处理器优化的，从双重校验单例可以看出 synchronized保证的有序性是多个线程之间的有序性，即被加锁的内容要按照顺序被多个线程执行。但是其内部的同步代码还是会发生重排序，只不过由于编译器和处理器都遵循as-if-serial语义，所以我们可以认为这些重排序在单线程内部可忽略。 synchronize可见性通过Happens-Before 规则保证的 实现原理 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同 步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter指令时，线程试图获取锁也就是获取monitor的持有权.当计数器为0则可以成功获取，获取后将锁计数器设 为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当 前线程就要阻塞等待，直到锁被另外一个线程释放为止。 8. Lock 基于AQS实现 9. wait/notify对比await/signal wait/notify Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，是java底层级别的。 wait/notify方式不支持响应中断 wait/notify方式支持一个等待队列 wait/notify可能导致线程永远无法被唤醒 await/signal Condition与Lock配合完成等待通知机制，是语言级别的，具有更高的可控制性和扩展性。 Condition能够支持响应中断 Condition能够支持多个等待队列（new 多个Condition对象） 10. lock对比synchronized synchronized synchronized无法破坏不可抢占条件（死锁的条件之一）。 synchronized在申请资源的时候，如果申请不到，线程直接进入阻塞状态，也不会释放线程已经占有的资源。 lock 能够响应中断 持有锁A的线程在尝试获取锁B失败，进入阻塞状态，如果发生死锁，将没有机会唤醒阻塞线程 如果处于阻塞状态的线程能够响应中断信号，那阻塞线程就有机会释放曾经持有的锁A 支持超时 如果线程在一段时间内没有获得锁，不是进入阻塞状态，而是返回一个错误 那么该线程也有机会释放曾经持有的锁 非阻塞地获取锁 如果尝试获取锁失败，不是进入阻塞状态，而是直接返回，那么该线程也有机会释放曾经持有的锁 1234567// java.util.concurrent.locks.Lock接口// 能够响应中断void lockInterruptibly() throws InterruptedException;// 支持超时（同时也能够响应中断）boolean tryLock(long time, TimeUnit unit) throws InterruptedException;// 非阻塞地获取锁boolean tryLock(); 11. CAS 12. AQS volatile修饰的state保证可见性、顺序性，Unsafe类的CAS保证原子性 13. Unsafe 14. 死锁 死锁发生的条件 互斥: 共享资源X和共享资源Y只能被一个线程占用 请求保持: 线程T1占有共享资源X，在等待共享资源Y的时候，不会释放共享资源X 不可剥夺: 其他线程不能强行抢占线程已经占有的共享资源 环路等待: 线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源 规避死锁 破坏请求保持: 一次性申请所有共享资源，不存在等待 破坏不可剥夺: 占有部分共享资源的线程进一步申请其他共享资源时，如果申请不到，可以主动释放它所占用的共享资源，如超时释放等。 破坏环路等待: 按序申请共享资源（共享资源是有线性顺序的）","categories":[{"name":"并发","slug":"并发","permalink":"https://idea360.cn/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://idea360.cn/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"LinkedHashMap源码解读","slug":"source-code-linkedhashmap","date":"2020-03-13T09:22:04.000Z","updated":"2021-02-23T14:41:04.971Z","comments":true,"path":"2020/03/13/source-code-linkedhashmap/","link":"","permalink":"https://idea360.cn/2020/03/13/source-code-linkedhashmap/","excerpt":"","text":"1. 前言 还是从面试中来，到面试中去。面试官在面试Redis的时候经常会问到，Redis的LRU是如何实现的？如果让你实现LRU算法，你会怎么实现呢？除了用现有的结构LinkedHashMap实现，你可以自己实现一个吗？跳跃表、小顶堆行不行… 阅读这篇文章前建议大家先熟悉下Java面试必问之Hashmap底层实现原理(JDK1.8)。LinkedHashMap基于HashMap实现，其中很多方法都是在HashMap上进行了增强。 2. 使用LinkedHashMap实现LRU缓存 实现代码如下: 12345678910111213141516171819public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private int cacheSize; public LRUCache(int cacheSize) &#123; super(16, (float) 0.75, true); this.cacheSize = cacheSize; &#125; /** * 判断节点数是否超限 * @param eldest * @return 超限返回 true，否则返回 false */ @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; cacheSize; &#125;&#125; 测试代码如下: 1234567891011121314151617181920212223242526272829/** * 输出结果: * 17:44:31.635 [main] INFO com.demo.cache.Test - 所有的缓存:&#123;key0=0, key1=1, key2=2&#125; * 17:44:31.641 [main] INFO com.demo.cache.Test - 访问key0后的缓存:&#123;key1=1, key2=2, key0=0&#125; * 17:44:31.642 [main] INFO com.demo.cache.Test - 测试热点缓存:&#123;key2=2, key0=0, key3=3&#125; */@Slf4jpublic class Test &#123; public static void main(String[] args) &#123; LRUCache&lt;Object, Object&gt; lruCache = new LRUCache&lt;&gt;(3); for (int i=0; i&lt;3; i++) &#123; lruCache.put(&quot;key&quot; + i, i); &#125; log.info(&quot;所有的缓存:&#123;&#125;&quot;, lruCache); // 理论上刚访问过key0，key0应该放在链表尾部，代表最近使用，删除策略从头部删除 lruCache.get(&quot;key0&quot;); log.info(&quot;访问key0后的缓存:&#123;&#125;&quot;, lruCache); // 新插入缓存，超过了缓存阈值，理论上会删除链表头部元素，并将新缓存放置在链表尾部。 lruCache.put(&quot;key3&quot;, 3); log.info(&quot;测试热点缓存:&#123;&#125;&quot;, lruCache); &#125;&#125; 3. 源码分析 Redis中LRU的实现暂时没有研究，大家可以看下别人的分析，这里只做java部分的分析。 笔者的代码环境是OpenJDK8 LinkedHashMap底层依旧基于HashMap实现，同时增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 3.1 基础节点Entry 1234567static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; // 构造方法直接复用Hashmap的构造方法 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 基础节点的继承自HashMap的Node节点. 3.2 新增节点 查看源码方法列表可以看出，源码中没有put()方法，那一定是继承父类Hashmap的put()方法。 这里我们再看下链表的插入逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// HashMap方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;// HashMap方法final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 判断数组是否为空，长度是否为0，是则进行扩容数组初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 通过hash算法找到数组下标得到数组元素，为空则新建 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 找到数组元素，hash相等同时key相等，则直接覆盖 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 该数组元素在链表长度&gt;8后形成红黑树结构的对象,p为树结构已存在的对象 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 该数组元素hash相等，key不等，同时链表长度&lt;8.进行遍历寻找元素，有就覆盖无则新建 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 新建链表中数据元素，尾插法 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度&gt;=8 结构转为 红黑树 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 新值覆盖旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // onlyIfAbsent默认false if (!onlyIfAbsent || oldValue == null) e.value = value; // 需要子类实现 afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 判断是否需要扩容 if (++size &gt; threshold) resize(); // 需要子类实现，默认是true afterNodeInsertion(evict); return null;&#125;// 覆盖HashMap方法,新创建Entry节点的元素放在链表尾部(需要新建节点的走这里，包括链表和红黑树)Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;// 将元素插入到双端链表尾部private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; // 数组和链表都为空，首尾指针指向当前节点 if (last == null) head = p; else &#123; // 移动尾指针指向新节点 p.before = last; last.after = p; &#125;&#125;// 将被访问节点移动到链表最后(覆盖旧节点value的走这里，包括链表和红黑树)void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125;// 根据条件判断是否移除最近最少被访问的节点void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; // 删除头节点 removeNode(hash(key), key, null, false, true); &#125;&#125;// 覆盖此方法可实现不同的策略缓存, protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 基本插入逻辑和HashMap是相同的，我把需要子类覆写的地方用不同颜色表示出来了，具体见下图: 3.3 删除节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// HashMap实现public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;// HashMap实现final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; // 默认空实现，子类中实现删除回调 afterNodeRemoval(node); return node; &#125; &#125; return null;&#125;// LinkedHashMap中实现。删除节点后的链表维护void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; 删除节点的逻辑比较简单，和HashMap基本一样，删除节点后重新维护前后节点指针即可。 3.4 获取节点(最近使用节点移动至尾节点) 1234567891011121314151617181920212223242526272829303132333435363738394041// 重写HashMap方法public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; // 如果accessOrder=true,则获取节点元素后将该节点移动至链表尾部(删除旧节点从头部删除) if (accessOrder) afterNodeAccess(e); return e.value;&#125;// LinkedHashMap 中覆写。将被访问节点移动到链表最后(覆盖旧节点value的走这里，包括链表和红黑树)// 将被访问节点移动到链表最后(覆盖旧节点value的走这里，包括链表和红黑树)void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else // 移除节点e,并重新维护前后节点链表指针 b.after = a; if (a != null) // 移除节点e,并重新维护前后节点链表指针 a.before = b; else last = b; if (last == null) head = p; else &#123; // 将节点e移动到链表尾部 p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 从代码中可以看到，每次调用get方法时，如果开启了accessOrder，则会将当前元素移动到链表尾部。 4. 总结 本来源码加配图学习会更加容易明白，奈何绘图功底有限。大家有什么比较好用的工具可以推荐一下。到此，本篇文章就写完了，感谢大家的阅读！如果您觉得对您有帮助，请关注公众号【当我遇上你】。","categories":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"集合","slug":"集合","permalink":"https://idea360.cn/tags/%E9%9B%86%E5%90%88/"},{"name":"linkhashmap","slug":"linkhashmap","permalink":"https://idea360.cn/tags/linkhashmap/"}]},{"title":"Hashset源码分析","slug":"source-code-hashset","date":"2020-03-12T08:13:54.000Z","updated":"2021-02-23T14:40:50.898Z","comments":true,"path":"2020/03/12/source-code-hashset/","link":"","permalink":"https://idea360.cn/2020/03/12/source-code-hashset/","excerpt":"","text":"1. 概述 Hashset实现set接口，底层基于Hashmap实现, 但与Hashmap不同的实Hashmap存储键值对，Hashset仅存储对象。 HashSet使用成员对象来计算hashcode值。 2. 原理 在《Head fist java》一书中有描述: 当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，则覆盖旧元素。 这里看到很多文章说: 如果equals()方法相等，HashSet就不会让加入操作成功。根据hashmap的put()方法源码可知，实际上是覆盖操作，虽然覆盖对象的key和value都完全一致。 hashCode()与equals()的相关规定： 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个equals方法返回true 两个对象有相同的hashcode值，它们也不一定是相等的 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。 ==与equals的区别 ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同 ==是指对内存地址进行比较 equals()是对字符串的内容进行比较 ==指引用是否相同 equals()指的是值是否相同 3. 源码分析 首先查看下源码结构，发现该类源码相对比较简单 3.1 构造方法 12345678/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */// 内部存储在hashmap中public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; 3.2 添加元素add() 1234private static final Object PRESENT = new Object(); public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; 可以看到添加的对象直接作为Hashmap的key, 而value是final修饰的空对象。 根据之前对 Java面试必问之Hashmap底层实现原理(JDK1.8) 中 put() 方法的解读可以知道: 在Hashmap中首先根据hashCode寻找数组bucket，当hash冲突时，需要比较key是否相等，相等则覆盖，否则通过拉链法进行处理。在Hashset中存储的对象作为key，所以存储对象需要重写 hashCode() 和 equals() 方法。 4. 使用案例分析 4.1 存储字符串案例 再来看一组示例 1234567891011public class Demo2 &#123; public static void main(String[] args) &#123; HashSet&lt;Object&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(&quot;a&quot;); hashSet.add(&quot;b&quot;); hashSet.add(&quot;c&quot;); hashSet.add(&quot;a&quot;); System.out.println(hashSet); &#125;&#125; 结果 1[a, b, c] 分析 查看字符串源码.字符串重写了hashCode()和equals方法, 所以结果符合预期 1234567891011121314151617181920212223242526272829303132333435public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125;public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; &#125; 4.2 存储对象错误案例 首先我们创建一个 user 对象 12345678@Getter@Setter@AllArgsConstructor@ToStringpublic class User &#123; private String username;&#125; 根据set集合的属性，set中的元素是不重复的，现在测试下 1234567891011public class Demo &#123; public static void main(String[] args) &#123; HashSet&lt;Object&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(new User(&quot;a&quot;)); hashSet.add(new User(&quot;b&quot;)); hashSet.add(new User(&quot;c&quot;)); hashSet.add(new User(&quot;a&quot;)); System.out.println(hashSet); &#125;&#125; 结果输出 1[User(username&#x3D;a), User(username&#x3D;c), User(username&#x3D;b), User(username&#x3D;a)] 怎么会有重复的呢? 和预期结果不符呀。其实根据上边的源码我们已经知道原因了，打印hash值确认下 1[901506536, 1513712028, 747464370, 1018547642] java中对象默认继承顶级父类Object。在Object类中源码如下: 12345public native int hashCode();// 比较内存地址public boolean equals(Object obj) &#123; return (this == obj);&#125; 4.3 存储对象正确示范 重写equals()和hashCode()方法。(这里偷了个懒，感兴趣的大家可以自己重写下这2个方法) 123456789@Getter@Setter@AllArgsConstructor@ToString@EqualsAndHashCodepublic class User extends Object&#123; private String username;&#125; 再次输出发现结果唯一了 1[User(username&#x3D;a), User(username&#x3D;b), User(username&#x3D;c)] 5. 总结 其实HashSet的一些东西都是用HashMap来实现的，如果HashMap的源码已经阅读过的话基本上没有什么问题。这可能是我写的最轻松的一篇文章。","categories":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"集合","slug":"集合","permalink":"https://idea360.cn/tags/%E9%9B%86%E5%90%88/"},{"name":"hashset","slug":"hashset","permalink":"https://idea360.cn/tags/hashset/"}]},{"title":"从一道面试题引发的Java线程通信的思考","slug":"learn-java-thread-wait-notify-from-interview","date":"2020-03-09T12:03:36.000Z","updated":"2021-02-23T14:36:17.328Z","comments":true,"path":"2020/03/09/learn-java-thread-wait-notify-from-interview/","link":"","permalink":"https://idea360.cn/2020/03/09/learn-java-thread-wait-notify-from-interview/","excerpt":"","text":"一、前言 线程通信是Java并发编程中的基础。曾经面试的时候遇到一个比较有趣的面试题拿出来与大家分享。 题目: 2个线程A和B，A线程生产A数据，然后消费B数据；B线程生产B数据，然后消费A数据，请用代码实现。 题目分析: 这是个典型的线程间通信的题目，由于AB分别需要消费对方生产的数据，需要AB在生产完成后通知对方线程消费，同时也需要在没有数据的时候阻塞等待。有没有觉得很熟悉？类似交替打印的问题？ 二、题解 下边，我将用2种思路进行解答。 思路一: wait/notify 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * ThreadA--生产A--打印B--start * ThreadB--生产B--打印A--start * * 执行结果 * thread-B:A * thread-A:B */public class ThreadLockDemo2 &#123; private String A = null; private String B = null; private Object lock = new Object(); public void doA() &#123; // 生产A A = &quot;A&quot;; // 假设A获得锁，则B阻塞等待 synchronized (lock) &#123; if (B == null) &#123; try &#123; // 只有拥有对象锁，才能调用对象的wait()方法让当前线程阻塞(进入monitor的等待队列)，该方法会释放对象锁。 // 该线程必须有其他线程通过notify()或者notifyAll()唤醒 lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // A线程被B线程notify唤醒，顺利消费B System.out.println(Thread.currentThread().getName() + &quot;:&quot; + B); lock.notify(); &#125; &#125; public void doB() &#123; // 生产B B = &quot;B&quot;; // A释放锁后，B可以获得monitor的所有权 synchronized (lock) &#123; if (A == null) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // B顺利消费A生产的数据，然后唤醒A线程 System.out.println(Thread.currentThread().getName() + &quot;:&quot; + A); lock.notify(); &#125; &#125; public static void main(String[] args) &#123; ThreadLockDemo2 threadLockDemo = new ThreadLockDemo2(); new Thread(new Runnable() &#123; @Override public void run() &#123; threadLockDemo.doA(); &#125; &#125;, &quot;thread-A&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; threadLockDemo.doB(); &#125; &#125;, &quot;thread-B&quot;).start(); &#125;&#125; 思路二: Condition/await/signal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * ThreadA--生产A--打印B--start * ThreadB--生产B--打印A--start * * 执行结果 * thread-B:A * thread-A:B */public class ThreadLockDemo &#123; private String A = null; private String B = null; private ReentrantLock lock = new ReentrantLock(); private Condition conditionA = lock.newCondition(); private Condition conditionB = lock.newCondition(); public void doA() &#123; // 假设A线程先获得锁。则B会阻塞在此等待锁释放 lock.lock(); try &#123; // 生产A A = &quot;A&quot;; if (B == null) &#123; // 会阻塞A线程，并让该Condition关联的锁释放(阻塞在lock方法处的线程B重新获取锁) conditionA.await(); &#125; // 打印B System.out.println(Thread.currentThread().getName() + &quot;:&quot; + B); // 唤醒B线程 conditionB.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void doB() &#123; // 现成B由于conditionA.await而获得锁 lock.lock(); try &#123; // 生产B B = &quot;B&quot;; if (A == null) &#123; conditionB.await(); &#125; // 打印A System.out.println(Thread.currentThread().getName() + &quot;:&quot; + A); // 唤醒该Condition关联的线程A conditionA.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ThreadLockDemo threadLockDemo = new ThreadLockDemo(); new Thread(new Runnable() &#123; @Override public void run() &#123; threadLockDemo.doA(); &#125; &#125;, &quot;thread-A&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; threadLockDemo.doB(); &#125; &#125;, &quot;thread-B&quot;).start(); &#125;&#125; 三、注意 当前线程必须拥有此对象的monitor（即锁），才能调用某个对象的wait()方法能让当前线程阻塞。（这种阻塞是通过提前释放synchronized锁，进入等待队列导致的阻塞，这种请求必须有其他线程通过notify()或者notifyAll()唤醒重新竞争获得锁） 调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程； （notify()或者notifyAll()方法并不是真正释放锁，必须等到synchronized方法或者语法块执行完才真正释放锁） 调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程，唤醒的线程获得锁的概率是随机的，取决于cpu调度 下边我们来验证下2. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 执行结果: * * Thread-A wait before... * Thread-B i=0 * Thread-B i=1 * Thread-B i=2 * Thread-B notify... * Thread-B i=3 * Thread-B i=4 * Thread-B i=5 * Thread-A wait after... * * 由结果可以看出，线程B执行notify之后线程A并没有立即获得锁， * 而是等待B释放锁后。 */public class WaitDemo &#123; private int index = 0; Object lock = new Object(); public void method1() &#123; try &#123; synchronized (lock) &#123; if (index != 3) &#123; System.out.println(Thread.currentThread().getName() + &quot; wait before...&quot;); lock.wait(); System.out.println(Thread.currentThread().getName() + &quot; wait after...&quot;); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void method2() &#123; try &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 6; i++) &#123; index ++; if (i == 3) &#123; lock.notify(); System.out.println(Thread.currentThread().getName() + &quot; notify...&quot;); &#125; System.out.println(Thread.currentThread().getName() + &quot; i=&quot; + i); Thread.sleep(1000); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; WaitDemo waitDemo = new WaitDemo(); Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; waitDemo.method1(); &#125; &#125;, &quot;Thread-A&quot;); threadA.start(); // 注意，这里为了模拟让A线程先执行，此处sleep 1s。(如果B先执行则A wait后无法唤醒) try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; waitDemo.method2(); &#125; &#125;, &quot;Thread-B&quot;); threadB.start(); &#125;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"复盘MySQL分页查询优化方案","slug":"how-to-optimization-mysql-page","date":"2020-03-09T06:37:24.000Z","updated":"2020-03-15T03:53:40.375Z","comments":true,"path":"2020/03/09/how-to-optimization-mysql-page/","link":"","permalink":"https://idea360.cn/2020/03/09/how-to-optimization-mysql-page/","excerpt":"","text":"一、前言 MySQL分页查询作为Java面试的一道高频面试题，这里有必要实践一下，毕竟实践出真知。 很多同学在做测试时苦于没有海量数据，官方其实是有一套测试库的。 二、模拟数据 这里模拟数据分2种情况导入，如果只是需要数据测试下，那么推荐官方数据。如果官方数据满足不了需求的话，那么我们自己模拟数据。 1. 导入官方测试库 下载 官方数据库文件 或者在 github 上下载。 该测试库含有6个表。 首先进入 employees_db, 执行导入数据指令 1mysql -uroot -proot -t &lt; employees.sql 有些环境可能会报错 1ERROR 1193 (HY000) at line 38: Unknown system variable &#39;storage_engine&#39; 连接mysql查看默认引擎，发现不是本地环境的问题。 12345678910mysql&gt; show variables like &#39;%engine%&#39;;+----------------------------------+--------+| Variable_name | Value |+----------------------------------+--------+| default_storage_engine | InnoDB || default_tmp_storage_engine | InnoDB || disabled_storage_engines | || internal_tmp_disk_storage_engine | InnoDB |+----------------------------------+--------+4 rows in set (0.01 sec) 修改 employees.sql 脚本 1234567 set default_storage_engine &#x3D; InnoDB;-- set storage_engine &#x3D; MyISAM;-- set storage_engine &#x3D; Falcon;-- set storage_engine &#x3D; PBXT;-- set storage_engine &#x3D; Maria;select CONCAT(&#39;storage engine: &#39;, @@default_storage_engine) as INFO; 再次执行发现导入成功 123456789101112131415161718192021222324252627282930313233343536373839404142➜ employees_db mysql -uroot -proot -t &lt; employees.sqlmysql: [Warning] Using a password on the command line interface can be insecure.+-----------------------------+| INFO |+-----------------------------+| CREATING DATABASE STRUCTURE |+-----------------------------++------------------------+| INFO |+------------------------+| storage engine: InnoDB |+------------------------++---------------------+| INFO |+---------------------+| LOADING departments |+---------------------++-------------------+| INFO |+-------------------+| LOADING employees |+-------------------++------------------+| INFO |+------------------+| LOADING dept_emp |+------------------++----------------------+| INFO |+----------------------+| LOADING dept_manager |+----------------------++----------------+| INFO |+----------------+| LOADING titles |+----------------++------------------+| INFO |+------------------+| LOADING salaries |+------------------+ 验证结果(配置修改同上) 1234567891011121314151617➜ employees_db mysql -uroot -proot -t &lt; test_employees_sha.sqlmysql: [Warning] Using a password on the command line interface can be insecure.+----------------------+| INFO |+----------------------+| TESTING INSTALLATION |+----------------------++--------------+------------------+------------------------------------------+| table_name | expected_records | expected_crc |+--------------+------------------+------------------------------------------+| departments | 9 | 4b315afa0e35ca6649df897b958345bcb3d2b764 || dept_emp | 331603 | d95ab9fe07df0865f592574b3b33b9c741d9fd1b || dept_manager | 24 | 9687a7d6f93ca8847388a42a6d8d93982a841c6c || employees | 300024 | 4d4aa689914d8fd41db7e45c2168e7dcb9697359 || salaries | 2844047 | b5a1785c27d75e33a4173aaa22ccf41ebd7d4a9f || titles | 443308 | d12d5f746b88f07e69b9e36675b6067abb01b60e |+--------------+------------------+------------------------------------------+ 我们可以看到emp大概有33万条数据。 2. 存储过程导入模拟数据 这里我们可以选择存储过程批量导入。 首先创建一张表 1234567drop table if exists &#96;user&#96;;create table &#96;user&#96;( &#96;id&#96; int unsigned auto_increment, &#96;username&#96; varchar(64) not null default &#39;&#39;, &#96;score&#96; int(11) not null default 0, primary key(&#96;id&#96;))ENGINE &#x3D; InnoDB; 创建存储过程 1234567891011121314DROP PROCEDURE IF EXISTS batchInsert;delimiter $$ -- 声明存储过程结束符号create procedure batchInsert() -- 创建存储过程begin -- 存储过程主体开始 declare num int; -- 声明变量 set num&#x3D;1; -- 初始值 while num&lt;&#x3D;3000000 do -- 循环条件 insert into user(&#96;username&#96;,&#96;score&#96;) values(concat(&#39;user-&#39;, num),num); -- 执行语句 set num&#x3D;num+1; -- 循环变量自增 end while; -- 结束循环end$$ -- 存储过程主体结束delimiter ; #恢复;表示结束CALL batchInsert; -- 执行存储过程 可以看到测试300W条数据大概1046s插入完成。好吧，本来计划导入1000w的结果时间太长了。 三、常用的MySQL分页查询问题复现及优化。 我们拿现有的表 user 进行测试，该表有 300w 条数据。 1. 前置检查 首先查看下该表结构以及目前存在哪些索引 1234567891011121314151617mysql&gt; desc user;+----------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || username | varchar(30) | NO | | | || score | int(11) | NO | | 0 | |+----------+------------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql&gt; show index from user;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| user | 0 | PRIMARY | 1 | id | A | 2991886 | NULL | NULL | | BTREE | | |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec) 可以看到只有 id 主键索引。 其次查看是否开启 缓存 (避免查询缓存对执行效率产生影响) 123456789101112131415mysql&gt; show variables like &#39;%query_cache%&#39;;+------------------------------+---------+| Variable_name | Value |+------------------------------+---------+| have_query_cache | YES || query_cache_limit | 1048576 || query_cache_min_res_unit | 4096 || query_cache_size | 1048576 || query_cache_type | OFF || query_cache_wlock_invalidate | OFF |+------------------------------+---------+6 rows in set (0.00 sec)mysql&gt; show profiles;Empty set, 1 warning (0.00 sec) have_query_cache 和 query_cache_type 说明支持缓存但并未开启。 show profiles 显示为空，说明profiles功能是关闭的。 开启 profiles 12345678910mysql&gt; SET profiling &#x3D; 1;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; show profiles;+----------+------------+-------------------+| Query_ID | Duration | Query |+----------+------------+-------------------+| 1 | 0.00012300 | SET profiling &#x3D; 1 |+----------+------------+-------------------+1 row in set, 1 warning (0.00 sec) 2. 无索引分页查询 一般我们最常用的分页查询的方式为 order by + limit m,n 的方式, 现在我们测试下分页性能 1234select * from user order by score limit 0,10; -- 10 rows in set (0.65 sec)select * from user order by score limit 10000,10; -- 10 rows in set (0.83 sec)select * from user order by score limit 100000,10; -- 10 rows in set (1.03 sec)select * from user order by score limit 1000000,10; -- 10 rows in set (1.14 sec) 这里我们确认下是否用到了索引 1234567mysql&gt; explain select * from user order by score limit 1000000,10;+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+| 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 2991995 | 100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+1 row in set, 1 warning (0.00 sec) 可以看到确实没有用到索引，全表扫描100W数据分页大概需要1.14s的时间。 3. 有索引分页查询 123select * from user order by id limit 10000,10; -- 10 rows in set (0.01 sec)select * from user order by id limit 1000000,10; -- 10 rows in set (0.18 sec)select * from user order by id limit 2000000,10; -- 10 rows in set (0.35 sec) 该查询用到了主键索引，所以查询效率比较高。 可以看到，当数据量变大时，查询效率明显下降。 这里我们确认下是否使用到了索引 1234567mysql&gt; explain select * from user order by id limit 2000000,10;+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------+| 1 | SIMPLE | user | NULL | index | NULL | PRIMARY | 4 | NULL | 2000010 | 100.00 | NULL |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------+1 row in set, 1 warning (0.00 sec) 可以看到用了全索引扫描，共查询了2000010行数据。 4. 优化 我们根据MYSQL自带的一种query诊断分析工具查看下sql语句执行各个操作的耗时详情。可以看到查询获取到的2000010条记录都返回给客户端了，耗时主要集中在Sending data阶段。但是客户端只需要10条数据，我们能否只给客户端返回10条数据呢？ 123456789101112131415161718192021222324252627282930313233mysql&gt; show profiles;+----------+------------+---------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+---------------------------------------------------------+| 1 | 0.00012300 | SET profiling &#x3D; 1 || 2 | 0.00009200 | SET profiling &#x3D; 1 || 3 | 0.35689500 | select * from user order by id limit 2000000,10 || 4 | 0.00023900 | explain select * from user order by id limit 2000000,10 |+----------+------------+---------------------------------------------------------+4 rows in set, 1 warning (0.00 sec)mysql&gt; show profile for query 3;+----------------------+----------+| Status | Duration |+----------------------+----------+| starting | 0.000071 || checking permissions | 0.000007 || Opening tables | 0.000012 || init | 0.000017 || System lock | 0.000008 || optimizing | 0.000005 || statistics | 0.000024 || preparing | 0.000016 || Sorting result | 0.000004 || executing | 0.000003 || Sending data | 0.356653 || end | 0.000013 || query end | 0.000005 || closing tables | 0.000008 || freeing items | 0.000019 || cleaning up | 0.000030 |+----------------------+----------+16 rows in set, 1 warning (0.00 sec) 网上的优化方案: 子查询 + 覆盖索引 12345678910111213141516171819202122232425mysql&gt; select * from user where id &gt; (select id from user order by id limit 2000000, 1) limit 10;+---------+--------------+---------+| id | username | score |+---------+--------------+---------+| 2000002 | user-2000002 | 2000002 || 2000003 | user-2000003 | 2000003 || 2000004 | user-2000004 | 2000004 || 2000005 | user-2000005 | 2000005 || 2000006 | user-2000006 | 2000006 || 2000007 | user-2000007 | 2000007 || 2000008 | user-2000008 | 2000008 || 2000009 | user-2000009 | 2000009 || 2000010 | user-2000010 | 2000010 || 2000011 | user-2000011 | 2000011 |+---------+--------------+---------+10 rows in set (0.29 sec)mysql&gt; explain select * from user where id &gt; (select id from user order by id limit 2000000, 1) limit 10;+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+| 1 | PRIMARY | user | NULL | range | PRIMARY | PRIMARY | 4 | NULL | 1495997 | 100.00 | Using where || 2 | SUBQUERY | user | NULL | index | NULL | PRIMARY | 4 | NULL | 2000001 | 100.00 | Using index |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+2 rows in set, 1 warning (0.30 sec) 然而并没有提升查询性能。没看到问题出在哪里呢？从执行计划可以看出，索引和我们期望是一致的。rows这里检索了很多行。单独看下子查询 123456789101112131415mysql&gt; select id from user order by id limit 2000000, 1;+---------+| id |+---------+| 2000001 |+---------+1 row in set (0.29 sec)mysql&gt; explain select id from user order by id limit 2000000, 1;+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+| 1 | SIMPLE | user | NULL | index | NULL | PRIMARY | 4 | NULL | 2000001 | 100.00 | Using index |+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+1 row in set, 1 warning (0.00 sec) 这里可以看出子查询即使走了覆盖索引，依旧消耗3s左右，我觉得这就是正常的索引IO花费的时间。没找到官方测试数据做对比，以及MySQL一次IO查询花费的时间来做对比。 理论上int主键一页可以存储1000个键,根常驻内存,那么B+Tree第二层大概100W个键,测试数据在200W的分页，理论上需要2次IO可以找到数据。2次IO花费的时间是3s的话，1次应该在1.5s左右, 我们查询下99W左右的分页看是否符合假想。 1234567mysql&gt; select id from user order by id limit 990000,1;+--------+| id |+--------+| 990001 |+--------+1 row in set (0.15 sec) 所以这里笔者大胆的猜想结果是正常开销 四、最后 本来想复盘网上的分页优化方案是否可靠，但是预期结果还是有区别。希望聪明的读者有不同见解的不吝赐教。公众号里有笔者的微信二维码。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"},{"name":"调优","slug":"调优","permalink":"https://idea360.cn/tags/%E8%B0%83%E4%BC%98/"}]},{"title":"TCP的三次握手和四次挥手","slug":"tcp-protocol-intro","date":"2020-03-08T21:42:12.000Z","updated":"2020-03-15T03:54:46.487Z","comments":true,"path":"2020/03/09/tcp-protocol-intro/","link":"","permalink":"https://idea360.cn/2020/03/09/tcp-protocol-intro/","excerpt":"","text":"前言 TCP的三次握手和四次挥手常作为面试题考察程序员对于TCP握手协议的理解。该篇文章写于2018年, 此处为博客迁移，无内容增删。 TCP三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 说明: SYN（synchronous）是TCP/IP建立连接时使用的握手信号. ACK (Acknowledgement）即是确认字符.TCP报文格式中的控制位由6个标志比特构成，其中一个就是ACK，ACK为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。 seq 是序列号,是为了连接以后传送数据用的,初始随机. ack 是期望对方继续发送的那个数据包的序列号.因为已经收到了序列号为x的数据包，准备接收序列号为x+1的包，所以ack=x+1 举个例子 第一次(A—&gt;B)，SYN=1，seq=x 第二次(B—&gt;A)，SYN=1，ACK=1，seq=y，ack=x+1 //seq为什么是y，ack为什么是x+1？ 第三次(A—&gt;B)，ACK=1，seq=x+1,ack=y+1 //seq为什么是x+1，ack为什么是y+1？ 12345seq是序列号，这是为了连接以后传送数据用的，ack是对收到的数据包的确认，值是等待接收的数据包的序列号。在第一次消息发送中，A随机选取一个序列号作为自己的初始序号发送给B；第二次消息B使用ack对A的数据包进行确认，因为已经收到了序列号为x的数据包，准备接收序列号为x+1的包，所以ack=x+1，同时B告诉A自己的初始序列号，就是seq=y；第三条消息A告诉B收到了B的确认消息并准备建立连接，A自己此条消息的序列号是x+1，所以seq=x+1，而ack=y+1是表示A正准备接收B序列号为y+1的数据包。seq是数据包本身的序列号；ack是期望对方继续发送的那个数据包的序列号。 TCP四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文段，FIN=1； B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据； 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1； A 收到后发出确认，此时连接释放。","categories":[{"name":"面试","slug":"面试","permalink":"https://idea360.cn/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"TCP","slug":"TCP","permalink":"https://idea360.cn/tags/TCP/"}]},{"title":"Java大小端与报文解析","slug":"java-message-parse","date":"2020-03-08T21:31:36.000Z","updated":"2021-02-23T14:24:37.987Z","comments":true,"path":"2020/03/09/java-message-parse/","link":"","permalink":"https://idea360.cn/2020/03/09/java-message-parse/","excerpt":"","text":"定义 要想搞懂大小端，首先得明白大小端的定义，以下是百度的定义 下面以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value Big-Endian: 低地址存放高位，如下： 123456高地址buf[3] (0x78) -- 低位buf[2] (0x56)buf[1] (0x34)buf[0] (0x12) -- 高位低地址 Little-Endian: 低地址存放低位，如下： 1234buf[3] (0x12) -- 高位buf[2] (0x34)buf[1] (0x56)buf[0] (0x78) -- 低位 所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放； 所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。 工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 字节数组转int * 大端模式 * @param b * @return */ public static int byteArray2BigInt(byte[] b) &#123; int intValue = 0; for (int i = 0; i &lt; b.length; i++) &#123; intValue += (b[i] &amp; 0xFF) &lt;&lt; (8 * (3 - i)); &#125; return intValue; &#125; /** * 字节数组转int * 小端模式 * @param b * @return */ public static int byteArray2LittleInt(byte[] b)&#123; int initValue = 0; for (int i = 0; i &lt; b.length; i++)&#123; initValue += (b[i] &amp; 0xFF) &lt;&lt; (8 * i); &#125; return initValue; &#125; /** * 大端模式 * @param iValue * @return */ public static byte[] int2ByteArrayBig(int iValue)&#123; byte[] b = new byte[4]; for (int i = 0; i &lt; b.length; i++)&#123; b[3-i] = (byte)((iValue &gt;&gt; (8 * i)) &amp; 0xFF); &#125; return b; &#125; /** *小端模式 * @param iValue * @return */ public static byte[] int2ByteArrayLittle(int iValue)&#123; byte[] b = new byte[4]; for (int i = 0; i &lt; b.length; i++)&#123; b[i] = (byte)((iValue &gt;&gt; (8 * i)) &amp; 0xFF); &#125; return b; &#125; 断点调试 1234567int a = 257;byte[] bytes = ParseUtils.int2ByteArrayBig(a);byte[] bytes1 = ParseUtils.int2ByteArrayLittle(a);int i = ParseUtils.byteArray2BigInt(bytes);int i1 = ParseUtils.byteArray2LittleInt(bytes1); 工业报文 Java由于int 4个字节。很多工业数据都是16进制报文，用1个字节或者2个字节表示int。所以做此记录. 先上个工具类 1234567891011121314151617181920212223242526272829303132package com.ud.ruleengine.utils;import java.math.BigInteger;public class ParseUtils &#123; /** * 截取byte数组 * @param src * @param begin * @param count * @return * 小端，有符号 */ public static byte[] subBytes(byte[] src, int begin, int count) &#123; byte[] bs = new byte[count]; System.arraycopy(src, begin, bs, 0, count); return bs; &#125; /** * 字节数组转不同进制字符串 * @param bytes * @param radix * @return */ public static String binary(byte[] bytes, int radix)&#123; return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数 &#125;&#125; base64解析工具 123456789101112131415161718192021222324252627282930313233343536package com.ud.ruleengine.utils;import java.io.IOException;import java.util.Base64;public class Base64Encrypt &#123; static Base64.Decoder decoder = Base64.getDecoder(); static Base64.Encoder encoder = Base64.getEncoder(); /** * 编码 * * @param bstr * @return String */ public static String encode(byte[] bstr) &#123; return encoder.encodeToString(bstr); &#125; /** * 解码 * * @param str * @return string */ public static byte[] decode(String str) &#123; byte[] bt = null; try &#123; bt = decoder.decode(str); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bt; &#125;&#125; 假设6个字段分别是212212个字节，int值，那么我们的解析为： 12345678byte[] decode = Base64Encrypt.decode(data);String a1 = ParseUtils.binary(ParseUtils.subBytes(decode, 0, 2), 10);String a2 = ParseUtils.binary(ParseUtils.subBytes(decode,2,1), 10);String a3 = ParseUtils.binary(ParseUtils.subBytes(decode,3,2), 10);String a4 = ParseUtils.binary(ParseUtils.subBytes(decode,5,2), 10);String a5 = ParseUtils.binary(ParseUtils.subBytes(decode,7,1), 10);String a6 = ParseUtils.binary(ParseUtils.subBytes(decode,8,2), 10);","categories":[{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"报文","slug":"报文","permalink":"https://idea360.cn/tags/%E6%8A%A5%E6%96%87/"}]},{"title":"drupal8入门学习笔记","slug":"learn-drupal8","date":"2020-03-08T21:22:40.000Z","updated":"2021-02-23T14:35:44.608Z","comments":true,"path":"2020/03/09/learn-drupal8/","link":"","permalink":"https://idea360.cn/2020/03/09/learn-drupal8/","excerpt":"","text":"前言 Java转Drupal开发，有很多不习惯，非全面向对象开发。该博客首写于2017, 博客迁移, 仅做记录。 Drupal8渲染twig示例 在modules/custom建立test_twig文件夹(模块根目录) 模块结构： -css -----test.css -js -----test.js -src -----Controller --------TestTwigController.php -templates -----my-template.html.twig -test_twig.info.yml -test_twig.module -test_twig.routing.yml test_twig.info.yml 12345name: &quot;Test twig&quot;type: moduledescription: &quot;自定义模块自定义模板&quot;package: &quot;Example modules&quot;core: 8.x test_twig.module 1234567891011121314151617181920212223&lt;?php/** * @param $existing * @param $type * @param $theme * @param $path * * @return array * * my_element 模板名 * test_var 参数名 */function test_twig_theme($existing, $type, $theme, $path) &#123; return [ &#x27;my_template&#x27; =&gt; [ &#x27;variables&#x27; =&gt; [&#x27;test_var&#x27; =&gt; NULL,&#x27;test_var1&#x27; =&gt; NULL], ], ]; return $theme;&#125; test_twig.routing.yml 123456test_twig_test: path: &#x27;test_twig/test&#x27; defaults: _controller: &#x27;\\Drupal\\test_twig\\Controller\\TestTwigController::content&#x27; requirements: _access: &#x27;TRUE&#x27; test.css 123.acme-hello-text &#123; background-color: #dedede;&#125; TestTwigController.php 123456789101112131415161718&lt;?phpnamespace Drupal\\test_twig\\Controller;use Drupal\\Core\\Controller\\ControllerBase;class TestTwigController extends ControllerBase &#123; public function content() &#123; return [ &#x27;#theme&#x27; =&gt; &#x27;my_template&#x27;, &#x27;#test_var&#x27; =&gt; $this-&gt;t(&#x27;Test Value7&#x27;), &quot;#test_var1&quot; =&gt; $this-&gt;t(&quot;Test Value1&quot;) ]; &#125;&#125; my-template.html.twig 1234&lt;p&gt;Test twig template!&lt;/p&gt;&lt;p&gt;test_var: &#123;&#123; test_var &#125;&#125;&lt;/p&gt;&lt;p&gt;test_var1: &#123;&#123; test_var1 &#125;&#125;&lt;/p&gt;t Twig渲染表单 结构目录同1,创建test_form模块 test_form.info.yml 12345name: &#x27;test_form&#x27;type: moduledescription: &#x27;表单twig&#x27;package: &quot;Example modules&quot;core: 8.x test_form.routing.yml 1234567test_form.test: path: &#x27;test_form/test&#x27; defaults: _form: &#x27;\\Drupal\\test_form\\Form\\TestForm&#x27; _title: &#x27;Twig form&#x27; requirements: _permission: &#x27;access content&#x27; test_form.module 123456789&lt;?phpfunction test_form_theme() &#123; return [ &#x27;test_form&#x27; =&gt; [ &#x27;render element&#x27; =&gt; &#x27;form&#x27;, ], ];&#125; test_form.libraries.yml 123456789101112sample_library: css: # For some reason, you need to put css under &#x27;theme&#x27;. theme: css/example.css: &#123;&#125; dependencies: # jQuery is not included by default, so we add it as a dependency - core/jquery # We are also going to use jQuery.once so that code doesn&#x27;t trigger multiple times. - core/jquery.once # drupal and drupalSettings are not included by default either. - core/drupal 在src/Form下创建TestForm.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?phpnamespace Drupal\\test_form\\Form;use Drupal\\Core\\Form\\FormBase;use Drupal\\Core\\Form\\FormStateInterface;class TestForm extends FormBase&#123; /** * Returns a unique string identifying the form. * * @return string * The unique string identifying the form. */ public function getFormId() &#123; return &quot;test_form&quot;; &#125; /** * Form constructor. * * @param array $form * An associative array containing the structure of the form. * @param \\Drupal\\Core\\Form\\FormStateInterface $form_state * The current state of the form. * * @return array * The form structure. */ public function buildForm(array $form, FormStateInterface $form_state) &#123; $form[&#x27;#attributes&#x27;] = array(&#x27;class&#x27; =&gt; &#x27;editForm editForm-thread&#x27;); $form[&#x27;postfeed_reply_Message&#x27;] = array( &#x27;#type&#x27; =&gt; &#x27;textarea&#x27;, &#x27;#title&#x27; =&gt; t(&#x27;&#x27;), &#x27;#required&#x27; =&gt; TRUE, &#x27;#attributes&#x27; =&gt; array(&#x27;placeholder&#x27; =&gt; $this-&gt;t(&#x27;postfeed_reply_Message&#x27;) ) ); $form[&#x27;first_name&#x27;] = array( &#x27;#type&#x27; =&gt; &#x27;textfield&#x27;, &#x27;#title&#x27; =&gt; $this-&gt;t(&#x27;First Name&#x27;), &#x27;#default_value&#x27; =&gt; $this-&gt;t(&#x27;default_value&#x27;), &#x27;#required&#x27; =&gt; TRUE, ); $form[&#x27;last_name&#x27;] = array( &#x27;#type&#x27; =&gt; &#x27;textfield&#x27;, &#x27;#title&#x27; =&gt; t(&#x27;Last Name&#x27;), &#x27;#default_value&#x27; =&gt; $this-&gt;t(&#x27;刘德华&#x27;), &#x27;#required&#x27; =&gt; TRUE, ); $form[&#x27;metier&#x27;] = array( &#x27;#type&#x27; =&gt; &#x27;search&#x27;, &#x27;#title&#x27; =&gt; $this-&gt;t(&#x27;metier-title&#x27;), &#x27;#default_value&#x27; =&gt; &#x27;&#x27;, &#x27;#placeholder&#x27;=&gt;&#x27;metier提示&#x27;, &#x27;#attributes&#x27; =&gt; array(&#x27;title&#x27; =&gt; $this-&gt;t(&#x27;att-metierr&#x27;)), ); $form[&#x27;position&#x27;] = array( &#x27;#type&#x27; =&gt; &#x27;search&#x27;, &#x27;#title&#x27; =&gt; $this-&gt;t(&#x27;position-title&#x27;), &#x27;#placeholder&#x27;=&gt;&#x27;position提示&#x27;, &#x27;#attributes&#x27; =&gt; array(&#x27;title&#x27; =&gt; $this-&gt;t(&#x27;att-position&#x27;)), ); $form[&#x27;submit_btn&#x27;] = array( &#x27;#type&#x27; =&gt; &#x27;submit&#x27;, &#x27;#value&#x27; =&gt; $this-&gt;t(&#x27;Submit&#x27;), ); // 添加样式 $form[&#x27;#attached&#x27;] = [ &#x27;library&#x27; =&gt; [ &#x27;test_form/sample_library&#x27;, ], ]; $form[&#x27;#theme&#x27;] = &#x27;test_form&#x27;; return $form; &#125; /** * Form submission handler. * * @param array $form * An associative array containing the structure of the form. * @param \\Drupal\\Core\\Form\\FormStateInterface $form_state * The current state of the form. */ public function submitForm(array &amp;$form, FormStateInterface $form_state) &#123; // TODO: Implement submitForm() method. &#125;&#125; templates/test-form.html.twig 123456789101112131415161718&lt;div class=&quot;row&quot;&gt; &lt;h1&gt;测试Twig&lt;/h1&gt; &#123;&#123; form.postfeed_reply_Message &#125;&#125; &lt;form method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;First Name&lt;/label&gt; &lt;div class=&quot;input-group&quot;&gt; &#123;&#123;form.first_name&#125;&#125; &#123;&#123; form.last_name &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group test&quot;&gt; &#123;&#123; form.submit_btn &#125;&#125; &#123;# btn btn-default #&#125; &lt;/div&gt; &lt;div class=&quot;col-md-12 myElement&quot;&gt;&#123;&#123; form.metier &#125;&#125;&lt;/div&gt; &lt;div class=&quot;col-md-12&quot;&gt;&#123;&#123; form.position &#125;&#125;&lt;/div&gt; &lt;/form&gt;&lt;/div&gt;","categories":[{"name":"php","slug":"php","permalink":"https://idea360.cn/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://idea360.cn/tags/php/"},{"name":"drupal","slug":"drupal","permalink":"https://idea360.cn/tags/drupal/"}]},{"title":"阿里nodejs框架egg-js入门教程","slug":"learn-egg-js","date":"2020-03-08T21:00:34.000Z","updated":"2021-02-23T14:36:01.741Z","comments":true,"path":"2020/03/09/learn-egg-js/","link":"","permalink":"https://idea360.cn/2020/03/09/learn-egg-js/","excerpt":"","text":"一、前言 nodejs作为轻量级的web框架，在一些小项目上有着生态丰富, 开发快, 易运维的绝对优势。本篇博客是对阿里egg.js框架的学习记录, 最初写于2018年,更多特性请关注官网。 二、初始化 我们推荐直接使用脚手架，只需几条简单指令，即可快速生成项目: 1234$ npm i egg-init -g$ egg-init egg-learn --type=simple$ cd egg-learn$ npm i 启动项目 npm run dev , 然后用webstorm导入项目 三、项目搭建 框架提供了 egg-mysql 插件来访问 MySQL 数据库。这个插件既可以访问普通的 MySQL 数据库，也可以访问基于 MySQL 协议的在线数据库服务。 安装与配置 安装对应的插件 egg-mysql ： 1npm i --save egg-mysql 开启插件： 12345// config/plugin.jsexports.mysql = &#123; enable: true, package: &#x27;egg-mysql&#x27;,&#125;; 单数据源 1234567891011121314151617181920// config/config.$&#123;env&#125;.jsconfig.mysql = &#123; // 单数据库信息配置 client: &#123; // host host: &#x27;localhost&#x27;, // 端口号 port: &#x27;3306&#x27;, // 用户名 user: &#x27;root&#x27;, // 密码 password: &#x27;root&#x27;, // 数据库名 database: &#x27;test&#x27;, &#125;, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false,&#125;; 创建数据库文件 初始化表 123456789101112131415161718192021&#x2F;* Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50717 Source Host : localhost Source Database : test Target Server Type : MySQL Target Server Version : 50717 File Encoding : utf-8 Date: 01&#x2F;19&#x2F;2018 10:44:32 AM*&#x2F;DROP TABLE IF EXISTS &#96;egg_user&#96;;CREATE TABLE &#96;egg_user&#96; ( &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;用户id&#39;, &#96;name&#96; varchar(32) DEFAULT NULL COMMENT &#39;用户名&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;用户表&#39;; Service层 由于对 MySQL 数据库的访问操作属于 Web 层中的数据处理层，因此我们强烈建议将这部分代码放在 Service 层中维护。 下面是一个 Service 中访问 MySQL 数据库的例子。 12345678910111213141516171819// app/service/index.jsconst Service = require(&quot;egg&quot;).Service;class IndexService extends Service&#123; //插入数据 async insert()&#123; const result = await this.app.mysql.insert(&quot;egg_user&quot;,&#123;name:&quot;admin&quot;&#125;); return &#123;result&#125;; &#125; //查询数据 async find()&#123; const result = await this.app.mysql.get(&quot;egg_user&quot;,&#123;id:1&#125;); return &#123;result&#125;; &#125;&#125;module.exports = IndexService; Controller层 123456789101112131415161718192021// app/controller/index.jsconst Controller = require(&quot;egg&quot;).Controller;class IndexController extends Controller&#123; async insert()&#123; console.log(&quot;插入数据&quot;); const ctx = this.ctx; const result = await ctx.service.index.insert(); ctx.body = result; &#125; async find()&#123; console.log(&quot;查询数据&quot;); const ctx = this.ctx; const result = await ctx.service.index.find(); ctx.body = result; &#125;&#125;module.exports = IndexController; 路由配置 1234567// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get(&#x27;/&#x27;, controller.home.index); router.get(&#x27;/insert&#x27;, controller.index.insert); router.get(&#x27;/find&#x27;, controller.index.find);&#125;; 启动项目即可测试 四、中间件 中间件支持以下几种方式： 在应用中使用中间件、 在框架和插件中使用中间件、 在路由中使用中间件 我们只介绍在路由中使用中间件,只需对路由文件改造即可： 123456789module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; const logger = app.middleware.logger(); router.get(&#x27;/&#x27;, logger, controller.home.index); router.get(&#x27;/insert&#x27;, logger, controller.index.insert); router.get(&#x27;/find&#x27;, logger, controller.index.find);&#125;; 中间件文件如下： 12345678//app/middleware/logger.jsmodule.exports = options =&gt; &#123; return async function logger(ctx,next) &#123; console.log(&quot;中间件in&quot;); await next(); console.log(&quot;中间件out&quot;); &#125;;&#125;; 五、模板 框架内置 egg-view 作为模板解决方案，并支持多模板渲染，每个模板引擎都以插件的方式引入，但保持渲染的 API 一致。 以下以官方支持的 View 插件 egg-view-nunjucks 为例 引入view插件 1npm i egg-view-nunjucks --save 启用插件 12345// config/plugin.jsexports.nunjucks = &#123; enable: true, package: &#x27;egg-view-nunjucks&#x27;,&#125;; 配置插件 123456config.view = &#123; defaultViewEngine: &#x27;nunjucks&#x27;, mapping: &#123; &#x27;.html&#x27;: &#x27;nunjucks&#x27;, &#125;,&#125;; 创建模板 123456789101112131415//app/view/index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h2&gt;欢迎您 &#123;&#123;result.name&#125;&#125;&lt;/h2&gt;a &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Controller 123456async indexView()&#123; console.log(&quot;渲染模板&quot;); const ctx = this.ctx; const result = await ctx.service.index.find(); await ctx.render(&quot;index.html&quot;,result);&#125; 路由 1router.get(&#x27;/view&#x27;, logger, controller.index.indexView);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://idea360.cn/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://idea360.cn/tags/nodejs/"},{"name":"js","slug":"js","permalink":"https://idea360.cn/tags/js/"},{"name":"egg","slug":"egg","permalink":"https://idea360.cn/tags/egg/"}]},{"title":"如何用Nodejs快速搭建一个调试工具","slug":"how-to-maketools-by-nodejs","date":"2020-03-08T20:44:26.000Z","updated":"2020-03-15T03:53:36.960Z","comments":true,"path":"2020/03/09/how-to-maketools-by-nodejs/","link":"","permalink":"https://idea360.cn/2020/03/09/how-to-maketools-by-nodejs/","excerpt":"","text":"一、前言 很多时候，我们需要进行一些功能的调试，比如MQTT，比如某个功能脚本，或者是物联网场景下联调测试。这个时候苦于没有趁手的工具，花时间写个测试程序又觉得不值当(对于一个Java项目来说)，所以本篇博客教大家用nodejs进行快速调试。 既然选择nodejs，js脚本不是更简单吗？no、no、no，我们主要是想借用npm丰富的生态。 二、案例演示 首先我们通过express脚手架快速搭建一个项目，或者init一个空项目； 创建一个文件夹，里边就是我们的脚本文件； 这里假设我们的场景是MQTT接收消息并存入数据库(6字段字节数分别为212212); 执行 node mqtt.js 即可进行测试。 测试代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var mqtt = require(&#x27;mqtt&#x27;);var Sequelize = require(&#x27;sequelize&#x27;);var sequelize = new Sequelize(&#x27;iot&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, &#123; host: &#x27;127.0.0.1&#x27;, dialect: &#x27;mysql&#x27;, timezone:&#x27;+08:00&#x27;, pool: &#123; max: 5, min: 0, idle: 10000 &#125; &#125;)var SmallU = sequelize.define(&#x27;table1&#x27;, &#123; id: &#123; type: Sequelize.INTEGER, allowNull: false, autoIncrement: true, primaryKey: true &#125;, deviceName:&#123; type: Sequelize.STRING, field:&#x27;device_name&#x27;, comment:&quot;设备id&quot; &#125;, temperature: &#123; type: Sequelize.DOUBLE, comment:&quot;温度&quot; &#125;, humidity: &#123; type: Sequelize.DOUBLE, allowNull: false, comment: &quot;湿度&quot; &#125;, pm25: &#123; type: Sequelize.DOUBLE, allowNull: false, comment: &quot;PM2.5&quot; &#125;, formaldehyde: &#123; type: Sequelize.DOUBLE, allowNull: false, comment: &quot;甲醛&quot; &#125;, batteryLevel: &#123; type: Sequelize.STRING, field:&quot;battery_level&quot;, comment:&quot;电池电量&quot; &#125;, counter: &#123; type: Sequelize.INTEGER, comment:&quot;计数&quot; &#125;&#125;, &#123; underscored: true,//驼峰式 freezeTableName: true, // paranoid: true // tableName: &#x27;user_less_add&#x27;&#125;);sequelize.sync(&#123;force: false&#125;)//MQTTvar client = mqtt.connect(&#123;port: 8883, host: &#x27;127.0.0.1&#x27;, keepalive: 60&#125;);let topic = &#x27;application/7/node/+/rx&#x27;;client.subscribe(topic);client.on(&#x27;message&#x27;, function (topic, message, puback) &#123; var data = JSON.parse(message.toString()); console.log(&quot;========开始=====&quot;); console.log(data); console.log(&quot;========结束====&quot;); const deviceName = data.deviceName; var rowData = Buffer(data.data, &#x27;base64&#x27;) var temperature = parseInt(rowData.subarray(0,2).toString(&#x27;hex&#x27;),16)/10; //温度 var humidity = parseInt(rowData.subarray(2,3).toString(&#x27;hex&#x27;),16); //湿度 var pm25 = parseInt(rowData.subarray(3,5).toString(&#x27;hex&#x27;),16); //PM2.5 var formaldehyde = parseInt(rowData.subarray(5,7).toString(&#x27;hex&#x27;),16)/1000; //甲醛 var batteryLevel = parseInt(rowData.subarray(7,8).toString(&#x27;hex&#x27;),16); //电池电量 var counter = parseInt(rowData.subarray(8,10).toString(&#x27;hex&#x27;),16); //计数 SmallU.create(&#123; deviceName:deviceName, temperature:temperature, humidity:humidity, pm25:pm25, formaldehyde:formaldehyde, batteryLevel:batteryLevel, counter:counter &#125;)&#125;); 三、最后 本篇博客仅作为工具类进行记录。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://idea360.cn/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://idea360.cn/tags/nodejs/"}]},{"title":"【Spring源码解析】组件注册-@Import注解","slug":"spring-source-code-import","date":"2020-03-08T15:38:57.000Z","updated":"2021-03-08T16:03:11.919Z","comments":true,"path":"2020/03/08/spring-source-code-import/","link":"","permalink":"https://idea360.cn/2020/03/08/spring-source-code-import/","excerpt":"","text":"@Import注解 @Import 注解支持导入普通 java 类，并将其声明成一个bean。主要用于将多个分散的 java config 配置类融合成一个更大的 config 类。 @Import 三种使用方式 直接导入普通的 Java 类。 配合自定义的 ImportSelector 使用。 配合 ImportBeanDefinitionRegistrar 使用。 Configuration方式 创建一个普通类 12345public class Hi &#123; public void sayHello() &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 创建一个配置类，里面没有显式声明任何的 Bean，然后将刚才创建的 Hi 导入 1234@Import(Hi.class)@Configurationpublic class HiConfig &#123;&#125; 创建controller 12345678910111213141516@RestControllerpublic class HiController &#123; @Autowired Hi hi; /** * http://localhost:7777/hi * 输出 Hello World * @return */ @GetMapping(&quot;/hi&quot;) public Object hi() &#123; hi.sayHello(); return &quot;hi&quot;; &#125;&#125; annotation方式 创建EnableHiConfig 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;Hi.class&#125;)public @interface EnableHiConfig &#123;&#125; 在application中加入注解@EnableHiConfig然后controller中即可调用 1234567@EnableHiConfig@SpringBootApplicationpublic class IdcMpApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(IdcMpApplication.class, args); &#125;&#125; ImportSelector 如果定义太多注解,那么在main方法上要添加太多注解…因此使用ImportSelector ImportSelector 是一个接口，该接口中只有一个 selectImports 方法，用于返回全类名数组。所以利用该特性我们可以给容器动态导入 N 个 Bean。 因为这两个bean都是通过@Enable类型注解来将配置类注册到IOC容器中，所以我们现在要做的就是将这两个bean一次性都注册到IOC容器中。在Spring中，要将多个类进行注册，可以使用selector的方式。 创建HiSelector 12345678public class HiSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; return new String[]&#123; Hi.class.getName() &#125;; &#125;&#125; 创建EnableHiConfig 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;HiSelector.class&#125;)public @interface EnableHiConfig &#123;&#125; 在application中加入注解@EnableHiConfig然后controller中即可调用 IOC IOC是一种编程思想, 由主动的编程改成被动的接收。 所谓IOC一句话搞定, 对象由spring来创建、管理、装配。 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"程序员如何用Markdown快速输出技术博客?","slug":"how-to-fuck-markdown","date":"2020-03-08T03:31:33.000Z","updated":"2021-02-23T14:19:29.257Z","comments":true,"path":"2020/03/08/how-to-fuck-markdown/","link":"","permalink":"https://idea360.cn/2020/03/08/how-to-fuck-markdown/","excerpt":"","text":"一、前言 最近受疫情影响宅在家里,决定重新开始写博客。做过微信公众号的朋友们知道,微信采用富文本编辑器,就像word排版,想做出绚丽的效果那是相当的难。于是想到了用 Markdown 编辑,渲染富文本的思路,这样可以添加不同的皮肤,输出我们想要的风格。 最初的选型是 Typore 这款神器, 但用着还是优点水土不服的感觉。内心更加倾向与 SegmentFault 和 掘金 相似的风格, 思来想去还是决定用 Sublime Text 加原生的语法来写。本篇文章作为工具篇记录如何用 Markdown 编辑技术文章。 二、基础语法 1. 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 2. 列表 有序列表 1. 有序列表 2. 有序列表 无序列表 * 无序列表 - 无序列表 + 无序列表 注意，有序列表和无序列表中间都有一个空格。 3. 字体 *斜体* **加粗** ***斜体加粗*** ~~删除线~~ 4. 图片 ![图片说明, 可以不填](图片链接) 5. 超链接 [链接文字](超链接) &lt;https://idea360.cn&gt; 6. 引用 &gt; 引用内容 7. 代码 单行代码 `单行代码` 代码块 8. 表格 | h1 | h2 | h3 | |-------|-------|-------| | data1 | data2 | data3 | 9. 任务 - [ ] Eat + [x] Code 10. 目录 自动生成目录 [TOC] 手动目录 - [前言](#前言) - [基础语法](#基础语法) - [标题](#一、标题) 三、上下角标 key&lt;sub&gt;1&lt;/sub&gt; key&lt;sup&gt;2&lt;/sup&gt; 四、数学公式 $a_&#123;1&#125;$ $x^&#123;2&#125;$ $a^&#123;3&#125;_&#123;2&#125;$ $\\log_d ((N+1)/2)$ $e^&#123;x^2&#125; \\neq &#123;e^x&#125;^2$ $\\sqrt&#123;x&#125;$ $\\sqrt[3]&#123;4&#125;$ $\\frac&#123;x+y&#125;&#123;2&#125;$ $\\sum_&#123;k=1&#125;^n\\frac&#123;1&#125;&#123;k&#125;$ $\\int_a^b f(x)dx$ 五、流程 横向流程图 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a&#x3D;1| D[结果1] C --&gt;|a&#x3D;2| E[结果2] F[横向流程图] 竖向流程图 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a&#x3D;1| D[结果1] C --&gt; |a&#x3D;2| E[结果2] F[竖向流程图] 标准流程图 123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 横向标准流程图 123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 时序图 UML时序图 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ UML时序图复杂样例 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 UML标准时序图 12345678910111213%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 participant 王五 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 甘特图 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h UML类图 123456789101112131415161718192021classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125; 饼状图 1234pie title Pets adopted by volunteers &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 15 最后 本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。","categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://idea360.cn/tags/markdown/"}]},{"title":"Java面试必问之Hashmap底层实现原理(JDK1.8)","slug":"java-interview-hashmap-version8","date":"2020-03-06T17:42:19.000Z","updated":"2021-02-23T14:24:27.401Z","comments":true,"path":"2020/03/07/java-interview-hashmap-version8/","link":"","permalink":"https://idea360.cn/2020/03/07/java-interview-hashmap-version8/","excerpt":"","text":"1. 前言 上一篇从源码方面了解了JDK1.7中Hashmap的实现原理，可以看到其源码相对还是比较简单的。本篇笔者和大家一起学习下JDK1.8下Hashmap的实现。JDK1.8中对Hashmap做了以下改动。 默认初始化容量=0 引入红黑树，优化数据结构 将链表头插法改为尾插法，解决1.7中多线程循环链表的bug 优化hash算法 resize计算索引位置的算法改进 先插入后扩容 2. Hashmap中put()过程 笔者的源码是OpenJDK1.8的源码。 JDK1.8中，Hashmap将基本元素由Entry换成了Node，不过查看源码后发现换汤不换药，这里没啥好说的。 下图是一位大神级别画的图，自己就不再造轮子了。客官请看 put()源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 判断数组是否为空，长度是否为0，是则进行扩容数组初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 通过hash算法找到数组下标得到数组元素，为空则新建 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 找到数组元素，hash相等同时key相等，则直接覆盖 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 该数组元素在链表长度&gt;8后形成红黑树结构的对象,p为树结构已存在的对象 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 该数组元素hash相等，key不等，同时链表长度&lt;8.进行遍历寻找元素，有就覆盖无则新建 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 新建链表中数据元素，尾插法 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度&gt;=8 结构转为 红黑树 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 新值覆盖旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // onlyIfAbsent默认false if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 判断是否需要扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 基本过程如下: 检查数组是否为空，执行resize()扩充；在实例化HashMap时，并不会进行初始化数组） 通过hash值计算数组索引，获取该索引位的首节点。 如果首节点为null（没发生碰撞），则创建新的数组元素，直接添加节点到该索引位(bucket)。 如果首节点不为null（发生碰撞），那么有3种情况 ① key和首节点的key相同，覆盖old value（保证key的唯一性）；否则执行②或③ ② 如果首节点是红黑树节点（TreeNode），将键值对添加到红黑树。 ③ 如果首节点是链表，进行遍历寻找元素，有就覆盖无则新建，将键值对添加到链表。添加之后会判断链表长度是否到达TREEIFY_THRESHOLD - 1这个阈值，“尝试”将链表转换成红黑树。 最后判断当前元素个数是否大于threshold，扩充数组。 3. Hashmap中get()过程 12345678910111213141516171819202122232425public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 永远检查第一个node if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) // 树查找 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; // 遍历链表 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 在Hashmap1.8中，无论是存元素还是取元素，都是优先判断bucket上第一个元素是否匹配，而在1.7中则是直接遍历查找。 基本过程如下: 根据key计算hash; 检查数组是否为空，为空返回null; 根据hash计算bucket位置，如果bucket第一个元素是目标元素，直接返回。否则执行4; 如果bucket上元素大于1并且是树结构，则执行树查找。否则执行5; 如果是链表结构，则遍历寻找目标 4. Hashmap中resize()过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 如果已达到最大容量不在扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 通过位运算扩容到原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 新的扩容临界值 threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果该位置元素没有next节点，将该元素放入新数组 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 树节点 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 链表节点。 // lo串的新索引位置与原先相同 Node&lt;K,V&gt; loHead = null, loTail = null; // hi串的新索引位置为[原先位置j+oldCap] Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引，oldCap是2的n次方，二进制表示只有一个1，其余是0 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else // 尾插法 loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 根据hash判断该bucket上的整个链表的index还是旧数组的index，还是index+oldCap if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; JDK1.8版本中扩容相对复杂。在1.7版本中，重新根据hash计算索引位置即可；而在1.8版本中分2种情况，下边用图例来解释。 5. 总结 其余还有为什么阈值=8转红黑树，长度&lt;=6 转链表这些问题。基本都是数据科学家根据概率做出的经验值，同时避免数据结构频繁的转换引起的性能开销。 整体看来，JDK1.8主要在数据结构、算法和性能上对1.7进行了优化。 6. AD 欢迎大家关注公众号【当我遇上你】, 每天第一时间与您分享干货。","categories":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"hashmap","slug":"hashmap","permalink":"https://idea360.cn/tags/hashmap/"},{"name":"集合","slug":"集合","permalink":"https://idea360.cn/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java面试必问之Hashmap底层实现原理(JDK1.7)","slug":"java-interview-hashmap-version7","date":"2020-03-06T17:42:08.000Z","updated":"2021-02-23T14:24:21.571Z","comments":true,"path":"2020/03/07/java-interview-hashmap-version7/","link":"","permalink":"https://idea360.cn/2020/03/07/java-interview-hashmap-version7/","excerpt":"","text":"1. 前言 Hashmap可以说是Java面试必问的，一般的面试题会问: Hashmap有哪些特性？ Hashmap底层实现原理(get\\put\\resize) Hashmap怎么解决hash冲突？ Hashmap是线程安全的吗？ … 今天就从源码角度一探究竟。笔者的源码是OpenJDK1.7 2. 构造方法 首先看构造方法的源码 123456789101112131415// 默认初始容量static final int DEFAULT_INITIAL_CAPACITY = 16;// 默认负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 数组, 该数据不参与序列化transient Entry[] table; public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // 初始容量16，扩容因子0.75，扩容临界值12 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 基础结构为Entry数组 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init();&#125; 由以上源码可知，Hashmap的初始容量默认是16, 底层存储结构是数组(到这里只能看出是数组, 其实还有链表，下边看源码解释)。基本存储单元是Entry，那Entry是什么呢?我们接着看Entry相关源码， 1234567891011121314151617static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; // 链表后置节点 final int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; // 头插法: newEntry.next=e key = k; hash = h; &#125; ...&#125; 由Entry源码可知，Entry是链表结构。综上所述，可以得出: Hashmap底层是基于数组和链表实现的 3. Hashmap中put()过程 我已经将put过程绘制了流程图帮助大家理解 先上put源码 1234567891011121314151617181920212223public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); // 根据key计算hash int hash = hash(key.hashCode()); // 计算元素在数组中的位置 int i = indexFor(hash, table.length); // 遍历链表，如果相同覆盖 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 头插法插入元素 addEntry(hash, key, value, i); return null;&#125; 上图中多次提到头插法，啥是 头插法 呢？接下来看 addEntry 方法 12345678910void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 取出原bucket链表 Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); // 判断是否需要扩容 if (size++ &gt;= threshold) // 扩容好容量为原来的2倍 resize(2 * table.length);&#125; 结合Entry类的构造方法，每次插入新元素的时候，将bucket原链表取出，新元素的next指向原链表,这就是 头插法 。为了更加清晰的表示Hashmap存储结构，再绘制一张存储结构图。 4. Hashmap中get()过程 get()逻辑相对比较简单，如图所示 我们来对应下get()源码 12345678910111213141516public V get(Object key) &#123; // 获取key为null的值 if (key == null) return getForNullKey(); // 根据key获取hash int hash = hash(key.hashCode()); // 遍历链表，直到找到元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 5. Hashmap中resize()过程 只要是新插入元素，即执行addEntry()方法，在插入完成后，都会判断是否需要扩容。从addEntry()方法可知，扩容后的容量为原来的2倍。 12345678910111213141516void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建数组 Entry[] newTable = new Entry[newCapacity]; // 数据迁移 transfer(newTable); // table指向新的数组 table = newTable; // 新的扩容临界值 threshold = (int)(newCapacity * loadFactor);&#125; 这里有个transfer()方法没讲，别着急，扩容时线程安全的问题出现在这个方法中，接下来讲解数组复制过程。 6. Hashmap扩容安全问题 大家都知道结果: 多线程扩容有可能会形成环形链表，这里用图给大家模拟下扩容过程。 首先看下单线程扩容的头插法 然后看下多线程可能会出现的问题 以下是源码，你仔细品一品 12345678910111213141516171819202122void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; // 释放旧Entry数组的对象引用 src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; // 重新根据新的数组长度计算位置(同一个bucket上元素hash相等，所以扩容后必然还在一个链表上) int i = indexFor(e.hash, newCapacity); // 头插法(同一位置上新元素总会被放在链表的头部位置),将newTable[i]的引用赋给了e.next e.next = newTable[i]; // 将元素放在数组上 newTable[i] = e; // 访问下一个元素 e = next; &#125; while (e != null); &#125; &#125;&#125; 7. Hashmap寻找bucket位置 1234static int indexFor(int h, int length) &#123; // 根据hash与数组长度mod运算 return h &amp; (length-1);&#125; 由源码可知, jdk根据key的hash值和数组长度做mod运算，这里用位运算代替mod。 hash运算值是一个int整形值，在java中int占4个字节，32位，下边通过图示来说明位运算。 8. AD 如果您觉得还行，请关注公众号【当我遇上你】, 您的支持是我输出的最大动力。 同时，欢迎大家一起交流学习。","categories":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"hashmap","slug":"hashmap","permalink":"https://idea360.cn/tags/hashmap/"},{"name":"集合","slug":"集合","permalink":"https://idea360.cn/tags/%E9%9B%86%E5%90%88/"}]},{"title":"设计模式——单例","slug":"design-patterns-singleton","date":"2020-03-06T17:41:53.000Z","updated":"2021-02-23T14:15:28.190Z","comments":true,"path":"2020/03/07/design-patterns-singleton/","link":"","permalink":"https://idea360.cn/2020/03/07/design-patterns-singleton/","excerpt":"","text":"概述 单例模式(SingletonPattern)，保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式有 3 个特点： 单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点； 在很多比较大型的程序中，全局变量经常被用到。如果不用全局变量，那么在使用到的模块中，都需要用参数将全局变量传入，这是非常麻烦的。虽然要减少使用全局变量，但是如果需要，还是要用。单例模式就是对传统的全局的一种改进。单例可以做到延时实例化，即在需要的时候才进行实例化。针对一些大型的类，延时实例化是有好处的。 实现 饿汉式单例 123456789101112131415161718/** * 饿汉式单例 * 线程安全 */public class Singleton1 &#123; // jvm保证在任何线程访问instance静态变量之前一定先创建了此实例 private static Singleton1 instance = new Singleton1(); // 私有化构造方法，保证外界无法直接实例化 private Singleton1() &#123; &#125; // 提供全局访问点获取唯一的实例 public static Singleton1 getInstance() &#123; return instance; &#125;&#125; 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 场景：这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大，或单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了，这时候就需要用到懒汉模式进行延迟加载。 懒汉式单例 123456789101112131415161718192021222324252627282930/** * 双重检查单例(懒汉式) * 线程安全 * 单例实例在第一次使用时进行创建 */public class Singleton2 &#123; private volatile static Singleton2 instance = null; // 私有化构造函数 private Singleton2() &#123; &#125; public static Singleton2 getInstance() &#123; if (instance == null) &#123; // 多线程可达，可能存在A实例化释放锁后，阻塞在此的B获得同步锁，所以此处需要双重检测 synchronized (Singleton2.class) &#123; if (instance == null) &#123; // 此处的执行顺序期望如下: // 1. memory = allocate() 分配对象的内存空间 // 2. ctorInstance() 初始化对象 // 3. instance = memory 设置instance指向刚分配的内存 // 如果不用volatile修饰变量, 2、3指令可能重排，导致获取未初始化的对象 instance = new Singleton2(); &#125; &#125; &#125; return instance; &#125;&#125; 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁synchronized才能保证单例，(静态同步方法实现的懒汉式)加锁会影响效率。 登记式单例 123456789101112131415161718192021222324252627282930/** * 静态内部类单例(登记式、延迟加载) */public class Singleton3 &#123; private Singleton3() &#123; &#125; /** * 静态内部类 * 在第一次调用getInstance方法之前，SingletonWrapper类是没有被加载的，因为它是一个静态内部类。 * 当有线程第一次调用getInstance的时候，SingletonWrapper就会被class loader加载进JVM，在加载的同时，执行instance的初始化。 * 所以，这种写法，仍然是一种懒汉式的单例类。 */ private static class SingletonWrapper &#123; private static final Singleton3 instance = new Singleton3(); &#125; /** * 为什么这样写就是线程安全的呢？ * 因为类的加载的过程是单线程执行的。它的并发安全是由JVM保证的。 * 所以，这样写的好处是在instance初始化的过程中，由JVM的类加载机制保证了线程安全， * 而在初始化完成以后，不管后面多少次调用getInstance方法都不会再遇到锁的问题了。 * * @return */ public static Singleton3 getInstance() &#123; return SingletonWrapper.instance; &#125;&#125; 优点: 内部类只有在外部类被调用才加载，产生SINGLETON实例；又不用加锁。此模式有上述两个模式的优点，屏蔽了它们的缺点，是推荐的单例模式。 缺点: 在实例需要序列化的场景下，反射和序列化会破坏单例，这是懒汉式、饿汉式和登记式共同存在的缺陷。 枚举单例 123456789101112131415161718192021222324252627282930313233/** * 枚举单例 * 线程安全 */public class Singleton4 &#123; // 私有构造函数 private Singleton4() &#123; &#125; public static Singleton4 getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; // 枚举实例是static final类型的，也就表明只能被实例化一次。 // 在调用构造方法时，我们的单例被实例化 private enum Singleton &#123; INSTANCE; private Singleton4 singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new Singleton4(); &#125; public Singleton4 getInstance() &#123; return singleton; &#125; &#125;&#125; 枚举提供了序列化机制，推荐的最佳实现方式 反射和反序列化对单例的影响 通过反射来实例化类 1234567891011121314/** * 用反射来获得实例 */public class Singleton5 &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Class&lt;Singleton1&gt; clz = Singleton1.class; Constructor&lt;Singleton1&gt; constructor = clz.getDeclaredConstructor(); constructor.setAccessible(true); Singleton1 reflectInstance = constructor.newInstance(); Singleton1 instance = Singleton1.getInstance(); System.out.println(reflectInstance == instance); // false &#125;&#125; 结果输出false，说明reflectInstance和instance不是同一个对象。(==比较的是实例对象的内存地址) 通过反序列化来实例化类 123456789101112131415161718192021222324252627282930/** * 反序列化来获得实例 */public class Singleton6 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; // 单例(此处对单例进行修改，实现Serializable接口) Singleton1 singleton = Singleton1.getInstance(); // 序列化 FileOutputStream fos = new FileOutputStream(&quot;Singleton1.obj&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(singleton); oos.flush(); fos.close(); oos.close(); // 反序列化 FileInputStream fis = new FileInputStream(&quot;Singleton1.obj&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Singleton1 instance = (Singleton1) ois.readObject(); fis.close(); ois.close(); // 对比 System.out.println(singleton == instance); // false &#125;&#125; 结果输出false，说明singleton和instance指向不同对象。 如何避免单例被破坏 修改单例类，解决反序列化的问题 123456789101112131415161718192021222324/** * 饿汉式单例 * 线程安全 */public class Singleton1 implements Serializable &#123; // jvm保证在任何线程访问instance静态变量之前一定先创建了此实例 private static Singleton1 instance = new Singleton1(); // 私有化构造方法，保证外界无法直接实例化 private Singleton1() &#123; &#125; // 提供全局访问点获取唯一的实例 public static Singleton1 getInstance() &#123; return instance; &#125; //该方法在反序列化时会被调用，该方法不是接口定义的方法，有点儿约定俗成的感觉 protected Object readResolve() throws ObjectStreamException &#123; System.out.println(&quot;调用了readResolve方法！&quot;); return instance; &#125;&#125; 结果输出 12调用了readResolve方法！true 应用场景 单例模式可以避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间。有以下场景的特点即可使用单例。 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如数据库的连接池、zK分布式锁、工具类等。 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例","slug":"单例","permalink":"https://idea360.cn/tags/%E5%8D%95%E4%BE%8B/"}]},{"title":"设计模式——概述","slug":"design-patterns-overview","date":"2020-03-06T17:41:43.000Z","updated":"2021-02-23T14:15:21.407Z","comments":true,"path":"2020/03/07/design-patterns-overview/","link":"","permalink":"https://idea360.cn/2020/03/07/design-patterns-overview/","excerpt":"","text":"写在前边 《庚子年记》 以前总是听说: 今年是经济形势最差的一年，各企业都准备过冬。没想到2020仅一个月就打败了最难过的2019。 笔者于2019年底裸辞，原计划2020春招再工作，怎耐遇上了武汉疫情。举国闭门谢客，当然也包括往日的金三银四。各大小企业纷纷缩减开支，立求生存下去，求职市场略显惨淡。值此之际，获得了难得的学习时间，想趁着自由的时光巩固下知识，打牢基本功。 回首以前做过的项目，愈发频繁地觉得自己写的代码不够优雅，遂决定研读一下设计模式相关。在很多场景大家力求破，不破不立。但在软件上，个人觉得立更重要: 约定大于配置。要立规范，要遵守范式，要引入设计模式等。遂重新开始学习、总结。一是为日后自己回顾总结，二是供同样初入设计模式大门的程序员们参考学习。作者水平有限，文中若有错漏之处，还望不吝指出。 设计原则 1. 开闭原则 开闭原则的意思是：对扩展开放，对修改关闭。程序应该通过扩展来实现变化，而不是通过修改已有代码来实现一个扩展和变化。简言之，是为了使程序的扩展性好，易于维护和升级。 2. 里氏替换原则 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3. 依赖倒置原则 1、高层模块不应该依赖低层模块，两者都应该依赖其抽象； 2、抽象不应该依赖细节； 3、细节应该依赖抽象。 4. 接口隔离原则 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 也就是仅仅需要提供客户端需要的接口，其实就是客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上，就比如说你有一个抽象类里面有很多接口，也就是说防止一个抽象类中汇总了很多的抽象方法，而要分开来其实就是一个接口的隔离。根据我们的需求去实现该实现的方法，不去实现其他方法，其实就是接口隔离原则。 5. 迪米特法则 又称最少知道原则。如果两个类不必彼此直接通讯，那么这两个类就不应该直接发生作用。这就要求我们在设计类的时候，尽量降低类的成员的访问权限。它的根本思想其实也是松耦合。 6. 单一职责原则 尽量使用对象组合，而不是继承来达到复用的目的。这样可以降低类与类之间的耦合度 模式分类 设计模式根据目的可以分为三大类，分别是创建型设计模式、行为型设计模式以及结构型设计模式。 创建型模式涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解藕。 行为型模式涉及到类和对象如何交互及分配职责。 结构型模式可以让你把类或对象组合到更大的结构中。 创建型设计模式 单例模式(Singleton) 构建模式(Builder) 原型模式(Prototype) 抽象工厂模式(Abstract Factory) 工厂方法模式(Factory Method) 行为设计模式 策略模式(Strategy) 状态模式(State) 责任链模式(Chain of Responsibility) 解释器模式(Interpreter) 命令模式(Command) 观察者模式(Observer) 备忘录模式(Memento) 迭代器模式(Iterator) 模板方法模式(Template Method) 访问者模式(Visitor) 中介者模式(Mediator) 结构型设计模式 装饰者模式(Decorator) 代理模式(Proxy) 组合模式(Composite) 桥连接模式(Bridge) 适配器模式(Adapter) 享元模式(Flyweight) 外观模式(Facade)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"通过乐观锁解决库存超卖的问题","slug":"stock-unsafe-optimistic-lock","date":"2020-03-06T17:41:28.000Z","updated":"2021-02-23T14:48:48.573Z","comments":true,"path":"2020/03/07/stock-unsafe-optimistic-lock/","link":"","permalink":"https://idea360.cn/2020/03/07/stock-unsafe-optimistic-lock/","excerpt":"","text":"前言 在通过多线程来解决高并发的问题上，线程安全往往是最先需要考虑的问题，其次才是性能。库存超卖问题是有很多种技术解决方案的，比如悲观锁，分布式锁，乐观锁，队列串行化，Redis原子操作等。本篇通过MySQL乐观锁来演示基本实现。 开发前准备 1. 环境参数 开发工具：IDEA 基础工具：Maven+JDK8 所用技术：SpringBoot+Mybatis 数据库：MySQL5.7 SpringBoot版本：2.2.5.RELEASE 2. 创建数据库 基本的scheme已建好，演示就拿最简单的数据结构最好不过了。 12345678910111213141516171819DROP TABLE IF EXISTS &#96;goods&#96;;CREATE TABLE &#96;goods&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;商品id&#39;, &#96;name&#96; varchar(30) DEFAULT NULL COMMENT &#39;商品名称&#39;, &#96;stock&#96; int(11) DEFAULT &#39;0&#39; COMMENT &#39;商品库存&#39;, &#96;version&#96; int(11) DEFAULT &#39;0&#39; COMMENT &#39;并发版本控制&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT &#39;商品表&#39;;INSERT INTO &#96;goods&#96; VALUES (1, &#39;iphone&#39;, 10, 0);INSERT INTO &#96;goods&#96; VALUES (2, &#39;huawei&#39;, 10, 0);DROP TABLE IF EXISTS &#96;order&#96;;CREATE TABLE &#96;order&#96; ( &#96;id&#96; int(11) AUTO_INCREMENT, &#96;uid&#96; int(11) COMMENT &#39;用户id&#39;, &#96;gid&#96; int(11) COMMENT &#39;商品id&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT &#39;订单表&#39;; 没有环境的小伙伴可以通过Docker实战之MySQL主从复制，快速的进行MySQL环境的搭建。创建数据库test,然后导入相关的sql初始化Table。 3. 配置 pom 文件中的相关依赖 下边是pom.xml依赖配置。 12345678910111213141516171819202122232425262728293031&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 4. 配置 application.yml 由于演示中MyBatis基于接口映射，配置简单。application.yml中只需要配置mysql相关即可 1234567spring: datasource: type: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3307/test?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: root 5. 创建相关Bean 1234567891011package com.idcmind.ants.entity;public class Goods &#123; private int id; private String name; private int stock; private int version; ... 此处省略getter、setter以及 toString方法&#125; 12345678public class Order &#123; private int id; private int uid; private int gid; ... 此处省略getter、setter以及 toString方法&#125; 乐观锁解决库存超卖方案 1. Dao层开发 GoodsDao.java 1234567891011121314151617181920@Mapperpublic interface GoodsDao &#123; /** * 查询商品库存 * @param id 商品id * @return */ @Select(&quot;SELECT * FROM goods WHERE id = #&#123;id&#125;&quot;) Goods getStock(@Param(&quot;id&quot;) int id); /** * 乐观锁方案扣减库存 * @param id 商品id * @param version 版本号 * @return */ @Update(&quot;UPDATE goods SET stock = stock - 1, version = version + 1 WHERE id = #&#123;id&#125; AND stock &gt; 0 AND version = #&#123;version&#125;&quot;) int decreaseStockForVersion(@Param(&quot;id&quot;) int id, @Param(&quot;version&quot;) int version);&#125; OrderDao.java 这里需要特别注意，由于order是sql中的关键字，所以表名需要加上反引号。 123456789101112@Mapperpublic interface OrderDao &#123; /** * 插入订单 * 注意: order表是关键字，需要`order` * @param order */ @Insert(&quot;INSERT INTO `order` (uid, gid) VALUES (#&#123;uid&#125;, #&#123;gid&#125;)&quot;) @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;) int insertOrder(Order order);&#125; 2. Service层开发 GoodsService.java 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class GoodsService &#123; @Autowired private GoodsDao goodsDao; @Autowired private OrderDao orderDao; /** * 扣减库存 * @param gid 商品id * @param uid 用户id * @return SUCCESS 1 FAILURE 0 */ @Transactional public int sellGoods(int gid, int uid) &#123; // 获取库存 Goods goods = goodsDao.getStock(gid); if (goods.getStock() &gt; 0) &#123; // 乐观锁更新库存 int update = goodsDao.decreaseStockForVersion(gid, goods.getVersion()); // 更新失败，说明其他线程已经修改过数据，本次扣减库存失败，可以重试一定次数或者返回 if (update == 0) &#123; return 0; &#125; // 库存扣减成功，生成订单 Order order = new Order(); order.setUid(uid); order.setGid(gid); int result = orderDao.insertOrder(order); return result; &#125; // 失败返回 return 0; &#125;&#125; 并发测试 这里我们写个单元测试进行并发测试。 1234567891011121314151617181920212223242526272829303132@SpringBootTestclass GoodsServiceTest &#123; @Autowired GoodsService goodsService; @Test void seckill() throws InterruptedException &#123; // 库存初始化为10，这里通过CountDownLatch和线程池模拟100个并发 int threadTotal = 100; ExecutorService executorService = Executors.newCachedThreadPool(); final CountDownLatch countDownLatch = new CountDownLatch(threadTotal); for (int i = 0; i &lt; threadTotal ; i++) &#123; int uid = i; executorService.execute(() -&gt; &#123; try &#123; goodsService.sellGoods(1, uid); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); &#125;&#125; 查看数据库验证是否超卖 上图的结果与我们的预期一致。此外还可以通过Postman或者Jmeter进行并发测试。由于不是此处的重点，不再做演示，感兴趣的小伙伴可以留言，我会整理下相关的教程。 后续 这篇文章通过数据库乐观锁已经解决了库存超卖的问题，不过效率上并不是最优方案，后续会完善其他方案的演示。文中如有错漏之处，还望大家不吝赐教。","categories":[{"name":"实战","slug":"实战","permalink":"https://idea360.cn/categories/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"实战","slug":"实战","permalink":"https://idea360.cn/tags/%E5%AE%9E%E6%88%98/"},{"name":"乐观锁","slug":"乐观锁","permalink":"https://idea360.cn/tags/%E4%B9%90%E8%A7%82%E9%94%81/"},{"name":"超卖","slug":"超卖","permalink":"https://idea360.cn/tags/%E8%B6%85%E5%8D%96/"}]},{"title":"JVM类加载器是否可以加载自定义的String","slug":"jvm-classload-string-self","date":"2020-03-06T17:41:16.000Z","updated":"2021-02-23T14:35:21.463Z","comments":true,"path":"2020/03/07/jvm-classload-string-self/","link":"","permalink":"https://idea360.cn/2020/03/07/jvm-classload-string-self/","excerpt":"","text":"前言 曾经有一次，面试官问到类加载机制，相信大多数小伙伴都可以答上来双亲委派机制，也都知道JVM出于安全性的考虑，全限定类名相同的String是不能被加载的。但是如果加载了，会出现什么样的结果呢？异常？那是什么样的异常。如果包名不相同呢？自定义类加载器是否可以加载呢？相信面试官从各种不同的角度出击，很快就会答出漏洞，毕竟咱没有深入研究过虚拟机… 接下来笔者就针对上述问题进行一一验证。该篇文章抱着求证答案的方向出发，并无太多理论方面的详解。如有理解上的偏差，还望大家不吝赐教。 JVM都有哪些类加载器 首先我们放上一张节选自网络的JVM类加载机制示意图 JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader： BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。 ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。 AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。 JVM类加载方式 类加载有三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 3、通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别 Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 JVM类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 JVM类加载机制源码 双亲委派模型实现源码分析 123456789101112131415161718192021222324252627282930313233343536private final ClassLoader parent; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先，检查请求的类是否已经被加载过 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123;//父加载器不为空，调用父加载器loadClass()方法处理 c = parent.loadClass(name, false); &#125; else &#123;//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; //抛出异常说明父类加载器无法完成加载请求 &#125; if (c == null) &#123; long t1 = System.nanoTime(); //自己尝试加载 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 双亲委派模型的好处 双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。 如果我们不想用双亲委派模型怎么办？ 为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 loadClass() 即可。 系统类加载器加载自定义String 1. 首先我们看下普通的类加载过程 123456789package com.example.demojava.loadclass;public class ClassLoaderDemo&#123; public static void main(String[] args) &#123; System.out.println(&quot;ClassLodarDemo&#x27;s ClassLoader is &quot; + ClassLoaderDemo.class.getClassLoader()); System.out.println(&quot;The Parent of ClassLodarDemo&#x27;s ClassLoader is &quot; + ClassLoaderDemo.class.getClassLoader().getParent()); System.out.println(&quot;The GrandParent of ClassLodarDemo&#x27;s ClassLoader is &quot; + ClassLoaderDemo.class.getClassLoader().getParent().getParent()); &#125;&#125; 结果输出 123ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@75bd9247The GrandParent of ClassLodarDemo&#39;s ClassLoader is null AppClassLoader的父类加载器为ExtClassLoader ExtClassLoader的父类加载器为null，null并不代表ExtClassLoader没有父类加载器，而是 BootstrapClassLoader 。 2. 我们自己定义一个String类,看下会发生什么 1234567package com.example.demojava.loadclass;public class String &#123; public static void main(String[] args) &#123; System.out.println(&quot;我是自定义的String&quot;); &#125;&#125; 结果输出 123➜ demo-java javac src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;demojava&#x2F;loadclass&#x2F;String.java ➜ demo-java java src.main.java.com.example.demojava.loadclass.String 错误: 找不到或无法加载主类 src.main.java.com.example.demojava.loadclass.String 这里分明有main方法，全限定类名又和jdk的String不在同一个package(不会造成冲突)，为什么会输出找不到或无法加载主类呢？ 细心的小伙伴一定会发现该类’没有导入’系统的String类，会不会因为JVM的类加载机制，AppClassLoader加载类的时候，由于自定义的String被加载，拦截了上层的String类呢？String对象是自定义的，不符合main()方法的定义方式，故系统抛找不到main()方法。 我们反过来验证下刚才的推测，再次运行刚才的ClassLoaderDemo会发生什么呢？what？IDE中的main()方法去哪里了？还是手动编译运行下吧 123➜ demo-java javac src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;demojava&#x2F;loadclass&#x2F;ClassLoaderDemo.java ➜ demo-java java src.main.java.com.example.demojava.loadclass.ClassLoaderDemo 错误: 找不到或无法加载主类 src.main.java.com.example.demojava.loadclass.ClassLoaderDemo 结果显示: 之前正常运行的java类也找不到主类了。 我们导入正确的String类再来验证下 1234567package com.example.demojava.loadclass;public class String &#123; public static void main(java.lang.String[] args) &#123; System.out.println(&quot;我是自定义的String&quot;); &#125;&#125; 结果输出 1我是自定义的String 3. 能否覆写lang包下的String类? 上边的案例修改包路径即可 1234567package java.lang;public class String &#123; public static void main(java.lang.String[] args) &#123; System.out.println(&quot;我是自定义的String&quot;); &#125;&#125; 输出报错 1234Connected to the target VM, address: &#39;127.0.0.1:63569&#39;, transport: &#39;socket&#39;错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args)否则 JavaFX 应用程序类必须扩展javafx.application.Application **分析:**首先由于全限定类名java.lang.String等于jdk中的String类，根据上边类加载源码可知，当AppClassLoader加载该String时，判断java.lang.String已经加载，便不会再次加载。所以执行的依旧是jdk中的String，但是系统的java.lang.String中没有main()方法，所以会报错。这是一种安全机制。 然后验证下默认的类加载器能否加载自定义的java.lang.String。==，默认的AppClassLoader能加载Everything？ 12345678910public class LoadStringDemo &#123; public static void main(String[] args) &#123; URLClassLoader systemClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader(); URL[] urLs = systemClassLoader.getURLs(); for (URL url: urLs) &#123; System.out.println(url); &#125; &#125;&#125; 输出日志如下 123...file:&#x2F;Users&#x2F;cuishiying&#x2F;work&#x2F;demo-java&#x2F;target&#x2F;classes&#x2F;... 日志太多，但是绝对没有其他的包路径(当前包下的java.lang.String默认只能时jdk中的) 自定义类加载器 为什么会存在自定义类加载器呢 自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。 因为实际项目中，会有多种加载.class文件的方式， 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 如何自定义类加载器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.example.demojava.loadclass;import com.demo.ClassLoaderDemo;import java.io.*;import java.lang.reflect.Method;public class MyClassLoader extends ClassLoader &#123; private String root; /** * @param name 全限定类名 * @return * @throws ClassNotFoundException */ @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String className) &#123; String fileName = root + File.separatorChar + className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getRoot() &#123; return root; &#125; public void setRoot(String root) &#123; this.root = root; &#125; public static void main(String[] args) throws Exception &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot(&quot;/Users/cuishiying/Desktop/demo&quot;); Class&lt;?&gt; clz = Class.forName(&quot;LoadDemo&quot;, true, classLoader); Object instance = clz.newInstance(); Method test = clz.getDeclaredMethod(&quot;test&quot;); test.setAccessible(true); test.invoke(instance); System.out.println(instance.getClass().getClassLoader()); &#125;&#125; 结果输出 12testcom.example.demojava.loadclass.MyClassLoader@75bd9247 由此可知，自定义类加载器已可以正常工作。这里我们不能把LoadDemo放在类路径下，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader加载，而不会通过我们自定义类加载器来加载。 自定义类加载器加载手写java.lang.String 改写自定义类加载器的main()方法 12345678910public static void main(String[] args) throws Exception &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot(&quot;/Users/cuishiying/Desktop/demo&quot;); Class&lt;?&gt; clz = classLoader.findClass(&quot;java.lang.String&quot;); Object instance = clz.newInstance(); System.out.println(instance.getClass().getClassLoader());&#125; JVM由于安全机制抛出了SecurityException 1234567&#x2F;Users&#x2F;cuishiying&#x2F;Desktop&#x2F;demo&#x2F;java&#x2F;lang&#x2F;String.classException in thread &quot;main&quot; java.lang.SecurityException: Prohibited package name: java.lang at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662) at java.lang.ClassLoader.defineClass(ClassLoader.java:761) at java.lang.ClassLoader.defineClass(ClassLoader.java:642) at com.example.demojava.loadclass.MyClassLoader.findClass(MyClassLoader.java:25) at com.example.demojava.loadclass.MyClassLoader.main(MyClassLoader.java:71)","categories":[{"name":"JVM","slug":"JVM","permalink":"https://idea360.cn/categories/JVM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://idea360.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"多线程-线程池的正确打开方式","slug":"java-multi-thread-pool","date":"2020-03-06T17:41:03.000Z","updated":"2020-03-15T03:54:06.973Z","comments":true,"path":"2020/03/07/java-multi-thread-pool/","link":"","permalink":"https://idea360.cn/2020/03/07/java-multi-thread-pool/","excerpt":"","text":"概述 线程可认为是操作系统可调度的最小的程序执行序列，一般作为进程的组成部分，同一进程中多个线程可共享该进程的资源（如内存等）。JVM线程跟内核轻量级进程有一对一的映射关系，所以JVM中的线程是很宝贵的。 一般在工程上多线程的实现是基于线程池的。因为相比自己创建线程，多线程具有以下优点 线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。 可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。 Executors存在什么问题 看阿里巴巴开发手册并发编程这块有一条：线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。 Executors为什么存在缺陷 1. 线程池工作原理 当一个任务通过execute(Runnable)方法欲添加到线程池时： 如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。 那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 2.newFixedThreadPool分析 Java中的BlockingQueue主要有两种实现，分别是ArrayBlockingQueue 和 LinkedBlockingQueue。 ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。 LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。 这里的问题就出在：**不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。**也就是说，如果我们不设置LinkedBlockingQueue的容量的话，其默认容量将会是Integer.MAX_VALUE。 而newFixedThreadPool中创建LinkedBlockingQueue时，并未指定容量。此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。 3. newCachedThreadPool分析 结合上述流程图，核心线程数=0，最大线程无限大，由于SynchronousQueue是一个缓存值为1的阻塞队列。当有大量任务请求时，线程池会创建大量线程，造成OOM。 线程池参数详解 1. 构造方法 123456789101112131415/** * @param corePoolSize 核心线程数 * @param maximumPoolSize 最大线程数 * @param keepAliveTime 线程所允许的空闲时间 * @param unit 线程所允许的空闲时间的单位 * @param workQueue 线程池所使用的缓冲队列 * @param handler 线程池对拒绝任务的处理策略 */ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) 2. 线程池拒绝策略 RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。。以下是JDK1.5提供的四种策略。 AbortPolicy：直接抛出异常 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。 线程池正确打开方式 1. 创建线程池 避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。 12345ThreadPoolExecutor executorService = new ThreadPoolExecutor(8, 16, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10)); 2. 向线程池提交任务 我们可以使用execute提交的任务，但是execute方法没有返回值，所以无法判断任务知否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。 12345678ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 20, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(60));threadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;线程池无返回结果&quot;); &#125;&#125;);复制ErrorCopied 我们也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。 123456789ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 20, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(60));Future&lt;String&gt; future = threadPoolExecutor.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return &quot;ok&quot;; &#125;&#125;);System.out.println(&quot;线程池返回结果:&quot; + future.get()); 3. 关闭线程池 shutdown关闭线程池 方法定义：public void shutdown() （1）线程池的状态变成SHUTDOWN状态，此时不能再往线程池中添加新的任务，否则会抛出RejectedExecutionException异常。 （2）线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。 注意这个函数不会等待提交的任务执行完成，要想等待全部任务完成，可以调用： public boolean awaitTermination(longtimeout, TimeUnit unit) shutdownNow关闭线程池并中断任务 方法定义：public List shutdownNow() （1）线程池的状态立刻变成STOP状态，此时不能再往线程池中添加新的任务。 （2）终止等待执行的线程，并返回它们的列表； （3）试图停止所有正在执行的线程，试图终止的方法是调用Thread.interrupt()，但是大家知道，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。 4. 如何配置线程池大小 CPU密集型任务 该任务需要大量的运算，并且没有阻塞，CPU一直全速运行，CPU密集任务只有在真正的多核CPU上才可能通过多线程加速 CPU密集型任务配置尽可能少的线程数量： CPU核数+1个线程的线程池。 例如: CPU 16核，内存32G。线程数=16 IO密集型任务 IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数*2 某大厂设置策略：IO密集型时，大部分线程都阻塞，故需要多配置线程数： CPU核数/(1-阻塞系数) 例如: CPU 16核, 阻塞系数 0.9 -------------&gt;16/(1-0.9) = 160 个线程数。 此时非阻塞线程=16 写在最后 这篇文章是对线程池使用的简单分析，为了更好的学习编程，后续会从源码的角度分析线程池的运行原理，上述文章如有错漏，还望大家不吝赐教。","categories":[{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程池","slug":"线程池","permalink":"https://idea360.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"Docker实战之Kafka集群","slug":"docker-kafka-cluster","date":"2020-03-06T17:40:30.000Z","updated":"2021-08-11T13:35:11.154Z","comments":true,"path":"2020/03/07/docker-kafka-cluster/","link":"","permalink":"https://idea360.cn/2020/03/07/docker-kafka-cluster/","excerpt":"","text":"1. 概述 Apache Kafka是一个快速、可扩展的、高吞吐、可容错的分布式发布订阅消息系统。其具有高吞吐量、内置分区、支持数据副本和容错的特性，适合在大规模消息处理场景中使用。 笔者之前在物联网公司工作，其中Kafka作为物联网MQ选型的事实标准，这里优先给大家搭建Kafka集群环境。由于Kafka的安装需要依赖Zookeeper，对Zookeeper还不了解的小伙伴可以在 这里 先认识下Zookeeper。 Kafka能解决什么问题呢？先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。 2. Kafka基本概念 Kafka部分名词解释如下： Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。 Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。 Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。 Segment：partition物理上由多个segment组成，下面有详细说明。 offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.每个partition中的消息都由offset=0开始记录消息。 3. Docker环境搭建 配合上一节的Zookeeper环境,计划搭建一个3节点的集群。宿主机IP为 192.168.124.5。 docker-compose-kafka-cluster.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495version: &#x27;3.7&#x27;networks: docker_net: external: trueservices: kafka1: image: wurstmeister/kafka restart: unless-stopped container_name: kafka1 ports: - &quot;9093:9092&quot; external_links: - zoo1 - zoo2 - zoo3 environment: KAFKA_BROKER_ID: 1 KAFKA_ADVERTISED_HOST_NAME: 192.168.124.5 ## 修改:宿主机IP KAFKA_ADVERTISED_PORT: 9093 ## 修改:宿主机映射port KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.124.5:9093 ## 绑定发布订阅的端口。修改:宿主机IP KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181,zoo2:2181,zoo3:2181&quot; volumes: - &quot;./kafka/kafka1/docker.sock:/var/run/docker.sock&quot; - &quot;./kafka/kafka1/data/:/kafka&quot; networks: - docker_net kafka2: image: wurstmeister/kafka restart: unless-stopped container_name: kafka2 ports: - &quot;9094:9092&quot; external_links: - zoo1 - zoo2 - zoo3 environment: KAFKA_BROKER_ID: 2 KAFKA_ADVERTISED_HOST_NAME: 192.168.124.5 ## 修改:宿主机IP KAFKA_ADVERTISED_PORT: 9094 ## 修改:宿主机映射port KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.124.5:9094 ## 修改:宿主机IP KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181,zoo2:2181,zoo3:2181&quot; volumes: - &quot;./kafka/kafka2/docker.sock:/var/run/docker.sock&quot; - &quot;./kafka/kafka2/data/:/kafka&quot; networks: - docker_net kafka3: image: wurstmeister/kafka restart: unless-stopped container_name: kafka3 ports: - &quot;9095:9092&quot; external_links: - zoo1 - zoo2 - zoo3 environment: KAFKA_BROKER_ID: 3 KAFKA_ADVERTISED_HOST_NAME: 192.168.124.5 ## 修改:宿主机IP KAFKA_ADVERTISED_PORT: 9095 ## 修改:宿主机映射port KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.124.5:9095 ## 修改:宿主机IP KAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181,zoo2:2181,zoo3:2181&quot; volumes: - &quot;./kafka/kafka3/docker.sock:/var/run/docker.sock&quot; - &quot;./kafka/kafka3/data/:/kafka&quot; networks: - docker_net kafka-manager: image: sheepkiller/kafka-manager:latest restart: unless-stopped container_name: kafka-manager hostname: kafka-manager ports: - &quot;9000:9000&quot; links: # 连接本compose文件创建的container - kafka1 - kafka2 - kafka3 external_links: # 连接本compose文件以外的container - zoo1 - zoo2 - zoo3 environment: ZK_HOSTS: zoo1:2181,zoo2:2181,zoo3:2181 ## 修改:宿主机IP TZ: CST-8 networks: - docker_net 执行以下命令启动 1docker-compose -f docker-compose-kafka-cluster.yml up -d 可以看到kafka集群已经启动成功。 4. Kafka初认识 4.1 可视化管理 细心的小伙伴发现上边的配置除了kafka外还有一个kafka-manager模块。它是kafka的可视化管理模块。因为kafka的元数据、配置信息由Zookeeper管理，这里我们在UI页面做下相关配置。 1. 访问 http:localhost:9000,按图示添加相关配置 2. 配置后我们可以看到默认有一个topic(__consumer_offsets)，3个brokers。该topic分50个partition，用于记录kafka的消费偏移量。 4.2 Zookeeper在kafka环境中做了什么 1. 首先观察下根目录 kafka基于zookeeper，kafka启动会将元数据保存在zookeeper中。查看zookeeper节点目录，会发现多了很多和kafka相关的目录。结果如下: 12345678910➜ docker zkCli -server 127.0.0.1:2183Connecting to 127.0.0.1:2183Welcome to ZooKeeper!JLine support is enabledWATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: 127.0.0.1:2183(CONNECTED) 0] ls /[cluster, controller, brokers, zookeeper, admin, isr_change_notification, log_dir_event_notification, controller_epoch, zk-test0000000000, kafka-manager, consumers, latest_producer_id_block, config] 2. 查看我们映射的kafka目录，新版本的kafka偏移量不再存储在zk中，而是在kafka自己的环境中。 我们节选了部分目录(包含2个partition) 1234567891011121314151617181920├── kafka1│ ├── data│ │ └── kafka-logs-c4e2e9edc235│ │ ├── __consumer_offsets-1│ │ │ ├── 00000000000000000000.index // segment索引文件│ │ │ ├── 00000000000000000000.log // 数据文件│ │ │ ├── 00000000000000000000.timeindex // 消息时间戳索引文件│ │ │ └── leader-epoch-checkpoint...│ │ ├── __consumer_offsets-7│ │ │ ├── 00000000000000000000.index│ │ │ ├── 00000000000000000000.log│ │ │ ├── 00000000000000000000.timeindex│ │ │ └── leader-epoch-checkpoint│ │ ├── cleaner-offset-checkpoint│ │ ├── log-start-offset-checkpoint│ │ ├── meta.properties│ │ ├── recovery-point-offset-checkpoint│ │ └── replication-offset-checkpoint│ └── docker.sock 结果与Kafka-Manage显示结果一致。图示的文件是一个Segment，00000000000000000000.log表示offset从0开始，随着数据不断的增加，会有多个Segment文件。 5. docker创建topic 123456➜ docker docker exec -it kafka1 /bin/bash # 进入容器bash-4.4# cd /opt/kafka/ # 进入安装目录bash-4.4# ./bin/kafka-topics.sh --list --zookeeper zoo1:2181,zoo2:2181,zoo3:2181 # 查看主题列表__consumer_offsetsbash-4.4# ./bin/kafka-topics.sh --create --zookeeper zoo1:2181,zoo2:2181,zoo3:2181 --replication-factor 2 --partitions 3 --topic test # 新建主题Created topic test. 说明: –replication-factor副本数; –partitions分区数; replication&lt;=broker(一定); 有效消费者数&lt;=partitions分区数(一定); 新建主题后, 再次查看映射目录, 由图可见，partition在3个broker上均匀分布。图示同步副本表示当前和主节点数据保持同步的副本数。kafka服务端可以设置 min.insync.replicas 参数(最小同步副本)。这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower (一种保证消息可靠不丢失的策略)。 ISR是由leader维护，follower从leader同步数据有一些延迟 （包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度）， 任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。 docker中的data路径示例: /kafka/kafka-logs-c4e2e9edc235/test-0/00000000000000000000.log 6. 官方工具 brew安装的kafka指令路径 /usr/local/Cellar/kafka/2.6.0_1/bin 真正的脚本路径 /usr/local/Cellar/kafka/2.6.0_1/libexec/bin 配置文件路径 /usr/local/etc/kafka 数据存储在 /usr/local/var/lib/kafka-logs 目录下 1234567891011121314151617181920212223242526272829303132├── connect-distributed├── connect-mirror-maker├── connect-standalone├── kafka-acls├── kafka-broker-api-versions├── kafka-configs├── kafka-console-consumer├── kafka-console-producer├── kafka-consumer-groups├── kafka-consumer-perf-test├── kafka-delegation-tokens├── kafka-delete-records├── kafka-dump-log├── kafka-leader-election├── kafka-log-dirs├── kafka-mirror-maker├── kafka-preferred-replica-election├── kafka-producer-perf-test├── kafka-reassign-partitions├── kafka-replica-verification├── kafka-run-class├── kafka-server-start├── kafka-server-stop├── kafka-streams-application-reset├── kafka-topics├── kafka-verifiable-consumer├── kafka-verifiable-producer├── trogdor├── zookeeper-security-migration├── zookeeper-server-start├── zookeeper-server-stop└── zookeeper-shell 运维管理类 kafka-topics.sh: 用来创建，删除，查看，改变一个topic参数的工具 kafka-reassign-partitions.sh: 用来对partition进行重新分配(管理员会较多使用) kafka-log-dirs.sh: 用来查看指定broker下日志目录的使用空间 kafka-leader-election.sh: 用于一组Topic分区的leader重新分配，可以支持优先副本和非同步副本(不在ISR中)，老版本中的kafka-preferred-replica-election.sh脚本 kafka-replica-verification.sh: 该工具可以用来检查topic的一组副本的数据是否一致 kafka-broker-api-versions.sh: 用来查看指定broker当前支持的各个接口的版本(kafka高版本已经保证了向下兼容) kafka-configs.sh: 用来操作和查看topic, client, user or broker的实体配置 kafka操作类 kafka-console-consumer.sh: 通过终端来启动消费者 kafka-console-producer.sh: 通过终端来启动生产者 kafka-consumer-groups.sh: 用来查看，删除或者重置消费者组offset kafka-consumer-perf-test.sh: 用来进行消费者压力测试 kafka-producer-perf-test.sh: 用来进行生产者压力测试 kafka-delete-records.sh: 删除指定分区的记录，直到指定的offset kafka-mirror-maker.sh: 用于多集群之间同步topic数据 kafka-server-start.sh: broker启动脚本 kafka-server-stop.sh: broker关闭脚本 kafka-streams-application-reset.sh: 流式应用工具 zookeeper-shell.sh: kafka工具中也默认提供了zookeeper管理工具(不太好用) kafka-topics.sh topic创建 --create: 创建topic --topic: 指定topic名称 --partitions: 指定分区数量 --replication-factor: 指定副本数量(仅在创建时可用) --config: 指定topic级别的参数(动态参数，可修改) --replica-assignment: 手动指定partition到broker的分配&lt;part1_replica1:part1_replica2,part2_replica1:part2_replica2&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 创建topic➜ bin .&#x2F;kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --create --topic testCreated topic test.# 查看默认创建topic的参数详情(由broker配置决定)# 默认1个分区，1个副本➜ bin .&#x2F;kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --describe --topic testTopic: test PartitionCount: 1 ReplicationFactor: 1 Configs: segment.bytes&#x3D;1073741824 Topic: test Partition: 0 Leader: 1 Replicas: 1 Isr: 1# 指定参数创建topic, 2个分片, 1个副本# 指定分区partitions为2，副本replication-factor为1，topic数据保留2分钟# replication&lt;&#x3D;broker(一定);# 有效消费者数&lt;&#x3D;partitions分区数(一定);➜ bin .&#x2F;kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --create --topic test1 --partitions 2 --replication-factor 1 --config retention.ms&#x3D;120000Created topic test1.# 分区，副本和指定参数都改变了,2个分片, 1个副本➜ bin .&#x2F;kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --describe --topic test1Topic: test1 PartitionCount: 2 ReplicationFactor: 1 Configs: segment.bytes&#x3D;1073741824,retention.ms&#x3D;120000 Topic: test1 Partition: 0 Leader: 3 Replicas: 3 Isr: 3 Topic: test1 Partition: 1 Leader: 1 Replicas: 1 Isr: 1# 3个broker, 设置3个分片, 2个副本(1主1从), 可以看到分布相当均匀bash-5.1# .&#x2F;kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --create --topic test2 --partitions 3 --replication-factor 2 --config retention.ms&#x3D;120000Created topic test2.bash-5.1# .&#x2F;kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --describe --topic test2Topic: test2 PartitionCount: 3 ReplicationFactor: 2 Configs: segment.bytes&#x3D;1073741824,retention.ms&#x3D;120000 Topic: test2 Partition: 0 Leader: 3 Replicas: 3,1 Isr: 3,1 Topic: test2 Partition: 1 Leader: 1 Replicas: 1,2 Isr: 1,2 Topic: test2 Partition: 2 Leader: 2 Replicas: 2,3 Isr: 2,3# 3个broker, 设置3个分片, 1个副本(1个leader)bash-5.1# .&#x2F;bin&#x2F;kafka-topics.sh --create --zookeeper zoo1:2181,zoo2:2181,zoo3:2181 --replication-factor 1 --partitions 3 --topic test3Created topic test3.bash-5.1#bash-5.1# .&#x2F;bin&#x2F;kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --describe --topic test3Topic: test3 PartitionCount: 3 ReplicationFactor: 1 Configs: segment.bytes&#x3D;1073741824 Topic: test3 Partition: 0 Leader: 2 Replicas: 2 Isr: 2 Topic: test3 Partition: 1 Leader: 3 Replicas: 3 Isr: 3 Topic: test3 Partition: 2 Leader: 1 Replicas: 1 Isr: 1# 查看topic列表➜ bin .&#x2F;kafka-topics.sh --list --zookeeper 127.0.0.1:2181__consumer_offsetstesttest1test2# 删除topic➜ bin .&#x2F;kafka-topics.sh --delete --zookeeper 127.0.0.1:2181 --topic testTopic test is marked for deletion.Note: This will have no impact if delete.topic.enable is not set to true.# 查看集群leader不可用分区➜ bin .&#x2F;kafka-topics.sh --zookeeper 127.0.0.1:2181&#x2F;test --describe --unavailable-partitions# 查看副本不同步的分区详情➜ bin .&#x2F;kafka-topics.sh --zookeeper 127.0.0.1:2181&#x2F;test --describe --under-replicated-partitions kafka-run-class.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 查看topic偏移量➜ bin .&#x2F;kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list 127.0.0.1:9092 --topic testtest:0:7# 查看topic指定分区offset的最大值# -1为最大值➜ bin .&#x2F;kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list 127.0.0.1:9092 --topic test --time -1test:0:7# 查看topic指定分区offset的最小值# -2为最小值➜ bin .&#x2F;kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list 127.0.0.1:9092 --topic test --time -2test:0:0# 查看.log数据文件➜ bin .&#x2F;kafka-run-class.sh kafka.tools.DumpLogSegments --files &#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;test-0&#x2F;00000000000000000000.log --print-data-logDumping &#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;test-0&#x2F;00000000000000000000.logStarting offset: 0baseOffset: 0 lastOffset: 1 count: 2 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 0 CreateTime: 1607746708893 size: 78 magic: 2 compresscodec: NONE crc: 3385071347 isvalid: true| offset: 0 CreateTime: 1607746708347 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: 1| offset: 1 CreateTime: 1607746708893 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: 2baseOffset: 2 lastOffset: 4 count: 3 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 78 CreateTime: 1607746710358 size: 87 magic: 2 compresscodec: NONE crc: 2415539616 isvalid: true| offset: 2 CreateTime: 1607746709397 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: 3| offset: 3 CreateTime: 1607746709874 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: 4| offset: 4 CreateTime: 1607746710358 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: 5baseOffset: 5 lastOffset: 6 count: 2 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 165 CreateTime: 1607746712081 size: 78 magic: 2 compresscodec: NONE crc: 449097919 isvalid: true| offset: 5 CreateTime: 1607746711241 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: 6| offset: 6 CreateTime: 1607746712081 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: 7baseOffset: 7 lastOffset: 7 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 243 CreateTime: 1607750506795 size: 69 magic: 2 compresscodec: NONE crc: 1201654216 isvalid: true| offset: 7 CreateTime: 1607750506795 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: abaseOffset: 8 lastOffset: 9 count: 2 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 312 CreateTime: 1607750508922 size: 78 magic: 2 compresscodec: NONE crc: 2249065123 isvalid: true| offset: 8 CreateTime: 1607750508188 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: b| offset: 9 CreateTime: 1607750508922 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: cbaseOffset: 10 lastOffset: 10 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 390 CreateTime: 1607750511875 size: 69 magic: 2 compresscodec: NONE crc: 926719390 isvalid: true| offset: 10 CreateTime: 1607750511875 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: d# 查看.index索引文件➜ bin .&#x2F;kafka-run-class.sh kafka.tools.DumpLogSegments --files &#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;test-0&#x2F;00000000000000000000.indexDumping &#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;test-0&#x2F;00000000000000000000.indexoffset: 0 position: 0Mismatches in :&#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;test-0&#x2F;00000000000000000000.index Index offset: 0, log offset: 1# 查看.timeindex索引文件➜ bin .&#x2F;kafka-run-class.sh kafka.tools.DumpLogSegments --files &#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;test-0&#x2F;00000000000000000000.timeindex --verify-index-onlyDumping &#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;test-0&#x2F;00000000000000000000.timeindexThe following indexed offsets are not found in the log.Indexed offset: 0, found log offset: 1 kafka-console-producer.sh 12# 生产消息➜ bin .&#x2F;kafka-console-producer.sh --broker-list 127.0.0.1:9092 --topic test kafka-console-consumer.sh 12345678910# 消费消息➜ bin .&#x2F;kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic test --from-beginning# 指定offset消费消息# 指定offset&#x3D;2, 分片0, 最多消费3条➜ bin .&#x2F;kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic test --offset 2 --partition 0 --max-messages 3345Processed a total of 3 messages kafka-consumer-groups.sh 消费组管理工具，可以列出所有的消费组，查看消费组详情，删除消费组信息以及重置消费组的offset --all-groups: 应用到所有的消费组 --all-topics: --delete: 删除topic分区的offset,以及拥有者和消费组信息(–group g1 –group g2) --delete-offsets: 删除消费组的offset --describe: 查看消费组信息以及消费者的offset lag --execute: 指定操作，支持reset-offsets操作 --export: 导出操作执行到csv，支持reset-offsets --from-file: 指定文件中指定的值重置offset (csv文件) --group: 指定消费组 --list: 列出所有的消费组 --members: 查看消费组中的成员 --state: 查看消费组的状态 --offsets: 查看消费组并且列出每个消费组所有topic的分区以及消息的offset lag --reset-offsets: 重置消费组的offset (需要指定如下一个参数) --to-datetime: --by-period: --to-earliest: --to-latest: --shift-by: --from-file: --to-current: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 查看分组列表➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --listconsole-consumer-10023console-consumer-20994# 查看消费组的成员➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-32644 --members --describeConsumer group &#39;console-consumer-32644&#39; has no active members.# 查看消费组的offset信息➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-32644 --offsets --describeConsumer group &#39;console-consumer-32644&#39; has no active members.# 查看消费组状态➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-32644 --state --describeConsumer group &#39;console-consumer-32644&#39; has no active members.GROUP COORDINATOR (ID) ASSIGNMENT-STRATEGY STATE #MEMBERSconsole-consumer-32644 localhost:9092 (0) Empty 0# 查看group详情# CURRENT-OFFSET: 当前消费者群组最近提交的 offset，也就是消费者分区里读取的当前位置# LOG-END-OFFSET: 当前最高水位偏移量，也就是最近一个读取消息的偏移量，同时也是最近一个提交到集群的偏移量# LAG：消费者的 CURRENT-OFFSET 与 broker 的 LOG-END-OFFSET 之间的差距➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-20994 --describeConsumer group &#39;console-consumer-20994&#39; has no active members.GROUP TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG CONSUMER-ID HOST CLIENT-IDconsole-consumer-20994 test 0 4 7 3 - - -# 重新设置设置group的offset# 指定group&#x3D;console-consumer-20994, 重置offset&#x3D;4➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-20994 --reset-offsets --topic test --to-offset 4 --executeGROUP TOPIC PARTITION NEW-OFFSETconsole-consumer-20994 test 0 4# 把group&#x3D;console-consumer-20994在topic&#x3D;test上的offcet恢复到最初➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-20994 --topic test --reset-offsets --to-earliest –executeWARN: No action will be performed as the --execute option is missing.In a future major release, the default behavior of this command will be to prompt the user before executing the reset rather than doing a dry run. You should add the --dry-run option explicitly if you are scripting this command and want to keep the current default behavior without prompting.GROUP TOPIC PARTITION NEW-OFFSETconsole-consumer-20994 test 0 0# 重置Consumer Group的Offset到最新位移➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-20994 --reset-offsets --topic test --to-latest --executeGROUP TOPIC PARTITION NEW-OFFSETconsole-consumer-20994 test 0 7# 把offcet从当前位置往前移动2个，如果是正数就是往后移动。➜ bin .&#x2F;kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group console-consumer-20994 --topic test --reset-offsets --shift-by -2 --executeGROUP TOPIC PARTITION NEW-OFFSETconsole-consumer-20994 test 0 5 kafka-log-dirs.sh 12345# 查看kafka各个broker节点以及topic的磁盘使用率情况➜ bin .&#x2F;kafka-log-dirs.sh --bootstrap-server 127.0.0.1:9092 --describe --topic-list testQuerying brokers for log directories informationReceived log directory information from brokers 0&#123;&quot;version&quot;:1,&quot;brokers&quot;:[&#123;&quot;broker&quot;:0,&quot;logDirs&quot;:[&#123;&quot;logDir&quot;:&quot;&#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&quot;,&quot;error&quot;:null,&quot;partitions&quot;:[&#123;&quot;partition&quot;:&quot;test-0&quot;,&quot;size&quot;:243,&quot;offsetLag&quot;:0,&quot;isFuture&quot;:false&#125;]&#125;]&#125;]&#125; kafka-configs.sh 用来查看和修改kafka相关的配置信息，包含集群的动态配置，topic级别的动态配置等等 --all: 列出给定实体的全部配置文件(默认已经生效的全部参数，如果没有all仅对动态参数生效) --entity-type: 实体类型[topics/clients/users/brokers/broker-loggers] --entity-name: 实体名称[topic名称/client-id/user-name/broker-id] --describe: 列出给定实体的配置文件 --force: 强制生效 --topic: 指定topic名称 --alter: 修改指定实体的配置文件 注意:当使用delete-config和add-config时必须使用--alter --delete-config: 删除指定的配置&quot;k1,k2&quot; --add-config: 给指定的实体增加配置(k=v,k2=[v1,v2,v3],k3=v3) topic级别的动态参数 cleanup.policy: 清理策略 compression.type: 压缩类型(通常建议在produce端控制) delete.retention.ms: 压缩日志的保留时间 flush.messages: 持久化message限制 flush.ms: 持久化频率 follower.replication.throttled.replicas: follower副本限流 leader.replication.throttled.replicas: leader副本限流 max.message.bytes: 最大的batch的message大小 message.downconversion.enable: message向下兼容 message.format.version: message格式版本 min.insync.replicas: 最小的ISR retention.ms: 日志保留时间 retention.bytes: 日志保留大小(通常按照时间限制) segment.bytes: segment的大小限制 segment.ms: segment的切割时间 unclean.leader.election.enable: 是否允许非同步副本选主(针对可用性设置的一个参数) broker级别的动态参数 broker级别的动态参数比较多，这里只列举常用的几个 log.retention.ms: 日志保留时间 max.connections: 最大连接数 max.connections.per.ip: 每个ip的最大连接数 message.max.bytes: batch的message的最大限制 min.insync.replicas: 最小的ISR num.io.threads: IO线程数(网络线程数的两倍) num.network.threads: 网络线程数(cpu的2/3较好) num.recovery.threads.per.data.dir: 每个数据目录的恢复线程 num.replica.fetchers: 副本的fetchers数量(默认为1,可适当调大) user级别的参数 SCRAM-SHA-256: SCRAM-SHA-512: consumer_byte_rate: 针对消费者user进行限流 producer_byte_rate: 针对生产者进行限流 request_percentage: 请求百分比 clients级别参数 consumer_byte_rate: 针对消费者user进行限流 producer_byte_rate: 针对生产者进行限流 request_percentage: 请求百分比 123456789101112131415161718# 修改topic的数据保留时间➜ bin .&#x2F;kafka-configs.sh --bootstrap-server 127.0.0.1:9092 --topic test --add-config retention.ms&#x3D;10000000 --alterCompleted updating config for topic test.# 查看topic的动态参数配置➜ bin .&#x2F;kafka-configs.sh --bootstrap-server 127.0.0.1:9092 --topic test --describeDynamic configs for topic test are: retention.ms&#x3D;10000000 sensitive&#x3D;false synonyms&#x3D;&#123;DYNAMIC_TOPIC_CONFIG:retention.ms&#x3D;10000000&#125;# 删除topic动态参数配置➜ bin .&#x2F;kafka-configs.sh --bootstrap-server 127.0.0.1:9092 --topic test --alter --delete-config retention.msCompleted updating config for topic test.查看broker全部的参数(--all会获取全部的参数)➜ bin .&#x2F;kafka-configs.sh --bootstrap-server 127.0.0.1:9092 --all --broker-defaults --describeDefault configs for brokers in the cluster are: kafka-broker-api-versions.sh 查看kafka对外的各个api版本. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 查看当前kafka版本➜ bin .&#x2F;kafka-broker-api-versions.sh --bootstrap-server 127.0.0.1:9092 --version2.6.0 (Commit:62abe01bee039651)# 查看集群所有节点的api版本➜ bin .&#x2F;kafka-broker-api-versions.sh --bootstrap-server 127.0.0.1:9092localhost:9092 (id: 0 rack: null) -&gt; ( Produce(0): 0 to 8 [usable: 8], Fetch(1): 0 to 11 [usable: 11], ListOffsets(2): 0 to 5 [usable: 5], Metadata(3): 0 to 9 [usable: 9], LeaderAndIsr(4): 0 to 4 [usable: 4], StopReplica(5): 0 to 3 [usable: 3], UpdateMetadata(6): 0 to 6 [usable: 6], ControlledShutdown(7): 0 to 3 [usable: 3], OffsetCommit(8): 0 to 8 [usable: 8], OffsetFetch(9): 0 to 7 [usable: 7], FindCoordinator(10): 0 to 3 [usable: 3], JoinGroup(11): 0 to 7 [usable: 7], Heartbeat(12): 0 to 4 [usable: 4], LeaveGroup(13): 0 to 4 [usable: 4], SyncGroup(14): 0 to 5 [usable: 5], DescribeGroups(15): 0 to 5 [usable: 5], ListGroups(16): 0 to 4 [usable: 4], SaslHandshake(17): 0 to 1 [usable: 1], ApiVersions(18): 0 to 3 [usable: 3], CreateTopics(19): 0 to 5 [usable: 5], DeleteTopics(20): 0 to 4 [usable: 4], DeleteRecords(21): 0 to 2 [usable: 2], InitProducerId(22): 0 to 3 [usable: 3], OffsetForLeaderEpoch(23): 0 to 3 [usable: 3], AddPartitionsToTxn(24): 0 to 1 [usable: 1], AddOffsetsToTxn(25): 0 to 1 [usable: 1], EndTxn(26): 0 to 1 [usable: 1], WriteTxnMarkers(27): 0 [usable: 0], TxnOffsetCommit(28): 0 to 3 [usable: 3], DescribeAcls(29): 0 to 2 [usable: 2], CreateAcls(30): 0 to 2 [usable: 2], DeleteAcls(31): 0 to 2 [usable: 2], DescribeConfigs(32): 0 to 3 [usable: 3], AlterConfigs(33): 0 to 1 [usable: 1], AlterReplicaLogDirs(34): 0 to 1 [usable: 1], DescribeLogDirs(35): 0 to 2 [usable: 2], SaslAuthenticate(36): 0 to 2 [usable: 2], CreatePartitions(37): 0 to 2 [usable: 2], CreateDelegationToken(38): 0 to 2 [usable: 2], RenewDelegationToken(39): 0 to 2 [usable: 2], ExpireDelegationToken(40): 0 to 2 [usable: 2], DescribeDelegationToken(41): 0 to 2 [usable: 2], DeleteGroups(42): 0 to 2 [usable: 2], ElectLeaders(43): 0 to 2 [usable: 2], IncrementalAlterConfigs(44): 0 to 1 [usable: 1], AlterPartitionReassignments(45): 0 [usable: 0], ListPartitionReassignments(46): 0 [usable: 0], OffsetDelete(47): 0 [usable: 0], DescribeClientQuotas(48): 0 [usable: 0], AlterClientQuotas(49): 0 [usable: 0] 7. SpringBoot集成 笔者SpringBoot版本是 2.2.2.RELEASE pom.xml添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.4.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 生产者配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Configurationpublic class KafkaProducerConfig &#123; /** * producer配置 * @return */ public Map&lt;String, Object&gt; producerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); // 指定多个kafka集群多个地址 127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094 props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,&quot;192.168.124.5:9093,192.168.124.5:9094,192.168.124.5:9095&quot;); // 重试次数，0为不启用重试机制 props.put(ProducerConfig.RETRIES_CONFIG, Integer.MAX_VALUE); // acks=0 把消息发送到kafka就认为发送成功 // acks=1 把消息发送到kafka leader分区，并且写入磁盘就认为发送成功 // acks=all 把消息发送到kafka leader分区，并且leader分区的副本follower对消息进行了同步就任务发送成功 props.put(ProducerConfig.ACKS_CONFIG,&quot;all&quot;); // 生产者空间不足时，send()被阻塞的时间，默认60s props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 6000); // 控制批处理大小，单位为字节 props.put(ProducerConfig.BATCH_SIZE_CONFIG, 4096); // 批量发送，延迟为1毫秒，启用该功能能有效减少生产者发送消息次数，从而提高并发量 props.put(ProducerConfig.LINGER_MS_CONFIG, 1); // 生产者可以使用的总内存字节来缓冲等待发送到服务器的记录 props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 40960); // 消息的最大大小限制,也就是说send的消息大小不能超过这个限制, 默认1048576(1MB) props.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG,1048576); // 客户端id props.put(ProducerConfig.CLIENT_ID_CONFIG,&quot;producer.client.id.topinfo&quot;); // 键的序列化方式 props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); // 值的序列化方式 props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); // 压缩消息，支持四种类型，分别为：none、lz4、gzip、snappy，默认为none。 // 消费者默认支持解压，所以压缩设置在生产者，消费者无需设置。 props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG,&quot;none&quot;); return props; &#125; /** * producer工厂配置 * @return */ public ProducerFactory&lt;String, String&gt; producerFactory() &#123; return new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs()); &#125; /** * Producer Template 配置 */ @Bean(name=&quot;kafkaTemplate&quot;) public KafkaTemplate&lt;String, String&gt; kafkaTemplate() &#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125;&#125; 消费者配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104@Configurationpublic class KafkaConsumerConfig &#123; private static final String GROUP0_ID = &quot;group0&quot;; private static final String GROUP1_ID = &quot;group1&quot;; /** * 1. setAckMode: 消费者手动提交ack * * RECORD： 每处理完一条记录后提交。 * BATCH(默认)： 每次poll一批数据后提交一次，频率取决于每次poll的调用频率。 * TIME： 每次间隔ackTime的时间提交。 * COUNT： 处理完poll的一批数据后并且距离上次提交处理的记录数超过了设置的ackCount就提交。 * COUNT_TIME： TIME和COUNT中任意一条满足即提交。 * MANUAL： 手动调用Acknowledgment.acknowledge()后，并且处理完poll的这批数据后提交。 * MANUAL_IMMEDIATE： 手动调用Acknowledgment.acknowledge()后立即提交。 * * 2. factory.setConcurrency(3); * 此处设置的目的在于：假设 topic test 下有 0、1、2三个 partition，Spring Boot中只有一个 @KafkaListener() 消费者订阅此 topic，此处设置并发为3， * 启动后 会有三个不同的消费者分别订阅 p0、p1、p2，本地实际有三个消费者线程。 * 而 factory.setConcurrency(1); 的话 本地只有一个消费者线程， p0、p1、p2被同一个消费者订阅。 * 由于 一个partition只能被同一个消费者组下的一个消费者订阅，对于只有一个 partition的topic，即使设置 并发为3，也只会有一个消费者，多余的消费者没有 partition可以订阅。 * * 3. factory.setBatchListener(true); * 设置批量消费 ，每个批次数量在Kafka配置参数ConsumerConfig.MAX_POLL_RECORDS_CONFIG中配置， * 限制的是 一次批量接收的最大条数，而不是 等到达到最大条数才接收，这点容易被误解。 * 实际测试时，接收是实时的，当生产者大量写入时，一次批量接收的消息数量为 配置的最大条数。 */ @Bean KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt; kafkaListenerContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); // 设置消费者工厂 factory.setConsumerFactory(consumerFactory()); // 设置为批量消费，每个批次数量在Kafka配置参数中设置ConsumerConfig.MAX_POLL_RECORDS_CONFIG factory.setBatchListener(true); // 消费者组中线程数量,消费者数量&lt;=partition数量，即使配置的消费者数量大于partition数量，多余消费者无法消费到数据。 factory.setConcurrency(4); // 拉取超时时间 factory.getContainerProperties().setPollTimeout(3000); // 手动提交 factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL_IMMEDIATE); return factory; &#125; @Bean public ConsumerFactory&lt;Integer, String&gt; consumerFactory() &#123; Map&lt;String, Object&gt; map = consumerConfigs(); map.put(ConsumerConfig.GROUP_ID_CONFIG, GROUP0_ID); return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); &#125;// @Bean// KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt; kafkaListenerContainerFactory1() &#123;// ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt;// factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;();// // 设置消费者工厂// factory.setConsumerFactory(consumerFactory1());// // 设置为批量消费，每个批次数量在Kafka配置参数中设置ConsumerConfig.MAX_POLL_RECORDS_CONFIG// factory.setBatchListener(true);// // 消费者组中线程数量,消费者数量&lt;=partition数量，即使配置的消费者数量大于partition数量，多余消费者无法消费到数据。// factory.setConcurrency(3);// // 拉取超时时间// factory.getContainerProperties().setPollTimeout(3000);// // 手动提交// factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL_IMMEDIATE);// return factory;// &#125;//// public ConsumerFactory&lt;Integer, String&gt; consumerFactory1() &#123;// Map&lt;String, Object&gt; map = consumerConfigs();// map.put(ConsumerConfig.GROUP_ID_CONFIG, GROUP1_ID);// return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs());// &#125; @Bean public Map&lt;String, Object&gt; consumerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); // Kafka地址 props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;192.168.124.5:9093,192.168.124.5:9094,192.168.124.5:9095&quot;); // 是否自动提交offset偏移量(默认true) props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false); // 批量消费 props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, &quot;100&quot;); // 消费者组 props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;group-default&quot;); // 自动提交的频率(ms)// propsMap.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, &quot;100&quot;); // Session超时设置 props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, &quot;15000&quot;); // 键的反序列化方式 props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); // 值的反序列化方式 props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); // offset偏移量规则设置： // (1)、earliest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费 // (2)、latest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据 // (3)、none：topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常 props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;latest&quot;); return props; &#125;&#125; 主题配置 123456789101112131415161718192021222324@Configurationpublic class KafkaTopicConfig &#123; /** * 定义一个KafkaAdmin的bean，可以自动检测集群中是否存在topic，不存在则创建 */ @Bean public KafkaAdmin kafkaAdmin() &#123; Map&lt;String, Object&gt; configs = new HashMap&lt;&gt;(); // 指定多个kafka集群多个地址，例如：192.168.2.11,9092,192.168.2.12:9092,192.168.2.13:9092 configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG,&quot;192.168.124.5:9093,192.168.124.5:9094,192.168.124.5:9095&quot;); return new KafkaAdmin(configs); &#125; /** * 创建 Topic */ @Bean public NewTopic topicinfo() &#123; // 创建topic，需要指定创建的topic的&quot;名称&quot;、&quot;分区数&quot;、&quot;副本数量(副本数数目设置要小于Broker数量)&quot; return new NewTopic(&quot;test&quot;, 3, (short) 2); &#125;&#125; 消费者服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@Slf4j@Servicepublic class KafkaConsumerService &#123;// /**// * 单条消费// * @param message// */// @KafkaListener(id = &quot;id0&quot;, topics = &#123;Constant.TOPIC&#125;, containerFactory=&quot;kafkaListenerContainerFactory&quot;)// public void kafkaListener0(String message)&#123;// log.info(&quot;consumer:group0 --&gt; message:&#123;&#125;&quot;, message);// &#125;//// @KafkaListener(id = &quot;id1&quot;, topics = &#123;Constant.TOPIC&#125;, groupId = &quot;group1&quot;)// public void kafkaListener1(String message)&#123;// log.info(&quot;consumer:group1 --&gt; message:&#123;&#125;&quot;, message);// &#125;// /**// * 监听某个 Topic 的某个分区示例,也可以监听多个 Topic 的分区// * 为什么找不到group2呢？// * @param message// */// @KafkaListener(id = &quot;id2&quot;, groupId = &quot;group2&quot;, topicPartitions = &#123; @TopicPartition(topic = Constant.TOPIC, partitions = &#123; &quot;0&quot; &#125;) &#125;)// public void kafkaListener2(String message) &#123;// log.info(&quot;consumer:group2 --&gt; message:&#123;&#125;&quot;, message);// &#125;//// /**// * 获取监听的 topic 消息头中的元数据// * @param message// * @param topic// * @param key// */// @KafkaListener(id = &quot;id3&quot;, topics = Constant.TOPIC, groupId = &quot;group3&quot;)// public void kafkaListener(@Payload String message,// @Header(KafkaHeaders.RECEIVED_TOPIC) String topic,// @Header(KafkaHeaders.RECEIVED_PARTITION_ID) String partition,// @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) String key) &#123;// Long threadId = Thread.currentThread().getId();// log.info(&quot;consumer:group3 --&gt; message:&#123;&#125;, topic:&#123;&#125;, partition:&#123;&#125;, key:&#123;&#125;, threadId:&#123;&#125;&quot;, message, topic, partition, key, threadId);// &#125;//// /**// * 监听 topic 进行批量消费// * @param messages// */// @KafkaListener(id = &quot;id4&quot;, topics = Constant.TOPIC, groupId = &quot;group4&quot;)// public void kafkaListener(List&lt;String&gt; messages) &#123;// for(String msg:messages)&#123;// log.info(&quot;consumer:group4 --&gt; message:&#123;&#125;&quot;, msg);// &#125;// &#125;//// /**// * 监听topic并手动提交偏移量// * @param messages// * @param acknowledgment// */// @KafkaListener(id = &quot;id5&quot;, topics = Constant.TOPIC,groupId = &quot;group5&quot;)// public void kafkaListener(List&lt;String&gt; messages, Acknowledgment acknowledgment) &#123;// for(String msg:messages)&#123;// log.info(&quot;consumer:group5 --&gt; message:&#123;&#125;&quot;, msg);// &#125;// // 触发提交offset偏移量// acknowledgment.acknowledge();// &#125;//// /**// * 模糊匹配多个 Topic// * @param message// */// @KafkaListener(id = &quot;id6&quot;, topicPattern = &quot;test.*&quot;,groupId = &quot;group6&quot;)// public void annoListener2(String message) &#123;// log.error(&quot;consumer:group6 --&gt; message:&#123;&#125;&quot;, message);// &#125; /** * 完整consumer * @return */ @KafkaListener(id = &quot;id7&quot;, topics = &#123;Constant.TOPIC&#125;, groupId = &quot;group7&quot;) public boolean consumer4(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; data) &#123; for (int i=0; i&lt;data.size(); i++) &#123; ConsumerRecord&lt;?, ?&gt; record = data.get(i); Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value()); Long threadId = Thread.currentThread().getId(); if (kafkaMessage.isPresent()) &#123; Object message = kafkaMessage.get(); log.info(&quot;consumer:group7 --&gt; message:&#123;&#125;, topic:&#123;&#125;, partition:&#123;&#125;, key:&#123;&#125;, offset:&#123;&#125;, threadId:&#123;&#125;&quot;, message.toString(), record.topic(), record.partition(), record.key(), record.offset(), threadId); &#125; &#125; return true; &#125;&#125; 生产者服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Servicepublic class KafkaProducerService &#123; @Autowired private KafkaTemplate kafkaTemplate; /** * producer 同步方式发送数据 * @param topic topic名称 * @param key 一般用业务id，相同业务在同一partition保证消费顺序 * @param message producer发送的数据 */ public void sendMessageSync(String topic, String key, String message) throws InterruptedException, ExecutionException, TimeoutException &#123; // 默认轮询partition kafkaTemplate.send(topic, message).get(10, TimeUnit.SECONDS);// // 根据key进行hash运算，再将运算结果写入到不同partition// kafkaTemplate.send(topic, key, message).get(10, TimeUnit.SECONDS);// // 第二个参数为partition,当partition和key同时设置时partition优先。// kafkaTemplate.send(topic, 0, key, message);// // 组装消息// Message msg = MessageBuilder.withPayload(&quot;Send Message(payload,headers) Test&quot;)// .setHeader(KafkaHeaders.MESSAGE_KEY, key)// .setHeader(KafkaHeaders.TOPIC, topic)// .setHeader(KafkaHeaders.PREFIX,&quot;kafka_&quot;)// .build();// kafkaTemplate.send(msg).get(10, TimeUnit.SECONDS);// // 组装消息// ProducerRecord&lt;String, String&gt; producerRecord = new ProducerRecord&lt;&gt;(&quot;test&quot;, &quot;Send ProducerRecord(topic,value) Test&quot;);// kafkaTemplate.send(producerRecord).get(10, TimeUnit.SECONDS); &#125; /** * producer 异步方式发送数据 * @param topic topic名称 * @param message producer发送的数据 */ public void sendMessageAsync(String topic, String message) &#123; ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; future = kafkaTemplate.send(topic, message); // 设置异步发送消息获取发送结果后执行的动作 ListenableFutureCallback listenableFutureCallback = new ListenableFutureCallback&lt;SendResult&lt;Integer, String&gt;&gt;() &#123; @Override public void onSuccess(SendResult&lt;Integer, String&gt; result) &#123; System.out.println(&quot;success&quot;); &#125; @Override public void onFailure(Throwable ex) &#123; System.out.println(&quot;failure&quot;); &#125; &#125;; // 将listenableFutureCallback与异步发送消息对象绑定 future.addCallback(listenableFutureCallback); &#125; public void test(String topic, Integer partition, String key, String message) throws InterruptedException, ExecutionException, TimeoutException &#123; kafkaTemplate.send(topic, partition, key, message).get(10, TimeUnit.SECONDS); &#125;&#125; web测试 12345678910111213141516171819202122@RestControllerpublic class KafkaProducerController &#123; @Autowired private KafkaProducerService producerService; @GetMapping(&quot;/sync&quot;) public void sendMessageSync(@RequestParam String topic) throws InterruptedException, ExecutionException, TimeoutException &#123; producerService.sendMessageSync(topic, null, &quot;同步发送消息测试&quot;); &#125; @GetMapping(&quot;/async&quot;) public void sendMessageAsync()&#123; producerService.sendMessageAsync(&quot;test&quot;,&quot;异步发送消息测试&quot;); &#125; @GetMapping(&quot;/test&quot;) public void test(@RequestParam String topic, @RequestParam(required = false) Integer partition, @RequestParam(required = false) String key, @RequestParam String message) throws InterruptedException, ExecutionException, TimeoutException &#123; producerService.test(topic, partition, key, message); &#125;&#125; 7. AD 如果您觉得写的还不错，请关注公众号 【当我遇上你】, 您的支持是我最大的动力。 参考 https://bgbiao.top/post/kafka生产规划和运维/#11-kafka-topicssh https://blog.csdn.net/weixin_45778734/article/details/105710636","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"kafka","slug":"kafka","permalink":"https://idea360.cn/tags/kafka/"}]},{"title":"Docker实战之Zookeeper集群","slug":"docker-zookeeper-cluster","date":"2020-03-06T17:40:12.000Z","updated":"2020-03-15T03:53:27.741Z","comments":true,"path":"2020/03/07/docker-zookeeper-cluster/","link":"","permalink":"https://idea360.cn/2020/03/07/docker-zookeeper-cluster/","excerpt":"","text":"1. 概述 这里是Docker实战系列第四篇。主要介绍分布式系统中的元老级组件Zookeeper。 ZooKeeper 是一个开源的分布式协调服务，是Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。 读过 Docker实战之Consul集群 的小伙伴应该有印象，里边有一张一致性算法的对比图。所有的分布式系统都面临着CAP理论的抉择，都需要一致性算法的保障。这里先放上一个简单的总结，用于大家借鉴那些顶级开源软件在分布式上的思路。 分布式组件 算法/协议 服务 Redis Cluster Gossip master提供读写，slave只备份 Zookeeper ZAB Leader提供读写，Follower只读，遇到写请求转发给Leader Kafka ZK临时节点 只有leader提供读写服务 2. 应用场景 大致来说，zookeeper 的使用场景如下: 分布式协调 分布式锁 元数据/配置信息管理 HA高可用性 发布/订阅 负载均衡 Master选举 这里引用中华石杉老师的例子 2.1 分布式协调 这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。 2.2 分布式锁 举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。 2.3 元数据/配置信息管理 zookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？ 2.4 HA高可用性 这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。 3. Docker配置 docker-compose-zookeeper-cluster.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455version: &#x27;3.7&#x27;networks: docker_net: external: trueservices: zoo1: image: zookeeper restart: unless-stopped hostname: zoo1 container_name: zoo1 ports: - 2182:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=0.0.0.0:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 volumes: - ./zookeeper/zoo1/data:/data - ./zookeeper/zoo1/datalog:/datalog networks: - docker_net zoo2: image: zookeeper restart: unless-stopped hostname: zoo2 container_name: zoo2 ports: - 2183:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=zoo3:2888:3888;2181 volumes: - ./zookeeper/zoo2/data:/data - ./zookeeper/zoo2/datalog:/datalog networks: - docker_net zoo3: image: zookeeper restart: unless-stopped hostname: zoo3 container_name: zoo3 ports: - 2184:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181 volumes: - ./zookeeper/zoo3/data:/data - ./zookeeper/zoo3/datalog:/datalog networks: - docker_net 启动集群 1docker-compose -f docker-compose-zookeeper-cluster.yml up -d 4. 集群初认识 在ZAB算法中，存在Leader、Follower、Observer三种角色，现在我们就来认识下它们。 查看zoo1角色 123456➜ docker docker exec -it zoo1 /bin/sh# zkServer.sh status ZooKeeper JMX enabled by defaultUsing config: /conf/zoo.cfgClient port found: 2181. Client address: localhost.Mode: follower 由上结果可知，zoo1是follower 查看zoo2角色 123456➜ docker docker exec -it zoo2 /bin/sh# zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /conf/zoo.cfgClient port found: 2181. Client address: localhost.Mode: follower 由上结果可知，zoo2是follower 查看zoo3角色 123456➜ docker docker exec -it zoo3 /bin/sh# zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /conf/zoo.cfgClient port found: 2181. Client address: localhost.Mode: leader 由上结果可知，zoo3是leader。负责集群的读写。 查看zoo3选举数据 1234567891011➜ docker echo srvr | nc localhost 2184Zookeeper version: 3.5.6-c11b7e26bc554b8523dc929761dd28808913f091, built on 10/08/2019 20:18 GMTLatency min/avg/max: 0/0/0Received: 2Sent: 1Connections: 1Outstanding: 0Zxid: 0x100000000Mode: leaderNode count: 5Proposal sizes last/min/max: -1/-1/-1 查看映射数据 如果实践了上述操作的小伙伴一定会发现，映射路径下的文件夹多了好多东西，感兴趣的小伙伴可以打开看一下，了解下ZAB的选举算法(没错，里边记录的就是选举相关的数据)。 1234567891011➜ zookeeper cd zoo1➜ zoo1 tree.├── data│ ├── myid│ └── version-2│ ├── acceptedEpoch│ ├── currentEpoch│ └── snapshot.0└── datalog └── version-2 注意：留意currentEpoch中的数值 5. 选举演练 5.1 模拟Leader掉线 12➜ zoo1 docker stop zoo3zoo3 查看此时的选举结果(操作同查看角色操作步骤)。可以看到Zookeeper集群重新选举结果: zoo2被选为leader 5.2 zoo3节点重新上线 12➜ zoo1 docker start zoo3zoo3 查看zoo3角色，发现zoo3自动作为follower加入集群。 注意：查看currentEpoch中的数值，存储值为2，代表经过了2次选举。第一次为刚启动时触发选举，第二次为leader宕机后重新选举 6. 常用操作 6.1 查看文件目录 笔者本地有安装的Zookeeper环境，所以这里用本地的zkCli进行测试。 12345678910zkCli -server localhost:2182,localhost:2183,localhost:2184Connecting to localhost:2182,localhost:2183,localhost:2184Welcome to ZooKeeper!JLine support is enabledWATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 0] ls /[zookeeper] 6.2 创建顺序节点 顺序节点保证znode路径将是唯一的。 1234[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 1] create -s /zk-test 123Created /zk-test0000000000[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 2] ls /[zk-test0000000000, zookeeper] 6.3 创建临时节点 当会话过期或客户端断开连接时，临时节点将被自动删除 1234[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 3] create -e /zk-temp 123Created /zk-temp[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 4] ls /[zk-test0000000000, zookeeper, zk-temp] 临时节点在客户端会话结束后就会自动删除，下面使用quit命令行退出客户端,再次连接后即可验证。 123456789101112[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 5] quitQuitting...➜ docker zkCli -server localhost:2182,localhost:2183,localhost:2184Connecting to localhost:2182,localhost:2183,localhost:2184Welcome to ZooKeeper!JLine support is enabledWATCHER::WatchedEvent state:SyncConnected type:None path:null[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 0] ls /[zk-test0000000000, zookeeper] 6.4 创建永久节点 1234[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 1] create /zk-permanent 123Created /zk-permanent[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 2] ls /[zk-permanent, zk-test0000000000, zookeeper] 6.5 读取节点 1234567891011121314151617181920212223242526[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 3] get /cZxid = 0x0ctime = Thu Jan 01 08:00:00 CST 1970mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x400000008cversion = 3dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 0numChildren = 3[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 4] ls2 /[zk-permanent, zk-test0000000000, zookeeper]cZxid = 0x0ctime = Thu Jan 01 08:00:00 CST 1970mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x400000008cversion = 3dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 0numChildren = 3 使用 ls2 命令来查看某个目录包含的所有文件，与ls不同的是它查看到time、version等信息 6.6 更新节点 123456789101112[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 5] set /zk-permanent 456cZxid = 0x400000008ctime = Tue Mar 03 21:35:20 CST 2020mZxid = 0x400000009mtime = Tue Mar 03 21:40:11 CST 2020pZxid = 0x400000008cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 3numChildren = 0 6.7 检查状态 123456789101112[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 6] stat /zk-permanentcZxid = 0x400000008ctime = Tue Mar 03 21:35:20 CST 2020mZxid = 0x400000009mtime = Tue Mar 03 21:40:11 CST 2020pZxid = 0x400000008cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 3numChildren = 0 6.8 删除节点 123[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 7] rmr /zk-permanent[zk: localhost:2182,localhost:2183,localhost:2184(CONNECTED) 8] ls /[zk-test0000000000, zookeeper] 7. AD 公众号【当我遇上你】, 每天带给你不一样的内容","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://idea360.cn/tags/zookeeper/"}]},{"title":"Docker实战之Consul集群","slug":"docker-consul-cluster","date":"2020-03-06T17:39:59.000Z","updated":"2021-02-23T14:16:45.769Z","comments":true,"path":"2020/03/07/docker-consul-cluster/","link":"","permalink":"https://idea360.cn/2020/03/07/docker-consul-cluster/","excerpt":"","text":"前言 最近参加了几场Java面试，发现大多数的微服务实践还是Eureka偏多，鉴于笔者的单位选型Consul，这里对Consul做简单总结。 该篇是Docker实战系列的第三篇。传送门: Docker实战之MySQL主从复制 Docker实战之Redis-Cluster集群 为什么选Consul？ 首先Consul有以下几个关键特性: 服务发现：支持服务发现。你可以通过 DNS 或 HTTP 的方式获取服务信息。 健康检查：支持健康检查。可以提供与给定服务相关联的任何数量的健康检查（如 web 状态码或 cpu 使用率）。 K/V 存储：键/值对存储。你可用通过 consul 存储如动态配置之类的相关信息。 多数据中心：支持多数据中心，开箱即用。 WEB-UI：支持WEB-UI。点点点，你就能够了解你的服务现在的运行情况，一目了然，对开发运维是非常友好的。 作为高频的提问方式，面试官永远从十万个为什么开始。但是最为程序员，还是需要知其然，知其所以然。以下是几个常用的服务发现组件的对比。 服务发现组件的选型主要从以下几个方面进行。CAP理论、一致性算法、多数据中心、健康检查、是否支持k8s等。 1. CAP 一致性的强制数据统一要求，必然会导致在更新数据时部分节点处于被锁定状态，此时不可对外提供服务，影响了服务的可用性。 2. 一致性算法 Raft算法将Server分为三种类型：Leader、Follower和Candidate。Leader处理所有的查询和事务，并向Follower同步事务。Follower会将所有的RPC查询和事务转发给Leader处理，它仅从Leader接受事务的同步。数据的一致性以Leader中的数据为准实现。 以下是几种常见的一致性算法 3. 多数据中心 Consul 通过 WAN 的Gossip协议，完成跨数据中心的同步；而其他的产品则需要额外的开发工作来实现； 注意多数据中心和多节点是2个概念 Gossip协议是P2P网络中比较成熟的协议。Gossip协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许Consul管理的集群规模能横向扩展到数千个节点。 Consul的每个Agent会利用Gossip协议互相检查在线状态，本质上是节点之间互Ping，分担了服务器节点的心跳压力。如果有节点掉线，不用服务器节点检查，其他普通节点会发现，然后用Gossip广播给整个集群。 Consul架构 consul 的架构是什么，官方给出了一个很直观的图片 单独看数据中心1，可以看出consul的集群是由N个SERVER，加上M个CLIENT组成的。而不管是SERVER还是CLIENT，都是consul的一个节点，所有的服务都可以注册到这些节点上，正是通过这些节点实现服务注册信息的共享。除了这两个，还有一些小细节，一一简单介绍。 CLIENT CLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。 SERVER SERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。 SERVER-LEADER 中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。 Docker环境搭建 docker-compose-consul-cluster.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546version: &#x27;3&#x27;services: consul-server1: image: consul:latest hostname: &quot;consul-server1&quot; ports: - &quot;8500:8500&quot; - &quot;53&quot; volumes: - ./consul/data1:/consul/data command: &quot;agent -server -bootstrap-expect 3 -ui -disable-host-node-id -client 0.0.0.0&quot; consul-server2: image: consul:latest hostname: &quot;consul-server2&quot; ports: - &quot;8501:8500&quot; - &quot;53&quot; volumes: - ./consul/data2:/consul/data command: &quot;agent -server -ui -join consul-server1 -disable-host-node-id -client 0.0.0.0&quot; depends_on: - consul-server1 consul-server3: image: consul:latest hostname: &quot;consul-server3&quot; ports: - &quot;8502:8500&quot; - &quot;53&quot; volumes: - ./consul/data3:/consul/data command: &quot;agent -server -ui -join consul-server1 -disable-host-node-id -client 0.0.0.0&quot; depends_on: - consul-server1 consul-node1: image: consul:latest hostname: &quot;consul-node1&quot; command: &quot;agent -join consul-server1 -disable-host-node-id&quot; depends_on: - consul-server1 consul-node2: image: consul:latest hostname: &quot;consul-node2&quot; command: &quot;agent -join consul-server1 -disable-host-node-id&quot; depends_on: - consul-server1 执行 docker-compose -f docker-compose-consul-cluster.yml up -d 启动，然后访问 http://localhost:8500 看到下图即启动成功 最后 Docker实战系列皆以快速搭建学习环境为主，Consul的特性学习及生产环境配置还任重道远。阅读过程中如有疑问或错误，还望多多指正。","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"consul","slug":"consul","permalink":"https://idea360.cn/tags/consul/"}]},{"title":"Docker实战之Redis-Cluster集群","slug":"docker-redis-cluster","date":"2020-03-06T17:39:38.000Z","updated":"2020-03-15T03:53:23.407Z","comments":true,"path":"2020/03/07/docker-redis-cluster/","link":"","permalink":"https://idea360.cn/2020/03/07/docker-redis-cluster/","excerpt":"","text":"概述 接上一篇Docker实战之MySQL主从复制, 这里是Docker实战系列的第二篇，主要进行Redis-Cluster集群环境的快速搭建。Redis作为基于键值对的NoSQL数据库，具有高性能、丰富的数据结构、持久化、高可用、分布式等特性，同时Redis本身非常稳定，已经得到业界的广泛认可和使用。 在Redis中，集群的解决方案有三种 主从复制 哨兵机制 Cluster Redis Cluster是Redis的分布式解决方案，在 3.0 版本正式推出。 集群方案的对比 1. 主从复制 同Mysql主从复制的原因一样，Redis虽然读取写入的速度都特别快，但是也会产生读压力特别大的情况。为了分担读压力，Redis支持主从复制，读写分离。一个Master可以有多个Slaves。 优点 数据备份 读写分离，提高服务器性能 缺点 不能自动故障恢复,RedisHA系统（需要开发） 无法实现动态扩容 2. 哨兵机制 Redis Sentinel是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群。 其中Redis Sentinel集群是由若干Sentinel节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel的节点数量要满足2n+1（n&gt;=1）的奇数个。 优点 自动化故障恢复 缺点 Redis 数据节点中 slave 节点作为备份节点不提供服务 无法实现动态扩容 3. Redis-Cluster Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。 Redis Cluster着眼于提高并发量。 群集至少需要3主3从，且每个实例使用不同的配置文件。 在redis-cluster架构中，redis-master节点一般用于接收读写，而redis-slave节点则一般只用于备份， 其与对应的master拥有相同的slot集合，若某个redis-master意外失效，则再将其对应的slave进行升级为临时redis-master。 在redis的官方文档中，对redis-cluster架构上，有这样的说明：在cluster架构下，默认的，一般redis-master用于接收读写，而redis-slave则用于备份，当有请求是在向slave发起时，会直接重定向到对应key所在的master来处理。 但如果不介意读取的是redis-cluster中有可能过期的数据并且对写请求不感兴趣时，则亦可通过readonly命令，将slave设置成可读，然后通过slave获取相关的key，达到读写分离。具体可以参阅redis官方文档等相关内容 优点 解决分布式负载均衡的问题。具体解决方案是分片/虚拟槽slot。 可实现动态扩容 P2P模式，无中心化 缺点 为了性能提升，客户端需要缓存路由表信息 Slave在集群中充当“冷备”，不能缓解读压力 网络规划 这里没有搭建虚拟机环境，全部在本地部署。本机的ip为 192.168.124.5 ip port 192.168.124.5 7001 192.168.124.5 7002 192.168.124.5 7003 192.168.124.5 7004 192.168.124.5 7005 192.168.124.5 7006 Redis配置文件 在docker环境中，配置文件映射宿主机的时候，(宿主机)必须有配置文件。附件在这里。大家可以根据自己的需求定制配置文件。 下边是我的配置文件 redis-cluster.tmpl 12345678910111213141516171819202122232425# redis端口port $&#123;PORT&#125;# 关闭保护模式protected-mode no# 开启集群cluster-enabled yes# 集群节点配置cluster-config-file nodes.conf# 超时cluster-node-timeout 5000# 集群节点IP host模式为宿主机IPcluster-announce-ip 192.168.124.5# 集群节点端口 7001 - 7006cluster-announce-port $&#123;PORT&#125;cluster-announce-bus-port 1$&#123;PORT&#125;# 开启 appendonly 备份模式appendonly yes# 每秒钟备份appendfsync everysec# 对aof文件进行压缩时，是否执行同步操作no-appendfsync-on-rewrite no# 当目前aof文件大小超过上一次重写时的aof文件大小的100%时会再次进行重写auto-aof-rewrite-percentage 100# 重写前AOF文件的大小最小值 默认 64mbauto-aof-rewrite-min-size 64mb 由于节点IP相同，只有端口上的差别，现在通过脚本 redis-cluster-config.sh 批量生成配置文件 12345for port in `seq 7001 7006`; do \\ mkdir -p ./redis-cluster/$&#123;port&#125;/conf \\ &amp;&amp; PORT=$&#123;port&#125; envsubst &lt; ./redis-cluster.tmpl &gt; ./redis-cluster/$&#123;port&#125;/conf/redis.conf \\ &amp;&amp; mkdir -p ./redis-cluster/$&#123;port&#125;/data; \\done 生成的配置文件如下图 Docker环境搭建 这里还是通过docker-compose进行测试环境的docker编排。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798version: &#x27;3.7&#x27;services: redis7001: image: &#x27;redis&#x27; container_name: redis7001 command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;] volumes: - ./redis-cluster/7001/conf/redis.conf:/usr/local/etc/redis/redis.conf - ./redis-cluster/7001/data:/data ports: - &quot;7001:7001&quot; - &quot;17001:17001&quot; environment: # 设置时区为上海，否则时间会有问题 - TZ=Asia/Shanghai redis7002: image: &#x27;redis&#x27; container_name: redis7002 command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;] volumes: - ./redis-cluster/7002/conf/redis.conf:/usr/local/etc/redis/redis.conf - ./redis-cluster/7002/data:/data ports: - &quot;7002:7002&quot; - &quot;17002:17002&quot; environment: # 设置时区为上海，否则时间会有问题 - TZ=Asia/Shanghai redis7003: image: &#x27;redis&#x27; container_name: redis7003 command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;] volumes: - ./redis-cluster/7003/conf/redis.conf:/usr/local/etc/redis/redis.conf - ./redis-cluster/7003/data:/data ports: - &quot;7003:7003&quot; - &quot;17003:17003&quot; environment: # 设置时区为上海，否则时间会有问题 - TZ=Asia/Shanghai redis7004: image: &#x27;redis&#x27; container_name: redis7004 command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;] volumes: - ./redis-cluster/7004/conf/redis.conf:/usr/local/etc/redis/redis.conf - ./redis-cluster/7004/data:/data ports: - &quot;7004:7004&quot; - &quot;17004:17004&quot; environment: # 设置时区为上海，否则时间会有问题 - TZ=Asia/Shanghai redis7005: image: &#x27;redis&#x27; container_name: redis7005 command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;] volumes: - ./redis-cluster/7005/conf/redis.conf:/usr/local/etc/redis/redis.conf - ./redis-cluster/7005/data:/data ports: - &quot;7005:7005&quot; - &quot;17005:17005&quot; environment: # 设置时区为上海，否则时间会有问题 - TZ=Asia/Shanghai redis7006: image: &#x27;redis&#x27; container_name: redis7006 command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;] volumes: - ./redis-cluster/7006/conf/redis.conf:/usr/local/etc/redis/redis.conf - ./redis-cluster/7006/data:/data ports: - &quot;7006:7006&quot; - &quot;17006:17006&quot; environment: # 设置时区为上海，否则时间会有问题 - TZ=Asia/Shanghai 启动结果如图 集群配置 redis集群官方提供了配置脚本，4.x和5.x略有不同，具体可参见集群配置 下边是我自己的环境 1docker exec -it redis7001 redis-cli -p 7001 -a 123456 --cluster create 192.168.124.5:7001 192.168.124.5:7002 192.168.124.5:7003 192.168.124.5:7004 192.168.124.5:7005 192.168.124.5:7006 --cluster-replicas 1 看到如下结果说明集群配置成功 集群测试 接下来进行一些集群的基本测试 1. 查看集群通信是否正常 redis7001主节点对它的副本节点redis7005进行ping操作。 -h host -p port -a pwd 1234➜ docker docker exec -it redis7001 redis-cli -h 192.168.124.5 -p 7005 -a 123456 pingWarning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.PONG 2. 测试简单存储 redis7001主节点客户端操作redis7003主节点 12345➜ docker docker exec -it redis7001 redis-cli -h 192.168.124.5 -p 7003 -a 123456Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.192.168.124.5:7003&gt; set name admin(error) MOVED 5798 192.168.124.5:7002 由于Redis Cluster会根据key进行hash运算，然后将key分散到不同slots，name的hash运算结果在redis7002节点上的slots中。所以我们操作redis7003写操作会自动路由到7002。然而error提示无法路由？没关系，差一个 -c 参数而已。 再次运行查看结果如下: 123456789➜ docker docker exec -it redis7001 redis-cli -h 192.168.124.5 -p 7003 -a 123456 -cWarning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.192.168.124.5:7003&gt; set name admin-&gt; Redirected to slot [5798] located at 192.168.124.5:7002OK192.168.124.5:7002&gt; get name&quot;admin&quot;192.168.124.5:7002&gt; 3. 查看集群状态 4. 查看slots分片 5. 查看集群信息 6. 测试读写分离 试试看，发现读不到，原来在redis cluster中，如果你要在slave读取数据，那么需要带先执行 readonly 指令，然后 get key 7. 简单压测 选项 描述 -t 指定命令 -c 客户端连接数 -n 总请求数 -d set、get的value大小(单位byte) 测试如下 1234567891011121314➜ docker docker exec -it redis7001 bashroot@cbc6e76a3ed2:/data# redis-benchmark -h 192.168.124.5 -p 7001 -t set -c 100 -n 50000 -d 20====== SET ====== 50000 requests completed in 10.65 seconds 100 parallel clients 20 bytes payload keep alive: 10.00% &lt;= 2 milliseconds0.01% &lt;= 3 milliseconds...100.00% &lt;= 48 milliseconds100.00% &lt;= 49 milliseconds4692.63 requests per second 这里没啥实际意义，在工作业务上大家可以根据QPS和主机配置进行压测，计算规划出节点数量。 容灾演练 现在我们杀掉主节点redis7001，看从节点redis7005是否会接替它的位置。 1docker stop redis7001 再试着启动7001，它将自动作为slave挂载到7005 SpringBoot配置Redis集群 在SpringBoot2.x版本中，redis默认的连接池已经更换为Lettuce，而不再是jedis。 1. 在pom.xml中引入相关依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 2. application.yml 12345678910111213141516171819202122spring: redis: timeout: 6000 password: 123456 cluster: max-redirects: 3 # 获取失败 最大重定向次数 nodes: - 192.168.124.5:7001 - 192.168.124.5:7002 - 192.168.124.5:7003 - 192.168.124.5:7004 - 192.168.124.5:7005 - 192.168.124.5:7006 lettuce: pool: max-active: 1000 #连接池最大连接数（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 5 # 连接池中的最小空闲连接 max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） cache: jcache: config: classpath:ehcache.xml 3. redis配置 123456789101112@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)public class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisCacheTemplate(LettuceConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 4. 基本测试 12345678910111213@SpringBootTestpublic class RedisTest &#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; @Test public void test() &#123; redisTemplate.opsForValue().set(&quot;name&quot;, &quot;admin&quot;); String name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(name); //输出admin &#125;&#125; 总结 通过以上演示，基本上可以在本地环境下用我们的Redis Cluster集群了。最后再上一张本地映射文件的最终样子，帮助大家了解Redis持久化及集群相关的东西。感兴趣的小伙伴可以自行测试并查看其中的内容。 内容如有错漏，还望大家不吝赐教，同时，欢迎大家关注公众号【当我遇上你】,你们的支持就是我写作的最大动力。 参考 https://redis.io/topics/cluster-tutorial","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://idea360.cn/tags/redis/"},{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"}]},{"title":"Docker实战之MySQL主从复制","slug":"docker-mysql-master-slave","date":"2020-03-06T17:39:12.000Z","updated":"2020-03-15T03:53:18.837Z","comments":true,"path":"2020/03/07/docker-mysql-master-slave/","link":"","permalink":"https://idea360.cn/2020/03/07/docker-mysql-master-slave/","excerpt":"","text":"前言 曾几何时，看着高大上的架构和各位前辈高超的炫技，有没有怦然心动，也想一窥究竟？每当面试的时候，拿着单应用的架构，吹着分库分表的牛X，有没有心里慌的一批？ 其实很多时候，我们所缺少的只是对高大上的技术的演练。没有相关的业务需求，没有集群环境，然后便只是Google几篇博文，看下原理，便算是了解了。然而真的明白了吗？众多的复制粘贴中，那篇文章才对我们有用，哪些又是以讹传讹？ 所幸容器技术的快速发展，让各种技术的模拟成为现实。接下来Docker相关的一系列文章，将以实战为主，帮助大家快速搭建测试和演练环境。 Docker文件编排 由于是测试为了演练用，这里用docker-compose进行配置文件的编排，实际的集群环境中并不是这么部署的。 编排docker-compose-mysql-cluster.yml,安装master和slave节点 1234567891011121314151617181920212223242526version: &#x27;3&#x27;services: mysql-master: image: mysql:5.7 container_name: mysql-master environment: - MYSQL_ROOT_PASSWORD=root ports: - &quot;3307:3306&quot; volumes: - &quot;./mysql/master/my.cnf:/etc/my.cnf&quot; - &quot;./mysql/master/data:/var/lib/mysql&quot; links: - mysql-slave mysql-slave: image: mysql:5.7 container_name: mysql-slave environment: - MYSQL_ROOT_PASSWORD=root ports: - &quot;3308:3306&quot; volumes: - &quot;./mysql/slave/my.cnf:/etc/my.cnf&quot; - &quot;./mysql/slave/data:/var/lib/mysql&quot; 配置master配置文件my.cnf 1234567[mysqld]# [必须]启用二进制日志log-bin&#x3D;mysql-bin # [必须]服务器唯一ID，默认是1，一般取IP最后一段 server-id&#x3D;1## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db&#x3D;mysql 配置slave配置文件my.cnf 123[mysqld]# [必须]服务器唯一ID，默认是1，一般取IP最后一段 server-id&#x3D;2 启动docker-compose，创建docker镜像文件 1docker-compose -f docker-compose-mysql-cluster.yml up -d docker ps查看进程，可以看到2个实例已启动。 123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1f4ad96b4d5e mysql:5.7 &quot;docker-entrypoint.s…&quot; 48 seconds ago Up 46 seconds 33060&#x2F;tcp, 0.0.0.0:3307-&gt;3306&#x2F;tcp mysql-master8e2214aacc43 mysql:5.7 &quot;docker-entrypoint.s…&quot; 49 seconds ago Up 47 seconds 33060&#x2F;tcp, 0.0.0.0:3308-&gt;3306&#x2F;tcp mysql-slave 配置主从复制 配置master 配置slave 这时候就可以运行一些 SQL 语句来验证同步服务是否正常了。 验证主从复制 master创建db 查看slave是否同步创建 由结果可知，已完成MySQL主从复制环境的搭建。 读写分离 MySQL主从复制是其自己的功能，实现读写分离就得依靠其他组件了，比如sharding-jdbc。但是sharding-jdbc只是实现读写分离，本身的权限控制还是需要MySQL这边来配置的。 配置master账户及权限 创建帐号并授予读写权限 123CREATE USER &#39;master&#39;@&#39;%&#39; IDENTIFIED BY &#39;Password123&#39;;GRANT select,insert,update,delete ON *.* TO &#39;master&#39;@&#39;%&#39;;flush privileges; 配置slave账户及权限 创建帐号并授予只读权限 1234use mysql;CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;Password123&#39;;GRANT select ON *.* TO &#39;slave&#39;@&#39;%&#39;;FLUSH PRIVILEGES; 最后 这篇文章以搭建环境为主，后续会继续完善故障转移、分库分表、数据平滑迁移等相关演练。菜鸟博客，不尽完善，希望大家不吝赐教。同时欢迎大家关注小生的公众号【当我遇上你】。","categories":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"}]}],"categories":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/categories/tools/"},{"name":"spring","slug":"spring","permalink":"https://idea360.cn/categories/spring/"},{"name":"sql","slug":"sql","permalink":"https://idea360.cn/categories/sql/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/categories/java/"},{"name":"junit","slug":"junit","permalink":"https://idea360.cn/categories/junit/"},{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/categories/jvm/"},{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/categories/mysql/"},{"name":"git","slug":"git","permalink":"https://idea360.cn/categories/git/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/categories/springboot/"},{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"nacos","slug":"nacos","permalink":"https://idea360.cn/categories/nacos/"},{"name":"docker","slug":"docker","permalink":"https://idea360.cn/categories/docker/"},{"name":"生活","slug":"生活","permalink":"https://idea360.cn/categories/%E7%94%9F%E6%B4%BB/"},{"name":"Java面试全解析","slug":"Java面试全解析","permalink":"https://idea360.cn/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/"},{"name":"ajax","slug":"ajax","permalink":"https://idea360.cn/categories/ajax/"},{"name":"css","slug":"css","permalink":"https://idea360.cn/categories/css/"},{"name":"activiti","slug":"activiti","permalink":"https://idea360.cn/categories/activiti/"},{"name":"微信","slug":"微信","permalink":"https://idea360.cn/categories/%E5%BE%AE%E4%BF%A1/"},{"name":"算法","slug":"算法","permalink":"https://idea360.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"redis","slug":"redis","permalink":"https://idea360.cn/categories/redis/"},{"name":"公众号","slug":"公众号","permalink":"https://idea360.cn/categories/%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"maven","slug":"maven","permalink":"https://idea360.cn/categories/maven/"},{"name":"dubbo","slug":"dubbo","permalink":"https://idea360.cn/categories/dubbo/"},{"name":"oracle","slug":"oracle","permalink":"https://idea360.cn/categories/oracle/"},{"name":"devops","slug":"devops","permalink":"https://idea360.cn/categories/devops/"},{"name":"k8s","slug":"k8s","permalink":"https://idea360.cn/categories/k8s/"},{"name":"数据结构","slug":"数据结构","permalink":"https://idea360.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/categories/%E6%BA%90%E7%A0%81/"},{"name":"并发","slug":"并发","permalink":"https://idea360.cn/categories/%E5%B9%B6%E5%8F%91/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/categories/%E9%9D%A2%E8%AF%95/"},{"name":"php","slug":"php","permalink":"https://idea360.cn/categories/php/"},{"name":"nodejs","slug":"nodejs","permalink":"https://idea360.cn/categories/nodejs/"},{"name":"实战","slug":"实战","permalink":"https://idea360.cn/categories/%E5%AE%9E%E6%88%98/"},{"name":"JVM","slug":"JVM","permalink":"https://idea360.cn/categories/JVM/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://idea360.cn/tags/tools/"},{"name":"idea","slug":"idea","permalink":"https://idea360.cn/tags/idea/"},{"name":"插件","slug":"插件","permalink":"https://idea360.cn/tags/%E6%8F%92%E4%BB%B6/"},{"name":"spring","slug":"spring","permalink":"https://idea360.cn/tags/spring/"},{"name":"拦截器","slug":"拦截器","permalink":"https://idea360.cn/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"源码","slug":"源码","permalink":"https://idea360.cn/tags/%E6%BA%90%E7%A0%81/"},{"name":"HandlerInterceptor","slug":"HandlerInterceptor","permalink":"https://idea360.cn/tags/HandlerInterceptor/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://idea360.cn/tags/Interceptor/"},{"name":"springboot","slug":"springboot","permalink":"https://idea360.cn/tags/springboot/"},{"name":"nacos","slug":"nacos","permalink":"https://idea360.cn/tags/nacos/"},{"name":"springcloud","slug":"springcloud","permalink":"https://idea360.cn/tags/springcloud/"},{"name":"灰度","slug":"灰度","permalink":"https://idea360.cn/tags/%E7%81%B0%E5%BA%A6/"},{"name":"ribbon","slug":"ribbon","permalink":"https://idea360.cn/tags/ribbon/"},{"name":"gray","slug":"gray","permalink":"https://idea360.cn/tags/gray/"},{"name":"规范","slug":"规范","permalink":"https://idea360.cn/tags/%E8%A7%84%E8%8C%83/"},{"name":"sql","slug":"sql","permalink":"https://idea360.cn/tags/sql/"},{"name":"log","slug":"log","permalink":"https://idea360.cn/tags/log/"},{"name":"日志","slug":"日志","permalink":"https://idea360.cn/tags/%E6%97%A5%E5%BF%97/"},{"name":"valid","slug":"valid","permalink":"https://idea360.cn/tags/valid/"},{"name":"RequestBodyAdvice","slug":"RequestBodyAdvice","permalink":"https://idea360.cn/tags/RequestBodyAdvice/"},{"name":"junit","slug":"junit","permalink":"https://idea360.cn/tags/junit/"},{"name":"MockMVC","slug":"MockMVC","permalink":"https://idea360.cn/tags/MockMVC/"},{"name":"单元测试","slug":"单元测试","permalink":"https://idea360.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"api","slug":"api","permalink":"https://idea360.cn/tags/api/"},{"name":"docs","slug":"docs","permalink":"https://idea360.cn/tags/docs/"},{"name":"javaparser","slug":"javaparser","permalink":"https://idea360.cn/tags/javaparser/"},{"name":"监控","slug":"监控","permalink":"https://idea360.cn/tags/%E7%9B%91%E6%8E%A7/"},{"name":"调优","slug":"调优","permalink":"https://idea360.cn/tags/%E8%B0%83%E4%BC%98/"},{"name":"jvm","slug":"jvm","permalink":"https://idea360.cn/tags/jvm/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://idea360.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"类加载机制","slug":"类加载机制","permalink":"https://idea360.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"name":"内存结构","slug":"内存结构","permalink":"https://idea360.cn/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"},{"name":"内存模型","slug":"内存模型","permalink":"https://idea360.cn/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"MySQL","slug":"MySQL","permalink":"https://idea360.cn/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"https://idea360.cn/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"索引","slug":"索引","permalink":"https://idea360.cn/tags/%E7%B4%A2%E5%BC%95/"},{"name":"mysql","slug":"mysql","permalink":"https://idea360.cn/tags/mysql/"},{"name":"left join","slug":"left-join","permalink":"https://idea360.cn/tags/left-join/"},{"name":"连表","slug":"连表","permalink":"https://idea360.cn/tags/%E8%BF%9E%E8%A1%A8/"},{"name":"分页","slug":"分页","permalink":"https://idea360.cn/tags/%E5%88%86%E9%A1%B5/"},{"name":"java","slug":"java","permalink":"https://idea360.cn/tags/java/"},{"name":"文档","slug":"文档","permalink":"https://idea360.cn/tags/%E6%96%87%E6%A1%A3/"},{"name":"extract javadoc comment","slug":"extract-javadoc-comment","permalink":"https://idea360.cn/tags/extract-javadoc-comment/"},{"name":"git","slug":"git","permalink":"https://idea360.cn/tags/git/"},{"name":"sort","slug":"sort","permalink":"https://idea360.cn/tags/sort/"},{"name":"排序","slug":"排序","permalink":"https://idea360.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"序号","slug":"序号","permalink":"https://idea360.cn/tags/%E5%BA%8F%E5%8F%B7/"},{"name":"gateway","slug":"gateway","permalink":"https://idea360.cn/tags/gateway/"},{"name":"网关","slug":"网关","permalink":"https://idea360.cn/tags/%E7%BD%91%E5%85%B3/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"https://idea360.cn/tags/Spring-Cloud/"},{"name":"delay","slug":"delay","permalink":"https://idea360.cn/tags/delay/"},{"name":"延时","slug":"延时","permalink":"https://idea360.cn/tags/%E5%BB%B6%E6%97%B6/"},{"name":"tree","slug":"tree","permalink":"https://idea360.cn/tags/tree/"},{"name":"树结构","slug":"树结构","permalink":"https://idea360.cn/tags/%E6%A0%91%E7%BB%93%E6%9E%84/"},{"name":"数","slug":"数","permalink":"https://idea360.cn/tags/%E6%95%B0/"},{"name":"java8","slug":"java8","permalink":"https://idea360.cn/tags/java8/"},{"name":"starter","slug":"starter","permalink":"https://idea360.cn/tags/starter/"},{"name":"接口","slug":"接口","permalink":"https://idea360.cn/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"validator","slug":"validator","permalink":"https://idea360.cn/tags/validator/"},{"name":"异常","slug":"异常","permalink":"https://idea360.cn/tags/%E5%BC%82%E5%B8%B8/"},{"name":"统一","slug":"统一","permalink":"https://idea360.cn/tags/%E7%BB%9F%E4%B8%80/"},{"name":"线程池","slug":"线程池","permalink":"https://idea360.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"thread","slug":"thread","permalink":"https://idea360.cn/tags/thread/"},{"name":"threadPool","slug":"threadPool","permalink":"https://idea360.cn/tags/threadPool/"},{"name":"config","slug":"config","permalink":"https://idea360.cn/tags/config/"},{"name":"配置","slug":"配置","permalink":"https://idea360.cn/tags/%E9%85%8D%E7%BD%AE/"},{"name":"jcl","slug":"jcl","permalink":"https://idea360.cn/tags/jcl/"},{"name":"logback","slug":"logback","permalink":"https://idea360.cn/tags/logback/"},{"name":"appender","slug":"appender","permalink":"https://idea360.cn/tags/appender/"},{"name":"sdk","slug":"sdk","permalink":"https://idea360.cn/tags/sdk/"},{"name":"security","slug":"security","permalink":"https://idea360.cn/tags/security/"},{"name":"FilterChain","slug":"FilterChain","permalink":"https://idea360.cn/tags/FilterChain/"},{"name":"过滤器链","slug":"过滤器链","permalink":"https://idea360.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE/"},{"name":"filter","slug":"filter","permalink":"https://idea360.cn/tags/filter/"},{"name":"shiro","slug":"shiro","permalink":"https://idea360.cn/tags/shiro/"},{"name":"链路跟踪","slug":"链路跟踪","permalink":"https://idea360.cn/tags/%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/"},{"name":"DelegatingFilterProxy","slug":"DelegatingFilterProxy","permalink":"https://idea360.cn/tags/DelegatingFilterProxy/"},{"name":"序列化","slug":"序列化","permalink":"https://idea360.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"反序列化","slug":"反序列化","permalink":"https://idea360.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"动态","slug":"动态","permalink":"https://idea360.cn/tags/%E5%8A%A8%E6%80%81/"},{"name":"表单","slug":"表单","permalink":"https://idea360.cn/tags/%E8%A1%A8%E5%8D%95/"},{"name":"bean","slug":"bean","permalink":"https://idea360.cn/tags/bean/"},{"name":"注解","slug":"注解","permalink":"https://idea360.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"生命周期","slug":"生命周期","permalink":"https://idea360.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"xml","slug":"xml","permalink":"https://idea360.cn/tags/xml/"},{"name":"基础","slug":"基础","permalink":"https://idea360.cn/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Enable","slug":"Enable","permalink":"https://idea360.cn/tags/Enable/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://idea360.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"vim","slug":"vim","permalink":"https://idea360.cn/tags/vim/"},{"name":"快捷键","slug":"快捷键","permalink":"https://idea360.cn/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"cache","slug":"cache","permalink":"https://idea360.cn/tags/cache/"},{"name":"缓存","slug":"缓存","permalink":"https://idea360.cn/tags/%E7%BC%93%E5%AD%98/"},{"name":"caffeine","slug":"caffeine","permalink":"https://idea360.cn/tags/caffeine/"},{"name":"spi","slug":"spi","permalink":"https://idea360.cn/tags/spi/"},{"name":"多线程","slug":"多线程","permalink":"https://idea360.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"异步","slug":"异步","permalink":"https://idea360.cn/tags/%E5%BC%82%E6%AD%A5/"},{"name":"CompletableFuture","slug":"CompletableFuture","permalink":"https://idea360.cn/tags/CompletableFuture/"},{"name":"excel","slug":"excel","permalink":"https://idea360.cn/tags/excel/"},{"name":"poi","slug":"poi","permalink":"https://idea360.cn/tags/poi/"},{"name":"prometheus","slug":"prometheus","permalink":"https://idea360.cn/tags/prometheus/"},{"name":"shell","slug":"shell","permalink":"https://idea360.cn/tags/shell/"},{"name":"脚本","slug":"脚本","permalink":"https://idea360.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"AsyncContext","slug":"AsyncContext","permalink":"https://idea360.cn/tags/AsyncContext/"},{"name":"设计模式","slug":"设计模式","permalink":"https://idea360.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://idea360.cn/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"打包","slug":"打包","permalink":"https://idea360.cn/tags/%E6%89%93%E5%8C%85/"},{"name":"http","slug":"http","permalink":"https://idea360.cn/tags/http/"},{"name":"feign","slug":"feign","permalink":"https://idea360.cn/tags/feign/"},{"name":"归档","slug":"归档","permalink":"https://idea360.cn/tags/%E5%BD%92%E6%A1%A3/"},{"name":"docker","slug":"docker","permalink":"https://idea360.cn/tags/docker/"},{"name":"elk","slug":"elk","permalink":"https://idea360.cn/tags/elk/"},{"name":"生活","slug":"生活","permalink":"https://idea360.cn/tags/%E7%94%9F%E6%B4%BB/"},{"name":"kafka","slug":"kafka","permalink":"https://idea360.cn/tags/kafka/"},{"name":"markdown","slug":"markdown","permalink":"https://idea360.cn/tags/markdown/"},{"name":"时序图","slug":"时序图","permalink":"https://idea360.cn/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/"},{"name":"面试","slug":"面试","permalink":"https://idea360.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"装饰者模式","slug":"装饰者模式","permalink":"https://idea360.cn/tags/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://idea360.cn/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://idea360.cn/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"https://idea360.cn/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"springmvc","slug":"springmvc","permalink":"https://idea360.cn/tags/springmvc/"},{"name":"validation","slug":"validation","permalink":"https://idea360.cn/tags/validation/"},{"name":"swagger3","slug":"swagger3","permalink":"https://idea360.cn/tags/swagger3/"},{"name":"httpClient","slug":"httpClient","permalink":"https://idea360.cn/tags/httpClient/"},{"name":"ajax","slug":"ajax","permalink":"https://idea360.cn/tags/ajax/"},{"name":"js","slug":"js","permalink":"https://idea360.cn/tags/js/"},{"name":"秒杀","slug":"秒杀","permalink":"https://idea360.cn/tags/%E7%A7%92%E6%9D%80/"},{"name":"算法","slug":"算法","permalink":"https://idea360.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"限流","slug":"限流","permalink":"https://idea360.cn/tags/%E9%99%90%E6%B5%81/"},{"name":"redis","slug":"redis","permalink":"https://idea360.cn/tags/redis/"},{"name":"幂等","slug":"幂等","permalink":"https://idea360.cn/tags/%E5%B9%82%E7%AD%89/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://idea360.cn/tags/SpringCloud/"},{"name":"认证","slug":"认证","permalink":"https://idea360.cn/tags/%E8%AE%A4%E8%AF%81/"},{"name":"授权","slug":"授权","permalink":"https://idea360.cn/tags/%E6%8E%88%E6%9D%83/"},{"name":"ioc","slug":"ioc","permalink":"https://idea360.cn/tags/ioc/"},{"name":"socket","slug":"socket","permalink":"https://idea360.cn/tags/socket/"},{"name":"信号量","slug":"信号量","permalink":"https://idea360.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"semaphore","slug":"semaphore","permalink":"https://idea360.cn/tags/semaphore/"},{"name":"hashmap","slug":"hashmap","permalink":"https://idea360.cn/tags/hashmap/"},{"name":"动态代理","slug":"动态代理","permalink":"https://idea360.cn/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"验签","slug":"验签","permalink":"https://idea360.cn/tags/%E9%AA%8C%E7%AD%BE/"},{"name":"脱敏","slug":"脱敏","permalink":"https://idea360.cn/tags/%E8%84%B1%E6%95%8F/"},{"name":"md5","slug":"md5","permalink":"https://idea360.cn/tags/md5/"},{"name":"AES","slug":"AES","permalink":"https://idea360.cn/tags/AES/"},{"name":"加密","slug":"加密","permalink":"https://idea360.cn/tags/%E5%8A%A0%E5%AF%86/"},{"name":"rsa","slug":"rsa","permalink":"https://idea360.cn/tags/rsa/"},{"name":"环境变量","slug":"环境变量","permalink":"https://idea360.cn/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"jwt","slug":"jwt","permalink":"https://idea360.cn/tags/jwt/"},{"name":"Cookie","slug":"Cookie","permalink":"https://idea360.cn/tags/Cookie/"},{"name":"aop","slug":"aop","permalink":"https://idea360.cn/tags/aop/"},{"name":"递归","slug":"递归","permalink":"https://idea360.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"树","slug":"树","permalink":"https://idea360.cn/tags/%E6%A0%91/"},{"name":"long","slug":"long","permalink":"https://idea360.cn/tags/long/"},{"name":"精度丢失","slug":"精度丢失","permalink":"https://idea360.cn/tags/%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/"},{"name":"算法， 雪花算法","slug":"算法，-雪花算法","permalink":"https://idea360.cn/tags/%E7%AE%97%E6%B3%95%EF%BC%8C-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"name":"过滤器","slug":"过滤器","permalink":"https://idea360.cn/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"登录","slug":"登录","permalink":"https://idea360.cn/tags/%E7%99%BB%E5%BD%95/"},{"name":"正则","slug":"正则","permalink":"https://idea360.cn/tags/%E6%AD%A3%E5%88%99/"},{"name":"激活","slug":"激活","permalink":"https://idea360.cn/tags/%E6%BF%80%E6%B4%BB/"},{"name":"DbSchema","slug":"DbSchema","permalink":"https://idea360.cn/tags/DbSchema/"},{"name":"css","slug":"css","permalink":"https://idea360.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://idea360.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"建造者模式","slug":"建造者模式","permalink":"https://idea360.cn/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"json","slug":"json","permalink":"https://idea360.cn/tags/json/"},{"name":"mongodb","slug":"mongodb","permalink":"https://idea360.cn/tags/mongodb/"},{"name":"mongo","slug":"mongo","permalink":"https://idea360.cn/tags/mongo/"},{"name":"activiti","slug":"activiti","permalink":"https://idea360.cn/tags/activiti/"},{"name":"工作流","slug":"工作流","permalink":"https://idea360.cn/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"name":"微信","slug":"微信","permalink":"https://idea360.cn/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"扫码","slug":"扫码","permalink":"https://idea360.cn/tags/%E6%89%AB%E7%A0%81/"},{"name":"二维码","slug":"二维码","permalink":"https://idea360.cn/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"name":"图片","slug":"图片","permalink":"https://idea360.cn/tags/%E5%9B%BE%E7%89%87/"},{"name":"雪花算法","slug":"雪花算法","permalink":"https://idea360.cn/tags/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"},{"name":"redisTemplate","slug":"redisTemplate","permalink":"https://idea360.cn/tags/redisTemplate/"},{"name":"restTemplate","slug":"restTemplate","permalink":"https://idea360.cn/tags/restTemplate/"},{"name":"lua","slug":"lua","permalink":"https://idea360.cn/tags/lua/"},{"name":"去重","slug":"去重","permalink":"https://idea360.cn/tags/%E5%8E%BB%E9%87%8D/"},{"name":"反射","slug":"反射","permalink":"https://idea360.cn/tags/%E5%8F%8D%E5%B0%84/"},{"name":"ppt","slug":"ppt","permalink":"https://idea360.cn/tags/ppt/"},{"name":"动画","slug":"动画","permalink":"https://idea360.cn/tags/%E5%8A%A8%E7%94%BB/"},{"name":"gitlab","slug":"gitlab","permalink":"https://idea360.cn/tags/gitlab/"},{"name":"公众号","slug":"公众号","permalink":"https://idea360.cn/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"maven","slug":"maven","permalink":"https://idea360.cn/tags/maven/"},{"name":"dubbo","slug":"dubbo","permalink":"https://idea360.cn/tags/dubbo/"},{"name":"oracle","slug":"oracle","permalink":"https://idea360.cn/tags/oracle/"},{"name":"mybatis","slug":"mybatis","permalink":"https://idea360.cn/tags/mybatis/"},{"name":"降级","slug":"降级","permalink":"https://idea360.cn/tags/%E9%99%8D%E7%BA%A7/"},{"name":"压测","slug":"压测","permalink":"https://idea360.cn/tags/%E5%8E%8B%E6%B5%8B/"},{"name":"postman","slug":"postman","permalink":"https://idea360.cn/tags/postman/"},{"name":"动态路由","slug":"动态路由","permalink":"https://idea360.cn/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"name":"静态路由","slug":"静态路由","permalink":"https://idea360.cn/tags/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/"},{"name":"curl","slug":"curl","permalink":"https://idea360.cn/tags/curl/"},{"name":"数据结构","slug":"数据结构","permalink":"https://idea360.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉堆","slug":"二叉堆","permalink":"https://idea360.cn/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"},{"name":"devops","slug":"devops","permalink":"https://idea360.cn/tags/devops/"},{"name":"jenkins","slug":"jenkins","permalink":"https://idea360.cn/tags/jenkins/"},{"name":"linux","slug":"linux","permalink":"https://idea360.cn/tags/linux/"},{"name":"k8s","slug":"k8s","permalink":"https://idea360.cn/tags/k8s/"},{"name":"Minikube","slug":"Minikube","permalink":"https://idea360.cn/tags/Minikube/"},{"name":"队列","slug":"队列","permalink":"https://idea360.cn/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://idea360.cn/tags/%E6%A0%88/"},{"name":"模板方法","slug":"模板方法","permalink":"https://idea360.cn/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"name":"策略模式","slug":"策略模式","permalink":"https://idea360.cn/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"https://idea360.cn/tags/ConcurrentHashMap/"},{"name":"并发","slug":"并发","permalink":"https://idea360.cn/tags/%E5%B9%B6%E5%8F%91/"},{"name":"cas","slug":"cas","permalink":"https://idea360.cn/tags/cas/"},{"name":"unsafe","slug":"unsafe","permalink":"https://idea360.cn/tags/unsafe/"},{"name":"集合","slug":"集合","permalink":"https://idea360.cn/tags/%E9%9B%86%E5%90%88/"},{"name":"linkhashmap","slug":"linkhashmap","permalink":"https://idea360.cn/tags/linkhashmap/"},{"name":"hashset","slug":"hashset","permalink":"https://idea360.cn/tags/hashset/"},{"name":"TCP","slug":"TCP","permalink":"https://idea360.cn/tags/TCP/"},{"name":"报文","slug":"报文","permalink":"https://idea360.cn/tags/%E6%8A%A5%E6%96%87/"},{"name":"php","slug":"php","permalink":"https://idea360.cn/tags/php/"},{"name":"drupal","slug":"drupal","permalink":"https://idea360.cn/tags/drupal/"},{"name":"nodejs","slug":"nodejs","permalink":"https://idea360.cn/tags/nodejs/"},{"name":"egg","slug":"egg","permalink":"https://idea360.cn/tags/egg/"},{"name":"单例","slug":"单例","permalink":"https://idea360.cn/tags/%E5%8D%95%E4%BE%8B/"},{"name":"实战","slug":"实战","permalink":"https://idea360.cn/tags/%E5%AE%9E%E6%88%98/"},{"name":"乐观锁","slug":"乐观锁","permalink":"https://idea360.cn/tags/%E4%B9%90%E8%A7%82%E9%94%81/"},{"name":"超卖","slug":"超卖","permalink":"https://idea360.cn/tags/%E8%B6%85%E5%8D%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://idea360.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://idea360.cn/tags/zookeeper/"},{"name":"consul","slug":"consul","permalink":"https://idea360.cn/tags/consul/"}]}