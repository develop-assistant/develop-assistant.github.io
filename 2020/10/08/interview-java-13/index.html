<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  <meta name="google-site-verification" content="zo0LqAAU1ik3Yk5Gdqg2DpsQI1Xlhh7jC07I0IGeyVc" />
  <meta name="baidu-site-verification" content="6LE45O63Sc" />
  <!-- 谷歌广告-->
  <script data-ad-client="ca-pub-6442249173079218" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
  
  <title>13.集合详解之 Map + 面试题 | 当我遇上你</title>
  <meta name="description" content="集合详解之 Map + 面试题 集合有两个大接口：Collection 和 Map，本文重点来讲解集合中另一个常用的集合类型 Map。 以下是 Map 的继承关系图：   Map 简介 Map 常用的实现类如下：  Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用。 Hash">
<meta property="og:type" content="article">
<meta property="og:title" content="13.集合详解之 Map + 面试题">
<meta property="og:url" content="https://idea360.cn/2020/10/08/interview-java-13/index.html">
<meta property="og:site_name" content="当我遇上你">
<meta property="og:description" content="集合详解之 Map + 面试题 集合有两个大接口：Collection 和 Map，本文重点来讲解集合中另一个常用的集合类型 Map。 以下是 Map 的继承关系图：   Map 简介 Map 常用的实现类如下：  Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用。 Hash">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.gitbook.cn/Fpy4Na_uWi3rK9M8kOcgYK7_uXrK">
<meta property="og:image" content="https://images.gitbook.cn/319c8410-ccc7-11e9-93b3-c35630e1847c">
<meta property="og:image" content="https://images.gitbook.cn/54a52ca0-ccc7-11e9-b229-e35eb1d6e740">
<meta property="og:image" content="https://images.gitbook.cn/727836f0-ccc7-11e9-a9bd-857608719494">
<meta property="article:published_time" content="2020-10-08T06:08:24.000Z">
<meta property="article:modified_time" content="2020-10-08T06:21:31.516Z">
<meta property="article:author" content="当我遇上你">
<meta property="article:tag" content="java">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.gitbook.cn/Fpy4Na_uWi3rK9M8kOcgYK7_uXrK">
  <!-- Canonical links -->
  <link rel="canonical" href="https://idea360.cn/2020/10/08/interview-java-13/index.html">
  
    <link rel="alternate" href="/atom.xml" title="当我遇上你" type="application/atom+xml">
  
  
    <link rel="icon" href="https://gitee.com/idea360/oss/raw/master/images/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-white" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/qidian360" target="_blank">
          <img class="img-circle img-rotate" src="https://gitee.com/idea360/oss/raw/master/images/one.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">当我遇上你</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/qidian360" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p><div><img src="https://gitee.com/idea360/oss/raw/master/images/wechat-qr-code.png" width="140px" height="140px"></div>
            </div>
        </div>
    </div>
</div>

    
      <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 固定广告位 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-6442249173079218"
     data-ad-slot="7881226079"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3%E4%B9%8B-map-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text"> 集合详解之 Map + 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text"> Map 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text"> Map 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text"> HashMap 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text"> HashMap 重要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95putobject-key-object-value"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 1）添加方法：put(Object key, Object value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95getobject-key"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 2）获取方法：get(Object key)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text"> 相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1map-%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 1.Map 常见实现类有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8-hashmap-%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 2.使用 HashMap 可能会遇到什么问题？如何避免？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%BB%A5%E4%B8%8B%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 3.以下说法正确的是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4treemap-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE-value-%E5%80%BC%E5%80%92%E5%BA%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 4.TreeMap 怎么实现根据 value 值倒序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%B8%AA-set-%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%87%AA%E5%8A%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 5.以下哪个 Set 实现了自动排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E4%BB%A5%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.6.</span> <span class="toc-text"> 6.以下程序运行的结果是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7hashmap-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0%E7%94%A8%E9%80%94%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.7.</span> <span class="toc-text"> 7.HashMap 有哪些重要的参数？用途分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8hashmap-%E5%92%8C-hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.8.</span> <span class="toc-text"> 8.HashMap 和 Hashtable 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.5.9.</span> <span class="toc-text"> 9.什么是哈希冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.5.10.</span> <span class="toc-text"> 10.有哪些方法可以解决哈希冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11hashmap-%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="toc-number">1.5.11.</span> <span class="toc-text"> 11.HashMap 使用哪种方法来解决哈希冲突（哈希碰撞）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12hashmap-%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2n"><span class="toc-number">1.5.12.</span> <span class="toc-text"> 12.HashMap 的扩容为什么是 2^n ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E6%9C%89%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B-hashmap-%E5%A6%82%E4%BD%95%E5%8F%96%E5%80%BC"><span class="toc-number">1.5.13.</span> <span class="toc-text"> 13.有哈希冲突的情况下 HashMap 如何取值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E4%BB%A5%E4%B8%8B%E7%A8%8B%E5%BA%8F%E4%BC%9A%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C"><span class="toc-number">1.5.14.</span> <span class="toc-text"> 14.以下程序会输出什么结果？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99-hashcode"><span class="toc-number">1.5.15.</span> <span class="toc-text"> 15.为什么重写 equals() 时一定要重写 hashCode()？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16hashmap-%E5%9C%A8-jdk-7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.16.</span> <span class="toc-text"> 16.HashMap 在 JDK 7 多线程中使用会导致什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17hashmap-%E5%9C%A8-jdk-7-%E5%92%8C-jdk-8-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C"><span class="toc-number">1.5.17.</span> <span class="toc-text"> 17.HashMap 在 JDK 7 和 JDK 8 中有哪些不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-interview-java-13" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      13.集合详解之 Map + 面试题
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/10/08/interview-java-13/" class="article-date">
	  <time datetime="2020-10-08T06:08:24.000Z" itemprop="datePublished">2020-10-08</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/">Java面试全解析</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/java/" rel="tag">java</a>, <a class="article-tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


	<span class="article-read hidden-xs">
    	<i class="icon icon-eye-fill" aria-hidden="true"></i>
    	<span id="/2020/10/08/interview-java-13/" class="leancloud_visitors"  data-flag-title="13.集合详解之 Map + 面试题">
			<span class="leancloud-visitors-count">0</span>
		</span>
    </span>

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/10/08/interview-java-13/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="集合详解之-map-面试题"><a class="markdownIt-Anchor" href="#集合详解之-map-面试题"></a> 集合详解之 Map + 面试题</h2>
<p>集合有两个大接口：Collection 和 Map，本文重点来讲解集合中另一个常用的集合类型 Map。</p>
<p>以下是 Map 的继承关系图：</p>
<p><img src="https://images.gitbook.cn/Fpy4Na_uWi3rK9M8kOcgYK7_uXrK" alt="avatar" /></p>
<h3 id="map-简介"><a class="markdownIt-Anchor" href="#map-简介"></a> Map 简介</h3>
<p>Map 常用的实现类如下：</p>
<ul>
<li><strong>Hashtable</strong>：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用。</li>
<li><strong>HashMap</strong>：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代。</li>
<li><strong>TreeMap</strong>：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定 Comparator 来自定义排序。</li>
<li><strong>LinkedHashMap</strong>：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。</li>
</ul>
<h3 id="map-常用方法"><a class="markdownIt-Anchor" href="#map-常用方法"></a> Map 常用方法</h3>
<p>常用方法包括：put、remove、get、size 等，所有方法如下图：</p>
<p><img src="https://images.gitbook.cn/319c8410-ccc7-11e9-93b3-c35630e1847c" alt="enter image description here" /></p>
<p>使用示例，请参考以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map hashMap &#x3D; new HashMap();</span><br><span class="line">&#x2F;&#x2F; 增加元素</span><br><span class="line">hashMap.put(&quot;name&quot;, &quot;老王&quot;);</span><br><span class="line">hashMap.put(&quot;age&quot;, &quot;30&quot;);</span><br><span class="line">hashMap.put(&quot;sex&quot;, &quot;你猜&quot;);</span><br><span class="line">&#x2F;&#x2F; 删除元素</span><br><span class="line">hashMap.remove(&quot;age&quot;);</span><br><span class="line">&#x2F;&#x2F; 查找单个元素</span><br><span class="line">System.out.println(hashMap.get(&quot;age&quot;));</span><br><span class="line">&#x2F;&#x2F; 循环所有的 key</span><br><span class="line">for (Object k : hashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 循环所有的值</span><br><span class="line">for (Object v : hashMap.values()) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为 HashMap 的使用示例，其他类的使用也是类似。</p>
<h3 id="hashmap-数据结构"><a class="markdownIt-Anchor" href="#hashmap-数据结构"></a> HashMap 数据结构</h3>
<p>HashMap 底层的数据是数组被成为哈希桶，每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。</p>
<p>HashMap 数据结构，如下图：</p>
<p><img src="https://images.gitbook.cn/54a52ca0-ccc7-11e9-b229-e35eb1d6e740" alt="enter image description here" /></p>
<h3 id="hashmap-重要方法"><a class="markdownIt-Anchor" href="#hashmap-重要方法"></a> HashMap 重要方法</h3>
<h4 id="1添加方法putobject-key-object-value"><a class="markdownIt-Anchor" href="#1添加方法putobject-key-object-value"></a> 1）添加方法：put(Object key, Object value)</h4>
<p>执行流程如下：</p>
<ul>
<li>对 key 进行 hash 操作，计算存储 index；</li>
<li>判断是否有哈希碰撞，如果没碰撞直接放到哈希桶里，如果有碰撞则以链表的形式存储；</li>
<li>判断已有元素的类型，决定是追加树还是追加链表，当链表大于等于 8 时，把链表转换成红黑树；</li>
<li>如果节点已经存在就替换旧值；</li>
<li>判断是否超过阀值，如果超过就要扩容。</li>
</ul>
<p>源码及说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行 hash()</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">// 对 key 进行 hash() 的具体实现</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算 index，并对 null 做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put() 执行流程图如下：</p>
<p><img src="https://images.gitbook.cn/727836f0-ccc7-11e9-a9bd-857608719494" alt="enter image description here" /></p>
<h4 id="2获取方法getobject-key"><a class="markdownIt-Anchor" href="#2获取方法getobject-key"></a> 2）获取方法：get(Object key)</h4>
<p>执行流程如下：</p>
<ul>
<li>首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点；</li>
<li>如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对。</li>
</ul>
<p>源码及说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 该方法是 Map.get 方法的具体实现</span></span><br><span class="line"><span class="comment">* 接收两个参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash key 的 hash 值，根据 hash 值在节点数组中寻址，该 hash 值是通过 hash(key) 得到的</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key key 对象，当存在 hash 碰撞时，要逐个比对是否相等</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 查找到则返回键值对节点对象，否则返回 null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k; <span class="comment">// 声明节点数组对象、链表的第一个节点对象、循环遍历时的当前节点对象、数组长度、节点的键对象</span></span><br><span class="line">    <span class="comment">// 节点数组赋值、数组长度赋值、通过位运算得到求模结果确定链表的首节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first; <span class="comment">// 返回首节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对    </span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在下一个节点 e，那么先看看这个首节点是否是个树节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果是首节点是树节点，那么遍历树来查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果首节点不是树节点，就说明还是个普通的链表，那么逐个遍历比对即可    </span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 比对时还是先看 hash 值是否相同、再看地址或 equals</span></span><br><span class="line">                    <span class="keyword">return</span> e; <span class="comment">// 如果当前节点e的键对象和key相同，那么返回 e</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 看看是否还有下一个节点，如果有，继续下一轮比对，否则跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 在比对完了应该比对的树节点 或者全部的链表节点 都没能匹配到 key，那么就返回 null</span></span><br></pre></td></tr></table></figure>
<h3 id="相关面试题"><a class="markdownIt-Anchor" href="#相关面试题"></a> 相关面试题</h3>
<h4 id="1map-常见实现类有哪些"><a class="markdownIt-Anchor" href="#1map-常见实现类有哪些"></a> 1.Map 常见实现类有哪些？</h4>
<p>答：Map 的常见实现类如下列表：</p>
<ul>
<li>Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用；</li>
<li>HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代；</li>
<li>TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定的 Comparator 来自定义排序；</li>
<li>LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。</li>
</ul>
<h4 id="2使用-hashmap-可能会遇到什么问题如何避免"><a class="markdownIt-Anchor" href="#2使用-hashmap-可能会遇到什么问题如何避免"></a> 2.使用 HashMap 可能会遇到什么问题？如何避免？</h4>
<p>答：HashMap 在并发场景中可能出现死循环的问题，这是因为 HashMap 在扩容的时候会对链表进行一次倒序处理，假设两个线程同时执行扩容操作，第一个线程正在执行 B→A 的时候，第二个线程又执行了 A→B ，这个时候就会出现 B→A→B 的问题，造成死循环。<br />
解决的方法：升级 JDK 版本，在 JDK 8 之后扩容不会再进行倒序，因此死循环的问题得到了极大的改善，但这不是终极的方案，因为 HashMap 本来就不是用在多线程版本下的，如果是多线程可使用 ConcurrentHashMap 替代 HashMap。</p>
<h4 id="3以下说法正确的是"><a class="markdownIt-Anchor" href="#3以下说法正确的是"></a> 3.以下说法正确的是？</h4>
<p>A：Hashtable 和 HashMap 都是非线程安全的<br />
B：ConcurrentHashMap 允许 null 作为 key<br />
C：HashMap 允许 null 作为 key<br />
D：Hashtable 允许 null 作为 key<br />
答：C<br />
题目解析：Hashtable 是线程安全的，ConcurrentHashMap 和 Hashtable 是不允许 null 作为键和值的。</p>
<h4 id="4treemap-怎么实现根据-value-值倒序"><a class="markdownIt-Anchor" href="#4treemap-怎么实现根据-value-值倒序"></a> 4.TreeMap 怎么实现根据 value 值倒序？</h4>
<p>答：使用 <code>Collections.sort(list, new Comparator&gt;()</code> 自定义比较器实现，先把 TreeMap 转换为 ArrayList，在使用 Collections.sort() 根据 value 进行倒序，完整的实现代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String, String&gt; treeMap &#x3D; new TreeMap();</span><br><span class="line">treeMap.put(&quot;dog&quot;, &quot;dog&quot;);</span><br><span class="line">treeMap.put(&quot;camel&quot;, &quot;camel&quot;);</span><br><span class="line">treeMap.put(&quot;cat&quot;, &quot;cat&quot;);</span><br><span class="line">treeMap.put(&quot;ant&quot;, &quot;ant&quot;);</span><br><span class="line">&#x2F;&#x2F; map.entrySet() 转成 List</span><br><span class="line">List&lt;Map.Entry&lt;String, String&gt;&gt; list &#x3D; new ArrayList&lt;&gt;(treeMap.entrySet());</span><br><span class="line">&#x2F;&#x2F; 通过比较器实现比较排序</span><br><span class="line">Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">  public int compare(Map.Entry&lt;String, String&gt; m1, Map.Entry&lt;String, String&gt; m2) &#123;</span><br><span class="line">    return m2.getValue().compareTo(m1.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 打印结果</span><br><span class="line">for (Map.Entry&lt;String, String&gt; item : list) &#123;</span><br><span class="line">  System.out.println(item.getKey() + &quot;:&quot; + item.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dog:dog</span><br><span class="line">cat:cat</span><br><span class="line">camel:camel</span><br><span class="line">ant:ant</span><br></pre></td></tr></table></figure>
<h4 id="5以下哪个-set-实现了自动排序"><a class="markdownIt-Anchor" href="#5以下哪个-set-实现了自动排序"></a> 5.以下哪个 Set 实现了自动排序？</h4>
<p>A：LinedHashSet<br />
B：HashSet<br />
C：TreeSet<br />
D：AbstractSet</p>
<p>答：C</p>
<h4 id="6以下程序运行的结果是什么"><a class="markdownIt-Anchor" href="#6以下程序运行的结果是什么"></a> 6.以下程序运行的结果是什么？</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hashtable hashtable &#x3D; new Hashtable();</span><br><span class="line">hashtable.put(&quot;table&quot;, null);</span><br><span class="line">System.out.println(hashtable.get(&quot;table&quot;));</span><br></pre></td></tr></table></figure>
<p>答：程序执行报错：java.lang.NullPointerException。Hashtable 不允许 null 键和值。</p>
<h4 id="7hashmap-有哪些重要的参数用途分别是什么"><a class="markdownIt-Anchor" href="#7hashmap-有哪些重要的参数用途分别是什么"></a> 7.HashMap 有哪些重要的参数？用途分别是什么？</h4>
<p>答：HashMap 有两个重要的参数：容量（Capacity）和负载因子（LoadFactor）。</p>
<ul>
<li>容量（Capacity）：是指 HashMap 中桶的数量，默认的初始值为 16。</li>
<li>负载因子（LoadFactor）：也被称为装载因子，LoadFactor 是用来判定 HashMap 是否扩容的依据，默认值为 0.75f，装载因子的计算公式 = HashMap 存放的 KV 总和（size）/ Capacity。</li>
</ul>
<h4 id="8hashmap-和-hashtable-有什么区别"><a class="markdownIt-Anchor" href="#8hashmap-和-hashtable-有什么区别"></a> 8.HashMap 和 Hashtable 有什么区别？</h4>
<p>答：HashMap 和 Hashtable 区别如下：</p>
<ul>
<li>Hashtable 使用了 synchronized 关键字来保障线程安全，而 HashMap 是非线程安全的；</li>
<li>HashMap 允许 K/V 都为 null，而 Hashtable K/V 都不允许 null；</li>
<li>HashMap 继承自 AbstractMap 类；而 Hashtable 继承自 Dictionary 类。</li>
</ul>
<h4 id="9什么是哈希冲突"><a class="markdownIt-Anchor" href="#9什么是哈希冲突"></a> 9.什么是哈希冲突？</h4>
<p>答：当输入两个不同值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p>
<h4 id="10有哪些方法可以解决哈希冲突"><a class="markdownIt-Anchor" href="#10有哪些方法可以解决哈希冲突"></a> 10.有哪些方法可以解决哈希冲突？</h4>
<p>答：哈希冲突的常用解决方案有以下 4 种。</p>
<ul>
<li>开放定址法：当关键字的哈希地址 p=H（key）出现冲突时，以 p 为基础，产生另一个哈希地址 p1，如果 p1 仍然冲突，再以 p 为基础，产生另一个哈希地址 p2，循环此过程直到找出一个不冲突的哈希地址，将相应元素存入其中。</li>
<li>再哈希法：这种方法是同时构造多个不同的哈希函数，当哈希地址 Hi=RH1（key）发生冲突时，再计算 Hi=RH2（key），循环此过程直到找到一个不冲突的哈希地址，这种方法唯一的缺点就是增加了计算时间。</li>
<li>链地址法：这种方法的基本思想是将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li>
</ul>
<h4 id="11hashmap-使用哪种方法来解决哈希冲突哈希碰撞"><a class="markdownIt-Anchor" href="#11hashmap-使用哪种方法来解决哈希冲突哈希碰撞"></a> 11.HashMap 使用哪种方法来解决哈希冲突（哈希碰撞）？</h4>
<p>答：HashMap 使用链表和红黑树来解决哈希冲突，详见本文 put() 方法的执行过程。</p>
<h4 id="12hashmap-的扩容为什么是-2n"><a class="markdownIt-Anchor" href="#12hashmap-的扩容为什么是-2n"></a> 12.HashMap 的扩容为什么是 2^n ？</h4>
<p>答：这样做的目的是为了让散列更加均匀，从而减少哈希碰撞，以提供代码的执行效率。</p>
<h4 id="13有哈希冲突的情况下-hashmap-如何取值"><a class="markdownIt-Anchor" href="#13有哈希冲突的情况下-hashmap-如何取值"></a> 13.有哈希冲突的情况下 HashMap 如何取值？</h4>
<p>答：如果有哈希冲突，HashMap 会循环链表中的每项 key 进行 equals 对比，返回对应的元素。相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 比对时还是先看 hash 值是否相同、再看地址或 equals</span></span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// 如果当前节点 e 的键对象和 key 相同，那么返回 e</span></span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 看看是否还有下一个节点，如果有，继续下一轮比对，否则跳出循环</span></span><br></pre></td></tr></table></figure>
<h4 id="14以下程序会输出什么结果"><a class="markdownIt-Anchor" href="#14以下程序会输出什么结果"></a> 14.以下程序会输出什么结果？</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; null || !(o instanceof Person)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.getAge().equals(((Person) o).getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return age.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;Person, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        Person person &#x3D; new Person(18);</span><br><span class="line">        hashMap.put(person, 1);</span><br><span class="line">        System.out.println(hashMap.get(new Person(18)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：1<br />
题目解析：因为 Person 重写了 equals 和 hashCode 方法，所有 person 对象和 new Person(18) 的键值相同，所以结果就是 1。</p>
<h4 id="15为什么重写-equals-时一定要重写-hashcode"><a class="markdownIt-Anchor" href="#15为什么重写-equals-时一定要重写-hashcode"></a> 15.为什么重写 equals() 时一定要重写 hashCode()？</h4>
<p>答：因为 Java 规定，如果两个对象 equals 比较相等（结果为 true），那么调用 hashCode 也必须相等。如果重写了 equals() 但没有重写 hashCode()，就会与规定相违背，比如以下代码（故意注释掉 hashCode 方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; null || !(o instanceof Person)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.getAge().equals(((Person) o).getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;    public int hashCode() &#123;</span><br><span class="line">&#x2F;&#x2F;        return age.hashCode();</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">    public Person(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 &#x3D; new Person(18);</span><br><span class="line">        Person p2 &#x3D; new Person(18);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">        System.out.println(p1.hashCode() + &quot; : &quot; + p2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">21685669 : 2133927002</span><br></pre></td></tr></table></figure>
<p>如果重写 hashCode() 之后，执行的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">18 : 18</span><br></pre></td></tr></table></figure>
<p>这样就符合了 Java 的规定，因此重写 equals() 时一定要重写 hashCode()。</p>
<h4 id="16hashmap-在-jdk-7-多线程中使用会导致什么问题"><a class="markdownIt-Anchor" href="#16hashmap-在-jdk-7-多线程中使用会导致什么问题"></a> 16.HashMap 在 JDK 7 多线程中使用会导致什么问题？</h4>
<p>答：HashMap 在 JDK 7 中会导致死循环的问题。因为在 JDK 7 中，多线程进行 HashMap 扩容时会导致链表的循环引用，这个时候使用 get() 获取元素时就会导致死循环，造成 CPU 100% 的情况。</p>
<h4 id="17hashmap-在-jdk-7-和-jdk-8-中有哪些不同"><a class="markdownIt-Anchor" href="#17hashmap-在-jdk-7-和-jdk-8-中有哪些不同"></a> 17.HashMap 在 JDK 7 和 JDK 8 中有哪些不同？</h4>
<p>答：HashMap 在 JDK 7 和 JDK 8 的主要区别如下。</p>
<ul>
<li>存储结构：JDK 7 使用的是数组 + 链表；JDK 8 使用的是数组 + 链表 + 红黑树。</li>
<li>存放数据的规则：JDK 7 无冲突时，存放数组；冲突时，存放链表；JDK 8 在没有冲突的情况下直接存放数组，有冲突时，当链表长度小于 8 时，存放在单链表结构中，当链表长度大于 8 时，树化并存放至红黑树的数据结构中。</li>
<li>插入数据方式：JDK 7 使用的是头插法（先将原位置的数据移到后 1 位，再插入数据到该位置）；JDK 8 使用的是尾插法（直接插入到链表尾部/红黑树）。</li>
</ul>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>通过本文可以了解到：</p>
<ul>
<li>Map 的常用实现类 Hashtable 是 Java 早期的线程安全的哈希表实现；</li>
<li>HashMap 是最常用的哈希表实现，但它是非线程安全的，可使用 ConcurrentHashMap 替代；</li>
<li>TreeMap 是基于红黑树的一种提供顺序访问的哈希表实现；</li>
<li>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。</li>
</ul>
<p>HashMap 在 JDK 7 可能在扩容时会导致链表的循环引用而造成 CPU 100%，HashMap 在 JDK 8 时数据结构变更为：数组 + 链表 + 红黑树的存储方式，在没有冲突的情况下直接存放数组，有冲突，当链表长度小于 8 时，存放在单链表结构中，当链表长度大于 8 时，树化并存放至红黑树的数据结构中。</p>

      
    </div>
    <div class="article-footer">
      <!--<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-6442249173079218"
     data-ad-slot="9150075714"></ins>
<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
-->
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://idea360.cn/2020/10/08/interview-java-13/" title="13.集合详解之 Map + 面试题" target="_blank" rel="external">https://idea360.cn/2020/10/08/interview-java-13/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/qidian360" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://gitee.com/idea360/oss/raw/master/images/one.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/qidian360" target="_blank"><span class="text-dark">当我遇上你</span><small class="ml-1x"></small></a></h3>
        <div>勿在浮沙筑高楼</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/10/08/interview-java-14/" title="14.为什么要使用泛型和迭代器 + 面试题"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/10/08/interview-java-12/" title="12.集合详解之 Collection + 面试题"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="wechat" data-mobile-sites="wechat"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="https://gitee.com/idea360/oss/raw/master/images/zfbsk.JPG" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="https://gitee.com/idea360/oss/raw/master/images/wxsk.JPG" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/qidian360" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2021 当我遇上你
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'nPtA4r7LjqdHMXOW4Gs9yQz0',
    appKey: 'UUYHyTz9su4cY3J1XDKWlxIH',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: true
  });
  </script>

     







</body>
</html>