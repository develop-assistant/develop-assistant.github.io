<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当我遇上你</title>
  
  <subtitle>当我遇上你的博客</subtitle>
  <link href="https://idea360.cn/atom.xml" rel="self"/>
  
  <link href="https://idea360.cn/"/>
  <updated>2021-08-13T15:54:29.535Z</updated>
  <id>https://idea360.cn/</id>
  
  <author>
    <name>当我遇上你</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot Admin</title>
    <link href="https://idea360.cn/2021/08/13/spring-boot-admin/"/>
    <id>https://idea360.cn/2021/08/13/spring-boot-admin/</id>
    <published>2021-08-13T15:45:37.000Z</published>
    <updated>2021-08-13T15:54:29.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>悲伤的运维沟通史, 没权限, 有问题排查累死, 哎…</p><h1 id="admin-server"><a class="markdownIt-Anchor" href="#admin-server"></a> Admin-Server</h1><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-admin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-cloud-admin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>[公众号: 当我遇上你]<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud-alibaba.version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud-alibaba.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.admin.SpringCloudAdminApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">spring-cloud-admin</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">7700</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># Nacos帮助文档: https://nacos.io/zh-cn/docs/concepts.html</span></span><br><span class="line"><span class="comment"># Nacos认证信息</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.username</span>=<span class="string">nacos</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.password</span>=<span class="string">nacos</span></span><br><span class="line"><span class="comment"># Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="comment"># 注册到 nacos 的指定 namespace，默认为 public</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.namespace</span>=<span class="string">public</span></span><br><span class="line"><span class="comment"># 健康配置</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="meta">management.endpoint.health.show-details</span>=<span class="string">always</span></span><br><span class="line"><span class="comment"># 上下文</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.metadata.management.context-path</span>=<span class="string">$&#123;server.servlet.context-path&#125;/actuator</span></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line"><span class="meta">spring.security.user.name</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.security.user.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 指标安全, 否则401</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.metadata.user.name</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.metadata.user.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">/Users/cuishiying/Desktop/admin.log</span></span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.admin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.codecentric.boot.admin.server.config.EnableAdminServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://codecentric.github.io/spring-boot-admin/current/</span></span><br><span class="line"><span class="comment"> * http://localhost:7700</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudAdminApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.admin.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.codecentric.boot.admin.server.config.AdminServerProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.csrf.CookieCsrfTokenRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cuishiying</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdminServerProperties adminServer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityConfig</span><span class="params">(AdminServerProperties adminServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adminServer = adminServer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">        successHandler.setTargetUrlParameter(<span class="string">&quot;redirectTo&quot;</span>);</span><br><span class="line">        successHandler.setDefaultTargetUrl(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/assets/**&quot;</span>)).permitAll()</span><br><span class="line">                .antMatchers(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/login&quot;</span>)).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().loginPage(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/login&quot;</span>)).successHandler(successHandler).and()</span><br><span class="line">                .logout().logoutUrl(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/logout&quot;</span>)).and()</span><br><span class="line">                .httpBasic().and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</span><br><span class="line">                .ignoringRequestMatchers(</span><br><span class="line">                        <span class="keyword">new</span> AntPathRequestMatcher(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/instances&quot;</span>), HttpMethod.POST.toString()),</span><br><span class="line">                        <span class="keyword">new</span> AntPathRequestMatcher(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/instances/*&quot;</span>), HttpMethod.DELETE.toString()),</span><br><span class="line">                        <span class="keyword">new</span> AntPathRequestMatcher(<span class="keyword">this</span>.adminServer.path(<span class="string">&quot;/actuator/**&quot;</span>))</span><br><span class="line">                )</span><br><span class="line">                .and()</span><br><span class="line">                .rememberMe().key(UUID.randomUUID().toString()).tokenValiditySeconds(<span class="number">1209600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="client"><a class="markdownIt-Anchor" href="#client"></a> Client</h1><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-cloud-client<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>[公众号: 当我遇上你]<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud-alibaba.version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud-alibaba.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.springcloudclient.SpringCloudClientApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">spring-cloud-client</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">7701</span></span><br><span class="line"><span class="comment"># Nacos帮助文档: https://nacos.io/zh-cn/docs/concepts.html</span></span><br><span class="line"><span class="comment"># Nacos认证信息</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.username</span>=<span class="string">nacos</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.password</span>=<span class="string">nacos</span></span><br><span class="line"><span class="comment"># Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="comment"># 注册到 nacos 的指定 namespace，默认为 public</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.namespace</span>=<span class="string">public</span></span><br><span class="line"><span class="comment"># 健康配置</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="meta">management.endpoint.health.show-details</span>=<span class="string">always</span></span><br><span class="line"><span class="meta">spring.boot.admin.client.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.boot.admin.client.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># spring-cloud-admin地址</span></span><br><span class="line"><span class="meta">spring.boot.admin.client.url</span>=<span class="string">http://localhost:7700</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">/Users/cuishiying/Desktop/client.log</span></span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springcloudclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springcloudclient.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cuishiying</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http://localhost:7701/hello?name=root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(required = false)</span> String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello:&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello:&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;悲伤的运维沟通史, 没权限, 有问题排查累死, 哎…&lt;/p&gt;
&lt;h1 id=&quot;admin-server&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="spring" scheme="https://idea360.cn/categories/spring/"/>
    
    
    <category term="springboot" scheme="https://idea360.cn/tags/springboot/"/>
    
    <category term="监控" scheme="https://idea360.cn/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>JVM线上调优</title>
    <link href="https://idea360.cn/2021/08/05/jvm-tuning-online/"/>
    <id>https://idea360.cn/2021/08/05/jvm-tuning-online/</id>
    <published>2021-08-05T15:52:30.000Z</published>
    <updated>2021-08-05T16:26:46.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm线上调优"><a class="markdownIt-Anchor" href="#jvm线上调优"></a> JVM线上调优</h1><h2 id="1-调优原则"><a class="markdownIt-Anchor" href="#1-调优原则"></a> 1. 调优原则</h2><ol><li>必须有监控；</li><li>调优目标:<ul><li>最短停顿时间?   CMS<ul><li>最大吞吐量(吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间))？ Parallel Scavenge</li></ul></li></ul></li><li>调优手段</li></ol><h3 id="官方推荐调优流程"><a class="markdownIt-Anchor" href="#官方推荐调优流程"></a> 官方推荐调优流程</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90jvm%E8%B0%83%E4%BC%98%E6%B5%81%E7%A8%8B.png" alt="" /></p><h3 id="12-hotspot虚拟机优化大纲"><a class="markdownIt-Anchor" href="#12-hotspot虚拟机优化大纲"></a> 1.2. Hotspot虚拟机优化大纲</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/Hotspot%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%E8%A1%A8.png" alt="" /></p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="2-线上问题"><a class="markdownIt-Anchor" href="#2-线上问题"></a> 2. 线上问题</h2><ul><li>内存泄露；</li><li>某个进程突然 <code>CPU</code> 飙升；</li><li>线程死锁；</li><li>响应变慢(长时间卡顿)。</li><li>FGC频繁</li></ul><h2 id="3-调优方向"><a class="markdownIt-Anchor" href="#3-调优方向"></a> 3. 调优方向</h2><ul><li>内存调优</li><li>垃圾回收策略调优</li></ul><h2 id="4-arthas线上监控"><a class="markdownIt-Anchor" href="#4-arthas线上监控"></a> 4. Arthas线上监控</h2><ol><li>线上启动arthas后attach到我们需要监控的进程；</li><li>帮助文档</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@1701]$</span><span class="bash"> <span class="built_in">help</span></span></span><br><span class="line"> NAME         DESCRIPTION</span><br><span class="line"> help         Display Arthas Help</span><br><span class="line"> keymap       Display all the available keymap for the specified connection.</span><br><span class="line"> sc           Search all the classes loaded by JVM</span><br><span class="line"> sm           Search the method of classes loaded by JVM</span><br><span class="line"> classloader  Show classloader info</span><br><span class="line"> jad          Decompile class</span><br><span class="line"> getstatic    Show the static field of a class</span><br><span class="line"> monitor      Monitor method execution statistics, e.g. total/success/failure count, average rt, fail rate, etc.</span><br><span class="line"> stack        Display the stack trace for the specified class and method</span><br><span class="line"> thread       Display thread info, thread stack</span><br><span class="line"> trace        Trace the execution time of specified method invocation.</span><br><span class="line"> watch        Display the input/output parameter, return object, and thrown exception of specified method invocation</span><br><span class="line"> tt           Time Tunnel</span><br><span class="line"> jvm          Display the target JVM information</span><br><span class="line"> ognl         Execute ognl expression.</span><br><span class="line"> mc           Memory compiler, compiles java files into bytecode and class files in memory.</span><br><span class="line"> redefine     Redefine classes. @see Instrumentation#redefineClasses(ClassDefinition...)</span><br><span class="line"> dashboard    Overview of target jvm&#x27;s thread, memory, gc, vm, tomcat info.</span><br><span class="line"> dump         Dump class byte array from JVM</span><br><span class="line"> heapdump     Heap dump</span><br><span class="line"> options      View and change various Arthas options</span><br><span class="line"> cls          Clear the screen</span><br><span class="line"> reset        Reset all the enhanced classes</span><br><span class="line"> version      Display Arthas version</span><br><span class="line"> shutdown     Shutdown Arthas server and exit the console</span><br><span class="line"> stop         Stop/Shutdown Arthas server and exit the console. Alias for shutdown.</span><br><span class="line"> session      Display current session information</span><br><span class="line"> sysprop      Display, and change the system properties.</span><br><span class="line"> sysenv       Display the system env.</span><br><span class="line"> vmoption     Display, and update the vm diagnostic options.</span><br><span class="line"> logger       Print logger info, and update the logger level</span><br><span class="line"> history      Display command history</span><br><span class="line"> cat          Concatenate and print files</span><br><span class="line"> pwd          Return working directory name</span><br><span class="line"> mbean        Display the mbean information</span><br><span class="line"> grep         grep command for pipes.</span><br><span class="line"> profiler     Async Profiler. https://github.com/jvm-profiling-tools/async-profiler</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/idea360/oss/raw/master/images/arthas%E6%8C%87%E4%BB%A4%E8%A1%A8.png" alt="" /></p><h3 id="1-dashboard"><a class="markdownIt-Anchor" href="#1-dashboard"></a> 1、dashboard</h3><p>在arthas的命令行界面，输入dashboard，会实时展示当前tomcat的多线程状态、Jvm各区域、GC情况等信息</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/arthas-dashboard.png" alt="" /></p><h3 id="2-查看线程监控"><a class="markdownIt-Anchor" href="#2-查看线程监控"></a> 2、查看线程监控</h3><p>常用参数</p><p>输入thread会显示所有线程的状态信息</p><p>输入thread -n 3会显示当前最忙的3个线程，可以用来排查线程CPU消耗</p><p>输入thread -b 会显示当前处于BLOCKED状态的线程，可以排查线程锁的问题</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/arthas-thread.png" alt="" /></p><h3 id="3-jvm监控"><a class="markdownIt-Anchor" href="#3-jvm监控"></a> 3、jvm监控</h3><p>输入jvm，查看jvm详细的性能数据</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/arthas-jvm-1227024.png" alt="" /></p><h3 id="4-函数耗时监控"><a class="markdownIt-Anchor" href="#4-函数耗时监控"></a> 4、函数耗时监控</h3><p>通常说一个接口性能不好，其实就是接口响应时间比较长造成的，具体代码中哪个函数耗时比较长呢？可以使用trace功能来监控一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace com.idc.order.modules.sys.controller.AccountController login</span><br></pre></td></tr></table></figure><p>解释：</p><p>-j参数可以过滤掉jdk自身的函数</p><p>om.idc.order.modules.sys.controller.AccountController是接口所在的类</p><p>Login是接口的入口函数</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/arthas-trace.png" alt="" /></p><p>通过圈起来的部分可以看到，接口的入口函数login总耗时268ms</p><p>其中verify函数耗时85ms</p><p>很明显，最慢的函数已经找到了，接下里就要去对代码进行进一步分析，然后再进行优化</p><h2 id="5-模拟堆栈溢出"><a class="markdownIt-Anchor" href="#5-模拟堆栈溢出"></a> 5. 模拟堆栈溢出</h2><h3 id="堆溢出模拟"><a class="markdownIt-Anchor" href="#堆溢出模拟"></a> 堆溢出模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆溢出: java对象在堆中分配内存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * VM options: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 执行结果:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 分配次数：1</span></span><br><span class="line"><span class="comment"> * 分配次数：2</span></span><br><span class="line"><span class="comment"> * 分配次数：3</span></span><br><span class="line"><span class="comment"> * java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * Dumping heap to java_pid17426.hprof ...</span></span><br><span class="line"><span class="comment"> * Heap dump file created [17431809 bytes in 0.026 secs]</span></span><br><span class="line"><span class="comment"> * Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> *     at com.example.demojava.demo.HeapOOm.main(HeapOOm.java:15)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">            System.out.println(<span class="string">&quot;分配次数：&quot;</span>+(++i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>附：dump文件会在项目的根目录下生成</em></p><p>从上面的例子我们可以看出，在进行第4次内存分配时，发生了内存溢出。</p></blockquote><h3 id="栈溢出模拟"><a class="markdownIt-Anchor" href="#栈溢出模拟"></a> 栈溢出模拟</h3><p>栈空间不足时，需要分下面两种情况处理：</p><ul><li>线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError</li><li>虚拟机在扩展栈深度时无法申请到足够的内存空间，将抛出OutOfMemberError</li></ul><p>附：当前大部分的虚拟机栈都是可动态扩展的。</p><p>1、栈空间不足——StackOverflowError实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈空间不足溢出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 递归次数：18117</span></span><br><span class="line"><span class="comment"> * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment"> *     at com.example.demojava.demo.StackOverflowErrorDemo.sofMethod(StackOverflowErrorDemo.java:13)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowErrorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sofMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        depth ++ ;</span><br><span class="line">        sofMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackOverflowErrorDemo test = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test = <span class="keyword">new</span> StackOverflowErrorDemo();</span><br><span class="line">            test.sofMethod();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;递归次数：&quot;</span>+test.depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，sofMethod()方法递归调用了982次后，出现了StackOverflowError。</p><h3 id="永久代溢出模拟"><a class="markdownIt-Anchor" href="#永久代溢出模拟"></a> 永久代溢出模拟</h3><p>永久代溢出可以分为两种情况，第一种是常量池溢出，第二种是方法区溢出。</p><p><strong>1、永久代溢出——常量池溢出</strong></p><p><strong>2、永久代溢出——方法区溢出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java7 方法区溢出</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaOOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">                enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                enhancer.create();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;运行次数：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子我们可以看出，在进行第4次内存分配时，发生了内存溢出。</p><h3 id="元空间溢出模拟"><a class="markdownIt-Anchor" href="#元空间溢出模拟"></a> 元空间溢出模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m -XX：MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                unsafe.allocateMemory(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分配次数：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-btrace线上调优"><a class="markdownIt-Anchor" href="#6-btrace线上调优"></a> 6. Btrace线上调优</h2><p><a href="https://hacpai.com/article/1480092912242">https://hacpai.com/article/1480092912242</a></p><h2 id="7-线上内存溢出排查流程"><a class="markdownIt-Anchor" href="#7-线上内存溢出排查流程"></a> 7. 线上内存溢出排查流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;jps</span><br></pre></td></tr></table></figure><ul><li>2、查看线程信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;jstack 19645</span><br></pre></td></tr></table></figure><ul><li>3、存储进程信息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;jstack <span class="number">19645</span> &gt;t.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><ul><li>4、查看内存信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;jmap -histo 19645</span><br></pre></td></tr></table></figure><ul><li>5、dump内存信息到heap.bin文件</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>jmap <span class="operator">-</span>dump:format<span class="operator">=</span>b,file<span class="operator">=</span>heap.bin <span class="number">19645</span></span><br></pre></td></tr></table></figure><ul><li>6、jstat 监视垃圾回收（GC）时间，次数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;jstat -gc 19645</span><br></pre></td></tr></table></figure><ul><li>7、使用mat工具或者VisualVM工具导入heap.bin文件分析内存信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br></pre></td></tr></table></figure><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://juejin.im/post/5dd0c0b95188253d73575ca1">https://juejin.im/post/5dd0c0b95188253d73575ca1</a></li><li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></li><li><a href="https://juejin.im/post/59e6c1f26fb9a0451c397a8c">https://juejin.im/post/59e6c1f26fb9a0451c397a8c</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm线上调优&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm线上调优&quot;&gt;&lt;/a&gt; JVM线上调优&lt;/h1&gt;
&lt;h2 id=&quot;1-调优原则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-调优原则&quot;&gt;</summary>
      
    
    
    
    <category term="jvm" scheme="https://idea360.cn/categories/jvm/"/>
    
    
    <category term="调优" scheme="https://idea360.cn/tags/%E8%B0%83%E4%BC%98/"/>
    
    <category term="jvm" scheme="https://idea360.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优指令</title>
    <link href="https://idea360.cn/2021/08/05/jvm-tuning-cmd/"/>
    <id>https://idea360.cn/2021/08/05/jvm-tuning-cmd/</id>
    <published>2021-08-05T15:50:16.000Z</published>
    <updated>2021-08-05T15:51:41.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm调优指令"><a class="markdownIt-Anchor" href="#jvm调优指令"></a> JVM调优指令</h1><h2 id="jvm常用配置参数"><a class="markdownIt-Anchor" href="#jvm常用配置参数"></a> JVM常用配置参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g：初始化推大小为 2g；</span><br><span class="line">-Xmx2g：堆最大内存为 2g；</span><br><span class="line">-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；</span><br><span class="line">-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；</span><br><span class="line">–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</span><br><span class="line">-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</span><br><span class="line">-XX:+PrintGC：开启打印 gc 信息；</span><br><span class="line">-XX:+PrintGCDetails：打印 gc 详细信息。</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError：  虚拟机在出现内存溢出异常时dump出当前内存堆转储快照以便事后进行分析</span><br></pre></td></tr></table></figure><h2 id="jdk命令行工具"><a class="markdownIt-Anchor" href="#jdk命令行工具"></a> jdk命令行工具</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jps: 显示系统内所有hotspot虚拟机进程</span><br><span class="line">jstat: 用于收集Hotspot虚拟机各方面的运行参数。</span><br><span class="line">jinfo: 显示虚拟机配置信息</span><br><span class="line">jmap: 生成虚拟机内存转储快照</span><br><span class="line">jhat: 用于分析heapdump文件，它会建立一个http/html服务器，让用户可以在浏览器上查看分析结果</span><br><span class="line">jstack: 显示虚拟机的线程快照</span><br></pre></td></tr></table></figure><h2 id="1-jps"><a class="markdownIt-Anchor" href="#1-jps"></a> 1. jps</h2><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><h3 id="命令帮助"><a class="markdownIt-Anchor" href="#命令帮助"></a> 命令帮助</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jps -help</span><br><span class="line">usage: jps [-help]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a class="markdownIt-Anchor" href="#参数说明"></a> 参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l : 输出主类全名或jar路径</span><br><span class="line">-q : 只输出LVMID</span><br><span class="line">-m : 输出JVM启动时传递给main()的参数</span><br><span class="line">-v : 输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure><h3 id="示例详解"><a class="markdownIt-Anchor" href="#示例详解"></a> 示例详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]<span class="comment"># jps</span></span><br><span class="line">25378 Jps</span><br><span class="line">1701 idc-order-boot.jar</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]<span class="comment"># jps -l</span></span><br><span class="line">1701 target/idc-order-boot.jar</span><br><span class="line">25391 sun.tools.jps.Jps</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]<span class="comment"># jps -q</span></span><br><span class="line">25410</span><br><span class="line">1701</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]<span class="comment"># jps -m</span></span><br><span class="line">25425 Jps -m</span><br><span class="line">1701 idc-order-boot.jar --spring.profiles.active=dev --server.port=8080</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]<span class="comment"># jps -v</span></span><br><span class="line">25440 Jps -Denv.class.path=.:/usr/java/jdk1.8.0_201/jre/lib/rt.jar:/usr/java/jdk1.8.0_201/lib/dt.jar:/usr/java/jdk1.8.0_201/lib/tools.jar -Dapplication.home=/usr/java/jdk1.8.0_201 -Xms8m</span><br><span class="line">1701 idc-order-boot.jar</span><br></pre></td></tr></table></figure><h2 id="2-jstat"><a class="markdownIt-Anchor" href="#2-jstat"></a> 2. jstat</h2><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><h3 id="命令帮助-2"><a class="markdownIt-Anchor" href="#命令帮助-2"></a> 命令帮助</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -help</span><br><span class="line">Usage: jstat -help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">  &lt;option&gt;      An option reported by the -options option</span><br><span class="line">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:</span><br><span class="line">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class="line">                Where &lt;lvmid&gt; is the local vm identifier for the target</span><br><span class="line">                Java virtual machine, typically a process id; &lt;hostname&gt; is</span><br><span class="line">                the name of the host running the target Java virtual machine;</span><br><span class="line">                and &lt;port&gt; is the port number for the rmiregistry on the</span><br><span class="line">                target host. See the jvmstat documentation for a more complete</span><br><span class="line">                description of the Virtual Machine Identifier.</span><br><span class="line">  &lt;lines&gt;       Number of samples between header lines.</span><br><span class="line">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class="line">                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]</span><br><span class="line">                Where &lt;n&gt; is an integer and the suffix specifies the units as</span><br><span class="line">                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.</span><br><span class="line">  &lt;count&gt;       Number of samples to take before terminating.</span><br><span class="line">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -options</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure><h3 id="参数说明-2"><a class="markdownIt-Anchor" href="#参数说明-2"></a> 参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[option] : 操作参数</span><br><span class="line">LVMID : 本地虚拟机进程ID</span><br><span class="line">[interval] : 连续输出的时间间隔</span><br><span class="line">[count] : 连续输出的次数</span><br></pre></td></tr></table></figure><h3 id="option参数说明"><a class="markdownIt-Anchor" href="#option参数说明"></a> option参数说明</h3><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视java堆状况，包括Eden区，2个servivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，但是会额外输出导致上一次gc产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gcnew基本相同，输出主要关注使用到的最大最小空间</td></tr><tr><td>-gcold</td><td>监视GC老年代状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同，输出主要关注使用到的最大最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table><h3 id="示例详解-2"><a class="markdownIt-Anchor" href="#示例详解-2"></a> 示例详解</h3><h4 id="-class"><a class="markdownIt-Anchor" href="#-class"></a> -class</h4><p>监视类装载、卸载数量、总空间以及耗费的时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -class 1701</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line"> 14317 27168.2      140   209.1      25.95</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loaded : 加载class的数量</span><br><span class="line">Bytes : class字节大小</span><br><span class="line">Unloaded : 未加载class的数量</span><br><span class="line">Bytes : 未加载class的字节大小</span><br><span class="line">Time : 加载时间</span><br></pre></td></tr></table></figure><h4 id="-compiler"><a class="markdownIt-Anchor" href="#-compiler"></a> -compiler</h4><p>输出JIT编译过的方法数量耗时等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -compiler 1701</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">   13515      1       0   134.67          1 org/springframework/boot/loader/jar/Handler openConnection</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Compiled : 编译数量</span><br><span class="line">Failed : 编译失败数量</span><br><span class="line">Invalid : 无效数量</span><br><span class="line">Time : 编译耗时</span><br><span class="line">FailedType : 失败类型</span><br><span class="line">FailedMethod : 失败方法的全限定名</span><br></pre></td></tr></table></figure><h4 id="-gc"><a class="markdownIt-Anchor" href="#-gc"></a> -gc</h4><p>监视java堆状况，包括Eden区，2个servivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gc 1701 1000 5</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">5888.0 5888.0  0.0    0.0   47168.0   4656.0   117740.0   48648.4   86952.0 82657.6 10672.0 9866.7    306    6.441  14      2.882    9.323</span><br><span class="line">5888.0 5888.0  0.0    0.0   47168.0   4656.0   117740.0   48648.4   86952.0 82657.6 10672.0 9866.7    306    6.441  14      2.882    9.323</span><br><span class="line">5888.0 5888.0  0.0    0.0   47168.0   4656.0   117740.0   48648.4   86952.0 82657.6 10672.0 9866.7    306    6.441  14      2.882    9.323</span><br><span class="line">5888.0 5888.0  0.0    0.0   47168.0   4656.0   117740.0   48648.4   86952.0 82657.6 10672.0 9866.7    306    6.441  14      2.882    9.323</span><br><span class="line">5888.0 5888.0  0.0    0.0   47168.0   4656.0   117740.0   48648.4   86952.0 82657.6 10672.0 9866.7    306    6.441  14      2.882    9.323</span><br></pre></td></tr></table></figure><p>上述指令的意思是1701进程每隔1000ms输出一次gc情况，一共5次。</p><p>说明</p><p>C即Capacity 总容量，U即Used 已使用的容量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">MC : 当前元空间的容量 (KB)</span><br><span class="line">MU : Metaspace的使用 (KB)</span><br><span class="line">CCSC: 压缩类空间大小</span><br><span class="line">CCSU: 压缩类空间使用大小</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure><h4 id="-gccapacity"><a class="markdownIt-Anchor" href="#-gccapacity"></a> -gccapacity</h4><p>同-gc，不过还会输出Java堆各区域使用到的最大、最小空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gccapacity 1701</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC</span><br><span class="line"> 10240.0 156992.0  58944.0 5888.0 5888.0  47168.0    20480.0   314048.0   117740.0   117740.0      0.0 1126400.0  86952.0      0.0 1048576.0  10672.0    306    14</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NGCMN : 新生代占用的最小空间</span><br><span class="line">NGCMX : 新生代占用的最大空间</span><br><span class="line">OGCMN : 老年代占用的最小空间</span><br><span class="line">OGCMX : 老年代占用的最大空间</span><br><span class="line">OGC：当前年老代的容量 (KB)</span><br><span class="line">OC：当前年老代的空间 (KB)</span><br><span class="line">PGCMN : perm占用的最小空间</span><br><span class="line">PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure><h4 id="-gcutils"><a class="markdownIt-Anchor" href="#-gcutils"></a> -gcutils</h4><p>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcutil 1701</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00   0.00  11.78  41.32  95.06  92.45    306    6.441    14    2.882    9.323</span><br></pre></td></tr></table></figure><h4 id="-gccause"><a class="markdownIt-Anchor" href="#-gccause"></a> -gccause</h4><p>与-gcutil功能一样，但是会额外输出导致上一次gc产生的原因</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gccause 1701</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC</span><br><span class="line">  0.00   0.00  11.95  41.32  95.06  92.45    306    6.441    14    2.882    9.323 Heap Inspection Initiated GC No GC</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LGCC：最近垃圾回收的原因</span><br><span class="line">GCC：当前垃圾回收的原因</span><br></pre></td></tr></table></figure><h4 id="-gcnew"><a class="markdownIt-Anchor" href="#-gcnew"></a> -gcnew</h4><p>统计新生代的行为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcnew 1701</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">5888.0 5888.0    0.0    0.0  1  15 2080.0  47168.0   5656.6    306    6.441</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TT：Tenuring threshold(提升阈值)</span><br><span class="line">MTT：最大的tenuring threshold</span><br><span class="line">DSS：survivor区域大小 (KB)</span><br></pre></td></tr></table></figure><h4 id="-gcnewcapacity"><a class="markdownIt-Anchor" href="#-gcnewcapacity"></a> -gcnewcapacity</h4><p>新生代与其相应的内存空间的统计</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcnewcapacity 1701</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   10240.0   156992.0    58944.0  15680.0   5888.0  15680.0   5888.0   125632.0    47168.0   306    14</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NGC:当前年轻代的容量 (KB)</span><br><span class="line">S0CMX:最大的S0空间 (KB)</span><br><span class="line">S0C:当前S0空间 (KB)</span><br><span class="line">ECMX:最大eden空间 (KB)</span><br><span class="line">EC:当前eden空间 (KB)</span><br></pre></td></tr></table></figure><h4 id="-gcold"><a class="markdownIt-Anchor" href="#-gcold"></a> -gcold</h4><p>统计旧生代的行为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcold 1701</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</span><br><span class="line"> 86952.0  82657.6  10672.0   9866.7    117740.0     48648.4    306    14    2.882    9.323</span><br></pre></td></tr></table></figure><h4 id="-gcoldcapacity"><a class="markdownIt-Anchor" href="#-gcoldcapacity"></a> -gcoldcapacity</h4><p>统计旧生代的大小和空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcoldcapacity 1701</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">    20480.0    314048.0    117740.0    117740.0   306    14    2.882    9.323</span><br></pre></td></tr></table></figure><h4 id="-gcmetacapacity"><a class="markdownIt-Anchor" href="#-gcmetacapacity"></a> -gcmetacapacity</h4><p>元空间统计</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -gcmetacapacity 1701</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line">       0.0  1126400.0    86952.0        0.0  1048576.0    10672.0   306    14    2.882    9.323</span><br></pre></td></tr></table></figure><h4 id="-printcompilation"><a class="markdownIt-Anchor" href="#-printcompilation"></a> -printcompilation</h4><p>hotspot编译方法统计</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstat -printcompilation 1701</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">   13515     22    1 java/util/ResourceBundle$CacheKey getLoader</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled：被执行的编译任务的数量</span><br><span class="line">Size：方法字节码的字节数</span><br><span class="line">Type：编译类型</span><br><span class="line">Method：编译方法的类名和方法名。类名使用&quot;&#x2F;&quot; 代替 &quot;.&quot; 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</span><br></pre></td></tr></table></figure><h2 id="3-jmap"><a class="markdownIt-Anchor" href="#3-jmap"></a> 3. jmap</h2><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><h3 id="命令帮助-3"><a class="markdownIt-Anchor" href="#命令帮助-3"></a> 命令帮助</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -help</span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure><h3 id="参数详解"><a class="markdownIt-Anchor" href="#参数详解"></a> 参数详解</h3><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成java堆转储快照。格式为:-dump:[live, ]format=b, file=,其中live子参数说明是否只dump出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在finalizer线程执行finalize方法的对象，只在linux平台下有效</td></tr><tr><td>-heap</td><td>显示java堆详细信息，如使用哪些回收器、参数配置、分代状况等。只在linux平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-permstat</td><td>以Classloader为统计口径显示永久代内存状态。只在linux平台下有效</td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照，只在linux平台下有效</td></tr></tbody></table><h3 id="示例详解-3"><a class="markdownIt-Anchor" href="#示例详解-3"></a> 示例详解</h3><h4 id="-dump"><a class="markdownIt-Anchor" href="#-dump"></a> -dump</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -dump:format=b,file=dump.hprof 1701</span><br><span class="line">Dumping heap to /root/dump.hprof ...</span><br><span class="line">File exists</span><br></pre></td></tr></table></figure><p>dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名。dump.hprof这个后缀是为了后续可以直接用MAT(Memory Anlysis Tool)打开。</p><h4 id="-finalizerinfo"><a class="markdownIt-Anchor" href="#-finalizerinfo"></a> -finalizerinfo</h4><p>打印等待回收对象的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -finalizerinfo 1701</span><br><span class="line">Attaching to process ID 1701, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.201-b09</span><br><span class="line">Number of objects pending for finalization: 0</span><br></pre></td></tr></table></figure><p>可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行finalizer方法的对象。</p><h4 id="-heap"><a class="markdownIt-Anchor" href="#-heap"></a> -heap</h4><p>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jmap -heap 1701</span><br><span class="line">Attaching to process ID 1701, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.201-b09</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Mark Sweep Compact GC   //GC 方式  </span><br><span class="line"></span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line">   MinHeapFreeRatio         = 40    //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率</span><br><span class="line">   MaxHeapFreeRatio         = 70    //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率</span><br><span class="line">   MaxHeapSize              = 482344960 (460.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">   NewSize                  = 10485760 (10.0MB) //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">   MaxNewSize               = 160759808 (153.3125MB)    //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">   OldSize                  = 20971520 (20.0MB)  //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   NewRatio                 = 2 //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   SurvivorRatio            = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB) //元空间初始大小</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage: //堆内存使用情况</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 54329344 (51.8125MB)</span><br><span class="line">   used     = 7109688 (6.780326843261719MB)</span><br><span class="line">   free     = 47219656 (45.03217315673828MB)</span><br><span class="line">   13.086276175173401% used</span><br><span class="line">Eden Space:  //Eden区内存分布</span><br><span class="line">   capacity = 48300032 (46.0625MB) //Eden区总容量</span><br><span class="line">   used     = 7109688 (6.780326843261719MB) //Eden区已使用</span><br><span class="line">   free     = 41190344 (39.28217315673828MB) //Eden区剩余容量</span><br><span class="line">   14.719841179401289% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 6029312 (5.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 6029312 (5.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 6029312 (5.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 6029312 (5.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">tenured generation: //老年代内存分布</span><br><span class="line">   capacity = 120565760 (114.98046875MB)</span><br><span class="line">   used     = 49815952 (47.50819396972656MB)</span><br><span class="line">   free     = 70749808 (67.47227478027344MB)</span><br><span class="line">   41.318490423815184% used</span><br><span class="line"></span><br><span class="line">27371 interned Strings occupying 2942608 bytes.</span><br></pre></td></tr></table></figure><h4 id="-histo"><a class="markdownIt-Anchor" href="#-histo"></a> -histo</h4><p>打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live 1701 | less</span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          4358       18044728  [B</span><br><span class="line">   2:         97247        8984344  [C</span><br><span class="line">   3:         26579        2338952  java.lang.reflect.Method</span><br><span class="line">   4:         96737        2321688  java.lang.String</span><br><span class="line">   5:         58232        1863424  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   6:         22337        1824304  [Ljava.lang.Object;</span><br><span class="line">   7:         15080        1675792  java.lang.Class</span><br><span class="line">   8:         24027         961080  java.util.LinkedHashMap$Entry</span><br><span class="line">   9:          6227         917008  [I</span><br><span class="line">  10:         10500         797288  [Ljava.util.HashMap$Node;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="jhat"><a class="markdownIt-Anchor" href="#jhat"></a> jhat</h2><p>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [dumpfile]</span><br></pre></td></tr></table></figure><p><strong>分析同样一个dump快照，MAT需要的额外内存比jhat要小的多的多，所以建议使用MAT来进行分析，当然也看个人偏好。</strong></p><p>具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。<br /><strong>一般情况，会down到客户端用工具来分析</strong></p><h2 id="5-jstack"><a class="markdownIt-Anchor" href="#5-jstack"></a> 5. jstack</h2><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><h3 id="命令帮助-4"><a class="markdownIt-Anchor" href="#命令帮助-4"></a> 命令帮助</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jstack -help</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure><h3 id="参数详解-2"><a class="markdownIt-Anchor" href="#参数详解-2"></a> 参数详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">-m : 如果调用到本地方法的话，可以显示C&#x2F;C++的堆栈</span><br></pre></td></tr></table></figure><h3 id="示例详情"><a class="markdownIt-Anchor" href="#示例详情"></a> 示例详情</h3><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaedge.concurrency.example.deadLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">➜  Java-Concurrency-Progamming-Tutorial git:(master) ✗ jstack 26752</span><br><span class="line">2020-02-08 15:07:20</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #16 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff49814c800 nid&#x3D;0x3207 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #15 prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007ff495857800 nid&#x3D;0xd03 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;线程 2&quot; #14 prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007ff498836800 nid&#x3D;0x5903 waiting for monitor entry [0x0000700005b7e000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34)</span><br><span class="line">        - waiting to lock &lt;0x000000076af91968&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076af91978&gt; (a java.lang.Object)</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$2&#x2F;194494468.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;线程 1&quot; #13 prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007ff499876000 nid&#x3D;0xa703 waiting for monitor entry [0x0000700005a7b000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$0(DeadLockDemo.java:19)</span><br><span class="line">        - waiting to lock &lt;0x000000076af91978&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076af91968&gt; (a java.lang.Object)</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$1&#x2F;972765878.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #12 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff495820800 nid&#x3D;0xa903 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread3&quot; #11 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff49612f800 nid&#x3D;0x5503 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread2&quot; #10 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff497014000 nid&#x3D;0x3f03 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread1&quot; #9 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff497013800 nid&#x3D;0x3d03 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #8 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff499880800 nid&#x3D;0x3c03 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;JDWP Command Reader&quot; #7 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff497009000 nid&#x3D;0x3a03 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;JDWP Event Helper Thread&quot; #6 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff497004800 nid&#x3D;0x4203 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;JDWP Transport Listener: dt_socket&quot; #5 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff497003800 nid&#x3D;0x4407 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio&#x3D;9 os_prio&#x3D;31 tid&#x3D;0x00007ff49902d800 nid&#x3D;0x3803 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio&#x3D;8 os_prio&#x3D;31 tid&#x3D;0x00007ff497005800 nid&#x3D;0x4b03 in Object.wait() [0x0000700004e54000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000076ab08ed0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">        - locked &lt;0x000000076ab08ed0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio&#x3D;10 os_prio&#x3D;31 tid&#x3D;0x00007ff496835000 nid&#x3D;0x4d03 in Object.wait() [0x0000700004d51000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000076ab06bf8&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        - locked &lt;0x000000076ab06bf8&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff49682e800 nid&#x3D;0x2e03 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498803800 nid&#x3D;0x2207 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498804000 nid&#x3D;0x2103 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498804800 nid&#x3D;0x1e03 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498805000 nid&#x3D;0x2a03 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#4 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498806000 nid&#x3D;0x5403 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#5 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff496802000 nid&#x3D;0x5303 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#6 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff496802800 nid&#x3D;0x5103 runnable </span><br><span class="line"></span><br><span class="line">&quot;GC task thread#7 (ParallelGC)&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff495800800 nid&#x3D;0x4f03 runnable </span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio&#x3D;31 tid&#x3D;0x00007ff498824800 nid&#x3D;0x5703 waiting on condition </span><br><span class="line"></span><br><span class="line">JNI global references: 2505</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;线程 2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007ff4998056a8 (object 0x000000076af91968, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程 1&quot;</span><br><span class="line">&quot;线程 1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007ff499801608 (object 0x000000076af91978, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程 2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;线程 2&quot;:</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34)</span><br><span class="line">        - waiting to lock &lt;0x000000076af91968&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076af91978&gt; (a java.lang.Object)</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$2&#x2F;194494468.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;线程 1&quot;:</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo.lambda$main$0(DeadLockDemo.java:19)</span><br><span class="line">        - waiting to lock &lt;0x000000076af91978&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076af91968&gt; (a java.lang.Object)</span><br><span class="line">        at com.javaedge.concurrency.example.deadLock.DeadLockDemo$$Lambda$1&#x2F;972765878.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="6-jinfo"><a class="markdownIt-Anchor" href="#6-jinfo"></a> 6. jinfo</h2><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p><h3 id="命令帮助-5"><a class="markdownIt-Anchor" href="#命令帮助-5"></a> 命令帮助</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -help</span><br><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure><h3 id="参数详解-3"><a class="markdownIt-Anchor" href="#参数详解-3"></a> 参数详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-flag : 输出指定args参数的值</span><br><span class="line">-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure><h3 id="示例详情-2"><a class="markdownIt-Anchor" href="#示例详情-2"></a> 示例详情</h3><h4 id="-flags"><a class="markdownIt-Anchor" href="#-flags"></a> -flags</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flags 1701</span><br><span class="line">Attaching to process ID 1701, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.201-b09</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=31457280 -XX:MaxHeapSize=482344960 -XX:MaxNewSize=160759808 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=10485760 -XX:OldSize=20971520 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops</span><br><span class="line">Command line:</span><br></pre></td></tr></table></figure><h4 id="-flag"><a class="markdownIt-Anchor" href="#-flag"></a> -flag</h4><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag MaxHeapSize 1701</span><br><span class="line">-XX:MaxHeapSize=482344960</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag PrintGC 1701</span><br><span class="line">-XX:-PrintGC</span><br></pre></td></tr></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用。**</p><p><strong><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag PrintGC 1701</span><br><span class="line">-XX:-PrintGC</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag +PrintGC 1701</span><br><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# jinfo -flag PrintGC 1701</span><br><span class="line">-XX:+PrintGC</span><br></pre></td></tr></table></figure><h2 id="jvm查看运行时参数"><a class="markdownIt-Anchor" href="#jvm查看运行时参数"></a> JVM查看运行时参数</h2><p><strong>打印命令行参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze2e5wmatyx36v5jw5lz ~]# java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=30115776 -XX:MaxHeapSize=481852416 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops</span><br><span class="line">java version &quot;1.8.0_201&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>打印初始参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial -version</span><br></pre></td></tr></table></figure><p><strong>查看最终值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version</span><br></pre></td></tr></table></figure><h2 id="生成dump文件"><a class="markdownIt-Anchor" href="#生成dump文件"></a> 生成dump文件</h2><ol><li><p>JVM的配置文件中配置：</p><p>例如：堆初始化大小，而堆最大大小</p><p>在应用启动时配置相关的参数 -XX:+HeapDumpOnOutOfMemoryError，当应用抛出OutOfMemoryError时生成dump文件。</p><p>在启动的时候，配置文件在哪个目录下面：</p></li></ol><p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=目录+产生的时间.hprof</p><p>JVM启动时增加两个参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#出现 OOME 时生成堆 dump:</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">#生成堆文件地址：</span><br><span class="line">-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;liuke&#x2F;jvmlogs&#x2F;</span><br></pre></td></tr></table></figure><ol><li><p>发现程序异常前通过执行指令，直接生成当前JVM的dmp文件，6214是指JVM的进程号</p><p>jmap -dump:file=文件名.dump [pid]</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format&#x3D;b,file&#x3D;serviceDump.dat 6214</span><br></pre></td></tr></table></figure><p>由于第一种方式是一种事后方式，需要等待当前JVM出现问题后才能生成dmp文件，实时性不高，第二种方式在执行时，JVM是暂停服务的，所以对线上的运行会产生影响。所以建议第一种方式。</p><h2 id="生产级jvm参数配置"><a class="markdownIt-Anchor" href="#生产级jvm参数配置"></a> 生产级JVM参数配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;4核心8G内存配置 </span><br><span class="line">-Xms4g </span><br><span class="line">-Xmx4g </span><br><span class="line">-Xmn2g </span><br><span class="line">-XX:MetaspaceSize&#x3D;256M </span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;256M </span><br><span class="line">-XX:ReservedCodeCacheSize&#x3D;256M</span><br><span class="line">-XX:MaxDirectMemorySize&#x3D;1g </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;8核16G内存配置</span><br><span class="line">-Xms10g </span><br><span class="line">-Xmx10g </span><br><span class="line">-Xmn6g </span><br><span class="line">-XX:MetaspaceSize&#x3D;512M </span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;512M </span><br><span class="line">-XX:ReservedCodeCacheSize&#x3D;512M</span><br><span class="line">-XX:MaxDirectMemorySize&#x3D;1g </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Tuning JVM  for Production Deployments</span><br><span class="line">&#x2F;&#x2F; &gt; java8</span><br><span class="line">&#x2F;&#x2F; 生产环境推荐</span><br><span class="line">-server </span><br><span class="line">-Xms24G</span><br><span class="line">-Xmx24G</span><br><span class="line">-XX:PermSize&#x3D;512m</span><br><span class="line">-XX:+UseG1GC </span><br><span class="line">-XX:MaxGCPauseMillis&#x3D;200 </span><br><span class="line">-XX:ParallelGCThreads&#x3D;20 </span><br><span class="line">-XX:ConcGCThreads&#x3D;5 </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent&#x3D;70</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从服务器推荐</span><br><span class="line">-server </span><br><span class="line">-Xms4G </span><br><span class="line">-Xmx4G </span><br><span class="line">-XX:PermSize&#x3D;512m </span><br><span class="line">-XX:+UseG1GC </span><br><span class="line">-XX:MaxGCPauseMillis&#x3D;200 </span><br><span class="line">-XX:ParallelGCThreads&#x3D;20 </span><br><span class="line">-XX:ConcGCThreads&#x3D;5 </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent&#x3D;70</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 独立服务器</span><br><span class="line">-server </span><br><span class="line">-Xms32G </span><br><span class="line">-Xmx32G </span><br><span class="line">-XX:PermSize&#x3D;512m </span><br><span class="line">-XX:+UseG1GC </span><br><span class="line">-XX:MaxGCPauseMillis&#x3D;200 </span><br><span class="line">-XX:ParallelGCThreads&#x3D;20 </span><br><span class="line">-XX:ConcGCThreads&#x3D;5 </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent&#x3D;70</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;www.51gjie.com&#x2F;java&#x2F;551.html</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;gxyandwmm&#x2F;p&#x2F;9456955.html</span><br><span class="line">&#x2F;&#x2F; For JDK 1.7⁄ 1.8 (8GB heap example for machine with 32 CPUs):</span><br><span class="line">-server &#x2F;&#x2F; 服务器模式</span><br><span class="line">-Xms8g &#x2F;&#x2F; JVM初始分配的堆内存，一般和Xmx配置成一样以避免每次gc后JVM重新分配内存</span><br><span class="line">-Xmx8g &#x2F;&#x2F; JVM最大允许分配的堆内存，按需分配</span><br><span class="line">-XX:+UseParNewGC &#x2F;&#x2F; 年轻代垃圾收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC &#x2F;&#x2F; 并发标记清除（CMS）收集器 (年老代)</span><br><span class="line">-XX:+UseTLAB </span><br><span class="line">-XX:NewSize&#x3D;128m &#x2F;&#x2F; 年轻代大小</span><br><span class="line">-XX:MaxNewSize&#x3D;128m &#x2F;&#x2F; 最大年轻代大小</span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;2 &#x2F;&#x2F; 提升年老代的最大临界值,JDK8里CMS 默认是6，其他如G1是15</span><br><span class="line">-XX:SurvivorRatio&#x3D;8  &#x2F;&#x2F; Eden区与Survivor区的大小比值</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly  &#x2F;&#x2F;使用手动定义初始化定义开始CMS收集</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction&#x3D;40 &#x2F;&#x2F;使用cms作为垃圾回收使用40％后开始CMS收集</span><br><span class="line">-XX:MaxGCPauseMillis&#x3D;1000 &#x2F;&#x2F; 用户设定的最大gc 停顿时间1000ms</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent&#x3D;50 &#x2F;&#x2F; heap中50%的容量被使用，则会触发concurrent gc</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-XX:ParallelGCThreads&#x3D;8 &#x2F;&#x2F; 设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.</span><br><span class="line">-XX:ConcGCThreads&#x3D;8 </span><br><span class="line">-XX:+DisableExplicitGC &#x2F;&#x2F; 忽略手动调用GC, System.gc()的调用就会变成一个空调用，完全不触发GC</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="jvm参数设置优化例子"><a class="markdownIt-Anchor" href="#jvm参数设置优化例子"></a> JVM参数设置优化例子</h2><p><strong>1. 承受海量访问的动态Web应用</strong></p><p>服务器配置：8 CPU, 8G MEM, JDK 1.6.X<br />参数方案：<br />-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC<br />调优说明：<br />-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。<br />-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。<br />-Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。<br />-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。<br />-XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。<br />-XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。<br />-XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。</p><p><strong>2. 内部集成构建服务器案例</strong></p><p>高性能数据处理的工具应用<br />服务器配置：1 CPU, 4G MEM, JDK 1.6.X<br />参数方案：<br />-server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m<br />调优说明：<br />-XX:PermSize=196m -XX:MaxPermSize=196m 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。<br />-Xmn320m 遵循年轻代大小为整个堆的3/8原则。<br />-Xms768m -Xmx1024m 根据系统大致能够承受的堆内存大小设置即可。</p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm调优指令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm调优指令&quot;&gt;&lt;/a&gt; JVM调优指令&lt;/h1&gt;
&lt;h2 id=&quot;jvm常用配置参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm常用</summary>
      
    
    
    
    <category term="jvm" scheme="https://idea360.cn/categories/jvm/"/>
    
    
    <category term="调优" scheme="https://idea360.cn/tags/%E8%B0%83%E4%BC%98/"/>
    
    <category term="jvm" scheme="https://idea360.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="https://idea360.cn/2021/08/05/jvm-gc/"/>
    <id>https://idea360.cn/2021/08/05/jvm-gc/</id>
    <published>2021-08-05T15:48:21.000Z</published>
    <updated>2021-08-05T16:22:58.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm-垃圾回收"><a class="markdownIt-Anchor" href="#jvm-垃圾回收"></a> JVM 垃圾回收</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><h3 id="本节常见面试题"><a class="markdownIt-Anchor" href="#本节常见面试题"></a> 本节常见面试题</h3><p>问题答案在文中都有提到</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul><h3 id="本文导火索"><a class="markdownIt-Anchor" href="#本文导火索"></a> 本文导火索</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%9D%E8%B7%AF.jpeg" alt="" /></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="1-揭开-jvm-内存分配与回收的神秘面纱"><a class="markdownIt-Anchor" href="#1-揭开-jvm-内存分配与回收的神秘面纱"></a> 1 揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://gitee.com/idea360/oss/raw/master/images/Hotspot%E5%A0%86.png" alt="" /></p><p>参考自<a href="https://www.oracle.com/technetwork/cn/community/developer-day/2-jvm-tuning-1866448-zhs.pdf">oracle</a></p><p>上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。经过这次GC后，Eden区和&quot;From&quot;区已经被清空。这个时候，“From&quot;和&quot;To&quot;会交换他们的角色，也就是新的&quot;To&quot;就是上次GC前的“From”，新的&quot;From&quot;就是上次GC前的&quot;To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，&quot;To&quot;区被填满之后，会将所有对象移动到老年代中。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.jpeg" alt="" /></p><h3 id="11-对象优先在-eden-区分配"><a class="markdownIt-Anchor" href="#11-对象优先在-eden-区分配"></a> 1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p><p>在测试之前我们先来看看 <strong>Minor GC 和 Full GC 有什么不同呢？</strong></p><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方式运行：</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/25178350-1095188.jpeg" alt="" /></p><p>添加的参数：<code>-XX:+PrintGCDetails</code></p><p><img src="https://gitee.com/idea360/oss/raw/master/images/10317146.jpeg" alt="" /></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/28954286-2606571.jpeg" alt="" /></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 &#x3D; new byte[900*1024];</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/idea360/oss/raw/master/images/28128785.jpeg" alt="" /></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class GCTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 &#x3D; new byte[32000*1024];</span><br><span class="line">        allocation2 &#x3D; new byte[1000*1024];</span><br><span class="line">        allocation3 &#x3D; new byte[1000*1024];</span><br><span class="line">        allocation4 &#x3D; new byte[1000*1024];</span><br><span class="line">        allocation5 &#x3D; new byte[1000*1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-大对象直接进入老年代"><a class="markdownIt-Anchor" href="#12-大对象直接进入老年代"></a> 1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="13-长期存活的对象将进入老年代"><a class="markdownIt-Anchor" href="#13-长期存活的对象将进入老年代"></a> 1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="14-动态对象年龄判定"><a class="markdownIt-Anchor" href="#14-动态对象年龄判定"></a> 1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line">  &#x2F;&#x2F;survivor_capacity是survivor空间的大小</span><br><span class="line">  size_t desired_survivor_size &#x3D; (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)&#x2F;100);</span><br><span class="line">  size_t total &#x3D; 0;</span><br><span class="line">  uint age &#x3D; 1;</span><br><span class="line">  while (age &lt; table_size) &#123;</span><br><span class="line">    total +&#x3D; sizes[age];&#x2F;&#x2F;sizes数组是每个年龄段对象大小</span><br><span class="line">    if (total &gt; desired_survivor_size) break;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result &#x3D; age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-分配担保"><a class="markdownIt-Anchor" href="#15-分配担保"></a> 1.5 分配担保</h3><p>我们没有办法保证每次回收都只有不多于10%的对象存活，<strong>当Survivor空间不够用时</strong>，需要依赖<strong>老年代内存</strong>进行<strong>分配担保（Handle Promotion）</strong>。如果另外一块Survivor上没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><h2 id="2-对象已经死亡"><a class="markdownIt-Anchor" href="#2-对象已经死亡"></a> 2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/11034259.jpeg" alt="" /></p><h3 id="21-引用计数法"><a class="markdownIt-Anchor" href="#21-引用计数法"></a> 2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGc &#123;</span><br><span class="line">    Object instance &#x3D; null;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReferenceCountingGc objA &#x3D; new ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB &#x3D; new ReferenceCountingGc();</span><br><span class="line">        objA.instance &#x3D; objB;</span><br><span class="line">        objB.instance &#x3D; objA;</span><br><span class="line">        objA &#x3D; null;</span><br><span class="line">        objB &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-可达性分析算法"><a class="markdownIt-Anchor" href="#22-可达性分析算法"></a> 2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/72762049.jpeg" alt="" /></p><p>在Java语言中，可作为GC Roots的对象包含以下几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象)</li><li>方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象)</li><li>方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象)</li><li>本地方法栈中(Native方法)引用的对象(可以理解为:引用Native方法的所有对象)</li></ul><h3 id="23-再谈引用"><a class="markdownIt-Anchor" href="#23-再谈引用"></a> 2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="24-不可达的对象并非非死不可"><a class="markdownIt-Anchor" href="#24-不可达的对象并非非死不可"></a> 2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="25-如何判断一个常量是废弃常量"><a class="markdownIt-Anchor" href="#25-如何判断一个常量是废弃常量"></a> 2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。</p><h3 id="26-如何判断一个类是无用的类"><a class="markdownIt-Anchor" href="#26-如何判断一个类是无用的类"></a> 2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a class="markdownIt-Anchor" href="#3-垃圾收集算法"></a> 3 垃圾收集算法</h2><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.jpeg" alt="" /></p><h3 id="31-标记-清除算法"><a class="markdownIt-Anchor" href="#31-标记-清除算法"></a> 3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="https://gitee.com/idea360/oss/raw/master/images/63707281.jpeg" alt="" /></p><h3 id="32-复制算法"><a class="markdownIt-Anchor" href="#32-复制算法"></a> 3.2 复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/90984624.jpeg" alt="" /></p><h3 id="33-标记-整理算法"><a class="markdownIt-Anchor" href="#33-标记-整理算法"></a> 3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/94057049.jpeg" alt="" /></p><h3 id="34-分代收集算法"><a class="markdownIt-Anchor" href="#34-分代收集算法"></a> 3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a class="markdownIt-Anchor" href="#4-垃圾收集器"></a> 4 垃圾收集器</h2><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpeg" alt="" /></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="41-serial-收集器"><a class="markdownIt-Anchor" href="#41-serial-收集器"></a> 4.1 Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://gitee.com/idea360/oss/raw/master/images/46873026.jpeg" alt="" /></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="42-parnew-收集器"><a class="markdownIt-Anchor" href="#42-parnew-收集器"></a> 4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://gitee.com/idea360/oss/raw/master/images/22018368.jpeg" alt="" /></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="43-parallel-scavenge-收集器"><a class="markdownIt-Anchor" href="#43-parallel-scavenge-收集器"></a> 4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://gitee.com/idea360/oss/raw/master/images/22018368-1095019.jpeg" alt="" /></p><h3 id="44serial-old-收集器"><a class="markdownIt-Anchor" href="#44serial-old-收集器"></a> 4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="45-parallel-old-收集器"><a class="markdownIt-Anchor" href="#45-parallel-old-收集器"></a> 4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="46-cms-收集器"><a class="markdownIt-Anchor" href="#46-cms-收集器"></a> 4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</li></ul><p><img src="https://gitee.com/idea360/oss/raw/master/images/82825079.jpeg" alt="" /></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="47-g1-收集器"><a class="markdownIt-Anchor" href="#47-g1-收集器"></a> 4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="48-老年代垃圾收集器对比"><a class="markdownIt-Anchor" href="#48-老年代垃圾收集器对比"></a> 4.8. 老年代垃圾收集器对比</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94.png" alt="" /></p><h3 id="49-总结"><a class="markdownIt-Anchor" href="#49-总结"></a> 4.9. 总结</h3><table><thead><tr><th style="text-align:center">收集器</th><th style="text-align:center">串行、并行or并发</th><th style="text-align:center">新生代/老年代</th><th style="text-align:center">算法</th><th style="text-align:center">目标</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Serial</strong></td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单CPU环境下的Client模式</td></tr><tr><td style="text-align:center"><strong>Serial Old</strong></td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td style="text-align:center"><strong>ParNew</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">多CPU环境时在Server模式下与CMS配合</td></tr><tr><td style="text-align:center"><strong>Parallel Scavenge</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>Parallel Old</strong></td><td style="text-align:center">并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>CMS</strong></td><td style="text-align:center">并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">集中在互联网站或B/S系统服务端上的Java应用</td></tr><tr><td style="text-align:center"><strong>G1</strong></td><td style="text-align:center">并发</td><td style="text-align:center">both</td><td style="text-align:center">标记-整理+复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">面向服务端应用，将来替换CMS</td></tr></tbody></table><h2 id="5-几种常见的垃圾收集器组合"><a class="markdownIt-Anchor" href="#5-几种常见的垃圾收集器组合"></a> 5. 几种常见的垃圾收集器组合</h2><h3 id="51-常见垃圾收集器组合"><a class="markdownIt-Anchor" href="#51-常见垃圾收集器组合"></a> 5.1. 常见垃圾收集器组合</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88.png" alt="" /></p><p>以下内容来自<a href="https://www.oracle.com/technetwork/cn/community/developer-day/2-jvm-tuning-1866448-zhs.pdf">oracle官方</a>。</p><h3 id="52-有效的虚拟机组合"><a class="markdownIt-Anchor" href="#52-有效的虚拟机组合"></a> 5.2. 有效的虚拟机组合</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E6%9C%89%E6%95%88%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%84%E5%90%88.png" alt="" /></p><h3 id="53-官方推荐组合"><a class="markdownIt-Anchor" href="#53-官方推荐组合"></a> 5.3. 官方推荐组合</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/gc%E6%8E%A8%E8%8D%90.png" alt="" /></p><h3 id="54-jdk6官方推荐"><a class="markdownIt-Anchor" href="#54-jdk6官方推荐"></a> 5.4. JDK6官方推荐</h3><p><img src="https://gitee.com/idea360/oss/raw/master/images/jdk6%E6%8E%A8%E8%8D%90jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88.png" alt="" /></p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li><li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/">https://crowhawk.github.io/2017/08/15/jvm_3/</a></li><li><a href="https://www.cnblogs.com/alsf/p/9484770.html">https://www.cnblogs.com/alsf/p/9484770.html</a></li><li><a href="https://blog.liu-kevin.com/2019/12/29/jvmla-ji-hui-shou-qi/">https://blog.liu-kevin.com/2019/12/29/jvmla-ji-hui-shou-qi/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm-垃圾回收&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm-垃圾回收&quot;&gt;&lt;/a&gt; JVM 垃圾回收&lt;/h1&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="jvm" scheme="https://idea360.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://idea360.cn/tags/jvm/"/>
    
    <category term="垃圾回收" scheme="https://idea360.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="https://idea360.cn/2021/08/05/jvm-class-loader/"/>
    <id>https://idea360.cn/2021/08/05/jvm-class-loader/</id>
    <published>2021-08-05T15:46:32.000Z</published>
    <updated>2021-08-05T16:12:02.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm类加载机制"><a class="markdownIt-Anchor" href="#jvm类加载机制"></a> JVM类加载机制</h1><h2 id="1-什么是类的加载"><a class="markdownIt-Anchor" href="#1-什么是类的加载"></a> 1. 什么是类的加载</h2><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， <code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpeg" alt="" /></p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p><strong>加载.class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h2 id="2-类的生命周期"><a class="markdownIt-Anchor" href="#2-类的生命周期"></a> 2. 类的生命周期</h2><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1072665.png" alt="" /></p><h3 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h3><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h3 id="验证确保被加载的类的正确性"><a class="markdownIt-Anchor" href="#验证确保被加载的类的正确性"></a> 验证：确保被加载的类的正确性</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以 <code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 <code>java.lang.Object</code>之外。</li><li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h3 id="准备为类的-静态变量分配内存并将其初始化为默认值"><a class="markdownIt-Anchor" href="#准备为类的-静态变量分配内存并将其初始化为默认值"></a> 准备：为类的 <code>静态变量</code>分配内存，并将其初始化为默认值</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被复制为 111。</li></ol><h3 id="解析把类中的符号引用转换为直接引用"><a class="markdownIt-Anchor" href="#解析把类中的符号引用转换为直接引用"></a> 解析：把类中的符号引用转换为直接引用</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量是指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤</p><ul><li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如 <code>Class.forName(“com.shengsiyuan.Test”)</code>）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（ <code>JavaTest</code>），直接使用 <code>java.exe</code>命令来运行某个主类</li></ul><h3 id="结束生命周期"><a class="markdownIt-Anchor" href="#结束生命周期"></a> 结束生命周期</h3><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了 <code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="3-类加载器"><a class="markdownIt-Anchor" href="#3-类加载器"></a> 3. 类加载器</h2><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol><h3 id="jvm类加载机制-2"><a class="markdownIt-Anchor" href="#jvm类加载机制-2"></a> JVM类加载机制</h3><ul><li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h2 id="4-类的加载"><a class="markdownIt-Anchor" href="#4-类的加载"></a> 4. 类的加载</h2><p>类加载有三种方式：</p><ul><li>1、命令行启动应用时候由JVM初始化加载</li><li>2、通过Class.forName()方法动态加载</li><li>3、通过ClassLoader.loadClass()方法动态加载</li></ul><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li></ul><h2 id="5-双亲委派模型"><a class="markdownIt-Anchor" href="#5-双亲委派模型"></a> 5. 双亲委派模型</h2><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%A4%BA.png" alt="" /></p><p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;The Parent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;The GrandParent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2 The Parent of ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586 The GrandParent of ClassLodarDemo&#x27;s ClassLoader is null</span><br></pre></td></tr></table></figure><p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code><br /><code>ExtClassLoader</code>的父类加载器为null，<strong>null并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p><p><strong>双亲委派模型实现源码分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>双亲委派模型的好处</strong></p><p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p><p><strong>如果我们不想用双亲委派模型怎么办？</strong></p><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p><h2 id="6-自定义类加载器"><a class="markdownIt-Anchor" href="#6-自定义类加载器"></a> 6. 自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 <code>ClassLoader</code>类，从上面对 <code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demojava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String fileName = root + File.separatorChar +</span><br><span class="line">            className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line"></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line"></span><br><span class="line">        classLoader.setRoot(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">&quot;com.neo.classloader.Test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Object object</span><br><span class="line">                 = testClass.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><ul><li>1、这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</li><li>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li><li>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 <code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载。</li></ul><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm类加载机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm类加载机制&quot;&gt;&lt;/a&gt; JVM类加载机制&lt;/h1&gt;
&lt;h2 id=&quot;1-什么是类的加载&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-</summary>
      
    
    
    
    <category term="jvm" scheme="https://idea360.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://idea360.cn/tags/jvm/"/>
    
    <category term="类加载机制" scheme="https://idea360.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="https://idea360.cn/2021/08/05/jvm-memory-structure/"/>
    <id>https://idea360.cn/2021/08/05/jvm-memory-structure/</id>
    <published>2021-08-05T15:44:51.000Z</published>
    <updated>2021-08-05T16:10:29.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm内存结构"><a class="markdownIt-Anchor" href="#jvm内存结构"></a> JVM内存结构</h1><h2 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1. 前言</h2><p>以下是阅读《深入理解java虚拟机》一书的笔记，仅供参考</p><p>JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area<br />classloader 把硬盘上的class 文件加载到JVM中的运行时数据区域, 但是它不负责这个类文件能否执行，而这个是 执行引擎 负责的。</p><p><strong>上下文切换</strong></p><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。<br />但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次上下文切换。</p><p><strong>切换诱因</strong></p><ol><li><p>在操作系统中，上下文切换的类型可以分为进程间的上下文切换和线程间的上下文切换</p></li><li><p>线程状态：NEW、RUNNABLE、RUNNING、BLOCKED、DEAD<br />Java线程状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</p></li><li><p>线程上下文切换：RUNNING -&gt; BLOCKED -&gt; RUNNABLE -&gt; 被调度器选中执行</p></li></ol><p>一个线程从RUNNING状态转为BLOCKED状态，称为一个线程的暂停<br />线程暂停被切出后，操作系统会<strong>保存相应的上下文</strong></p><p>以便该线程再次进入RUNNABLE状态时能够在之前执行进度的基础上继续执行<br />一个线程从BLOCKED状态进入RUNNABLE状态，称为一个线程的唤醒<br />此时线程将获取上次保存的上下文继续执行</p><ol start="4"><li>诱因：程序本身触发的自发性上下文切换、系统或虚拟机触发的非自发性上下文切换<br />自发性上下文切换<br />sleep、wait、yield、join、park、synchronized、lock<br />非自发性上下文切换<br />线程被分配的时间片用完、JVM垃圾回收（STW、线程暂停）、线程执行优先级</li></ol><p><strong>切换的系统开销</strong></p><ul><li>操作系统保存和恢复上下文</li><li>调度器进行线程调度</li><li>处理器高速缓存重新加载</li><li>可能导致整个高速缓存区被冲刷，从而带来时间开销</li></ul><p><strong>锁竞争才是性能开销的根源</strong></p><p>所以，优化方向有： 减少锁粒度、非阻塞锁代替竞争锁等(比如自旋锁，本身没有阻塞，不需要保存上下文信息)</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpeg" alt="" /></p><h2 id="2-运行时数据区"><a class="markdownIt-Anchor" href="#2-运行时数据区"></a> 2. 运行时数据区</h2><p><img src="https://gitee.com/idea360/oss/raw/master/images/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="" /></p><h3 id="1-程序计数器"><a class="markdownIt-Anchor" href="#1-程序计数器"></a> 1. 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道程序计数器主要有两个作用：</p><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。<br />在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br />注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="2-虚拟机栈"><a class="markdownIt-Anchor" href="#2-虚拟机栈"></a> 2. 虚拟机栈</h3><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</p><p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><p>StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。<br />OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。<br />Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p>扩展：那么方法/函数如何调用？</p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：</p><p>return 语句。<br />抛出异常。<br />不管哪种返回方式都会导致栈帧被弹出</p><h3 id="3-本地方法栈"><a class="markdownIt-Anchor" href="#3-本地方法栈"></a> 3. 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="4-堆"><a class="markdownIt-Anchor" href="#4-堆"></a> 4. 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p><p>新生代内存(Young Ceneration)<br />老生代(Old Generation)<br />永生代(Permanent Generation)</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.jpeg" alt="" /></p><p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.jpeg" alt="" /></p><p>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><p><strong>动态年龄</strong></p><blockquote><p>“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p></blockquote><p>堆这里最容易出现的就是 OutOfMemoryError 异常，并且出现这种异常之后的表现形式还会有几种，比如：</p><ol><li><p>OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p></li><li><p>java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的对内存大小有关！)</p></li><li><p>…</p></li></ol><h3 id="5-方法区"><a class="markdownIt-Anchor" href="#5-方法区"></a> 5. 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p><p><strong>方法区和永久代的关系</strong></p><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p></blockquote><h3 id="6-运行时常量池"><a class="markdownIt-Anchor" href="#6-运行时常量池"></a> 6. 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池</strong></p><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.jpeg" alt="" /></p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm内存结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm内存结构&quot;&gt;&lt;/a&gt; JVM内存结构&lt;/h1&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-前言&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="jvm" scheme="https://idea360.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://idea360.cn/tags/jvm/"/>
    
    <category term="内存结构" scheme="https://idea360.cn/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="https://idea360.cn/2021/08/05/jvm-memory-model/"/>
    <id>https://idea360.cn/2021/08/05/jvm-memory-model/</id>
    <published>2021-08-05T15:42:44.000Z</published>
    <updated>2021-08-05T16:08:03.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h1><p>在Java JVM系列文章中有朋友问为什么要JVM，Java虚拟机不是已经帮我们处理好了么？同样，学习Java内存模型也有同样的问题，为什么要学习Java内存模型。它们的答案是一致的：能够让我们更好的理解底层原理，写出更高效的代码。</p><p>就Java内存模型而言，它是深入了解Java并发编程的先决条件。对于后续多线程中的线程安全、同步异步处理等更是大有裨益。</p><h2 id="硬件内存架构"><a class="markdownIt-Anchor" href="#硬件内存架构"></a> 硬件内存架构</h2><p>在学习Java内存模型之前，先了解一下计算机硬件内存模型。我们多知道处理器与计算机存储设备运算速度有几个数量级的差别。总不能让处理器总是等待计算机存储设备，这样就没办法显现出处理器的优势。</p><p>因此，为了“压榨”处理的性能，达到“高并发”的效果，在处理器和存储设备之间加入了高速缓存（cache）来作为缓冲。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84-0823734.jpeg" alt="" /></p><p>将运算需要使用到的数据复制到缓存中，让运算能够快速进行。当运算完成之后，再将缓存中的结果写入主内存，这样运算器就不用等待主内存的读写操作了。</p><p>每个处理器都有自己的高速缓存，同时又共同操作同一块主内存，当多个处理器同时操作主内存时，可能导致数据不一致，因此需要“缓存一致性协议”来保障。比如，MSI、MESI等。</p><h2 id="jvm内存结构简单介绍"><a class="markdownIt-Anchor" href="#jvm内存结构简单介绍"></a> JVM内存结构简单介绍</h2><p>我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。 在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">《Java虚拟机规范（Java SE 8）》</a>中描述了JVM运行时内存区域结构如下：</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-0824789.png" alt="" /></p><h2 id="java内存模型-2"><a class="markdownIt-Anchor" href="#java内存模型-2"></a> Java内存模型</h2><p>Java内存模型即Java Memory Model，简称JMM。用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能够达到一致的内存访问效果。</p><p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpeg" alt="" /></p><p>JMM与Java内存结构并不是同一个层次的内存划分，两者基本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义看，主内存主要对应Java堆中的对象实例数据部分，工作内存则对应虚拟机栈的部分区域。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%BB%86%E5%8C%96.jpeg" alt="" /></p><p>主内存：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p><p>工作内存：主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p><p>JMM模型与硬件模型直接的对照关系可简化为下图：</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/JMM%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%9B%B4%E6%8E%A5%E7%9A%84%E5%AF%B9%E7%85%A7%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="" /></p><h2 id="内存之间的交互操作"><a class="markdownIt-Anchor" href="#内存之间的交互操作"></a> 内存之间的交互操作</h2><p>线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-0824405.png" alt="" /></p><p>如上图，本地内存A和B有主内存中共享变量x的副本，初始值都为0。线程A执行之后把x更新为1，存放在本地内存A中。当线程A和线程B需要通信时，线程A首先会把本地内存中x=1值刷新到主内存中，主内存中的x值变为1。随后，线程B到主内存中去读取更新后的x值，线程B的本地内存的x值也变为了1。</p><p>在此交互过程中，Java内存模型定义了8种操作来完成，虚拟机实现必须保证每一种操作都是原子的、不可再拆分的（double和long类型例外）。</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p><img src="../assets/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.png" alt="java内存模型原子操作" /></p><p>如果需要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8中基本操作时必须满足如下规则。</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li></ul><h2 id="long和double型变量的特殊规则"><a class="markdownIt-Anchor" href="#long和double型变量的特殊规则"></a> long和double型变量的特殊规则</h2><p>Java内存模型要求lock，unlock，read，load，assign，use，store，write这8个操作都具有原子性，但对于64位的数据类型（long或double），在模型中定义了一条相对宽松的规定，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load，store，read，write这4个操作的原子性，即long和double的非原子性协定。</p><p>如果多线程的情况下double或long类型并未声明为volatile，可能会出现“半个变量”的数值，也就是既非原值，也非修改后的值。</p><p>虽然Java规范允许上面的实现，但商用虚拟机中基本都采用了原子性的操作，因此在日常使用中几乎不会出现读取到“半个变量”的情况。</p><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>本节课重点介绍了Java内存模型以及内存交互的步骤和操作。下篇文章将重点介绍Java内存模型涉及的几个特征和原则。欢迎关注微信公众号“程序新视界”，第一时间获得最新文章的更新。</p><p>本文部分内容引自周志明《深入理解java虚拟机》。</p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://juejin.im/post/5dbfa0aa51882538ce1a4ebc">https://juejin.im/post/5dbfa0aa51882538ce1a4ebc</a></li><li><a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java内存模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java内存模型&quot;&gt;&lt;/a&gt; Java内存模型&lt;/h1&gt;
&lt;p&gt;在Java JVM系列文章中有朋友问为什么要JVM，Java虚拟机不是已经帮我们处理好了么？同样，学习Jav</summary>
      
    
    
    
    <category term="jvm" scheme="https://idea360.cn/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://idea360.cn/tags/jvm/"/>
    
    <category term="内存模型" scheme="https://idea360.cn/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="https://idea360.cn/2021/08/05/mysql-transaction/"/>
    <id>https://idea360.cn/2021/08/05/mysql-transaction/</id>
    <published>2021-08-05T15:37:47.000Z</published>
    <updated>2021-08-05T16:29:20.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h1><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">READ UNCOMMITED</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">READ COMMITED</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">REPEATABLE READ</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">RSERIALIZABLE</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr></tbody></table><blockquote><p>mysql默认事务隔离级别是Repeatable Read级别</p></blockquote><p><strong>脏读</strong>: 读取到了其他事务未提交的数据</p><p><strong>不可重复读</strong>: A事务读取到了B事务已经提交的数据，造成2次读取的结果不一致</p><p><strong>幻读</strong>: A事务读取到了B事务新插入的数据</p><h1 id="事务实现原理"><a class="markdownIt-Anchor" href="#事务实现原理"></a> 事务实现原理</h1><p>实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC</p><h2 id="redo-log"><a class="markdownIt-Anchor" href="#redo-log"></a> redo log</h2><p><strong>redo log</strong>叫做<strong>重做日志</strong>，是用来实现事务的持久性。<br />该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,<br />前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。</p><p>如下场景：假设银行转账场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">-- 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">-- 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/idea360/oss/raw/master/images/redolog.png" alt="" /></p><p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。<br />为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，<br />作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；<br />当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。</p><p>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；<br />当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。<br />redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p><p>既然redo log也需要在事务提交时将日志写入磁盘，为什么它不直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p><p>1、刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</p><p>2、刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</p><h2 id="undo-log"><a class="markdownIt-Anchor" href="#undo-log"></a> undo log</h2><p><strong>undo log</strong>叫做<strong>回滚日志</strong>，用于记录数据被修改前的信息。<br />他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。<br />undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/undolog.png" alt="" /></p><p><img src="https://gitee.com/idea360/oss/raw/master/images/undologdesc.png" alt="" /></p><p>从上图可以了解到数据的变更都伴随着回滚日志的产生：</p><ul><li>(1) 产生了被修改前数据(zhangsan,1000) 的回滚日志</li><li>(2) 产生了被修改前数据(zhangsan,0) 的回滚日志</li></ul><p>根据上面流程可以得出如下结论：</p><ol><li>每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上</li><li>所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</li></ol><p>回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如：</p><ul><li>(1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句</li><li>(2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句</li><li>(3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</li></ul><h2 id="当前读与快照读"><a class="markdownIt-Anchor" href="#当前读与快照读"></a> 当前读与快照读</h2><ol><li><strong>当前读</strong>：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；</li></ol><p>使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert into table values (…);</span><br><span class="line">update table set ? where ?;</span><br><span class="line">delete from table where ?;</span><br></pre></td></tr></table></figure><p>注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><ol start="2"><li><strong>快照读</strong>：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；</li></ol><p>InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p><h2 id="mvcc"><a class="markdownIt-Anchor" href="#mvcc"></a> MVCC</h2><p>数据库底层是怎么实现隔离性的呢？都采用了哪些技术呢？ 主要有两个技术：MVCC(多版本并发控制)和锁。</p><blockquote><p>MVCC『多版本并发控制』，与之对应的是『基于锁的并发控制』；</p></blockquote><p>MVCC的最大好处：读不加任何锁，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；</p><p>InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，使用MVCC，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p><h2 id="事务原理分析"><a class="markdownIt-Anchor" href="#事务原理分析"></a> 事务原理分析</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务的原子性是通过 undo log 来实现的</span><br><span class="line">事务的持久性性是通过 redo log 来实现的</span><br><span class="line">事务的隔离性是通过 (读写锁+MVCC)来实现的</span><br><span class="line">而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！</span><br></pre></td></tr></table></figure><p>RR解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。</p><p>MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和undo log。<br />其中数据的隐藏列包括了该行数据的版本号、删除时间、指向undo log的指针等等；<br />当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo log，从而实现MVCC。</p><p><strong>如何避免脏读？</strong></p><p>当事务A执行查询时，如发现数据已被其他事务修改，且状态为未提交。<br />此时事务A读取最新数据后，根据数据的undo log执行回滚操作，得到事务B修改前的数据，从而避免了脏读。</p><p><strong>如何避免不可重复读？</strong></p><p>当事务A第一次读取数据时，会记录该数据的版本号（数据的版本号是以row为单位记录的），假设版本号为1；<br />当事务B提交时，该行记录的版本号增加，假设版本号为2；<br />当事务A再一次读取数据时，发现数据的版本号（2）大于第一次读取时记录的版本号（1），因此会根据undo log执行回滚操作，得到版本号为1时的数据，从而实现了可重复读。</p><p><strong>如何避免幻读？</strong></p><p>InnoDB实现的RR通过next-key lock机制避免了幻读现象。</p><p>next-key lock是行锁的一种，实现相当于record lock(记录锁) + gap lock(间隙锁)；<br />其特点是不仅会锁住记录本身(record lock的功能)，还会锁定一个范围(gap lock的功能)。</p><p>例如：</p><p>当事务A在第一次读取0&lt;id&lt;5数据时，标记的不只是id=1的数据，而是将范围(0,5)进行了标记，<br />这样当T5时刻再次读取0&lt;id&lt;5数据时，便可以发现id=4的数据比之前标记的版本号更高，<br />此时再结合undo log执行回滚操作，避免了幻读。</p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务隔离级别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#事务隔离级别&quot;&gt;&lt;/a&gt; 事务隔离级别&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;隔离级别&lt;/th&gt;
&lt;t</summary>
      
    
    
    
    <category term="mysql" scheme="https://idea360.cn/categories/mysql/"/>
    
    
    <category term="MySQL" scheme="https://idea360.cn/tags/MySQL/"/>
    
    <category term="事务" scheme="https://idea360.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://idea360.cn/2021/08/05/mysql-index/"/>
    <id>https://idea360.cn/2021/08/05/mysql-index/</id>
    <published>2021-08-05T15:35:13.000Z</published>
    <updated>2021-08-05T16:31:08.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1><p><strong>从索引角度谈MySQL优化。</strong></p><hr /><h1 id="innodb"><a class="markdownIt-Anchor" href="#innodb"></a> InnoDB</h1><h2 id="索引的本质"><a class="markdownIt-Anchor" href="#索引的本质"></a> 索引的本质</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。<br />最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，<br />例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上,<br />但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），<br />所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>看一个例子：</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/index-Sketch.png" alt="" /></p><center>图一</center>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p><p>数据结构基础我们可以参考<a href="https://www.jianshu.com/nb/41117784">数据结构与算法（java版）</a></p><h2 id="普通查找"><a class="markdownIt-Anchor" href="#普通查找"></a> 普通查找</h2><p>假设我们不用索引查找，那么会怎么样呢？很惨，我们必须全文顺序检索，直到查到我们需要的数据，时间复杂度为O(n)</p><h2 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h2><p>二分查找的前提是数据是有序数组,有序数组可以利用二分查找法快速的查找特定的值,时间复杂度为O(log2n)。<br />但是插入数据时很慢，插入的时候需要迭代检索数组直到找到排序位置，并且插入后右侧元素需要依次右移1位，时间复杂度为O(N)。<br />所以我们需要寻找更优质的数据结构和算法来均衡读写复杂度，于是引出了下边的二叉树。</p><h2 id="二叉查找树"><a class="markdownIt-Anchor" href="#二叉查找树"></a> 二叉查找树</h2><p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。<br />如下图所示就是一棵二叉查找树:</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/binary-tree.png" alt="" /></p><p>但是我们想一个问题，假设我们数据的插入顺序是由小到大呢，那么数据就会都在我们的右子树，数据结构转为单链表查询，插入、删除的效率将会严重地降低，时间复杂度变为O(n)</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/binary-tree-unbalance.png" alt="" /></p><p>因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树</p><h2 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h2><p>红黑树就是一种二叉平衡树。这里我们插一点磁盘的知识帮助理解:</p><p><strong>我们数据库查询的瓶颈从来都不是索引本身,也不是CPU,而是IO操作。相对于内存存取，I/O存取的消耗要高几个数量级</strong>假设我们的内存可以存放足够大的数据，那么我们是不需要维护索引的，我们可以在内存中直接通过查找算法去快速检索数据。<br />索引在数据库中是以文件的形式存在的，文件本身是没有计算功能的，它必须加载到内存，通过CPU的计算才会生成树结构进行查询。<br />但是系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。<br />这样就决定了我们的数据无法一次取出所有，只能分块取出，当然我们的内存也不能够一次加载大量数据。</p><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K。<br />而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>当需要查询的数据足够大时，红黑树的树深度会变得很大，由于磁盘读取机制，决定了我们每次读取的数据有限，这样就需要频繁的操作磁盘IO，性能便会下降</p><h2 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> B-Tree</h2><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。<br />另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质,这里我们暂时不做讨论。</p><p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/B-Tree.png" alt="" /></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h2 id="btree"><a class="markdownIt-Anchor" href="#btree"></a> B+Tree</h2><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/B+Tree.png" alt="" /></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p><strong>InnoDB</strong>存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗<sup>3）。也就是说一个深度为3的B+Tree索引可以维护10</sup>3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><p>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。<br />上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。<br />辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。<br />当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。<br />所以这里也反映了主键不能太长的原因，同时应该尽量选取自增字段符合B+Tree的数据结构(数据存放在叶子节点)</p><h1 id="myisam"><a class="markdownIt-Anchor" href="#myisam"></a> MyISAM</h1><p>MyISAM引擎也使用B+树作为索引结果，不同的是叶节点的data域存放的是数据记录的地址，如图所示：<br /><img src="https://gitee.com/idea360/oss/raw/master/images/MyISAM%E7%B4%A2%E5%BC%95.png" alt="" /></p><p>MyISAM的索引与行记录是分开存储的，叫做<strong>非聚集索引</strong>。</p><p>其主键索引与普通索引没有本质差异：</p><ul><li>有连续聚集的区域单独存储行记录</li><li>主键索引的叶子节点，存储主键与对应行记录的指针</li><li>普通索引的叶子结点，存储索引列，与对应行记录的指针</li></ul><p>画外音：MyISAM的表可以没有主键。</p><p>此外还有Hash索引，但是由于hash的散列性质，单个查找相当快，当我们需要范围查询的时候由于无法排序，会造成全表扫描。</p><h1 id="聚集索引与非聚集索引"><a class="markdownIt-Anchor" href="#聚集索引与非聚集索引"></a> 聚集索引与非聚集索引</h1><blockquote><p>简单理解就是聚集索引物理顺序存储，非聚集索引随机存储<br />这里的存储是索引到的数据行，而非索引段本身</p></blockquote><p>InnoDB的主键索引与行记录是存储在一起的，故叫做<strong>聚集索引</strong>，必须要有主键，通过主键索引效率很高，InnoDB一定有且只有一个聚集索引。</p><p>但是<strong>辅助索引</strong>需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p><p>InnoDB的聚集索引存储数据行本身，普通索引存储主键</p><p>以MySQL的InnoDB存储引擎为例，可以有如下解释：</p><p>每个索引上包含的字段会有不同，聚集索引包含所有字段，非聚集索引只包含索引字段+主键字段，所以如果在使用非聚集索引后还需要使用其他字段的（包括在where条件中或者select子句中），则需要通过主键索引回表到聚集索引获取其他字段。如果是非聚集索引可以满足SQL语句的所有字段的，则被称为全覆盖索引，没有回表开销。</p><p>回表是一个通过主键字段重新查询聚集索引的过程，所以如果在大量记录需要回表的情况下，查询成本会比直接在聚集索引上范围扫描的成本还大。所以对于一些情况，不使用非聚集索引效率反而更高。</p><p>MyISAM的索引与行记录是分开存储的，叫做<strong>非聚集索引</strong>。主键索引和辅助索引是独立的。</p><p>其主键索引与普通索引没有本质差异：</p><ul><li>有连续聚集的区域单独存储行记录</li><li>主键索引的叶子节点，存储主键，与对应行记录的指针</li><li>普通索引的叶子结点，存储索引列，与对应行记录的指针</li></ul><p>画外音：MyISAM的表可以没有主键。</p><h1 id="sql调优"><a class="markdownIt-Anchor" href="#sql调优"></a> SQL调优</h1><h2 id="执行计划中type调优"><a class="markdownIt-Anchor" href="#执行计划中type调优"></a> 执行计划中type调优</h2><p>首先我们创建一张测试表来测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;test_explain_type&#96;;</span><br><span class="line">CREATE TABLE &#96;test_explain_type&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;a&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;index_type&#96; (&#96;a&#96;, &#96;b&#96;) USING BTREE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">insert into test_explain_type(id,a,b,c) values (3,4,2,4);</span><br><span class="line">insert into test_explain_type(id,a,b,c) values (2,7,6,5);</span><br><span class="line">insert into test_explain_type(id,a,b,c) values (4,4,1,6);</span><br><span class="line">insert into test_explain_type(id,a,b,c) values (1,4,4,9);</span><br><span class="line">insert into test_explain_type(id,a,b,c) values (5,2,7,2);</span><br><span class="line">insert into test_explain_type(id,a,b,c) values (7,4,0,0);</span><br></pre></td></tr></table></figure><blockquote><p>下边的过程是依据我本地的mysql版本来的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 5.7.17    |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查看表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc test_explain_type;</span><br><span class="line">+-------+---------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra          |</span><br><span class="line">+-------+---------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(11) | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| a     | int(11) | NO   | MUL | NULL    |                |</span><br><span class="line">| b     | int(11) | NO   |     | NULL    |                |</span><br><span class="line">| c     | int(11) | NO   |     | NULL    |                |</span><br><span class="line">+-------+---------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>执行查询计划</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from test_explain_type;</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table             | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | test_explain_type | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>上边的执行结果，我们首先要关心的是type参数，type=all,看得出这里走了全表扫描。</p><p><strong>首先对结果参数进行说明</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">各列的含义如下:</span><br><span class="line"></span><br><span class="line">    id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</span><br><span class="line">    </span><br><span class="line">    select_type: SELECT 查询的类型.</span><br><span class="line">    </span><br><span class="line">    table: 查询的是哪个表</span><br><span class="line">    </span><br><span class="line">    partitions: 匹配的分区</span><br><span class="line">    </span><br><span class="line">    type: join 类型</span><br><span class="line">    </span><br><span class="line">    possible_keys: 此次查询中可能选用的索引</span><br><span class="line">    </span><br><span class="line">    key: 此次查询中确切使用到的索引.</span><br><span class="line">    </span><br><span class="line">    ref: 哪个字段或常数与 key 一起被使用</span><br><span class="line">    </span><br><span class="line">    rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</span><br><span class="line">    </span><br><span class="line">    filtered: 表示此查询条件所过滤的数据的百分比</span><br><span class="line">    </span><br><span class="line">    extra: 额外的信息</span><br></pre></td></tr></table></figure><p><strong>这里重点说明下type：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type：</span><br><span class="line">    连接类型(下面的从好到坏依次解释)</span><br><span class="line">    </span><br><span class="line">    system          触发条件：表只有一行，这是一个const type 的特殊情况。</span><br><span class="line">    const           触发条件：使用了主键或唯一索引索引的查询，最多只有一行匹配。</span><br><span class="line">    eq_ref          触发条件：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件</span><br><span class="line">    ref             触发条件：使用非唯一索引扫描，还可见于唯一索引最左原则匹配扫描</span><br><span class="line">    range           范围扫描通常出现在in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</span><br><span class="line">    index           表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</span><br><span class="line">                    以下两种情况会触发：</span><br><span class="line">                    1、如果索引是查询的覆盖索引，就是说索引查询的数据可以满足查询中所需的所有数据，则只扫描索引树，不需要回表查询。 在这种情况下，explain 的 Extra 列的结果是 Using index。仅索引扫描通常比ALL快，因为索引的大小通常小于表数据。</span><br><span class="line">                    2、全表扫描会按索引的顺序来查找数据行。使用索引不会出现在Extra列中。</span><br><span class="line">    all             全表扫描</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下边我们分别对几种索引连接类型进行说明：</p><ul><li>1、index类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id from test_explain_type;</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table             | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | test_explain_type | NULL       | index | NULL          | index_type | 8       | NULL |    6 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里全表扫描主键索引id，性能比all略好</p><ul><li>2、range类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from test_explain_type where id&gt;1;</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table             | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | test_explain_type | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    5 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里检索条件是索引字段上的范围值，走range。但是这里需要注意的是，当查询条件为非主键索引字段时，如果范围查询的条件全表满足，就会变成全表扫描，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from test_explain_type where a&gt;2;</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table             | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | test_explain_type | NULL       | ALL  | index_type    | NULL | NULL    | NULL |    6 |    83.33 | Using where |</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>3、ref类型</li></ul><p>使用了非主键或者非唯一索引的普通索引(即索引可以重复情况下的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from test_explain_type where a&#x3D;10;</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table             | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | test_explain_type | NULL       | ref  | index_type    | index_type | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------------------+------------+------+---------------+------------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>4、const类型</li></ul><p>使用了主键索引的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from test_explain_type where id&#x3D;1;</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table             | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | test_explain_type | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><h2 id="优化分页查询"><a class="markdownIt-Anchor" href="#优化分页查询"></a> 优化分页查询</h2><ol><li>经常使用LIMIT M,N+ORDER BY来实现分页查询<br />在没有任何索引条件支持的情况下，需要做大量的文件排序操作（file sort），性能很差<br />即便有对应的索引，也只是在刚开始时效率比较理想，越往后，性能越差<br />使用LIMIT M,N时，偏移量M越大，数据库检索的数据也会越多<br />例如LIMIT 10000,10，数据库需要检索10010条记录，但最后只返回10条记录</li><li>优化方案：子查询 + 覆盖索引</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-- 使用了索引，扫描了100010行</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from prop_action_reward order by create_time limit 100000,10;</span><br><span class="line">+----+-------------+--------------------+-------+---------------+-----------------+---------+------+--------+-------+</span><br><span class="line">| id | select_type | table              | type  | possible_keys | key             | key_len | ref  | rows   | Extra |</span><br><span class="line">+----+-------------+--------------------+-------+---------------+-----------------+---------+------+--------+-------+</span><br><span class="line">|  1 | SIMPLE      | prop_action_reward | index | NULL          | idx_create_time | 5       | NULL | 100010 | NULL  |</span><br><span class="line">+----+-------------+--------------------+-------+---------------+-----------------+---------+------+--------+-------+</span><br><span class="line"></span><br><span class="line">-- 耗费了0.19S，性能不太理想</span><br><span class="line">mysql&gt; select * from prop_action_reward order by create_time limit 100000,10;</span><br><span class="line">....</span><br><span class="line">10 rows in set (0.19 sec)</span><br><span class="line"></span><br><span class="line">-- 查询获取到的100010条记录都返回给客户端了，耗时主要集中在Sending data阶段</span><br><span class="line">mysql&gt; show profile for query 21;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000037 |</span><br><span class="line">| checking permissions | 0.000007 |</span><br><span class="line">| Opening tables       | 0.000016 |</span><br><span class="line">| init                 | 0.000028 |</span><br><span class="line">| System lock          | 0.000008 |</span><br><span class="line">| optimizing           | 0.000006 |</span><br><span class="line">| statistics           | 0.000010 |</span><br><span class="line">| preparing            | 0.000011 |</span><br><span class="line">| Sorting result       | 0.000005 |</span><br><span class="line">| executing            | 0.000004 |</span><br><span class="line">| Sending data         | 0.192705 |</span><br><span class="line">| end                  | 0.000018 |</span><br><span class="line">| query end            | 0.000008 |</span><br><span class="line">| closing tables       | 0.000010 |</span><br><span class="line">| freeing items        | 0.000029 |</span><br><span class="line">| cleaning up          | 0.000085 |</span><br><span class="line">+----------------------+----------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- 子查询用到了覆盖索引（Using index），无需回表</span><br><span class="line">mysql&gt; explain select * from prop_action_reward where id &gt; (select id from prop_action_reward order by create_time limit 100000,1) limit 10;</span><br><span class="line">+----+-------------+--------------------+-------+---------------+-----------------+---------+------+----------+-------------+</span><br><span class="line">| id | select_type | table              | type  | possible_keys | key             | key_len | ref  | rows     | Extra       |</span><br><span class="line">+----+-------------+--------------------+-------+---------------+-----------------+---------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | prop_action_reward | range | PRIMARY       | PRIMARY         | 8       | NULL | 47244120 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | prop_action_reward | index | NULL          | idx_create_time | 5       | NULL | 94488240 | Using index |</span><br><span class="line">+----+-------------+--------------------+-------+---------------+-----------------+---------+------+----------+-------------+</span><br><span class="line"></span><br><span class="line">-- 耗费了0.03S，提升很大</span><br><span class="line">mysql&gt; select * from prop_action_reward where id &gt; (select id from prop_action_reward order by create_time limit 100000,1) limit 10;</span><br><span class="line">...</span><br><span class="line">10 rows in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">-- 只会返回10条记录给客户端，所以快很多</span><br><span class="line">mysql&gt; show profile for query 24;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000064 |</span><br><span class="line">| checking permissions | 0.000007 |</span><br><span class="line">| checking permissions | 0.000007 |</span><br><span class="line">| Opening tables       | 0.000019 |</span><br><span class="line">| init                 | 0.000030 |</span><br><span class="line">| System lock          | 0.000009 |</span><br><span class="line">| optimizing           | 0.000008 |</span><br><span class="line">| statistics           | 0.000022 |</span><br><span class="line">| optimizing           | 0.000007 |</span><br><span class="line">| statistics           | 0.000011 |</span><br><span class="line">| preparing            | 0.000015 |</span><br><span class="line">| Sorting result       | 0.000005 |</span><br><span class="line">| executing            | 0.000004 |</span><br><span class="line">| Sending data         | 0.028916 |</span><br><span class="line">| preparing            | 0.000013 |</span><br><span class="line">| executing            | 0.000005 |</span><br><span class="line">| Sending data         | 0.000055 |</span><br><span class="line">| end                  | 0.000006 |</span><br><span class="line">| query end            | 0.000007 |</span><br><span class="line">| closing tables       | 0.000009 |</span><br><span class="line">| freeing items        | 0.000022 |</span><br><span class="line">| cleaning up          | 0.000013 |</span><br><span class="line">+----------------------+----------+</span><br></pre></td></tr></table></figure><h3 id="回表"><a class="markdownIt-Anchor" href="#回表"></a> 回表</h3><blockquote><p>下边解释下回表查询</p></blockquote><p>普通索引因为无法直接定位行记录，其查询过程在通常情况下是需要扫描两遍索引树的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where name &#x3D; &#39;lisi&#39;;</span><br></pre></td></tr></table></figure><p>粉红色的路径需要扫描两遍索引树，</p><p>第一遍先通过普通索引定位到主键值id=5，</p><p>第二遍再通过聚集索引定位到具体行记录。</p><p>这就是所谓的回表查询，即先定位主键值，再根据主键值定位行记录，性能相对于只扫描一遍聚集索引树的性能要低一些。</p><p><img src="https://gitee.com/idea360/oss/raw/master/images/mysql%E5%9B%9E%E8%A1%A8.png" alt="" /></p><h3 id="联合索引"><a class="markdownIt-Anchor" href="#联合索引"></a> 联合索引</h3><p>联合索引需要最左匹配。详见<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247490706&amp;idx=1&amp;sn=d98cd10845923c2bf5d933a8fd963cb5&amp;chksm=ebd623bedca1aaa87256f9729192d024897ba70bc38a0abc314cd59b1a1349c52ec33f1074a1&amp;scene=21#wechat_redirect">联合索引</a></p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li><li><a href="https://www.cnblogs.com/vianzhang/p/7922426.html">https://www.cnblogs.com/vianzhang/p/7922426.html</a></li><li><a href="http://zhongmingmao.me/2019/09/24/java-performance-high-performance-sql/">http://zhongmingmao.me/2019/09/24/java-performance-high-performance-sql/</a></li><li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">https://tech.meituan.com/2014/06/30/mysql-index.html</a></li><li><a href="https://mp.weixin.qq.com/s/ny8rE5-w57rsZiRxI6_Aqg">https://mp.weixin.qq.com/s/ny8rE5-w57rsZiRxI6_Aqg</a></li><li><a href="https://www.cnblogs.com/duanxz/p/3799045.html">https://www.cnblogs.com/duanxz/p/3799045.html</a></li><li><a href="https://www.cnblogs.com/duanxz/p/3799045.html">https://www.cnblogs.com/duanxz/p/3799045.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;从索引角度谈MySQL优化。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;innodb&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    <category term="mysql" scheme="https://idea360.cn/categories/mysql/"/>
    
    
    <category term="MySQL" scheme="https://idea360.cn/tags/MySQL/"/>
    
    <category term="索引" scheme="https://idea360.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL连表分页查询</title>
    <link href="https://idea360.cn/2021/08/04/mysql-left-join-page/"/>
    <id>https://idea360.cn/2021/08/04/mysql-left-join-page/</id>
    <published>2021-08-04T14:32:22.000Z</published>
    <updated>2021-08-04T14:36:24.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>基本背景:</p><ul><li>mybatis-plus</li><li>连表查询</li><li>分页</li><li>查询条件存在2张表中</li></ul><p>如果你看到这里了, 说明你也遇到类似的问题了, 无需再详细描述发生的问题。话不多说, 直接上结果。</p><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> q.id,</span><br><span class="line"> q.question,</span><br><span class="line"> q.company_id,</span><br><span class="line"> q.category_id,</span><br><span class="line"> q.category_name,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">  q.state </span><br><span class="line">  <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">  <span class="string">&#x27;学习完成&#x27;</span> </span><br><span class="line">  <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span></span><br><span class="line">  <span class="string">&#x27;学习中&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;未学习&#x27;</span> </span><br><span class="line"> <span class="keyword">END</span> <span class="keyword">AS</span> state,</span><br><span class="line"> a.answer,</span><br><span class="line"> a.voice_url </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> ( <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ai_knowledge <span class="keyword">WHERE</span> company_id <span class="operator">=</span> <span class="number">12345</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id ) <span class="keyword">AS</span> q</span><br><span class="line"> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ai_knowledge_answer a <span class="keyword">ON</span> q.id <span class="operator">=</span> a.question_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"> a.answer <span class="keyword">like</span> <span class="string">&#x27;您%&#x27;</span> </span><br><span class="line"> LIMIT <span class="number">0</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>本文到此结束，感谢阅读。如果您觉得不错，请关注公众号【当我遇上你】，您的支持是我写作的最大动力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;基本背景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mybatis-plus&lt;/li&gt;
&lt;li&gt;连表查询&lt;/li&gt;
&lt;li&gt;分页&lt;/li&gt;
&lt;li&gt;查询条件存</summary>
      
    
    
    
    <category term="mysql" scheme="https://idea360.cn/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://idea360.cn/tags/mysql/"/>
    
    <category term="left join" scheme="https://idea360.cn/tags/left-join/"/>
    
    <category term="连表" scheme="https://idea360.cn/tags/%E8%BF%9E%E8%A1%A8/"/>
    
    <category term="分页" scheme="https://idea360.cn/tags/%E5%88%86%E9%A1%B5/"/>
    
  </entry>
  
</feed>
